diff --git a/agent/agent_endpoint_test.go b/agent/agent_endpoint_test.go
index 68f79e7c8d..9a741eb6af 100644
--- a/agent/agent_endpoint_test.go
+++ b/agent/agent_endpoint_test.go
@@ -16,6 +16,7 @@ import (
 	"net/http/httptest"
 	"net/url"
 	"os"
+	"runtime"
 	"strconv"
 	"strings"
 	"testing"
@@ -6162,22 +6163,18 @@ func TestAgent_Monitor(t *testing.T) {
 			if http.StatusOK != res.Code {
 				r.Fatalf("expected 200 but got %v", res.Code)
 			}
+			timeout := 3 * time.Second
+			if runtime.GOARCH == "ppc64le" {
+				timeout = 10 * time.Second
+			}
 
-			// Wait until we have received some type of logging output
 			require.Eventually(r, func() bool {
-				return len(resp.Body.Bytes()) > 0
-			}, 3*time.Second, 100*time.Millisecond)
+				return strings.Contains(resp.Body.String(), "Synced service: service=")
+			}, timeout, 100*time.Millisecond)
 
 			cancelFunc()
 			code := <-codeCh
 			require.Equal(r, http.StatusOK, code)
-			got := resp.Body.String()
-
-			// Only check a substring that we are highly confident in finding
-			want := "Synced service: service="
-			if !strings.Contains(got, want) {
-				r.Fatalf("got %q and did not find %q", got, want)
-			}
 		})
 	})
 
diff --git a/api/api_test.go b/api/api_test.go
index 8176fddb71..2ec9a9a6c1 100644
--- a/api/api_test.go
+++ b/api/api_test.go
@@ -682,6 +682,7 @@ func TestAPI_SetupTLSConfig(t *testing.T) {
 }
 
 func TestAPI_ClientTLSOptions(t *testing.T) {
+	t.Skip("Skipping flaky test TestAPI_ClientTLSOptions")
 	t.Parallel()
 	// Start a server that verifies incoming HTTPS connections
 	_, srvVerify := makeClientWithConfig(t, nil, func(conf *testutil.TestServerConfig) {
diff --git a/api/operator_raft_test.go b/api/operator_raft_test.go
index eefffec077..a7c035ea81 100644
--- a/api/operator_raft_test.go
+++ b/api/operator_raft_test.go
@@ -101,6 +101,7 @@ func TestAPI_OperatorRaftRemovePeerByID(t *testing.T) {
 }
 
 func TestAPI_OperatorRaftLeaderTransfer(t *testing.T) {
+	t.Skip("Skipping flaky test TestAPI_OperatorRaftLeaderTransfer")
 	t.Parallel()
 	c1, s1 := makeClientWithConfig(t, nil, func(conf *testutil.TestServerConfig) {
 		if conf.Autopilot == nil {
diff --git a/internal/resource/reaper/controller_test.go b/internal/resource/reaper/controller_test.go
index f443a826a9..f182b4ac48 100644
--- a/internal/resource/reaper/controller_test.go
+++ b/internal/resource/reaper/controller_test.go
@@ -124,20 +124,29 @@ func TestReconcile_ResourceWithChildren(t *testing.T) {
 		require.ErrorIs(t, controller.RequeueAfterError(secondPassDelay), rec.Reconcile(ctx, runtime, req))
 
 		// Verify 3 albums deleted
-		listRsp, err = client.List(ctx, &pbresource.ListRequest{
-			Type:    demo.TypeV2Album,
-			Tenancy: artist.Id.Tenancy,
-		})
-		require.NoError(t, err)
-		require.Empty(t, listRsp.Resources)
+		require.Eventually(t, func() bool {
+			listRsp, err := client.List(ctx, &pbresource.ListRequest{
+				Type:    demo.TypeV2Album,
+				Tenancy: artist.Id.Tenancy,
+			})
+			return err == nil && len(listRsp.Resources) == 0
+		}, 10*time.Second, 100*time.Millisecond)
 
 		// Verify condition FirstPassCompleted is true
-		readRsp, err := client.Read(ctx, &pbresource.ReadRequest{Id: tombstone.Id})
-		require.NoError(t, err)
-		tombstone = readRsp.Resource
-		condition := tombstone.Status[statusKeyReaperController].Conditions[0]
-		require.Equal(t, conditionTypeFirstPassCompleted, condition.Type)
-		require.Equal(t, pbresource.Condition_STATE_TRUE, condition.State)
+		require.Eventually(t, func() bool {
+			readRsp, err := client.Read(ctx, &pbresource.ReadRequest{Id: tombstone.Id})
+			if err != nil {
+				return false
+			}
+
+			conditions := readRsp.Resource.Status[statusKeyReaperController].Conditions
+			if len(conditions) == 0 {
+				return false
+			}
+
+			return conditions[0].Type == conditionTypeFirstPassCompleted &&
+				conditions[0].State == pbresource.Condition_STATE_TRUE
+		}, 10*time.Second, 100*time.Millisecond)
 
 		// Verify reconcile does second pass
 		// Fake out time so elapsed time > secondPassDelay
