diff --git a/cmake/globals.cmake b/cmake/globals.cmake
index 549a82a46..5dabc6b10 100644
--- a/cmake/globals.cmake
+++ b/cmake/globals.cmake
@@ -40,7 +40,7 @@ elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "ARM64")
   # Windows on Arm
   set(TARGET_PROCESSOR "aarch64")
 else()
-  message(FATAL_ERROR "Unsupported architecture ${CMAKE_SYSTEM_PROCESSOR}")
+  set(TARGET_PROCESSOR "ppc64le")
 endif()
 
 if("arm64" IN_LIST CMAKE_OSX_ARCHITECTURES)
diff --git a/libraries/cmake/formula/openssl/CMakeLists.txt b/libraries/cmake/formula/openssl/CMakeLists.txt
index d81f37f4d..da29c3d8f 100644
--- a/libraries/cmake/formula/openssl/CMakeLists.txt
+++ b/libraries/cmake/formula/openssl/CMakeLists.txt
@@ -56,7 +56,7 @@ function(opensslMain)
     if(TARGET_PROCESSOR STREQUAL "aarch64")
       set(lib_folder_name "lib")
     else()
-      set(lib_folder_name "lib64")
+      set(lib_folder_name "lib")
     endif()
 
     set(openssl_libs
diff --git a/libraries/cmake/source/augeas/generated/linux/ppc64le/code/lexer.c b/libraries/cmake/source/augeas/generated/linux/ppc64le/code/lexer.c
new file mode 100644
index 000000000..b7b6f999c
--- /dev/null
+++ b/libraries/cmake/source/augeas/generated/linux/ppc64le/code/lexer.c
@@ -0,0 +1,2572 @@
+#line 1 "lexer.c"
+/* config.h must precede flex's inclusion of <stdio.h>
+   in order for its _GNU_SOURCE definition to take effect.  */
+#include <config.h>
+
+#line 6 "lexer.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 6
+#define YY_FLEX_SUBMINOR_VERSION 4
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+#ifdef yy_create_buffer
+#define augl__create_buffer_ALREADY_DEFINED
+#else
+#define yy_create_buffer augl__create_buffer
+#endif
+
+#ifdef yy_delete_buffer
+#define augl__delete_buffer_ALREADY_DEFINED
+#else
+#define yy_delete_buffer augl__delete_buffer
+#endif
+
+#ifdef yy_scan_buffer
+#define augl__scan_buffer_ALREADY_DEFINED
+#else
+#define yy_scan_buffer augl__scan_buffer
+#endif
+
+#ifdef yy_scan_string
+#define augl__scan_string_ALREADY_DEFINED
+#else
+#define yy_scan_string augl__scan_string
+#endif
+
+#ifdef yy_scan_bytes
+#define augl__scan_bytes_ALREADY_DEFINED
+#else
+#define yy_scan_bytes augl__scan_bytes
+#endif
+
+#ifdef yy_init_buffer
+#define augl__init_buffer_ALREADY_DEFINED
+#else
+#define yy_init_buffer augl__init_buffer
+#endif
+
+#ifdef yy_flush_buffer
+#define augl__flush_buffer_ALREADY_DEFINED
+#else
+#define yy_flush_buffer augl__flush_buffer
+#endif
+
+#ifdef yy_load_buffer_state
+#define augl__load_buffer_state_ALREADY_DEFINED
+#else
+#define yy_load_buffer_state augl__load_buffer_state
+#endif
+
+#ifdef yy_switch_to_buffer
+#define augl__switch_to_buffer_ALREADY_DEFINED
+#else
+#define yy_switch_to_buffer augl__switch_to_buffer
+#endif
+
+#ifdef yypush_buffer_state
+#define augl_push_buffer_state_ALREADY_DEFINED
+#else
+#define yypush_buffer_state augl_push_buffer_state
+#endif
+
+#ifdef yypop_buffer_state
+#define augl_pop_buffer_state_ALREADY_DEFINED
+#else
+#define yypop_buffer_state augl_pop_buffer_state
+#endif
+
+#ifdef yyensure_buffer_stack
+#define augl_ensure_buffer_stack_ALREADY_DEFINED
+#else
+#define yyensure_buffer_stack augl_ensure_buffer_stack
+#endif
+
+#ifdef yylex
+#define augl_lex_ALREADY_DEFINED
+#else
+#define yylex augl_lex
+#endif
+
+#ifdef yyrestart
+#define augl_restart_ALREADY_DEFINED
+#else
+#define yyrestart augl_restart
+#endif
+
+#ifdef yylex_init
+#define augl_lex_init_ALREADY_DEFINED
+#else
+#define yylex_init augl_lex_init
+#endif
+
+#ifdef yylex_init_extra
+#define augl_lex_init_extra_ALREADY_DEFINED
+#else
+#define yylex_init_extra augl_lex_init_extra
+#endif
+
+#ifdef yylex_destroy
+#define augl_lex_destroy_ALREADY_DEFINED
+#else
+#define yylex_destroy augl_lex_destroy
+#endif
+
+#ifdef yyget_debug
+#define augl_get_debug_ALREADY_DEFINED
+#else
+#define yyget_debug augl_get_debug
+#endif
+
+#ifdef yyset_debug
+#define augl_set_debug_ALREADY_DEFINED
+#else
+#define yyset_debug augl_set_debug
+#endif
+
+#ifdef yyget_extra
+#define augl_get_extra_ALREADY_DEFINED
+#else
+#define yyget_extra augl_get_extra
+#endif
+
+#ifdef yyset_extra
+#define augl_set_extra_ALREADY_DEFINED
+#else
+#define yyset_extra augl_set_extra
+#endif
+
+#ifdef yyget_in
+#define augl_get_in_ALREADY_DEFINED
+#else
+#define yyget_in augl_get_in
+#endif
+
+#ifdef yyset_in
+#define augl_set_in_ALREADY_DEFINED
+#else
+#define yyset_in augl_set_in
+#endif
+
+#ifdef yyget_out
+#define augl_get_out_ALREADY_DEFINED
+#else
+#define yyget_out augl_get_out
+#endif
+
+#ifdef yyset_out
+#define augl_set_out_ALREADY_DEFINED
+#else
+#define yyset_out augl_set_out
+#endif
+
+#ifdef yyget_leng
+#define augl_get_leng_ALREADY_DEFINED
+#else
+#define yyget_leng augl_get_leng
+#endif
+
+#ifdef yyget_text
+#define augl_get_text_ALREADY_DEFINED
+#else
+#define yyget_text augl_get_text
+#endif
+
+#ifdef yyget_lineno
+#define augl_get_lineno_ALREADY_DEFINED
+#else
+#define yyget_lineno augl_get_lineno
+#endif
+
+#ifdef yyset_lineno
+#define augl_set_lineno_ALREADY_DEFINED
+#else
+#define yyset_lineno augl_set_lineno
+#endif
+
+#ifdef yyget_column
+#define augl_get_column_ALREADY_DEFINED
+#else
+#define yyget_column augl_get_column
+#endif
+
+#ifdef yyset_column
+#define augl_set_column_ALREADY_DEFINED
+#else
+#define yyset_column augl_set_column
+#endif
+
+#ifdef yywrap
+#define augl_wrap_ALREADY_DEFINED
+#else
+#define yywrap augl_wrap
+#endif
+
+#ifdef yyget_lval
+#define augl_get_lval_ALREADY_DEFINED
+#else
+#define yyget_lval augl_get_lval
+#endif
+
+#ifdef yyset_lval
+#define augl_set_lval_ALREADY_DEFINED
+#else
+#define yyset_lval augl_set_lval
+#endif
+
+#ifdef yyget_lloc
+#define augl_get_lloc_ALREADY_DEFINED
+#else
+#define yyget_lloc augl_get_lloc
+#endif
+
+#ifdef yyset_lloc
+#define augl_set_lloc_ALREADY_DEFINED
+#else
+#define yyset_lloc augl_set_lloc
+#endif
+
+#ifdef yyalloc
+#define augl_alloc_ALREADY_DEFINED
+#else
+#define yyalloc augl_alloc
+#endif
+
+#ifdef yyrealloc
+#define augl_realloc_ALREADY_DEFINED
+#else
+#define yyrealloc augl_realloc
+#endif
+
+#ifdef yyfree
+#define augl_free_ALREADY_DEFINED
+#else
+#define yyfree augl_free
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* begin standard C++ headers. */
+
+/* TODO: this is always defined, so inline it */
+#define yyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define yynoreturn __attribute__((__noreturn__))
+#else
+#define yynoreturn
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
+
+/* An opaque pointer. */
+#ifndef YY_TYPEDEF_YY_SCANNER_T
+#define YY_TYPEDEF_YY_SCANNER_T
+typedef void* yyscan_t;
+#endif
+
+/* For convenience, these vars (plus the bison vars far below)
+   are macros in the reentrant scanner. */
+#define yyin yyg->yyin_r
+#define yyout yyg->yyout_r
+#define yyextra yyg->yyextra_r
+#define yyleng yyg->yyleng_r
+#define yytext yyg->yytext_r
+#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
+#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
+#define yy_flex_debug yyg->yy_flex_debug_r
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN yyg->yy_start = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START ((yyg->yy_start - 1) / 2)
+#define YYSTATE YY_START
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart( yyin , yyscanner )
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define YY_BUF_SIZE 32768
+#else
+#define YY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+    
+    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
+     *       access to the local variable yy_act. Since yyless() is a macro, it would break
+     *       existing scanners that call yyless() from OUTSIDE yylex.
+     *       One obvious solution it to make yy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-yylineno scanner, because yy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  YY_LESS_LINENO(n) \
+            do { \
+                int yyl;\
+                for ( yyl = n; yyl < yyleng; ++yyl )\
+                    if ( yytext[yyl] == '\n' )\
+                        --yylineno;\
+            }while(0)
+    #define YY_LINENO_REWIND_TO(dst) \
+            do {\
+                const char *p;\
+                for ( p = yy_cp-1; p >= (dst); --p)\
+                    if ( *p == '\n' )\
+                        --yylineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = yyg->yy_hold_char; \
+		YY_RESTORE_YY_MORE_OFFSET \
+		yyg->yy_c_buf_p = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+#define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	int yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
+                          ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
+
+void yyrestart ( FILE *input_file , yyscan_t yyscanner );
+void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
+YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
+void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
+void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
+void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
+void yypop_buffer_state ( yyscan_t yyscanner );
+
+static void yyensure_buffer_stack ( yyscan_t yyscanner );
+static void yy_load_buffer_state ( yyscan_t yyscanner );
+static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
+#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)
+
+YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
+
+void *yyalloc ( yy_size_t , yyscan_t yyscanner );
+void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
+void yyfree ( void * , yyscan_t yyscanner );
+
+#define yy_new_buffer yy_create_buffer
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (yyscanner); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (yyscanner); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define augl_wrap(yyscanner) (/*CONSTCOND*/1)
+#define YY_SKIP_YYWRAP
+typedef flex_uint8_t YY_CHAR;
+
+typedef int yy_state_type;
+
+#define yytext_ptr yytext_r
+
+static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
+static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
+static int yy_get_next_buffer ( yyscan_t yyscanner );
+static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	yyg->yytext_ptr = yy_bp; \
+	yyleng = (int) (yy_cp - yy_bp); \
+	yyg->yy_hold_char = *yy_cp; \
+	*yy_cp = '\0'; \
+	yyg->yy_c_buf_p = yy_cp;
+#define YY_NUM_RULES 29
+#define YY_END_OF_BUFFER 30
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static const flex_int16_t yy_accept[95] =
+    {   0,
+        1,    1,    1,    1,   30,   25,    1,    2,   25,   25,
+        7,    7,    7,   25,   23,   22,   22,   22,   22,   22,
+       22,   22,   22,   22,   22,   28,    1,   28,   28,   28,
+        1,    2,    3,    0,    4,    0,   24,   20,    0,    6,
+        0,    0,   23,   22,   22,   22,   22,   14,   22,   22,
+       22,   22,   22,   22,   26,   27,    0,    5,   21,   22,
+       22,   17,   22,   10,   22,   18,   22,   22,   22,   21,
+       22,   22,   13,    0,   22,   22,   22,   16,   19,   22,
+        0,   22,   22,   22,   22,    0,    8,   12,   11,   22,
+        0,   15,    9,    0
+
+    } ;
+
+static const YY_CHAR yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    5,    1,    1,    1,    1,    1,    6,
+        7,    8,    9,    1,   10,   11,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    9,    9,    1,
+        9,   14,    9,    1,   15,   15,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
+       15,   15,   15,   15,   15,   15,   15,   15,   15,   15,
+        9,   16,    9,    1,   17,    1,   18,   17,   19,   20,
+
+       21,   22,   23,   17,   24,   17,   17,   25,   26,   27,
+       28,   29,   17,   30,   31,   32,   33,   17,   17,   34,
+       17,   17,    9,    9,    9,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static const YY_CHAR yy_meta[35] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        2,    1,    3,    1,    3,    1,    4,    4,    4,    4,
+        4,    4,    4,    4,    4,    4,    4,    4,    4,    4,
+        4,    4,    4,    4
+    } ;
+
+static const flex_int16_t yy_base[102] =
+    {   0,
+        0,    0,   33,   40,  134,  135,  131,  129,  128,   33,
+      122,  135,  115,   35,  117,    0,   23,  106,   99,  104,
+       96,   90,  101,   89,   99,  135,  117,  115,  109,  109,
+      113,  111,  109,   45,  135,    0,  135,  135,   41,   88,
+        0,    0,  100,    0,   78,   77,   76,    0,   27,   87,
+       74,   82,   74,   72,  135,  135,   99,  135,    0,   80,
+       72,    0,   68,   96,   64,    0,   75,   71,   62,    0,
+       63,   67,    0,   38,   66,   56,   62,    0,    0,   60,
+       46,   45,   36,   41,   42,   39,    0,    0,    0,   35,
+       60,    0,  135,  135,   68,   72,   76,   79,   81,   48,
+
+       83
+    } ;
+
+static const flex_int16_t yy_def[102] =
+    {   0,
+       94,    1,   95,   95,   94,   94,   94,   94,   94,   96,
+       94,   94,   94,   97,   98,   99,   99,   99,   99,   99,
+       99,   99,   99,   99,   99,   94,   94,   94,   94,   94,
+       94,   94,   94,   96,   94,   96,   94,   94,   97,   94,
+       97,  100,   98,   99,   99,   99,   99,   99,   99,   99,
+       99,   99,   99,   99,   94,   94,   94,   94,  101,   99,
+       99,   99,   99,   99,   99,   99,   99,   99,   99,  101,
+       99,   99,   99,   94,   99,   99,   99,   99,   99,   99,
+       94,   99,   99,   99,   99,   94,   99,   99,   99,   99,
+       94,   99,   94,    0,   94,   94,   94,   94,   94,   94,
+
+       94
+    } ;
+
+static const flex_int16_t yy_nxt[170] =
+    {   0,
+        6,    7,    8,    9,   10,   11,   12,   12,   12,   13,
+       12,   14,    6,    6,   15,    6,   16,   17,   16,   16,
+       16,   16,   18,   19,   20,   21,   16,   16,   22,   23,
+       24,   25,   16,   16,   27,    8,   28,   35,   29,   74,
+       30,   27,    8,   28,   45,   29,   40,   30,   36,   35,
+       41,   59,   40,   63,   92,   46,   41,   91,   64,   90,
+       36,   93,   93,   89,   88,   87,   86,   81,   26,   26,
+       26,   26,   34,   34,   34,   34,   39,   39,   39,   39,
+       43,   43,   43,   44,   44,   70,   70,   85,   84,   83,
+       82,   80,   79,   78,   77,   76,   75,   74,   73,   72,
+
+       71,   33,   69,   68,   67,   66,   65,   62,   61,   60,
+       42,   58,   57,   32,   31,   56,   55,   33,   31,   54,
+       53,   52,   51,   50,   49,   48,   47,   42,   38,   37,
+       33,   32,   31,   94,    5,   94,   94,   94,   94,   94,
+       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
+       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
+       94,   94,   94,   94,   94,   94,   94,   94,   94
+    } ;
+
+static const flex_int16_t yy_chk[170] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    3,    3,    3,   10,    3,   74,
+        3,    4,    4,    4,   17,    4,   14,    4,   10,   34,
+       14,  100,   39,   49,   90,   17,   39,   86,   49,   85,
+       34,   91,   91,   84,   83,   82,   81,   74,   95,   95,
+       95,   95,   96,   96,   96,   96,   97,   97,   97,   97,
+       98,   98,   98,   99,   99,  101,  101,   80,   77,   76,
+       75,   72,   71,   69,   68,   67,   65,   64,   63,   61,
+
+       60,   57,   54,   53,   52,   51,   50,   47,   46,   45,
+       43,   40,   33,   32,   31,   30,   29,   28,   27,   25,
+       24,   23,   22,   21,   20,   19,   18,   15,   13,   11,
+        9,    8,    7,    5,   94,   94,   94,   94,   94,   94,
+       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
+       94,   94,   94,   94,   94,   94,   94,   94,   94,   94,
+       94,   94,   94,   94,   94,   94,   94,   94,   94
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static const flex_int32_t yy_rule_can_match_eol[30] =
+    {   0,
+0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,     };
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+#line 1 "lexer.l"
+/* Scanner for config specs   -*- C -*- */
+#define YY_NO_INPUT 1
+
+#line 16 "lexer.l"
+#include "syntax.h"
+#include "errcode.h"
+
+typedef struct info YYLTYPE;
+#define YYLTYPE_IS_DECLARED 1
+
+#include "parser.h"
+
+/* Advance of NUM lines. */
+# define LOCATION_LINES(Loc, Num)             \
+  (Loc).last_column = 0;                      \
+  (Loc).last_line += Num;
+
+/* Restart: move the first cursor to the last position. */
+# define LOCATION_STEP(Loc)                   \
+  (Loc).first_column = (Loc).last_column;     \
+  (Loc).first_line = (Loc).last_line;
+
+/* The lack of reference counting for filename is intentional */
+#define YY_USER_ACTION                                            \
+  do {                                                            \
+     yylloc->last_column += yyleng;                               \
+     yylloc->filename = augl_get_info(yyscanner)->filename;       \
+     yylloc->error = augl_get_info(yyscanner)->error;             \
+   } while(0);
+
+#define YY_USER_INIT LOCATION_STEP(*yylloc)
+
+#define YY_EXTRA_TYPE struct state *
+
+int augl_init_lexer(struct state *state, yyscan_t * scanner);
+void augl_close_lexer(yyscan_t *scanner);
+struct info *augl_get_info(yyscan_t yyscanner);
+
+static void loc_update(YYLTYPE *yylloc, const char *s, int len) {
+  for (int i=0; i < len; i++) {
+    if (s[i] == '\n') {
+      LOCATION_LINES(*yylloc, 1);
+    }
+  }
+}
+
+static char *regexp_literal(const char *s, int len) {
+  char *u = unescape(s, len, RX_ESCAPES);
+
+  if (u == NULL)
+    return NULL;
+
+  size_t u_len = strlen(u);
+  regexp_c_locale(&u, &u_len);
+
+  return u;
+}
+#line 809 "lexer.c"
+
+#line 811 "lexer.c"
+
+#define INITIAL 0
+#define COMMENT 1
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+/* Holds the entire state of the reentrant scanner. */
+struct yyguts_t
+    {
+
+    /* User-defined. Not touched by flex. */
+    YY_EXTRA_TYPE yyextra_r;
+
+    /* The rest are the same as the globals declared in the non-reentrant scanner. */
+    FILE *yyin_r, *yyout_r;
+    size_t yy_buffer_stack_top; /**< index of top of stack. */
+    size_t yy_buffer_stack_max; /**< capacity of stack. */
+    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
+    char yy_hold_char;
+    int yy_n_chars;
+    int yyleng_r;
+    char *yy_c_buf_p;
+    int yy_init;
+    int yy_start;
+    int yy_did_buffer_switch_on_eof;
+    int yy_start_stack_ptr;
+    int yy_start_stack_depth;
+    int *yy_start_stack;
+    yy_state_type yy_last_accepting_state;
+    char* yy_last_accepting_cpos;
+
+    int yylineno_r;
+    int yy_flex_debug_r;
+
+    char *yytext_r;
+    int yy_more_flag;
+    int yy_more_len;
+
+    YYSTYPE * yylval_r;
+
+    YYLTYPE * yylloc_r;
+
+    }; /* end struct yyguts_t */
+
+static int yy_init_globals ( yyscan_t yyscanner );
+
+    /* This must go here because YYSTYPE and YYLTYPE are included
+     * from bison output in section 1.*/
+    #    define yylval yyg->yylval_r
+    
+    #    define yylloc yyg->yylloc_r
+    
+int yylex_init (yyscan_t* scanner);
+
+int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy ( yyscan_t yyscanner );
+
+int yyget_debug ( yyscan_t yyscanner );
+
+void yyset_debug ( int debug_flag , yyscan_t yyscanner );
+
+YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
+
+void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
+
+FILE *yyget_in ( yyscan_t yyscanner );
+
+void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
+
+FILE *yyget_out ( yyscan_t yyscanner );
+
+void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
+
+			int yyget_leng ( yyscan_t yyscanner );
+
+char *yyget_text ( yyscan_t yyscanner );
+
+int yyget_lineno ( yyscan_t yyscanner );
+
+void yyset_lineno ( int _line_number , yyscan_t yyscanner );
+
+int yyget_column  ( yyscan_t yyscanner );
+
+void yyset_column ( int _column_no , yyscan_t yyscanner );
+
+YYSTYPE * yyget_lval ( yyscan_t yyscanner );
+
+void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
+
+       YYLTYPE *yyget_lloc ( yyscan_t yyscanner );
+    
+        void yyset_lloc ( YYLTYPE * yylloc_param , yyscan_t yyscanner );
+    
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap ( yyscan_t yyscanner );
+#else
+extern int yywrap ( yyscan_t yyscanner );
+#endif
+#endif
+
+#ifndef YY_NO_UNPUT
+    
+#endif
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+static int yyinput ( yyscan_t yyscanner );
+#else
+static int input ( yyscan_t yyscanner );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define YY_READ_BUF_SIZE 16384
+#else
+#define YY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg , yyscanner)
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex \
+               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner);
+
+#define YY_DECL int yylex \
+               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK /*LINTED*/break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	yy_state_type yy_current_state;
+	char *yy_cp, *yy_bp;
+	int yy_act;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+    yylval = yylval_param;
+
+    yylloc = yylloc_param;
+
+	if ( !yyg->yy_init )
+		{
+		yyg->yy_init = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! yyg->yy_start )
+			yyg->yy_start = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack (yyscanner);
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
+		}
+
+		yy_load_buffer_state( yyscanner );
+		}
+
+	{
+#line 81 "lexer.l"
+
+#line 1096 "lexer.c"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = yyg->yy_c_buf_p;
+
+		/* Support of yytext. */
+		*yy_cp = yyg->yy_hold_char;
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = yyg->yy_start;
+yy_match:
+		do
+			{
+			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			if ( yy_accept[yy_current_state] )
+				{
+				yyg->yy_last_accepting_state = yy_current_state;
+				yyg->yy_last_accepting_cpos = yy_cp;
+				}
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 95 )
+					yy_c = yy_meta[yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+			++yy_cp;
+			}
+		while ( yy_current_state != 94 );
+		yy_cp = yyg->yy_last_accepting_cpos;
+		yy_current_state = yyg->yy_last_accepting_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+		if ( yy_act != YY_END_OF_BUFFER && yy_rule_can_match_eol[yy_act] )
+			{
+			int yyl;
+			for ( yyl = 0; yyl < yyleng; ++yyl )
+				if ( yytext[yyl] == '\n' )
+					
+    do{ yylineno++;
+        yycolumn=0;
+    }while(0)
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of YY_DO_BEFORE_ACTION */
+			*yy_cp = yyg->yy_hold_char;
+			yy_cp = yyg->yy_last_accepting_cpos;
+			yy_current_state = yyg->yy_last_accepting_state;
+			goto yy_find_action;
+
+case 1:
+YY_RULE_SETUP
+#line 84 "lexer.l"
+LOCATION_STEP(*yylloc);
+	YY_BREAK
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+#line 85 "lexer.l"
+LOCATION_LINES(*yylloc, yyleng); LOCATION_STEP(*yylloc);
+	YY_BREAK
+case 3:
+/* rule 3 can match eol */
+YY_RULE_SETUP
+#line 86 "lexer.l"
+LOCATION_LINES(*yylloc, yyleng/2); LOCATION_STEP(*yylloc);
+	YY_BREAK
+
+
+
+case 4:
+/* rule 4 can match eol */
+YY_RULE_SETUP
+#line 91 "lexer.l"
+{
+               loc_update(yylloc, yytext, yyleng);
+               yylval->string = unescape(yytext+1, yyleng-2, STR_ESCAPES);
+               return DQUOTED;
+  }
+	YY_BREAK
+case 5:
+/* rule 5 can match eol */
+YY_RULE_SETUP
+#line 97 "lexer.l"
+{
+               loc_update(yylloc, yytext, yyleng);
+               yylval->regexp.nocase = 1;
+               yylval->regexp.pattern = regexp_literal(yytext+1, yyleng-3);
+               return REGEXP;
+  }
+	YY_BREAK
+case 6:
+/* rule 6 can match eol */
+YY_RULE_SETUP
+#line 104 "lexer.l"
+{
+               loc_update(yylloc, yytext, yyleng);
+               yylval->regexp.nocase = 0;
+               yylval->regexp.pattern = regexp_literal(yytext+1, yyleng-2);
+               return REGEXP;
+  }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 111 "lexer.l"
+return yytext[0];
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 113 "lexer.l"
+return KW_MODULE;
+	YY_BREAK
+case 9:
+/* rule 9 can match eol */
+*yy_cp = yyg->yy_hold_char; /* undo effects of setting up yytext */
+YY_LINENO_REWIND_TO(yy_cp - 1);
+yyg->yy_c_buf_p = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up yytext again */
+YY_RULE_SETUP
+#line 115 "lexer.l"
+return KW_LET_REC;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+#line 117 "lexer.l"
+return KW_LET;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+#line 118 "lexer.l"
+return KW_STRING;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+#line 119 "lexer.l"
+return KW_REGEXP;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+#line 120 "lexer.l"
+return KW_LENS;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+#line 121 "lexer.l"
+return KW_IN;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+#line 122 "lexer.l"
+return KW_AUTOLOAD;
+	YY_BREAK
+/* tests */
+case 16:
+YY_RULE_SETUP
+#line 125 "lexer.l"
+return KW_TEST;
+	YY_BREAK
+case 17:
+YY_RULE_SETUP
+#line 126 "lexer.l"
+return KW_GET;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+#line 127 "lexer.l"
+return KW_PUT;
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+#line 128 "lexer.l"
+return KW_AFTER;
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+#line 130 "lexer.l"
+return ARROW;
+	YY_BREAK
+case 21:
+YY_RULE_SETUP
+#line 132 "lexer.l"
+{
+                   yylval->string = strndup(yytext, yyleng);
+                   return QIDENT;
+                }
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+#line 136 "lexer.l"
+{
+                   yylval->string = strndup(yytext, yyleng);
+                   return LIDENT;
+                }
+	YY_BREAK
+case 23:
+YY_RULE_SETUP
+#line 140 "lexer.l"
+{
+                   yylval->string = strndup(yytext, yyleng);
+                   return UIDENT;
+                }
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+#line 144 "lexer.l"
+{
+                   augl_get_extra(yyscanner)->comment_depth = 1;
+                   BEGIN(COMMENT);
+                }
+	YY_BREAK
+case 25:
+YY_RULE_SETUP
+#line 148 "lexer.l"
+{
+    report_error(augl_get_info(yyscanner)->error, AUG_ESYNTAX,
+                 "%s:%d:%d: Unexpected character %c",
+                 augl_get_info(yyscanner)->filename->str,
+                 yylineno, yylloc->first_column, yytext[0]);
+                }
+	YY_BREAK
+case YY_STATE_EOF(INITIAL):
+#line 155 "lexer.l"
+{
+                  augl_close_lexer(yyscanner);
+                  yyterminate();
+                }
+	YY_BREAK
+
+
+
+case 26:
+YY_RULE_SETUP
+#line 164 "lexer.l"
+{
+                   augl_get_extra(yyscanner)->comment_depth += 1;
+                }
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+#line 167 "lexer.l"
+{
+                   augl_get_extra(yyscanner)->comment_depth -= 1;
+                   if (augl_get_extra(yyscanner)->comment_depth == 0)
+                       BEGIN(INITIAL);
+                }
+	YY_BREAK
+case 28:
+YY_RULE_SETUP
+#line 172 "lexer.l"
+/* Skip */;
+	YY_BREAK
+case YY_STATE_EOF(COMMENT):
+#line 173 "lexer.l"
+{
+                  report_error(augl_get_info(yyscanner)->error, AUG_ESYNTAX,
+                               "%s:%d:%d: Missing *)",
+                               augl_get_info(yyscanner)->filename->str,
+                               yylineno, yylloc->first_column);
+                  augl_close_lexer(yyscanner);
+                  yyterminate();
+                }
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+#line 182 "lexer.l"
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+#line 1379 "lexer.c"
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - yyg->yytext_ptr) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = yyg->yy_hold_char;
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( yyg->yy_c_buf_p <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			yyg->yy_c_buf_p = yyg->yytext_ptr + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state( yyscanner );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state , yyscanner);
+
+			yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++yyg->yy_c_buf_p;
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = yyg->yy_last_accepting_cpos;
+				yy_current_state = yyg->yy_last_accepting_state;
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer( yyscanner ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				yyg->yy_did_buffer_switch_on_eof = 0;
+
+				if ( yywrap( yyscanner ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					yyg->yy_c_buf_p = yyg->yytext_ptr + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! yyg->yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				yyg->yy_c_buf_p =
+					yyg->yytext_ptr + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state( yyscanner );
+
+				yy_cp = yyg->yy_c_buf_p;
+				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				yyg->yy_c_buf_p =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars];
+
+				yy_current_state = yy_get_previous_state( yyscanner );
+
+				yy_cp = yyg->yy_c_buf_p;
+				yy_bp = yyg->yytext_ptr + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	char *source = yyg->yytext_ptr;
+	int number_to_move, i;
+	int ret_val;
+
+	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+
+			int yy_c_buf_p_offset =
+				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					yyrealloc( (void *) b->yy_ch_buf,
+							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = NULL;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			yyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			yyg->yy_n_chars, num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
+		}
+
+	if ( yyg->yy_n_chars == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart( yyin  , yyscanner);
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
+			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
+	}
+
+	yyg->yy_n_chars += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;
+
+	yyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
+{
+	yy_state_type yy_current_state;
+	char *yy_cp;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	yy_current_state = yyg->yy_start;
+
+	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
+		{
+		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		if ( yy_accept[yy_current_state] )
+			{
+			yyg->yy_last_accepting_state = yy_current_state;
+			yyg->yy_last_accepting_cpos = yy_cp;
+			}
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 95 )
+				yy_c = yy_meta[yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
+{
+	int yy_is_jam;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
+	char *yy_cp = yyg->yy_c_buf_p;
+
+	YY_CHAR yy_c = 1;
+	if ( yy_accept[yy_current_state] )
+		{
+		yyg->yy_last_accepting_state = yy_current_state;
+		yyg->yy_last_accepting_cpos = yy_cp;
+		}
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 95 )
+			yy_c = yy_meta[yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+	yy_is_jam = (yy_current_state == 94);
+
+	(void)yyg;
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+#ifndef YY_NO_UNPUT
+
+#endif
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (yyscan_t yyscanner)
+#else
+    static int input  (yyscan_t yyscanner)
+#endif
+
+{
+	int c;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	*yyg->yy_c_buf_p = yyg->yy_hold_char;
+
+	if ( *yyg->yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( yyg->yy_c_buf_p < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] )
+			/* This was really a NUL. */
+			*yyg->yy_c_buf_p = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
+			++yyg->yy_c_buf_p;
+
+			switch ( yy_get_next_buffer( yyscanner ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart( yyin , yyscanner);
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( yyscanner ) )
+						return 0;
+
+					if ( ! yyg->yy_did_buffer_switch_on_eof )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput(yyscanner);
+#else
+					return input(yyscanner);
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					yyg->yy_c_buf_p = yyg->yytext_ptr + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) yyg->yy_c_buf_p;	/* cast for 8-bit char's */
+	*yyg->yy_c_buf_p = '\0';	/* preserve yytext */
+	yyg->yy_hold_char = *++yyg->yy_c_buf_p;
+
+	if ( c == '\n' )
+		
+    do{ yylineno++;
+        yycolumn=0;
+    }while(0)
+;
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * @param yyscanner The scanner object.
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack (yyscanner);
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
+	}
+
+	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
+	yy_load_buffer_state( yyscanner );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * @param yyscanner The scanner object.
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack (yyscanner);
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*yyg->yy_c_buf_p = yyg->yy_hold_char;
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( yyscanner );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	yyg->yy_did_buffer_switch_on_eof = 1;
+}
+
+static void yy_load_buffer_state  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	yyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	yyg->yy_hold_char = *yyg->yy_c_buf_p;
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * @param yyscanner The scanner object.
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer( b, file , yyscanner);
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * @param yyscanner The scanner object.
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree( (void *) b->yy_ch_buf , yyscanner );
+
+	yyfree( (void *) b , yyscanner );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)
+
+{
+	int oerrno = errno;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	yy_flush_buffer( b , yyscanner);
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * @param yyscanner The scanner object.
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( yyscanner );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  @param yyscanner The scanner object.
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack(yyscanner);
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*yyg->yy_c_buf_p = yyg->yy_hold_char;
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		yyg->yy_buffer_stack_top++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( yyscanner );
+	yyg->yy_did_buffer_switch_on_eof = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  @param yyscanner The scanner object.
+ */
+void yypop_buffer_state (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if (yyg->yy_buffer_stack_top > 0)
+		--yyg->yy_buffer_stack_top;
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( yyscanner );
+		yyg->yy_did_buffer_switch_on_eof = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (yyscan_t yyscanner)
+{
+	yy_size_t num_to_alloc;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+	if (!yyg->yy_buffer_stack) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								, yyscanner);
+		if ( ! yyg->yy_buffer_stack )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+
+		yyg->yy_buffer_stack_max = num_to_alloc;
+		yyg->yy_buffer_stack_top = 0;
+		return;
+	}
+
+	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		yy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
+		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
+								(yyg->yy_buffer_stack,
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								, yyscanner);
+		if ( ! yyg->yy_buffer_stack )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));
+		yyg->yy_buffer_stack_max = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * @param yyscanner The scanner object.
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return NULL;
+
+	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = NULL;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer( b , yyscanner );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * @param yyscanner The scanner object.
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
+{
+    
+	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param yybytes the byte buffer to scan
+ * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * @param yyscanner The scanner object.
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = (yy_size_t) (_yybytes_len + 2);
+	buf = (char *) yyalloc( n , yyscanner );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer( buf, n , yyscanner);
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
+{
+	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	(void)yyg;
+	fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = yyg->yy_hold_char; \
+		yyg->yy_c_buf_p = yytext + yyless_macro_arg; \
+		yyg->yy_hold_char = *yyg->yy_c_buf_p; \
+		*yyg->yy_c_buf_p = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the user-defined data for this scanner.
+ * @param yyscanner The scanner object.
+ */
+YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyextra;
+}
+
+/** Get the current line number.
+ * @param yyscanner The scanner object.
+ */
+int yyget_lineno  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+        if (! YY_CURRENT_BUFFER)
+            return 0;
+    
+    return yylineno;
+}
+
+/** Get the current column number.
+ * @param yyscanner The scanner object.
+ */
+int yyget_column  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+        if (! YY_CURRENT_BUFFER)
+            return 0;
+    
+    return yycolumn;
+}
+
+/** Get the input stream.
+ * @param yyscanner The scanner object.
+ */
+FILE *yyget_in  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyin;
+}
+
+/** Get the output stream.
+ * @param yyscanner The scanner object.
+ */
+FILE *yyget_out  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyout;
+}
+
+/** Get the length of the current token.
+ * @param yyscanner The scanner object.
+ */
+int yyget_leng  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yyleng;
+}
+
+/** Get the current token.
+ * @param yyscanner The scanner object.
+ */
+
+char *yyget_text  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yytext;
+}
+
+/** Set the user-defined data. This data is never touched by the scanner.
+ * @param user_defined The data to be associated with this scanner.
+ * @param yyscanner The scanner object.
+ */
+void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yyextra = user_defined ;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * @param yyscanner The scanner object.
+ */
+void yyset_lineno (int  _line_number , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+        /* lineno is only valid if an input buffer exists. */
+        if (! YY_CURRENT_BUFFER )
+           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
+    
+    yylineno = _line_number;
+}
+
+/** Set the current column.
+ * @param _column_no column number
+ * @param yyscanner The scanner object.
+ */
+void yyset_column (int  _column_no , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+        /* column is only valid if an input buffer exists. */
+        if (! YY_CURRENT_BUFFER )
+           YY_FATAL_ERROR( "yyset_column called with no buffer" );
+    
+    yycolumn = _column_no;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * @param yyscanner The scanner object.
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yyin = _in_str ;
+}
+
+void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yyout = _out_str ;
+}
+
+int yyget_debug  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yy_flex_debug;
+}
+
+void yyset_debug (int  _bdebug , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yy_flex_debug = _bdebug ;
+}
+
+/* Accessor methods for yylval and yylloc */
+
+YYSTYPE * yyget_lval  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yylval;
+}
+
+void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yylval = yylval_param;
+}
+
+YYLTYPE *yyget_lloc  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    return yylloc;
+}
+    
+void yyset_lloc (YYLTYPE *  yylloc_param , yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    yylloc = yylloc_param;
+}
+    
+/* User-visible API */
+
+/* yylex_init is special because it creates the scanner itself, so it is
+ * the ONLY reentrant function that doesn't take the scanner as the last argument.
+ * That's why we explicitly handle the declaration, instead of using our macros.
+ */
+int yylex_init(yyscan_t* ptr_yy_globals)
+{
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+
+    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );
+
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+
+    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
+/* yylex_init_extra has the same functionality as yylex_init, but follows the
+ * convention of taking the scanner as the last argument. Note however, that
+ * this is a *pointer* to a scanner, as it will be allocated by this call (and
+ * is the reason, too, why this function also must handle its own declaration).
+ * The user defined value in the first argument will be available to yyalloc in
+ * the yyextra field.
+ */
+int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
+{
+    struct yyguts_t dummy_yyguts;
+
+    yyset_extra (yy_user_defined, &dummy_yyguts);
+
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+
+    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
+
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+
+    /* By setting to 0xAA, we expose bugs in
+    yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+
+    yyset_extra (yy_user_defined, *ptr_yy_globals);
+
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
+static int yy_init_globals (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    yyg->yy_buffer_stack = NULL;
+    yyg->yy_buffer_stack_top = 0;
+    yyg->yy_buffer_stack_max = 0;
+    yyg->yy_c_buf_p = NULL;
+    yyg->yy_init = 0;
+    yyg->yy_start = 0;
+
+    yyg->yy_start_stack_ptr = 0;
+    yyg->yy_start_stack_depth = 0;
+    yyg->yy_start_stack =  NULL;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = NULL;
+    yyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (yyscan_t yyscanner)
+{
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state(yyscanner);
+	}
+
+	/* Destroy the stack itself. */
+	yyfree(yyg->yy_buffer_stack , yyscanner);
+	yyg->yy_buffer_stack = NULL;
+
+    /* Destroy the start condition stack. */
+        yyfree( yyg->yy_start_stack , yyscanner );
+        yyg->yy_start_stack = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( yyscanner);
+
+    /* Destroy the main struct (reentrant only). */
+    yyfree ( yyscanner , yyscanner );
+    yyscanner = NULL;
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
+{
+	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	(void)yyg;
+
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
+{
+	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	(void)yyg;
+	return malloc(size);
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
+{
+	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	(void)yyg;
+
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return realloc(ptr, size);
+}
+
+void yyfree (void * ptr , yyscan_t yyscanner)
+{
+	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+	(void)yyg;
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 182 "lexer.l"
+
+
+void augl_close_lexer(yyscan_t *scanner) {
+  FILE *fp = augl_get_in(scanner);
+
+  if (fp != NULL) {
+    fclose(fp);
+    augl_set_in(NULL, scanner);
+  }
+}
+
+int augl_init_lexer(struct state *state, yyscan_t *scanner) {
+  FILE *f;
+  struct string *name = state->info->filename;
+
+  f = fopen(name->str, "r");
+  if (f == NULL)
+    return -1;
+
+  if (augl_lex_init(scanner) != 0) {
+    fclose(f);
+    return -1;
+  }
+  augl_set_extra(state, *scanner);
+  augl_set_in(f, *scanner);
+  return 0;
+}
+
+struct info *augl_get_info(yyscan_t scanner) {
+  return augl_get_extra(scanner)->info;
+}
+
diff --git a/libraries/cmake/source/augeas/generated/linux/ppc64le/code/parser.c b/libraries/cmake/source/augeas/generated/linux/ppc64le/code/parser.c
new file mode 100644
index 000000000..e1235b68e
--- /dev/null
+++ b/libraries/cmake/source/augeas/generated/linux/ppc64le/code/parser.c
@@ -0,0 +1,2722 @@
+/* A Bison parser, made by GNU Bison 3.7.4.  */
+
+/* Bison implementation for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
+   Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output, and Bison version.  */
+#define YYBISON 30704
+
+/* Bison version string.  */
+#define YYBISON_VERSION "3.7.4"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 1
+
+/* Push parsers.  */
+#define YYPUSH 0
+
+/* Pull parsers.  */
+#define YYPULL 1
+
+
+/* Substitute the variable and function names.  */
+#define yyparse         augl_parse
+#define yylex           augl_lex
+#define yyerror         augl_error
+#define yydebug         augl_debug
+#define yynerrs         augl_nerrs
+
+/* First part of user prologue.  */
+#line 1 "parser.y"
+
+
+#include <config.h>
+
+#include "internal.h"
+#include "syntax.h"
+#include "list.h"
+#include "errcode.h"
+#include <stdio.h>
+
+/* Work around a problem on FreeBSD where Bison looks for _STDLIB_H
+ * to see if stdlib.h has been included, but the system includes
+ * use _STDLIB_H_
+ */
+#if HAVE_STDLIB_H && ! defined _STDLIB_H
+#  include <stdlib.h>
+#  define _STDLIB_H 1
+#endif
+
+#define YYDEBUG 1
+
+int augl_parse_file(struct augeas *aug, const char *name, struct term **term);
+
+typedef void *yyscan_t;
+typedef struct info YYLTYPE;
+#define YYLTYPE_IS_DECLARED 1
+/* The lack of reference counting on filename is intentional */
+# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
+  do {                                                                  \
+    (Current).filename = augl_get_info(scanner)->filename;              \
+    (Current).error = augl_get_info(scanner)->error;                    \
+    if (N) {                                                            \
+        (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;          \
+        (Current).first_column = YYRHSLOC (Rhs, 1).first_column;        \
+        (Current).last_line    = YYRHSLOC (Rhs, N).last_line;           \
+        (Current).last_column  = YYRHSLOC (Rhs, N).last_column;         \
+    } else {                                                            \
+      (Current).first_line   = (Current).last_line   =                  \
+	    YYRHSLOC (Rhs, 0).last_line;                                    \
+	  (Current).first_column = (Current).last_column =                  \
+	    YYRHSLOC (Rhs, 0).last_column;                                  \
+    }                                                                   \
+  } while (0)
+
+#line 121 "parser.c"
+
+# ifndef YY_CAST
+#  ifdef __cplusplus
+#   define YY_CAST(Type, Val) static_cast<Type> (Val)
+#   define YY_REINTERPRET_CAST(Type, Val) reinterpret_cast<Type> (Val)
+#  else
+#   define YY_CAST(Type, Val) ((Type) (Val))
+#   define YY_REINTERPRET_CAST(Type, Val) ((Type) (Val))
+#  endif
+# endif
+# ifndef YY_NULLPTR
+#  if defined __cplusplus
+#   if 201103L <= __cplusplus
+#    define YY_NULLPTR nullptr
+#   else
+#    define YY_NULLPTR 0
+#   endif
+#  else
+#   define YY_NULLPTR ((void*)0)
+#  endif
+# endif
+
+/* Use api.header.include to #include this header
+   instead of duplicating it here.  */
+#ifndef YY_AUGL_PARSER_H_INCLUDED
+# define YY_AUGL_PARSER_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int augl_debug;
+#endif
+
+/* Token kinds.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    DQUOTED = 258,                 /* DQUOTED  */
+    REGEXP = 259,                  /* REGEXP  */
+    LIDENT = 260,                  /* LIDENT  */
+    UIDENT = 261,                  /* UIDENT  */
+    QIDENT = 262,                  /* QIDENT  */
+    ARROW = 263,                   /* ARROW  */
+    KW_MODULE = 264,               /* KW_MODULE  */
+    KW_AUTOLOAD = 265,             /* KW_AUTOLOAD  */
+    KW_LET = 266,                  /* KW_LET  */
+    KW_LET_REC = 267,              /* KW_LET_REC  */
+    KW_IN = 268,                   /* KW_IN  */
+    KW_STRING = 269,               /* KW_STRING  */
+    KW_REGEXP = 270,               /* KW_REGEXP  */
+    KW_LENS = 271,                 /* KW_LENS  */
+    KW_TEST = 272,                 /* KW_TEST  */
+    KW_GET = 273,                  /* KW_GET  */
+    KW_PUT = 274,                  /* KW_PUT  */
+    KW_AFTER = 275                 /* KW_AFTER  */
+  };
+  typedef enum yytokentype yytoken_kind_t;
+#endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define DQUOTED 258
+#define REGEXP 259
+#define LIDENT 260
+#define UIDENT 261
+#define QIDENT 262
+#define ARROW 263
+#define KW_MODULE 264
+#define KW_AUTOLOAD 265
+#define KW_LET 266
+#define KW_LET_REC 267
+#define KW_IN 268
+#define KW_STRING 269
+#define KW_REGEXP 270
+#define KW_LENS 271
+#define KW_TEST 272
+#define KW_GET 273
+#define KW_PUT 274
+#define KW_AFTER 275
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+union YYSTYPE
+{
+#line 89 "parser.y"
+
+  struct term    *term;
+  struct type    *type;
+  struct ident   *ident;
+  struct tree    *tree;
+  char           *string;
+  struct {
+    int             nocase;
+    char           *pattern;
+  } regexp;
+  int            intval;
+  enum quant_tag quant;
+
+#line 228 "parser.c"
+
+};
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+/* Location type.  */
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
+typedef struct YYLTYPE YYLTYPE;
+struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+};
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+int augl_parse (struct term **term, yyscan_t scanner);
+/* "%code provides" blocks.  */
+#line 46 "parser.y"
+
+#include "info.h"
+
+/* Track custom scanner state */
+struct state {
+  struct info *info;
+  unsigned int comment_depth;
+};
+
+
+#line 265 "parser.c"
+
+#endif /* !YY_AUGL_PARSER_H_INCLUDED  */
+/* Symbol kind.  */
+enum yysymbol_kind_t
+{
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_DQUOTED = 3,                    /* DQUOTED  */
+  YYSYMBOL_REGEXP = 4,                     /* REGEXP  */
+  YYSYMBOL_LIDENT = 5,                     /* LIDENT  */
+  YYSYMBOL_UIDENT = 6,                     /* UIDENT  */
+  YYSYMBOL_QIDENT = 7,                     /* QIDENT  */
+  YYSYMBOL_ARROW = 8,                      /* ARROW  */
+  YYSYMBOL_KW_MODULE = 9,                  /* KW_MODULE  */
+  YYSYMBOL_KW_AUTOLOAD = 10,               /* KW_AUTOLOAD  */
+  YYSYMBOL_KW_LET = 11,                    /* KW_LET  */
+  YYSYMBOL_KW_LET_REC = 12,                /* KW_LET_REC  */
+  YYSYMBOL_KW_IN = 13,                     /* KW_IN  */
+  YYSYMBOL_KW_STRING = 14,                 /* KW_STRING  */
+  YYSYMBOL_KW_REGEXP = 15,                 /* KW_REGEXP  */
+  YYSYMBOL_KW_LENS = 16,                   /* KW_LENS  */
+  YYSYMBOL_KW_TEST = 17,                   /* KW_TEST  */
+  YYSYMBOL_KW_GET = 18,                    /* KW_GET  */
+  YYSYMBOL_KW_PUT = 19,                    /* KW_PUT  */
+  YYSYMBOL_KW_AFTER = 20,                  /* KW_AFTER  */
+  YYSYMBOL_21_ = 21,                       /* '='  */
+  YYSYMBOL_22_ = 22,                       /* '?'  */
+  YYSYMBOL_23_ = 23,                       /* '*'  */
+  YYSYMBOL_24_ = 24,                       /* ';'  */
+  YYSYMBOL_25_ = 25,                       /* '|'  */
+  YYSYMBOL_26_ = 26,                       /* '-'  */
+  YYSYMBOL_27_ = 27,                       /* '.'  */
+  YYSYMBOL_28_ = 28,                       /* '('  */
+  YYSYMBOL_29_ = 29,                       /* ')'  */
+  YYSYMBOL_30_ = 30,                       /* '['  */
+  YYSYMBOL_31_ = 31,                       /* ']'  */
+  YYSYMBOL_32_ = 32,                       /* '+'  */
+  YYSYMBOL_33_ = 33,                       /* ':'  */
+  YYSYMBOL_34_ = 34,                       /* '{'  */
+  YYSYMBOL_35_ = 35,                       /* '}'  */
+  YYSYMBOL_YYACCEPT = 36,                  /* $accept  */
+  YYSYMBOL_start = 37,                     /* start  */
+  YYSYMBOL_autoload = 38,                  /* autoload  */
+  YYSYMBOL_decls = 39,                     /* decls  */
+  YYSYMBOL_test_exp = 40,                  /* test_exp  */
+  YYSYMBOL_test_special_res = 41,          /* test_special_res  */
+  YYSYMBOL_exp = 42,                       /* exp  */
+  YYSYMBOL_composeexp = 43,                /* composeexp  */
+  YYSYMBOL_unionexp = 44,                  /* unionexp  */
+  YYSYMBOL_minusexp = 45,                  /* minusexp  */
+  YYSYMBOL_catexp = 46,                    /* catexp  */
+  YYSYMBOL_appexp = 47,                    /* appexp  */
+  YYSYMBOL_aexp = 48,                      /* aexp  */
+  YYSYMBOL_rexp = 49,                      /* rexp  */
+  YYSYMBOL_rep = 50,                       /* rep  */
+  YYSYMBOL_qid = 51,                       /* qid  */
+  YYSYMBOL_param_list = 52,                /* param_list  */
+  YYSYMBOL_param = 53,                     /* param  */
+  YYSYMBOL_id = 54,                        /* id  */
+  YYSYMBOL_type = 55,                      /* type  */
+  YYSYMBOL_atype = 56,                     /* atype  */
+  YYSYMBOL_tree_const = 57,                /* tree_const  */
+  YYSYMBOL_tree_const2 = 58,               /* tree_const2  */
+  YYSYMBOL_tree_branch = 59,               /* tree_branch  */
+  YYSYMBOL_tree_label = 60                 /* tree_label  */
+};
+typedef enum yysymbol_kind_t yysymbol_kind_t;
+
+
+/* Second part of user prologue.  */
+#line 114 "parser.y"
+
+/* Lexer */
+extern int augl_lex (YYSTYPE * yylval_param,struct info * yylloc_param ,yyscan_t yyscanner);
+int augl_init_lexer(struct state *state, yyscan_t * scanner);
+void augl_close_lexer(yyscan_t *scanner);
+int augl_lex_destroy (yyscan_t yyscanner );
+int augl_get_lineno (yyscan_t yyscanner );
+int augl_get_column  (yyscan_t yyscanner);
+struct info *augl_get_info(yyscan_t yyscanner);
+char *augl_get_text (yyscan_t yyscanner );
+
+static void augl_error(struct info *locp, struct term **term,
+                       yyscan_t scanner, const char *s);
+
+/* TERM construction */
+ static struct info *clone_info(struct info *locp);
+ static struct term *make_module(char *ident, char *autoload,
+                                 struct term *decls,
+                                 struct info *locp);
+
+ static struct term *make_bind(char *ident, struct term *params,
+                             struct term *exp, struct term *decls,
+                             struct info *locp);
+ static struct term *make_bind_rec(char *ident, struct term *exp,
+                                   struct term *decls, struct info *locp);
+ static struct term *make_let(char *ident, struct term *params,
+                              struct term *exp, struct term *body,
+                              struct info *locp);
+ static struct term *make_binop(enum term_tag tag,
+                               struct term *left, struct term *right,
+                               struct info *locp);
+ static struct term *make_unop(enum term_tag tag,
+                              struct term *exp, struct info *locp);
+ static struct term *make_ident(char *qname, struct info *locp);
+ static struct term *make_unit_term(struct info *locp);
+ static struct term *make_string_term(char *value, struct info *locp);
+ static struct term *make_regexp_term(char *pattern,
+                                      int nocase, struct info *locp);
+ static struct term *make_rep(struct term *exp, enum quant_tag quant,
+                             struct info *locp);
+
+ static struct term *make_get_test(struct term *lens, struct term *arg,
+                                   struct info *info);
+ static struct term *make_put_test(struct term *lens, struct term *arg,
+                                   struct term *cmds, struct info *info);
+ static struct term *make_test(struct term *test, struct term *result,
+                               enum test_result_tag tr_tag,
+                               struct term *decls, struct info *locp);
+ static struct term *make_tree_value(struct tree *, struct info*);
+ static struct tree *tree_concat(struct tree *, struct tree *);
+
+#define LOC_MERGE(a, b, c)                                              \
+ do {                                                                   \
+   (a).filename     = (b).filename;                                     \
+   (a).first_line   = (b).first_line;                                   \
+   (a).first_column = (b).first_column;                                 \
+   (a).last_line    = (c).last_line;                                    \
+   (a).last_column  = (c).last_column;                                  \
+   (a).error        = (b).error;                                        \
+ } while(0);
+
+
+#line 401 "parser.c"
+
+
+#ifdef short
+# undef short
+#endif
+
+/* On compilers that do not define __PTRDIFF_MAX__ etc., make sure
+   <limits.h> and (if available) <stdint.h> are included
+   so that the code can choose integer types of a good width.  */
+
+#ifndef __PTRDIFF_MAX__
+# include <limits.h> /* INFRINGES ON USER NAME SPACE */
+# if defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stdint.h> /* INFRINGES ON USER NAME SPACE */
+#  define YY_STDINT_H
+# endif
+#endif
+
+/* Narrow types that promote to a signed type and that can represent a
+   signed or unsigned integer of at least N bits.  In tables they can
+   save space and decrease cache pressure.  Promoting to a signed type
+   helps avoid bugs in integer arithmetic.  */
+
+#ifdef __INT_LEAST8_MAX__
+typedef __INT_LEAST8_TYPE__ yytype_int8;
+#elif defined YY_STDINT_H
+typedef int_least8_t yytype_int8;
+#else
+typedef signed char yytype_int8;
+#endif
+
+#ifdef __INT_LEAST16_MAX__
+typedef __INT_LEAST16_TYPE__ yytype_int16;
+#elif defined YY_STDINT_H
+typedef int_least16_t yytype_int16;
+#else
+typedef short yytype_int16;
+#endif
+
+#if defined __UINT_LEAST8_MAX__ && __UINT_LEAST8_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST8_TYPE__ yytype_uint8;
+#elif (!defined __UINT_LEAST8_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST8_MAX <= INT_MAX)
+typedef uint_least8_t yytype_uint8;
+#elif !defined __UINT_LEAST8_MAX__ && UCHAR_MAX <= INT_MAX
+typedef unsigned char yytype_uint8;
+#else
+typedef short yytype_uint8;
+#endif
+
+#if defined __UINT_LEAST16_MAX__ && __UINT_LEAST16_MAX__ <= __INT_MAX__
+typedef __UINT_LEAST16_TYPE__ yytype_uint16;
+#elif (!defined __UINT_LEAST16_MAX__ && defined YY_STDINT_H \
+       && UINT_LEAST16_MAX <= INT_MAX)
+typedef uint_least16_t yytype_uint16;
+#elif !defined __UINT_LEAST16_MAX__ && USHRT_MAX <= INT_MAX
+typedef unsigned short yytype_uint16;
+#else
+typedef int yytype_uint16;
+#endif
+
+#ifndef YYPTRDIFF_T
+# if defined __PTRDIFF_TYPE__ && defined __PTRDIFF_MAX__
+#  define YYPTRDIFF_T __PTRDIFF_TYPE__
+#  define YYPTRDIFF_MAXIMUM __PTRDIFF_MAX__
+# elif defined PTRDIFF_MAX
+#  ifndef ptrdiff_t
+#   include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  endif
+#  define YYPTRDIFF_T ptrdiff_t
+#  define YYPTRDIFF_MAXIMUM PTRDIFF_MAX
+# else
+#  define YYPTRDIFF_T long
+#  define YYPTRDIFF_MAXIMUM LONG_MAX
+# endif
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif defined __STDC_VERSION__ && 199901 <= __STDC_VERSION__
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM                                  \
+  YY_CAST (YYPTRDIFF_T,                                 \
+           (YYPTRDIFF_MAXIMUM < YY_CAST (YYSIZE_T, -1)  \
+            ? YYPTRDIFF_MAXIMUM                         \
+            : YY_CAST (YYSIZE_T, -1)))
+
+#define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
+
+
+/* Stored state numbers (used for stacks). */
+typedef yytype_int8 yy_state_t;
+
+/* State numbers in computations.  */
+typedef int yy_state_fast_t;
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(Msgid) Msgid
+# endif
+#endif
+
+
+#ifndef YY_ATTRIBUTE_PURE
+# if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
+# else
+#  define YY_ATTRIBUTE_PURE
+# endif
+#endif
+
+#ifndef YY_ATTRIBUTE_UNUSED
+# if defined __GNUC__ && 2 < __GNUC__ + (7 <= __GNUC_MINOR__)
+#  define YY_ATTRIBUTE_UNUSED __attribute__ ((__unused__))
+# else
+#  define YY_ATTRIBUTE_UNUSED
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(E) ((void) (E))
+#else
+# define YYUSE(E) /* empty */
+#endif
+
+#if defined __GNUC__ && ! defined __ICC && 407 <= __GNUC__ * 100 + __GNUC_MINOR__
+/* Suppress an incorrect diagnostic about yylval being uninitialized.  */
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN                            \
+    _Pragma ("GCC diagnostic push")                                     \
+    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")              \
+    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END      \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define YY_INITIAL_VALUE(Value) Value
+#endif
+#ifndef YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+# define YY_IGNORE_MAYBE_UNINITIALIZED_END
+#endif
+#ifndef YY_INITIAL_VALUE
+# define YY_INITIAL_VALUE(Value) /* Nothing. */
+#endif
+
+#if defined __cplusplus && defined __GNUC__ && ! defined __ICC && 6 <= __GNUC__
+# define YY_IGNORE_USELESS_CAST_BEGIN                          \
+    _Pragma ("GCC diagnostic push")                            \
+    _Pragma ("GCC diagnostic ignored \"-Wuseless-cast\"")
+# define YY_IGNORE_USELESS_CAST_END            \
+    _Pragma ("GCC diagnostic pop")
+#endif
+#ifndef YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_BEGIN
+# define YY_IGNORE_USELESS_CAST_END
+#endif
+
+
+#define YY_ASSERT(E) ((void) (0 && (E)))
+
+#if 1
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+      /* Use EXIT_SUCCESS as a witness for stdlib.h.  */
+#     ifndef EXIT_SUCCESS
+#      define EXIT_SUCCESS 0
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's 'empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
+       && ! ((defined YYMALLOC || defined malloc) \
+             && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef EXIT_SUCCESS
+#    define EXIT_SUCCESS 0
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined EXIT_SUCCESS
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined EXIT_SUCCESS
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* 1 */
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+         || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
+             && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yy_state_t yyss_alloc;
+  YYSTYPE yyvs_alloc;
+  YYLTYPE yyls_alloc;
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (YYSIZEOF (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (YYSIZEOF (yy_state_t) + YYSIZEOF (YYSTYPE) \
+             + YYSIZEOF (YYLTYPE)) \
+      + 2 * YYSTACK_GAP_MAXIMUM)
+
+# define YYCOPY_NEEDED 1
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack_alloc, Stack)                           \
+    do                                                                  \
+      {                                                                 \
+        YYPTRDIFF_T yynewbytes;                                         \
+        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
+        Stack = &yyptr->Stack_alloc;                                    \
+        yynewbytes = yystacksize * YYSIZEOF (*Stack) + YYSTACK_GAP_MAXIMUM; \
+        yyptr += yynewbytes / YYSIZEOF (*yyptr);                        \
+      }                                                                 \
+    while (0)
+
+#endif
+
+#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
+/* Copy COUNT objects from SRC to DST.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(Dst, Src, Count) \
+      __builtin_memcpy (Dst, Src, YY_CAST (YYSIZE_T, (Count)) * sizeof (*(Src)))
+#  else
+#   define YYCOPY(Dst, Src, Count)              \
+      do                                        \
+        {                                       \
+          YYPTRDIFF_T yyi;                      \
+          for (yyi = 0; yyi < (Count); yyi++)   \
+            (Dst)[yyi] = (Src)[yyi];            \
+        }                                       \
+      while (0)
+#  endif
+# endif
+#endif /* !YYCOPY_NEEDED */
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  4
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   129
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  25
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  61
+/* YYNSTATES -- Number of states.  */
+#define YYNSTATES  113
+
+/* YYMAXUTOK -- Last valid token kind.  */
+#define YYMAXUTOK   275
+
+
+/* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex, with out-of-bounds checking.  */
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
+
+/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
+   as returned by yylex.  */
+static const yytype_int8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      28,    29,    23,    32,     2,    26,    27,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    33,    24,
+       2,    21,     2,    22,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,    30,     2,    31,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    34,    25,    35,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20
+};
+
+#if YYDEBUG
+  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
+static const yytype_int16 yyrline[] =
+{
+       0,   179,   179,   182,   185,   187,   192,   197,   202,   208,
+     212,   214,   217,   219,   223,   228,   230,   232,   235,   237,
+     239,   242,   244,   247,   249,   252,   254,   257,   259,   261,
+     263,   265,   267,   270,   272,   275,   277,   279,   282,   284,
+     286,   288,   291,   294,   296,   299,   301,   303,   306,   308,
+     311,   313,   315,   317,   320,   322,   325,   330,   332,   336,
+     340,   342
+};
+#endif
+
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
+
+#if 1
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "\"end of file\"", "error", "\"invalid token\"", "DQUOTED", "REGEXP",
+  "LIDENT", "UIDENT", "QIDENT", "ARROW", "KW_MODULE", "KW_AUTOLOAD",
+  "KW_LET", "KW_LET_REC", "KW_IN", "KW_STRING", "KW_REGEXP", "KW_LENS",
+  "KW_TEST", "KW_GET", "KW_PUT", "KW_AFTER", "'='", "'?'", "'*'", "';'",
+  "'|'", "'-'", "'.'", "'('", "')'", "'['", "']'", "'+'", "':'", "'{'",
+  "'}'", "$accept", "start", "autoload", "decls", "test_exp",
+  "test_special_res", "exp", "composeexp", "unionexp", "minusexp",
+  "catexp", "appexp", "aexp", "rexp", "rep", "qid", "param_list", "param",
+  "id", "type", "atype", "tree_const", "tree_const2", "tree_branch",
+  "tree_label", YY_NULLPTR
+};
+
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
+{
+  return yytname[yysymbol];
+}
+#endif
+
+#ifdef YYPRINT
+/* YYTOKNUM[NUM] -- (External) token number corresponding to the
+   (internal) symbol number NUM (which must be that of a token).  */
+static const yytype_int16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,    61,    63,    42,    59,   124,    45,    46,    40,    41,
+      91,    93,    43,    58,   123,   125
+};
+#endif
+
+#define YYPACT_NINF (-90)
+
+#define yypact_value_is_default(Yyn) \
+  ((Yyn) == YYPACT_NINF)
+
+#define YYTABLE_NINF (-1)
+
+#define yytable_value_is_error(Yyn) \
+  0
+
+  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+     STATE-NUM.  */
+static const yytype_int8 yypact[] =
+{
+      -1,     8,    16,    -4,   -90,    14,    26,    53,   -90,    27,
+      29,    92,   -90,    11,    25,   -90,   -90,   -90,   -90,   -90,
+     -90,    50,    55,    28,    -6,   -90,     1,    30,    11,    55,
+      38,   -90,    44,    34,    52,    57,    51,    59,    92,    49,
+     -90,    64,    56,    22,    55,    92,   -90,   -90,   -90,    60,
+      55,   -90,    53,    11,   -90,    65,    80,   -90,    87,    92,
+      92,    92,   -90,   -90,   -90,   -90,   -90,    44,   -90,   -90,
+     -90,    53,    53,   -90,    82,    -5,    53,   -90,    83,   -90,
+     100,    73,    57,    51,    59,    92,    74,   -90,   -90,    55,
+     -90,   -90,   -90,    -5,    79,   104,   -90,    55,   -90,    44,
+     -90,   -90,    84,   -90,    -5,   101,    73,    81,   -90,   -90,
+      55,   -90,   -90
+};
+
+  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
+     Performed when YYTABLE does not specify something else to do.  Zero
+     means the default is an error.  */
+static const yytype_int8 yydefact[] =
+{
+       0,     0,     0,     0,     1,     4,     0,     9,     3,     0,
+       0,     0,     2,    43,     0,    28,    29,    38,    39,    40,
+      41,     0,     0,     0,     0,    27,     0,     0,    43,     0,
+       0,    32,    61,     0,    15,    17,    19,    22,    24,    34,
+      26,    20,     0,     0,     0,     0,    45,    46,    47,     0,
+       0,    42,     9,    43,    60,     0,    57,    30,     0,     0,
+       0,     0,    25,    37,    35,    36,    33,    61,    31,    12,
+      13,     9,     9,    10,     0,     0,     9,     6,     0,    55,
+       0,    58,    16,    18,    21,    23,     0,     8,     7,     0,
+      50,    51,    52,     0,     0,    49,     5,     0,    57,    61,
+      54,    11,     0,    44,     0,     0,    59,     0,    53,    48,
+       0,    56,    14
+};
+
+  /* YYPGOTO[NTERM-NUM].  */
+static const yytype_int8 yypgoto[] =
+{
+     -90,   -90,   -90,   -34,   -90,   -90,   -22,   -90,    61,    66,
+      58,    62,    -9,   -37,   -90,   -90,   -23,   -90,   -90,   -89,
+     -90,   -90,    31,   -64,   -90
+};
+
+  /* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int8 yydefgoto[] =
+{
+      -1,     2,     7,    12,    23,    71,    33,    34,    35,    36,
+      37,    38,    39,    40,    66,    25,    27,    28,    49,    94,
+      95,    41,    81,    55,    56
+};
+
+  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
+     positive, shift that token.  If negative, reduce the rule whose
+     number is the opposite.  If YYTABLE_NINF, syntax error.  */
+static const yytype_int8 yytable[] =
+{
+      42,    62,    24,    86,   102,    51,    46,    52,     1,    90,
+      91,    92,    44,    45,     3,   109,     4,     5,    77,    47,
+      48,    72,    73,    93,     6,    15,    16,    17,    76,    18,
+      78,     8,    13,    30,    14,   107,    74,    87,    88,    26,
+      19,    20,    96,    53,    69,    70,    29,    54,    62,    43,
+      21,    50,    22,    15,    16,    17,    32,    18,    15,    16,
+      17,    30,    18,    57,     9,    10,    30,   101,    19,    20,
+      11,    63,    64,    19,    20,   105,    58,    60,    21,    31,
+      22,    65,    59,    21,    32,    22,    61,    68,   112,    32,
+      15,    16,    17,    75,    18,    15,    16,    17,    67,    18,
+      79,    80,    89,    98,    97,    19,    20,    99,   103,   100,
+      19,    20,   104,   108,   110,    21,   111,    22,    84,    82,
+      21,    32,    22,    85,     0,    83,     0,     0,     0,   106
+};
+
+static const yytype_int8 yycheck[] =
+{
+      22,    38,    11,    67,    93,    28,     5,    29,     9,    14,
+      15,    16,    18,    19,     6,   104,     0,    21,    52,    18,
+      19,    43,    44,    28,    10,     3,     4,     5,    50,     7,
+      53,     5,     5,    11,     5,    99,    45,    71,    72,    28,
+      18,    19,    76,     5,    22,    23,    21,     3,    85,    21,
+      28,    21,    30,     3,     4,     5,    34,     7,     3,     4,
+       5,    11,     7,    29,    11,    12,    11,    89,    18,    19,
+      17,    22,    23,    18,    19,    97,    24,    26,    28,    29,
+      30,    32,    25,    28,    34,    30,    27,    31,   110,    34,
+       3,     4,     5,    33,     7,     3,     4,     5,    34,     7,
+      35,    21,    20,     3,    21,    18,    19,    34,    29,    35,
+      18,    19,     8,    29,    13,    28,    35,    30,    60,    58,
+      28,    34,    30,    61,    -1,    59,    -1,    -1,    -1,    98
+};
+
+  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+     symbol of state STATE-NUM.  */
+static const yytype_int8 yystos[] =
+{
+       0,     9,    37,     6,     0,    21,    10,    38,     5,    11,
+      12,    17,    39,     5,     5,     3,     4,     5,     7,    18,
+      19,    28,    30,    40,    48,    51,    28,    52,    53,    21,
+      11,    29,    34,    42,    43,    44,    45,    46,    47,    48,
+      49,    57,    42,    21,    18,    19,     5,    18,    19,    54,
+      21,    52,    42,     5,     3,    59,    60,    29,    24,    25,
+      26,    27,    49,    22,    23,    32,    50,    34,    31,    22,
+      23,    41,    42,    42,    48,    33,    42,    39,    52,    35,
+      21,    58,    44,    45,    46,    47,    59,    39,    39,    20,
+      14,    15,    16,    28,    55,    56,    39,    21,     3,    34,
+      35,    42,    55,    29,     8,    42,    58,    59,    29,    55,
+      13,    35,    42
+};
+
+  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_int8 yyr1[] =
+{
+       0,    36,    37,    38,    38,    39,    39,    39,    39,    39,
+      40,    40,    41,    41,    42,    42,    43,    43,    44,    44,
+      44,    45,    45,    46,    46,    47,    47,    48,    48,    48,
+      48,    48,    48,    49,    49,    50,    50,    50,    51,    51,
+      51,    51,    52,    52,    53,    54,    54,    54,    55,    55,
+      56,    56,    56,    56,    57,    57,    58,    58,    59,    59,
+      60,    60
+};
+
+  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
+static const yytype_int8 yyr2[] =
+{
+       0,     2,     5,     2,     0,     6,     5,     5,     5,     0,
+       3,     5,     1,     1,     7,     1,     3,     1,     3,     1,
+       1,     3,     1,     3,     1,     2,     1,     1,     1,     1,
+       3,     3,     2,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     2,     0,     5,     1,     1,     1,     3,     1,
+       1,     1,     1,     3,     4,     3,     4,     0,     2,     4,
+       1,     0
+};
+
+
+enum { YYENOMEM = -2 };
+
+#define yyerrok         (yyerrstatus = 0)
+#define yyclearin       (yychar = YYEMPTY)
+
+#define YYACCEPT        goto yyacceptlab
+#define YYABORT         goto yyabortlab
+#define YYERROR         goto yyerrorlab
+
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                                    \
+  do                                                              \
+    if (yychar == YYEMPTY)                                        \
+      {                                                           \
+        yychar = (Token);                                         \
+        yylval = (Value);                                         \
+        YYPOPSTACK (yylen);                                       \
+        yystate = *yyssp;                                         \
+        goto yybackup;                                            \
+      }                                                           \
+    else                                                          \
+      {                                                           \
+        yyerror (&yylloc, term, scanner, YY_("syntax error: cannot back up")); \
+        YYERROR;                                                  \
+      }                                                           \
+  while (0)
+
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)                                \
+    do                                                                  \
+      if (N)                                                            \
+        {                                                               \
+          (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;        \
+          (Current).first_column = YYRHSLOC (Rhs, 1).first_column;      \
+          (Current).last_line    = YYRHSLOC (Rhs, N).last_line;         \
+          (Current).last_column  = YYRHSLOC (Rhs, N).last_column;       \
+        }                                                               \
+      else                                                              \
+        {                                                               \
+          (Current).first_line   = (Current).last_line   =              \
+            YYRHSLOC (Rhs, 0).last_line;                                \
+          (Current).first_column = (Current).last_column =              \
+            YYRHSLOC (Rhs, 0).last_column;                              \
+        }                                                               \
+    while (0)
+#endif
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)                        \
+do {                                            \
+  if (yydebug)                                  \
+    YYFPRINTF Args;                             \
+} while (0)
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+# ifndef YY_LOCATION_PRINT
+#  if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+
+/* Print *YYLOCP on YYO.  Private, do not rely on its existence. */
+
+YY_ATTRIBUTE_UNUSED
+static int
+yy_location_print_ (FILE *yyo, YYLTYPE const * const yylocp)
+{
+  int res = 0;
+  int end_col = 0 != yylocp->last_column ? yylocp->last_column - 1 : 0;
+  if (0 <= yylocp->first_line)
+    {
+      res += YYFPRINTF (yyo, "%d", yylocp->first_line);
+      if (0 <= yylocp->first_column)
+        res += YYFPRINTF (yyo, ".%d", yylocp->first_column);
+    }
+  if (0 <= yylocp->last_line)
+    {
+      if (yylocp->first_line < yylocp->last_line)
+        {
+          res += YYFPRINTF (yyo, "-%d", yylocp->last_line);
+          if (0 <= end_col)
+            res += YYFPRINTF (yyo, ".%d", end_col);
+        }
+      else if (0 <= end_col && yylocp->first_column < end_col)
+        res += YYFPRINTF (yyo, "-%d", end_col);
+    }
+  return res;
+ }
+
+#   define YY_LOCATION_PRINT(File, Loc)          \
+  yy_location_print_ (File, &(Loc))
+
+#  else
+#   define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+#  endif
+# endif /* !defined YY_LOCATION_PRINT */
+
+
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
+do {                                                                      \
+  if (yydebug)                                                            \
+    {                                                                     \
+      YYFPRINTF (stderr, "%s ", Title);                                   \
+      yy_symbol_print (stderr,                                            \
+                  Kind, Value, Location, term, scanner); \
+      YYFPRINTF (stderr, "\n");                                           \
+    }                                                                     \
+} while (0)
+
+
+/*-----------------------------------.
+| Print this symbol's value on YYO.  |
+`-----------------------------------*/
+
+static void
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, struct term **term, yyscan_t scanner)
+{
+  FILE *yyoutput = yyo;
+  YYUSE (yyoutput);
+  YYUSE (yylocationp);
+  YYUSE (term);
+  YYUSE (scanner);
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yykind < YYNTOKENS)
+    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);
+# endif
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+/*---------------------------.
+| Print this symbol on YYO.  |
+`---------------------------*/
+
+static void
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp, struct term **term, yyscan_t scanner)
+{
+  YYFPRINTF (yyo, "%s %s (",
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
+
+  YY_LOCATION_PRINT (yyo, *yylocationp);
+  YYFPRINTF (yyo, ": ");
+  yy_symbol_value_print (yyo, yykind, yyvaluep, yylocationp, term, scanner);
+  YYFPRINTF (yyo, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+static void
+yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; yybottom <= yytop; yybottom++)
+    {
+      int yybot = *yybottom;
+      YYFPRINTF (stderr, " %d", yybot);
+    }
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)                            \
+do {                                                            \
+  if (yydebug)                                                  \
+    yy_stack_print ((Bottom), (Top));                           \
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+static void
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, YYLTYPE *yylsp,
+                 int yyrule, struct term **term, yyscan_t scanner)
+{
+  int yylno = yyrline[yyrule];
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %d):\n",
+             yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr,
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)],
+                       &(yylsp[(yyi + 1) - (yynrhs)]), term, scanner);
+      YYFPRINTF (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)          \
+do {                                    \
+  if (yydebug)                          \
+    yy_reduce_print (yyssp, yyvsp, yylsp, Rule, term, scanner); \
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+/* Context of a parse error.  */
+typedef struct
+{
+  yy_state_t *yyssp;
+  yysymbol_kind_t yytoken;
+  YYLTYPE *yylloc;
+} yypcontext_t;
+
+/* Put in YYARG at most YYARGN of the expected tokens given the
+   current YYCTX, and return the number of tokens stored in YYARG.  If
+   YYARG is null, return the number of expected tokens (guaranteed to
+   be less than YYNTOKENS).  Return YYENOMEM on memory exhaustion.
+   Return 0 if there are more than YYARGN expected tokens, yet fill
+   YYARG up to YYARGN. */
+static int
+yypcontext_expected_tokens (const yypcontext_t *yyctx,
+                            yysymbol_kind_t yyarg[], int yyargn)
+{
+  /* Actual size of YYARG. */
+  int yycount = 0;
+  int yyn = yypact[+*yyctx->yyssp];
+  if (!yypact_value_is_default (yyn))
+    {
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+         YYCHECK.  In other words, skip the first -YYN actions for
+         this state because they are default actions.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yyx;
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+        if (yycheck[yyx + yyn] == yyx && yyx != YYSYMBOL_YYerror
+            && !yytable_value_is_error (yytable[yyx + yyn]))
+          {
+            if (!yyarg)
+              ++yycount;
+            else if (yycount == yyargn)
+              return 0;
+            else
+              yyarg[yycount++] = YY_CAST (yysymbol_kind_t, yyx);
+          }
+    }
+  if (yyarg && yycount == 0 && 0 < yyargn)
+    yyarg[0] = YYSYMBOL_YYEMPTY;
+  return yycount;
+}
+
+
+
+
+#ifndef yystrlen
+# if defined __GLIBC__ && defined _STRING_H
+#  define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
+# else
+/* Return the length of YYSTR.  */
+static YYPTRDIFF_T
+yystrlen (const char *yystr)
+{
+  YYPTRDIFF_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+# endif
+#endif
+
+#ifndef yystpcpy
+# if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#  define yystpcpy stpcpy
+# else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+# endif
+#endif
+
+#ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYPTRDIFF_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYPTRDIFF_T yyn = 0;
+      char const *yyp = yystr;
+      for (;;)
+        switch (*++yyp)
+          {
+          case '\'':
+          case ',':
+            goto do_not_strip_quotes;
+
+          case '\\':
+            if (*++yyp != '\\')
+              goto do_not_strip_quotes;
+            else
+              goto append;
+
+          append:
+          default:
+            if (yyres)
+              yyres[yyn] = *yyp;
+            yyn++;
+            break;
+
+          case '"':
+            if (yyres)
+              yyres[yyn] = '\0';
+            return yyn;
+          }
+    do_not_strip_quotes: ;
+    }
+
+  if (yyres)
+    return yystpcpy (yyres, yystr) - yyres;
+  else
+    return yystrlen (yystr);
+}
+#endif
+
+
+static int
+yy_syntax_error_arguments (const yypcontext_t *yyctx,
+                           yysymbol_kind_t yyarg[], int yyargn)
+{
+  /* Actual size of YYARG. */
+  int yycount = 0;
+  /* There are many possibilities here to consider:
+     - If this state is a consistent state with a default action, then
+       the only way this function was invoked is if the default action
+       is an error action.  In that case, don't check for expected
+       tokens because there are none.
+     - The only way there can be no lookahead present (in yychar) is if
+       this state is a consistent state with a default action.  Thus,
+       detecting the absence of a lookahead is sufficient to determine
+       that there is no unexpected or expected token to report.  In that
+       case, just report a simple "syntax error".
+     - Don't assume there isn't a lookahead just because this state is a
+       consistent state with a default action.  There might have been a
+       previous inconsistent state, consistent state with a non-default
+       action, or user semantic action that manipulated yychar.
+     - Of course, the expected token list depends on states to have
+       correct lookahead information, and it depends on the parser not
+       to perform extra reductions after fetching a lookahead from the
+       scanner and before detecting a syntax error.  Thus, state merging
+       (from LALR or IELR) and default reductions corrupt the expected
+       token list.  However, the list is correct for canonical LR with
+       one exception: it will still contain any token that will not be
+       accepted due to an error action in a later state.
+  */
+  if (yyctx->yytoken != YYSYMBOL_YYEMPTY)
+    {
+      int yyn;
+      if (yyarg)
+        yyarg[yycount] = yyctx->yytoken;
+      ++yycount;
+      yyn = yypcontext_expected_tokens (yyctx,
+                                        yyarg ? yyarg + 1 : yyarg, yyargn - 1);
+      if (yyn == YYENOMEM)
+        return YYENOMEM;
+      else
+        yycount += yyn;
+    }
+  return yycount;
+}
+
+/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
+   about the unexpected token YYTOKEN for the state stack whose top is
+   YYSSP.
+
+   Return 0 if *YYMSG was successfully written.  Return -1 if *YYMSG is
+   not large enough to hold the message.  In that case, also set
+   *YYMSG_ALLOC to the required number of bytes.  Return YYENOMEM if the
+   required number of bytes is too large to store.  */
+static int
+yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
+                const yypcontext_t *yyctx)
+{
+  enum { YYARGS_MAX = 5 };
+  /* Internationalized format string. */
+  const char *yyformat = YY_NULLPTR;
+  /* Arguments of yyformat: reported tokens (one for the "unexpected",
+     one per "expected"). */
+  yysymbol_kind_t yyarg[YYARGS_MAX];
+  /* Cumulated lengths of YYARG.  */
+  YYPTRDIFF_T yysize = 0;
+
+  /* Actual size of YYARG. */
+  int yycount = yy_syntax_error_arguments (yyctx, yyarg, YYARGS_MAX);
+  if (yycount == YYENOMEM)
+    return YYENOMEM;
+
+  switch (yycount)
+    {
+#define YYCASE_(N, S)                       \
+      case N:                               \
+        yyformat = S;                       \
+        break
+    default: /* Avoid compiler warnings. */
+      YYCASE_(0, YY_("syntax error"));
+      YYCASE_(1, YY_("syntax error, unexpected %s"));
+      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
+      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
+      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
+      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
+#undef YYCASE_
+    }
+
+  /* Compute error message size.  Don't count the "%s"s, but reserve
+     room for the terminator.  */
+  yysize = yystrlen (yyformat) - 2 * yycount + 1;
+  {
+    int yyi;
+    for (yyi = 0; yyi < yycount; ++yyi)
+      {
+        YYPTRDIFF_T yysize1
+          = yysize + yytnamerr (YY_NULLPTR, yytname[yyarg[yyi]]);
+        if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
+          yysize = yysize1;
+        else
+          return YYENOMEM;
+      }
+  }
+
+  if (*yymsg_alloc < yysize)
+    {
+      *yymsg_alloc = 2 * yysize;
+      if (! (yysize <= *yymsg_alloc
+             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
+        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
+      return -1;
+    }
+
+  /* Avoid sprintf, as that infringes on the user's name space.
+     Don't have undefined behavior even if the translation
+     produced a string with the wrong number of "%s"s.  */
+  {
+    char *yyp = *yymsg;
+    int yyi = 0;
+    while ((*yyp = *yyformat) != '\0')
+      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
+        {
+          yyp += yytnamerr (yyp, yytname[yyarg[yyi++]]);
+          yyformat += 2;
+        }
+      else
+        {
+          ++yyp;
+          ++yyformat;
+        }
+  }
+  return 0;
+}
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+static void
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, struct term **term, yyscan_t scanner)
+{
+  YYUSE (yyvaluep);
+  YYUSE (yylocationp);
+  YYUSE (term);
+  YYUSE (scanner);
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  YYUSE (yykind);
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+}
+
+
+
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+int
+yyparse (struct term **term, yyscan_t scanner)
+{
+/* Lookahead token kind.  */
+int yychar;
+
+
+/* The semantic value of the lookahead symbol.  */
+/* Default value used for initialization, for pacifying older GCCs
+   or non-GCC compilers.  */
+YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
+YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
+
+/* Location data for the lookahead symbol.  */
+static YYLTYPE yyloc_default
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+  = { 1, 1, 1, 1 }
+# endif
+;
+YYLTYPE yylloc = yyloc_default;
+
+    /* Number of syntax errors so far.  */
+    int yynerrs = 0;
+
+    yy_state_fast_t yystate = 0;
+    /* Number of tokens to shift before error messages enabled.  */
+    int yyerrstatus = 0;
+
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
+       to reallocate them elsewhere.  */
+
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
+
+    /* The state stack: array, bottom, top.  */
+    yy_state_t yyssa[YYINITDEPTH];
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
+
+    /* The semantic value stack: array, bottom, top.  */
+    YYSTYPE yyvsa[YYINITDEPTH];
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
+
+    /* The location stack: array, bottom, top.  */
+    YYLTYPE yylsa[YYINITDEPTH];
+    YYLTYPE *yyls = yylsa;
+    YYLTYPE *yylsp = yyls;
+
+  int yyn;
+  /* The return value of yyparse.  */
+  int yyresult;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+  YYLTYPE yyloc;
+
+  /* The locations where the error started and ended.  */
+  YYLTYPE yyerror_range[3];
+
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yychar = YYEMPTY; /* Cause a token to be read.  */
+
+/* User initialization code.  */
+#line 66 "parser.y"
+{
+  yylloc.first_line   = 1;
+  yylloc.first_column = 0;
+  yylloc.last_line    = 1;
+  yylloc.last_column  = 0;
+  yylloc.filename     = augl_get_info(scanner)->filename;
+  yylloc.error        = augl_get_info(scanner)->error;
+}
+
+#line 1612 "parser.c"
+
+  yylsp[0] = yylloc;
+  goto yysetstate;
+
+
+/*------------------------------------------------------------.
+| yynewstate -- push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+
+/*--------------------------------------------------------------------.
+| yysetstate -- set current state (the top of the stack) to yystate.  |
+`--------------------------------------------------------------------*/
+yysetstate:
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+  YY_ASSERT (0 <= yystate && yystate < YYNSTATES);
+  YY_IGNORE_USELESS_CAST_BEGIN
+  *yyssp = YY_CAST (yy_state_t, yystate);
+  YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
+
+  if (yyss + yystacksize - 1 <= yyssp)
+#if !defined yyoverflow && !defined YYSTACK_RELOCATE
+    goto yyexhaustedlab;
+#else
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYPTRDIFF_T yysize = yyssp - yyss + 1;
+
+# if defined yyoverflow
+      {
+        /* Give user a chance to reallocate the stack.  Use copies of
+           these so that the &'s don't force the real ones into
+           memory.  */
+        yy_state_t *yyss1 = yyss;
+        YYSTYPE *yyvs1 = yyvs;
+        YYLTYPE *yyls1 = yyls;
+
+        /* Each stack pointer address is followed by the size of the
+           data in use in that stack, in bytes.  This used to be a
+           conditional around just the two extra args, but that might
+           be undefined if yyoverflow is a macro.  */
+        yyoverflow (YY_("memory exhausted"),
+                    &yyss1, yysize * YYSIZEOF (*yyssp),
+                    &yyvs1, yysize * YYSIZEOF (*yyvsp),
+                    &yyls1, yysize * YYSIZEOF (*yylsp),
+                    &yystacksize);
+        yyss = yyss1;
+        yyvs = yyvs1;
+        yyls = yyls1;
+      }
+# else /* defined YYSTACK_RELOCATE */
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+        goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+        yystacksize = YYMAXDEPTH;
+
+      {
+        yy_state_t *yyss1 = yyss;
+        union yyalloc *yyptr =
+          YY_CAST (union yyalloc *,
+                   YYSTACK_ALLOC (YY_CAST (YYSIZE_T, YYSTACK_BYTES (yystacksize))));
+        if (! yyptr)
+          goto yyexhaustedlab;
+        YYSTACK_RELOCATE (yyss_alloc, yyss);
+        YYSTACK_RELOCATE (yyvs_alloc, yyvs);
+        YYSTACK_RELOCATE (yyls_alloc, yyls);
+#  undef YYSTACK_RELOCATE
+        if (yyss1 != yyssa)
+          YYSTACK_FREE (yyss1);
+      }
+# endif
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+      yylsp = yyls + yysize - 1;
+
+      YY_IGNORE_USELESS_CAST_BEGIN
+      YYDPRINTF ((stderr, "Stack size increased to %ld\n",
+                  YY_CAST (long, yystacksize)));
+      YY_IGNORE_USELESS_CAST_END
+
+      if (yyss + yystacksize - 1 <= yyssp)
+        YYABORT;
+    }
+#endif /* !defined yyoverflow && !defined YYSTACK_RELOCATE */
+
+  if (yystate == YYFINAL)
+    YYACCEPT;
+
+  goto yybackup;
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+  /* Do appropriate processing given the current state.  Read a
+     lookahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+  yyn = yypact[yystate];
+  if (yypact_value_is_default (yyn))
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token\n"));
+      yychar = yylex (&yylval, &yylloc, scanner);
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      yyerror_range[1] = yylloc;
+      goto yyerrlab1;
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yytable_value_is_error (yyn))
+        goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the lookahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+  yystate = yyn;
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+  *++yylsp = yylloc;
+
+  /* Discard the shifted token.  */
+  yychar = YYEMPTY;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     '$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+  /* Default location. */
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+  yyerror_range[1] = yyloc;
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+  case 2: /* start: KW_MODULE UIDENT '=' autoload decls  */
+#line 180 "parser.y"
+       { (*term) = make_module((yyvsp[-3].string), (yyvsp[-1].string), (yyvsp[0].term), &(yylsp[-4])); }
+#line 1824 "parser.c"
+    break;
+
+  case 3: /* autoload: KW_AUTOLOAD LIDENT  */
+#line 183 "parser.y"
+          { (yyval.string) = (yyvsp[0].string); }
+#line 1830 "parser.c"
+    break;
+
+  case 4: /* autoload: %empty  */
+#line 185 "parser.y"
+          { (yyval.string) = NULL; }
+#line 1836 "parser.c"
+    break;
+
+  case 5: /* decls: KW_LET LIDENT param_list '=' exp decls  */
+#line 188 "parser.y"
+       {
+         LOC_MERGE((yylsp[-5]), (yylsp[-5]), (yylsp[-1]));
+         (yyval.term) = make_bind((yyvsp[-4].string), (yyvsp[-3].term), (yyvsp[-1].term), (yyvsp[0].term), &(yylsp[-5]));
+       }
+#line 1845 "parser.c"
+    break;
+
+  case 6: /* decls: KW_LET_REC LIDENT '=' exp decls  */
+#line 193 "parser.y"
+       {
+         LOC_MERGE((yylsp[-4]), (yylsp[-4]), (yylsp[-1]));
+         (yyval.term) = make_bind_rec((yyvsp[-3].string), (yyvsp[-1].term), (yyvsp[0].term), &(yylsp[-4]));
+       }
+#line 1854 "parser.c"
+    break;
+
+  case 7: /* decls: KW_TEST test_exp '=' exp decls  */
+#line 198 "parser.y"
+       {
+         LOC_MERGE((yylsp[-4]), (yylsp[-4]), (yylsp[-1]));
+         (yyval.term) = make_test((yyvsp[-3].term), (yyvsp[-1].term), TR_CHECK, (yyvsp[0].term), &(yylsp[-4]));
+       }
+#line 1863 "parser.c"
+    break;
+
+  case 8: /* decls: KW_TEST test_exp '=' test_special_res decls  */
+#line 203 "parser.y"
+       {
+         LOC_MERGE((yylsp[-4]), (yylsp[-4]), (yylsp[-1]));
+         (yyval.term) = make_test((yyvsp[-3].term), NULL, (yyvsp[-1].intval), (yyvsp[0].term), &(yylsp[-4]));
+       }
+#line 1872 "parser.c"
+    break;
+
+  case 9: /* decls: %empty  */
+#line 208 "parser.y"
+       { (yyval.term) = NULL; }
+#line 1878 "parser.c"
+    break;
+
+  case 10: /* test_exp: aexp KW_GET exp  */
+#line 213 "parser.y"
+          { (yyval.term) = make_get_test((yyvsp[-2].term), (yyvsp[0].term), &(yyloc)); }
+#line 1884 "parser.c"
+    break;
+
+  case 11: /* test_exp: aexp KW_PUT aexp KW_AFTER exp  */
+#line 215 "parser.y"
+          { (yyval.term) = make_put_test((yyvsp[-4].term), (yyvsp[-2].term), (yyvsp[0].term), &(yyloc)); }
+#line 1890 "parser.c"
+    break;
+
+  case 12: /* test_special_res: '?'  */
+#line 218 "parser.y"
+                  { (yyval.intval) = TR_PRINT; }
+#line 1896 "parser.c"
+    break;
+
+  case 13: /* test_special_res: '*'  */
+#line 220 "parser.y"
+                  { (yyval.intval) = TR_EXN; }
+#line 1902 "parser.c"
+    break;
+
+  case 14: /* exp: KW_LET LIDENT param_list '=' exp KW_IN exp  */
+#line 224 "parser.y"
+     {
+       LOC_MERGE((yylsp[-6]), (yylsp[-6]), (yylsp[-1]));
+       (yyval.term) = make_let((yyvsp[-5].string), (yyvsp[-4].term), (yyvsp[-2].term), (yyvsp[0].term), &(yylsp[-6]));
+     }
+#line 1911 "parser.c"
+    break;
+
+  case 16: /* composeexp: composeexp ';' unionexp  */
+#line 231 "parser.y"
+     { (yyval.term) = make_binop(A_COMPOSE, (yyvsp[-2].term), (yyvsp[0].term), &(yyloc)); }
+#line 1917 "parser.c"
+    break;
+
+  case 17: /* composeexp: unionexp  */
+#line 233 "parser.y"
+     { (yyval.term) = (yyvsp[0].term); }
+#line 1923 "parser.c"
+    break;
+
+  case 18: /* unionexp: unionexp '|' minusexp  */
+#line 236 "parser.y"
+     { (yyval.term) = make_binop(A_UNION, (yyvsp[-2].term), (yyvsp[0].term), &(yyloc)); }
+#line 1929 "parser.c"
+    break;
+
+  case 19: /* unionexp: minusexp  */
+#line 238 "parser.y"
+     { (yyval.term) = (yyvsp[0].term); }
+#line 1935 "parser.c"
+    break;
+
+  case 20: /* unionexp: tree_const  */
+#line 240 "parser.y"
+     { (yyval.term) = make_tree_value((yyvsp[0].tree), &(yylsp[0])); }
+#line 1941 "parser.c"
+    break;
+
+  case 21: /* minusexp: minusexp '-' catexp  */
+#line 243 "parser.y"
+     { (yyval.term) = make_binop(A_MINUS, (yyvsp[-2].term), (yyvsp[0].term), &(yyloc)); }
+#line 1947 "parser.c"
+    break;
+
+  case 22: /* minusexp: catexp  */
+#line 245 "parser.y"
+     { (yyval.term) = (yyvsp[0].term); }
+#line 1953 "parser.c"
+    break;
+
+  case 23: /* catexp: catexp '.' appexp  */
+#line 248 "parser.y"
+{ (yyval.term) = make_binop(A_CONCAT, (yyvsp[-2].term), (yyvsp[0].term), &(yyloc)); }
+#line 1959 "parser.c"
+    break;
+
+  case 24: /* catexp: appexp  */
+#line 250 "parser.y"
+{ (yyval.term) = (yyvsp[0].term); }
+#line 1965 "parser.c"
+    break;
+
+  case 25: /* appexp: appexp rexp  */
+#line 253 "parser.y"
+        { (yyval.term) = make_binop(A_APP, (yyvsp[-1].term), (yyvsp[0].term), &(yyloc)); }
+#line 1971 "parser.c"
+    break;
+
+  case 26: /* appexp: rexp  */
+#line 255 "parser.y"
+        { (yyval.term) = (yyvsp[0].term); }
+#line 1977 "parser.c"
+    break;
+
+  case 27: /* aexp: qid  */
+#line 258 "parser.y"
+      { (yyval.term) = make_ident((yyvsp[0].string), &(yylsp[0])); }
+#line 1983 "parser.c"
+    break;
+
+  case 28: /* aexp: DQUOTED  */
+#line 260 "parser.y"
+      { (yyval.term) = make_string_term((yyvsp[0].string), &(yylsp[0])); }
+#line 1989 "parser.c"
+    break;
+
+  case 29: /* aexp: REGEXP  */
+#line 262 "parser.y"
+      { (yyval.term) = make_regexp_term((yyvsp[0].regexp).pattern, (yyvsp[0].regexp).nocase, &(yylsp[0])); }
+#line 1995 "parser.c"
+    break;
+
+  case 30: /* aexp: '(' exp ')'  */
+#line 264 "parser.y"
+      { (yyval.term) = (yyvsp[-1].term); }
+#line 2001 "parser.c"
+    break;
+
+  case 31: /* aexp: '[' exp ']'  */
+#line 266 "parser.y"
+      { (yyval.term) = make_unop(A_BRACKET, (yyvsp[-1].term), &(yyloc)); }
+#line 2007 "parser.c"
+    break;
+
+  case 32: /* aexp: '(' ')'  */
+#line 268 "parser.y"
+      { (yyval.term) = make_unit_term(&(yyloc)); }
+#line 2013 "parser.c"
+    break;
+
+  case 33: /* rexp: aexp rep  */
+#line 271 "parser.y"
+      { (yyval.term) = make_rep((yyvsp[-1].term), (yyvsp[0].quant), &(yyloc)); }
+#line 2019 "parser.c"
+    break;
+
+  case 34: /* rexp: aexp  */
+#line 273 "parser.y"
+      { (yyval.term) = (yyvsp[0].term); }
+#line 2025 "parser.c"
+    break;
+
+  case 35: /* rep: '*'  */
+#line 276 "parser.y"
+     { (yyval.quant) = Q_STAR; }
+#line 2031 "parser.c"
+    break;
+
+  case 36: /* rep: '+'  */
+#line 278 "parser.y"
+     { (yyval.quant) = Q_PLUS; }
+#line 2037 "parser.c"
+    break;
+
+  case 37: /* rep: '?'  */
+#line 280 "parser.y"
+     { (yyval.quant) = Q_MAYBE; }
+#line 2043 "parser.c"
+    break;
+
+  case 38: /* qid: LIDENT  */
+#line 283 "parser.y"
+     { (yyval.string) = (yyvsp[0].string); }
+#line 2049 "parser.c"
+    break;
+
+  case 39: /* qid: QIDENT  */
+#line 285 "parser.y"
+     { (yyval.string) = (yyvsp[0].string); }
+#line 2055 "parser.c"
+    break;
+
+  case 40: /* qid: KW_GET  */
+#line 287 "parser.y"
+     { (yyval.string) = strdup("get"); }
+#line 2061 "parser.c"
+    break;
+
+  case 41: /* qid: KW_PUT  */
+#line 289 "parser.y"
+     { (yyval.string) = strdup("put"); }
+#line 2067 "parser.c"
+    break;
+
+  case 42: /* param_list: param param_list  */
+#line 292 "parser.y"
+            { (yyval.term) = (yyvsp[0].term); list_cons((yyval.term), (yyvsp[-1].term)); }
+#line 2073 "parser.c"
+    break;
+
+  case 43: /* param_list: %empty  */
+#line 294 "parser.y"
+            { (yyval.term) = NULL; }
+#line 2079 "parser.c"
+    break;
+
+  case 44: /* param: '(' id ':' type ')'  */
+#line 297 "parser.y"
+       { (yyval.term) = make_param((yyvsp[-3].string), (yyvsp[-1].type), clone_info(&(yylsp[-4]))); }
+#line 2085 "parser.c"
+    break;
+
+  case 45: /* id: LIDENT  */
+#line 300 "parser.y"
+    { (yyval.string) = (yyvsp[0].string); }
+#line 2091 "parser.c"
+    break;
+
+  case 46: /* id: KW_GET  */
+#line 302 "parser.y"
+    { (yyval.string) = strdup("get"); }
+#line 2097 "parser.c"
+    break;
+
+  case 47: /* id: KW_PUT  */
+#line 304 "parser.y"
+    { (yyval.string) = strdup("put"); }
+#line 2103 "parser.c"
+    break;
+
+  case 48: /* type: atype ARROW type  */
+#line 307 "parser.y"
+      { (yyval.type) = make_arrow_type((yyvsp[-2].type), (yyvsp[0].type)); }
+#line 2109 "parser.c"
+    break;
+
+  case 49: /* type: atype  */
+#line 309 "parser.y"
+      { (yyval.type) = (yyvsp[0].type); }
+#line 2115 "parser.c"
+    break;
+
+  case 50: /* atype: KW_STRING  */
+#line 312 "parser.y"
+       { (yyval.type) = make_base_type(T_STRING); }
+#line 2121 "parser.c"
+    break;
+
+  case 51: /* atype: KW_REGEXP  */
+#line 314 "parser.y"
+       { (yyval.type) = make_base_type(T_REGEXP); }
+#line 2127 "parser.c"
+    break;
+
+  case 52: /* atype: KW_LENS  */
+#line 316 "parser.y"
+       { (yyval.type) = make_base_type(T_LENS); }
+#line 2133 "parser.c"
+    break;
+
+  case 53: /* atype: '(' type ')'  */
+#line 318 "parser.y"
+       { (yyval.type) = (yyvsp[-1].type); }
+#line 2139 "parser.c"
+    break;
+
+  case 54: /* tree_const: tree_const '{' tree_branch '}'  */
+#line 321 "parser.y"
+            { (yyval.tree) = tree_concat((yyvsp[-3].tree), (yyvsp[-1].tree)); }
+#line 2145 "parser.c"
+    break;
+
+  case 55: /* tree_const: '{' tree_branch '}'  */
+#line 323 "parser.y"
+            { (yyval.tree) = tree_concat((yyvsp[-1].tree), NULL); }
+#line 2151 "parser.c"
+    break;
+
+  case 56: /* tree_const2: tree_const2 '{' tree_branch '}'  */
+#line 326 "parser.y"
+            {
+              (yyval.tree) = tree_concat((yyvsp[-3].tree), (yyvsp[-1].tree));
+            }
+#line 2159 "parser.c"
+    break;
+
+  case 57: /* tree_const2: %empty  */
+#line 330 "parser.y"
+            { (yyval.tree) = NULL; }
+#line 2165 "parser.c"
+    break;
+
+  case 58: /* tree_branch: tree_label tree_const2  */
+#line 333 "parser.y"
+             {
+               (yyval.tree) = make_tree((yyvsp[-1].string), NULL, NULL, (yyvsp[0].tree));
+             }
+#line 2173 "parser.c"
+    break;
+
+  case 59: /* tree_branch: tree_label '=' DQUOTED tree_const2  */
+#line 337 "parser.y"
+             {
+               (yyval.tree) = make_tree((yyvsp[-3].string), (yyvsp[-1].string), NULL, (yyvsp[0].tree));
+             }
+#line 2181 "parser.c"
+    break;
+
+  case 61: /* tree_label: %empty  */
+#line 342 "parser.y"
+            { (yyval.string) = NULL; }
+#line 2187 "parser.c"
+    break;
+
+
+#line 2191 "parser.c"
+
+      default: break;
+    }
+  /* User semantic actions sometimes alter yychar, and that requires
+     that yytoken be updated with the new translation.  We take the
+     approach of translating immediately before every use of yytoken.
+     One alternative is translating here after every semantic action,
+     but that translation would be missed if the semantic action invokes
+     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
+     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
+     incorrect destructor might then be invoked immediately.  In the
+     case of YYERROR or YYBACKUP, subsequent parser actions might lead
+     to an incorrect destructor call or verbose syntax error message
+     before the lookahead is translated.  */
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+
+  *++yyvsp = yyval;
+  *++yylsp = yyloc;
+
+  /* Now 'shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+  {
+    const int yylhs = yyr1[yyn] - YYNTOKENS;
+    const int yyi = yypgoto[yylhs] + *yyssp;
+    yystate = (0 <= yyi && yyi <= YYLAST && yycheck[yyi] == *yyssp
+               ? yytable[yyi]
+               : yydefgoto[yylhs]);
+  }
+
+  goto yynewstate;
+
+
+/*--------------------------------------.
+| yyerrlab -- here on detecting error.  |
+`--------------------------------------*/
+yyerrlab:
+  /* Make sure we have latest lookahead translation.  See comments at
+     user semantic actions for why this is necessary.  */
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+      {
+        yypcontext_t yyctx
+          = {yyssp, yytoken, &yylloc};
+        char const *yymsgp = YY_("syntax error");
+        int yysyntax_error_status;
+        yysyntax_error_status = yysyntax_error (&yymsg_alloc, &yymsg, &yyctx);
+        if (yysyntax_error_status == 0)
+          yymsgp = yymsg;
+        else if (yysyntax_error_status == -1)
+          {
+            if (yymsg != yymsgbuf)
+              YYSTACK_FREE (yymsg);
+            yymsg = YY_CAST (char *,
+                             YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
+            if (yymsg)
+              {
+                yysyntax_error_status
+                  = yysyntax_error (&yymsg_alloc, &yymsg, &yyctx);
+                yymsgp = yymsg;
+              }
+            else
+              {
+                yymsg = yymsgbuf;
+                yymsg_alloc = sizeof yymsgbuf;
+                yysyntax_error_status = YYENOMEM;
+              }
+          }
+        yyerror (&yylloc, term, scanner, yymsgp);
+        if (yysyntax_error_status == YYENOMEM)
+          goto yyexhaustedlab;
+      }
+    }
+
+  yyerror_range[1] = yylloc;
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse lookahead token after an
+         error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+          /* Return failure if at end of input.  */
+          if (yychar == YYEOF)
+            YYABORT;
+        }
+      else
+        {
+          yydestruct ("Error: discarding",
+                      yytoken, &yylval, &yylloc, term, scanner);
+          yychar = YYEMPTY;
+        }
+    }
+
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+  /* Pacify compilers when the user code never invokes YYERROR and the
+     label yyerrorlab therefore never appears in user code.  */
+  if (0)
+    YYERROR;
+
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;      /* Each real token shifted decrements this.  */
+
+  /* Pop stack until we find a state that shifts the error token.  */
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (!yypact_value_is_default (yyn))
+        {
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
+            {
+              yyn = yytable[yyn];
+              if (0 < yyn)
+                break;
+            }
+        }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+        YYABORT;
+
+      yyerror_range[1] = *yylsp;
+      yydestruct ("Error: popping",
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp, yylsp, term, scanner);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
+  *++yyvsp = yylval;
+  YY_IGNORE_MAYBE_UNINITIALIZED_END
+
+  yyerror_range[2] = yylloc;
+  ++yylsp;
+  YYLLOC_DEFAULT (*yylsp, yyerror_range, 2);
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+
+#if 1
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (&yylloc, term, scanner, YY_("memory exhausted"));
+  yyresult = 2;
+  goto yyreturn;
+#endif
+
+
+/*-------------------------------------------------------.
+| yyreturn -- parsing is finished, clean up and return.  |
+`-------------------------------------------------------*/
+yyreturn:
+  if (yychar != YYEMPTY)
+    {
+      /* Make sure we have latest lookahead translation.  See comments at
+         user semantic actions for why this is necessary.  */
+      yytoken = YYTRANSLATE (yychar);
+      yydestruct ("Cleanup: discarding lookahead",
+                  yytoken, &yylval, &yylloc, term, scanner);
+    }
+  /* Do not reclaim the symbols of the rule whose action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, yylsp, term, scanner);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+  return yyresult;
+}
+
+#line 343 "parser.y"
+
+
+int augl_parse_file(struct augeas *aug, const char *name,
+                    struct term **term) {
+  yyscan_t          scanner;
+  struct state      state;
+  struct string  *sname = NULL;
+  struct info    info;
+  int result = -1;
+  int r;
+
+  *term = NULL;
+
+  r = make_ref(sname);
+  ERR_NOMEM(r < 0, aug);
+
+  sname->str = strdup(name);
+  ERR_NOMEM(sname->str == NULL, aug);
+
+  MEMZERO(&info, 1);
+  info.ref = UINT_MAX;
+  info.filename = sname;
+  info.error = aug->error;
+
+  MEMZERO(&state, 1);
+  state.info = &info;
+  state.comment_depth = 0;
+
+  if (augl_init_lexer(&state, &scanner) < 0) {
+    augl_error(&info, term, NULL, "file not found");
+    goto error;
+  }
+
+  yydebug = getenv("YYDEBUG") != NULL;
+  r = augl_parse(term, scanner);
+  augl_close_lexer(scanner);
+  augl_lex_destroy(scanner);
+  if (r == 1) {
+    augl_error(&info, term, NULL, "syntax error");
+    goto error;
+  } else if (r == 2) {
+    augl_error(&info, term, NULL, "parser ran out of memory");
+    ERR_NOMEM(1, aug);
+  }
+  result = 0;
+
+ error:
+  unref(sname, string);
+  // free TERM
+  return result;
+}
+
+// FIXME: Nothing here checks for alloc errors.
+static struct info *clone_info(struct info *locp) {
+  struct info *info;
+  make_ref(info);
+  info->filename     = ref(locp->filename);
+  info->first_line   = locp->first_line;
+  info->first_column = locp->first_column;
+  info->last_line    = locp->last_line;
+  info->last_column  = locp->last_column;
+  info->error        = locp->error;
+  return info;
+}
+
+static struct term *make_term_locp(enum term_tag tag, struct info *locp) {
+  struct info *info = clone_info(locp);
+  return make_term(tag, info);
+}
+
+static struct term *make_module(char *ident, char *autoload,
+                                struct term *decls,
+                                struct info *locp) {
+  struct term *term = make_term_locp(A_MODULE, locp);
+  term->mname = ident;
+  term->autoload = autoload;
+  term->decls = decls;
+  return term;
+}
+
+static struct term *make_bind(char *ident, struct term *params,
+                              struct term *exp, struct term *decls,
+                              struct info *locp) {
+  struct term *term = make_term_locp(A_BIND, locp);
+  if (params != NULL)
+    exp = build_func(params, exp);
+
+  term->bname = ident;
+  term->exp = exp;
+  list_cons(decls, term);
+  return decls;
+}
+
+static struct term *make_bind_rec(char *ident, struct term *exp,
+                                  struct term *decls, struct info *locp) {
+  /* Desugar let rec IDENT = EXP as
+   *  let IDENT =
+   *    let RLENS = (lns_make_rec) in
+   *    lns_check_rec ((lambda IDENT: EXP) RLENS) RLENS
+   * where RLENS is a brandnew recursive lens.
+   *
+   * That only works since we know that 'let rec' is only defined for lenses,
+   * not general purposes functions, i.e. we know that IDENT has type 'lens'
+   *
+   * The point of all this is that we make it possible to put a recursive
+   * lens (which is a placeholder for the actual recursion) into arbitrary
+   * places in some bigger lens and then have LNS_CHECK_REC rattle through
+   * to do the special-purpose typechecking.
+   */
+  char *id;
+  struct info *info = exp->info;
+  struct term *lambda = NULL, *rlens = NULL;
+  struct term *app1 = NULL, *app2 = NULL, *app3 = NULL;
+
+  id = strdup(ident);
+  if (id == NULL) goto error;
+
+  lambda = make_param(id, make_base_type(T_LENS), ref(info));
+  if (lambda == NULL) goto error;
+  id = NULL;
+
+  build_func(lambda, exp);
+
+  rlens = make_term(A_VALUE, ref(exp->info));
+  if (rlens == NULL) goto error;
+  rlens->value = lns_make_rec(ref(exp->info));
+  if (rlens->value == NULL) goto error;
+  rlens->type = make_base_type(T_LENS);
+
+  app1 = make_app_term(lambda, rlens, ref(info));
+  if (app1 == NULL) goto error;
+
+  id = strdup(LNS_CHECK_REC_NAME);
+  if (id == NULL) goto error;
+  app2 = make_app_ident(id, app1, ref(info));
+  if (app2 == NULL) goto error;
+  id = NULL;
+
+  app3 = make_app_term(app2, ref(rlens), ref(info));
+  if (app3 == NULL) goto error;
+
+  return make_bind(ident, NULL, app3, decls, locp);
+
+ error:
+  free(id);
+  unref(lambda, term);
+  unref(rlens, term);
+  unref(app1, term);
+  unref(app2, term);
+  unref(app3, term);
+  return NULL;
+}
+
+static struct term *make_let(char *ident, struct term *params,
+                             struct term *exp, struct term *body,
+                             struct info *locp) {
+  /* let f (x:string) = "f " . x in
+     f "a" . f "b" */
+  /* (lambda f: f "a" . f "b") (lambda x: "f " . x) */
+  /* (lambda IDENT: BODY) (lambda PARAMS: EXP) */
+  /* Desugar as (lambda IDENT: BODY) (lambda PARAMS: EXP) */
+  struct term *term = make_term_locp(A_LET, locp);
+  struct term *p = make_param(ident, NULL, ref(term->info));
+  term->left = build_func(p, body);
+  if (params != NULL)
+    term->right = build_func(params, exp);
+  else
+    term->right = exp;
+  return term;
+}
+
+static struct term *make_binop(enum term_tag tag,
+                              struct term *left, struct term *right,
+                              struct info *locp) {
+  assert(tag == A_COMPOSE || tag == A_CONCAT
+         || tag == A_UNION || tag == A_APP || tag == A_MINUS);
+  struct term *term = make_term_locp(tag, locp);
+  term->left = left;
+  term->right = right;
+  return term;
+}
+
+static struct term *make_unop(enum term_tag tag, struct term *exp,
+                             struct info *locp) {
+  assert(tag == A_BRACKET);
+  struct term *term = make_term_locp(tag, locp);
+  term->brexp = exp;
+  return term;
+}
+
+static struct term *make_ident(char *qname, struct info *locp) {
+  struct term *term = make_term_locp(A_IDENT, locp);
+  term->ident = make_string(qname);
+  return term;
+}
+
+static struct term *make_unit_term(struct info *locp) {
+  struct term *term = make_term_locp(A_VALUE, locp);
+  term->value = make_unit(ref(term->info));
+  return term;
+}
+
+static struct term *make_string_term(char *value, struct info *locp) {
+  struct term *term = make_term_locp(A_VALUE, locp);
+  term->value = make_value(V_STRING, ref(term->info));
+  term->value->string = make_string(value);
+  return term;
+}
+
+static struct term *make_regexp_term(char *pattern, int nocase,
+                                     struct info *locp) {
+  struct term *term = make_term_locp(A_VALUE, locp);
+  term->value = make_value(V_REGEXP, ref(term->info));
+  term->value->regexp = make_regexp(term->info, pattern, nocase);
+  return term;
+}
+
+static struct term *make_rep(struct term *exp, enum quant_tag quant,
+                            struct info *locp) {
+  struct term *term = make_term_locp(A_REP, locp);
+  term->quant = quant;
+  term->exp = exp;
+  return term;
+}
+
+static struct term *make_get_test(struct term *lens, struct term *arg,
+                                  struct info *locp) {
+  /* Return a term for "get" LENS ARG */
+  struct info *info = clone_info(locp);
+  struct term *term = make_app_ident(strdup("get"), lens, info);
+  term = make_app_term(term, arg, ref(info));
+  return term;
+}
+
+static struct term *make_put_test(struct term *lens, struct term *arg,
+                                  struct term *cmds, struct info *locp) {
+  /* Return a term for "put" LENS (CMDS ("get" LENS ARG)) ARG */
+  struct term *term = make_get_test(lens, arg, locp);
+  term = make_app_term(cmds, term, ref(term->info));
+  struct term *put = make_app_ident(strdup("put"), ref(lens), ref(term->info));
+  put = make_app_term(put, term, ref(term->info));
+  put = make_app_term(put, ref(arg), ref(term->info));
+  return put;
+}
+
+static struct term *make_test(struct term *test, struct term *result,
+                              enum test_result_tag tr_tag,
+                              struct term *decls, struct info *locp) {
+  struct term *term = make_term_locp(A_TEST, locp);
+  term->tr_tag = tr_tag;
+  term->test = test;
+  term->result = result;
+  term->next = decls;
+  return term;
+}
+
+static struct term *make_tree_value(struct tree *tree, struct info *locp) {
+  struct term *term = make_term_locp(A_VALUE, locp);
+  struct value *value = make_value(V_TREE, ref(term->info));
+  value->origin = make_tree_origin(tree);
+  term->value = value;
+  return term;
+}
+
+static struct tree *tree_concat(struct tree *t1, struct tree *t2) {
+  if (t2 != NULL)
+    list_append(t1, t2);
+  return t1;
+}
+
+void augl_error(struct info *locp,
+                struct term **term,
+                yyscan_t scanner,
+                const char *s) {
+  struct info info;
+  struct string string;
+  MEMZERO(&info, 1);
+  info.ref = string.ref = UINT_MAX;
+  info.filename = &string;
+
+  if (locp != NULL) {
+    info.first_line   = locp->first_line;
+    info.first_column = locp->first_column;
+    info.last_line    = locp->last_line;
+    info.last_column  = locp->last_column;
+    info.filename->str = locp->filename->str;
+    info.error = locp->error;
+  } else if (scanner != NULL) {
+    info.first_line   = augl_get_lineno(scanner);
+    info.first_column = augl_get_column(scanner);
+    info.last_line    = augl_get_lineno(scanner);
+    info.last_column  = augl_get_column(scanner);
+    info.filename     = augl_get_info(scanner)->filename;
+    info.error        = augl_get_info(scanner)->error;
+  } else if (*term != NULL && (*term)->info != NULL) {
+    memcpy(&info, (*term)->info, sizeof(info));
+  } else {
+    info.first_line = info.last_line = 0;
+    info.first_column = info.last_column = 0;
+  }
+  syntax_error(&info, "%s", s);
+}
diff --git a/libraries/cmake/source/augeas/generated/linux/ppc64le/code/parser.h b/libraries/cmake/source/augeas/generated/linux/ppc64le/code/parser.h
new file mode 100644
index 000000000..00dabbe47
--- /dev/null
+++ b/libraries/cmake/source/augeas/generated/linux/ppc64le/code/parser.h
@@ -0,0 +1,159 @@
+/* A Bison parser, made by GNU Bison 3.7.4.  */
+
+/* Bison interface for Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989-1990, 2000-2015, 2018-2020 Free Software Foundation,
+   Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation, either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
+#ifndef YY_AUGL_PARSER_H_INCLUDED
+# define YY_AUGL_PARSER_H_INCLUDED
+/* Debug traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+#if YYDEBUG
+extern int augl_debug;
+#endif
+
+/* Token kinds.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+  enum yytokentype
+  {
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    DQUOTED = 258,                 /* DQUOTED  */
+    REGEXP = 259,                  /* REGEXP  */
+    LIDENT = 260,                  /* LIDENT  */
+    UIDENT = 261,                  /* UIDENT  */
+    QIDENT = 262,                  /* QIDENT  */
+    ARROW = 263,                   /* ARROW  */
+    KW_MODULE = 264,               /* KW_MODULE  */
+    KW_AUTOLOAD = 265,             /* KW_AUTOLOAD  */
+    KW_LET = 266,                  /* KW_LET  */
+    KW_LET_REC = 267,              /* KW_LET_REC  */
+    KW_IN = 268,                   /* KW_IN  */
+    KW_STRING = 269,               /* KW_STRING  */
+    KW_REGEXP = 270,               /* KW_REGEXP  */
+    KW_LENS = 271,                 /* KW_LENS  */
+    KW_TEST = 272,                 /* KW_TEST  */
+    KW_GET = 273,                  /* KW_GET  */
+    KW_PUT = 274,                  /* KW_PUT  */
+    KW_AFTER = 275                 /* KW_AFTER  */
+  };
+  typedef enum yytokentype yytoken_kind_t;
+#endif
+/* Token kinds.  */
+#define YYEMPTY -2
+#define YYEOF 0
+#define YYerror 256
+#define YYUNDEF 257
+#define DQUOTED 258
+#define REGEXP 259
+#define LIDENT 260
+#define UIDENT 261
+#define QIDENT 262
+#define ARROW 263
+#define KW_MODULE 264
+#define KW_AUTOLOAD 265
+#define KW_LET 266
+#define KW_LET_REC 267
+#define KW_IN 268
+#define KW_STRING 269
+#define KW_REGEXP 270
+#define KW_LENS 271
+#define KW_TEST 272
+#define KW_GET 273
+#define KW_PUT 274
+#define KW_AFTER 275
+
+/* Value type.  */
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+union YYSTYPE
+{
+#line 89 "parser.y"
+
+  struct term    *term;
+  struct type    *type;
+  struct ident   *ident;
+  struct tree    *tree;
+  char           *string;
+  struct {
+    int             nocase;
+    char           *pattern;
+  } regexp;
+  int            intval;
+  enum quant_tag quant;
+
+#line 121 "parser.h"
+
+};
+typedef union YYSTYPE YYSTYPE;
+# define YYSTYPE_IS_TRIVIAL 1
+# define YYSTYPE_IS_DECLARED 1
+#endif
+
+/* Location type.  */
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
+typedef struct YYLTYPE YYLTYPE;
+struct YYLTYPE
+{
+  int first_line;
+  int first_column;
+  int last_line;
+  int last_column;
+};
+# define YYLTYPE_IS_DECLARED 1
+# define YYLTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+int augl_parse (struct term **term, yyscan_t scanner);
+/* "%code provides" blocks.  */
+#line 46 "parser.y"
+
+#include "info.h"
+
+/* Track custom scanner state */
+struct state {
+  struct info *info;
+  unsigned int comment_depth;
+};
+
+
+#line 158 "parser.h"
+
+#endif /* !YY_AUGL_PARSER_H_INCLUDED  */
diff --git a/libraries/cmake/source/augeas/generated/linux/ppc64le/config/config.h b/libraries/cmake/source/augeas/generated/linux/ppc64le/config/config.h
new file mode 100644
index 000000000..0462c3960
--- /dev/null
+++ b/libraries/cmake/source/augeas/generated/linux/ppc64le/config/config.h
@@ -0,0 +1,1572 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to the number of bits in type 'ptrdiff_t'. */
+/* #undef BITSIZEOF_PTRDIFF_T */
+
+/* Define to the number of bits in type 'sig_atomic_t'. */
+/* #undef BITSIZEOF_SIG_ATOMIC_T */
+
+/* Define to the number of bits in type 'size_t'. */
+/* #undef BITSIZEOF_SIZE_T */
+
+/* Define to the number of bits in type 'wchar_t'. */
+/* #undef BITSIZEOF_WCHAR_T */
+
+/* Define to the number of bits in type 'wint_t'. */
+/* #undef BITSIZEOF_WINT_T */
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to 1 if the C locale may have encoding errors. */
+#define C_LOCALE_MAYBE_EILSEQ 1
+
+/* Define as the bit index in the word where to find bit 0 of the exponent of
+   'double'. */
+#define DBL_EXPBIT0_BIT 20
+
+/* Define as the word index where to find the exponent of 'double'. */
+#define DBL_EXPBIT0_WORD 1
+
+/* Define to 1 if // is a file system root distinct from /. */
+/* #undef DOUBLE_SLASH_IS_DISTINCT_ROOT */
+
+/* whether debugging is enabled */
+#define ENABLE_DEBUG 1
+
+/* Define this to 1 if F_DUPFD behavior does not match POSIX */
+/* #undef FCNTL_DUPFD_BUGGY */
+
+/* Define to nothing if C supports flexible array members, and to 1 if it does
+   not. That way, with a declaration like 'struct s { int n; double
+   d[FLEXIBLE_ARRAY_MEMBER]; };', the struct hack can be used with pre-C99
+   compilers. When computing the size of such an object, don't use 'sizeof
+   (struct s)' as it overestimates the size. Use 'offsetof (struct s, d)'
+   instead. Don't use 'offsetof (struct s, d[0])', as this doesn't work with
+   MSVC and with C++ compilers. */
+#define FLEXIBLE_ARRAY_MEMBER /**/
+
+/* Enable compile-time and run-time bounds-checking, and some warnings,
+        without upsetting newer glibc. */
+     #if !defined _FORTIFY_SOURCE && defined __OPTIMIZE__ && __OPTIMIZE__
+     # define _FORTIFY_SOURCE 2
+     #endif
+    
+
+/* Define to 1 if mkdir mistakenly creates a directory given with a trailing
+   dot component. */
+/* #undef FUNC_MKDIR_DOT_BUG */
+
+/* Define to 1 if nl_langinfo (YESEXPR) returns a non-empty string. */
+#define FUNC_NL_LANGINFO_YESEXPR_WORKS 1
+
+/* Define to 1 if realpath() can malloc memory, always gives an absolute path,
+   and handles trailing slash correctly. */
+#define FUNC_REALPATH_WORKS 1
+
+/* Define if gettimeofday clobbers the localtime buffer. */
+/* #undef GETTIMEOFDAY_CLOBBERS_LOCALTIME */
+
+/* Define this to 'void' or 'struct timezone' to match the system's
+   declaration of the second argument to gettimeofday. */
+#define GETTIMEOFDAY_TIMEZONE struct timezone
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module canonicalize-lgpl shall be considered present. */
+#define GNULIB_CANONICALIZE_LGPL 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module fscanf shall be considered present. */
+#define GNULIB_FSCANF 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module lock shall be considered present. */
+#define GNULIB_LOCK 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module msvc-nothrow shall be considered present. */
+#define GNULIB_MSVC_NOTHROW IN_AUGEAS_GNULIB_TESTS
+
+/* Define to 1 if printf and friends should be labeled with attribute
+   "__gnu_printf__" instead of "__printf__" */
+/* #undef GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU */
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module scanf shall be considered present. */
+#define GNULIB_SCANF 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module strerror shall be considered present. */
+#define GNULIB_STRERROR IN_AUGEAS_GNULIB_TESTS
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module strerror_r-posix shall be considered present. */
+#define GNULIB_STRERROR_R_POSIX IN_AUGEAS_GNULIB_TESTS
+
+/* Define to 1 when the gnulib module accept should be tested. */
+#define GNULIB_TEST_ACCEPT 1
+
+/* Define to 1 when the gnulib module bind should be tested. */
+#define GNULIB_TEST_BIND 1
+
+/* Define to 1 when the gnulib module btowc should be tested. */
+#define GNULIB_TEST_BTOWC 1
+
+/* Define to 1 when the gnulib module canonicalize_file_name should be tested.
+   */
+#define GNULIB_TEST_CANONICALIZE_FILE_NAME 1
+
+/* Define to 1 when the gnulib module cloexec should be tested. */
+#define GNULIB_TEST_CLOEXEC 1
+
+/* Define to 1 when the gnulib module close should be tested. */
+#define GNULIB_TEST_CLOSE 1
+
+/* Define to 1 when the gnulib module connect should be tested. */
+#define GNULIB_TEST_CONNECT 1
+
+/* Define to 1 when the gnulib module dup2 should be tested. */
+#define GNULIB_TEST_DUP2 1
+
+/* Define to 1 when the gnulib module environ should be tested. */
+#define GNULIB_TEST_ENVIRON 1
+
+/* Define to 1 when the gnulib module fcntl should be tested. */
+#define GNULIB_TEST_FCNTL 1
+
+/* Define to 1 when the gnulib module fdopen should be tested. */
+#define GNULIB_TEST_FDOPEN 1
+
+/* Define to 1 when the gnulib module fnmatch should be tested. */
+#define GNULIB_TEST_FNMATCH 1
+
+/* Define to 1 when the gnulib module fstat should be tested. */
+#define GNULIB_TEST_FSTAT 1
+
+/* Define to 1 when the gnulib module ftruncate should be tested. */
+#define GNULIB_TEST_FTRUNCATE 1
+
+/* Define to 1 when the gnulib module getcwd should be tested. */
+#define GNULIB_TEST_GETCWD 1
+
+/* Define to 1 when the gnulib module getdelim should be tested. */
+#define GNULIB_TEST_GETDELIM 1
+
+/* Define to 1 when the gnulib module getdtablesize should be tested. */
+#define GNULIB_TEST_GETDTABLESIZE 1
+
+/* Define to 1 when the gnulib module getline should be tested. */
+#define GNULIB_TEST_GETLINE 1
+
+/* Define to 1 when the gnulib module getpagesize should be tested. */
+#define GNULIB_TEST_GETPAGESIZE 1
+
+/* Define to 1 when the gnulib module gettimeofday should be tested. */
+#define GNULIB_TEST_GETTIMEOFDAY 1
+
+/* Define to 1 when the gnulib module ioctl should be tested. */
+#define GNULIB_TEST_IOCTL 1
+
+/* Define to 1 when the gnulib module listen should be tested. */
+#define GNULIB_TEST_LISTEN 1
+
+/* Define to 1 when the gnulib module localeconv should be tested. */
+#define GNULIB_TEST_LOCALECONV 1
+
+/* Define to 1 when the gnulib module localename should be tested. */
+#define GNULIB_TEST_LOCALENAME 1
+
+/* Define to 1 when the gnulib module lstat should be tested. */
+#define GNULIB_TEST_LSTAT 1
+
+/* Define to 1 when the gnulib module malloc-posix should be tested. */
+#define GNULIB_TEST_MALLOC_POSIX 1
+
+/* Define to 1 when the gnulib module mbrtowc should be tested. */
+#define GNULIB_TEST_MBRTOWC 1
+
+/* Define to 1 when the gnulib module mbsinit should be tested. */
+#define GNULIB_TEST_MBSINIT 1
+
+/* Define to 1 when the gnulib module mbsrtowcs should be tested. */
+#define GNULIB_TEST_MBSRTOWCS 1
+
+/* Define to 1 when the gnulib module mbtowc should be tested. */
+#define GNULIB_TEST_MBTOWC 1
+
+/* Define to 1 when the gnulib module memchr should be tested. */
+#define GNULIB_TEST_MEMCHR 1
+
+/* Define to 1 when the gnulib module mempcpy should be tested. */
+#define GNULIB_TEST_MEMPCPY 1
+
+/* Define to 1 when the gnulib module mkstemp should be tested. */
+#define GNULIB_TEST_MKSTEMP 1
+
+/* Define to 1 when the gnulib module nanosleep should be tested. */
+#define GNULIB_TEST_NANOSLEEP 1
+
+/* Define to 1 when the gnulib module nl_langinfo should be tested. */
+#define GNULIB_TEST_NL_LANGINFO 1
+
+/* Define to 1 when the gnulib module open should be tested. */
+#define GNULIB_TEST_OPEN 1
+
+/* Define to 1 when the gnulib module perror should be tested. */
+#define GNULIB_TEST_PERROR 1
+
+/* Define to 1 when the gnulib module pipe should be tested. */
+#define GNULIB_TEST_PIPE 1
+
+/* Define to 1 when the gnulib module pthread_sigmask should be tested. */
+#define GNULIB_TEST_PTHREAD_SIGMASK 1
+
+/* Define to 1 when the gnulib module putenv should be tested. */
+#define GNULIB_TEST_PUTENV 1
+
+/* Define to 1 when the gnulib module raise should be tested. */
+#define GNULIB_TEST_RAISE 1
+
+/* Define to 1 when the gnulib module rawmemchr should be tested. */
+#define GNULIB_TEST_RAWMEMCHR 1
+
+/* Define to 1 when the gnulib module readlink should be tested. */
+#define GNULIB_TEST_READLINK 1
+
+/* Define to 1 when the gnulib module realpath should be tested. */
+#define GNULIB_TEST_REALPATH 1
+
+/* Define to 1 when the gnulib module select should be tested. */
+#define GNULIB_TEST_SELECT 1
+
+/* Define to 1 when the gnulib module setenv should be tested. */
+#define GNULIB_TEST_SETENV 1
+
+/* Define to 1 when the gnulib module setlocale should be tested. */
+#define GNULIB_TEST_SETLOCALE 1
+
+/* Define to 1 when the gnulib module setsockopt should be tested. */
+#define GNULIB_TEST_SETSOCKOPT 1
+
+/* Define to 1 when the gnulib module sigaction should be tested. */
+#define GNULIB_TEST_SIGACTION 1
+
+/* Define to 1 when the gnulib module sigprocmask should be tested. */
+#define GNULIB_TEST_SIGPROCMASK 1
+
+/* Define to 1 when the gnulib module sleep should be tested. */
+#define GNULIB_TEST_SLEEP 1
+
+/* Define to 1 when the gnulib module socket should be tested. */
+#define GNULIB_TEST_SOCKET 1
+
+/* Define to 1 when the gnulib module stat should be tested. */
+#define GNULIB_TEST_STAT 1
+
+/* Define to 1 when the gnulib module stpcpy should be tested. */
+#define GNULIB_TEST_STPCPY 1
+
+/* Define to 1 when the gnulib module stpncpy should be tested. */
+#define GNULIB_TEST_STPNCPY 1
+
+/* Define to 1 when the gnulib module strchrnul should be tested. */
+#define GNULIB_TEST_STRCHRNUL 1
+
+/* Define to 1 when the gnulib module strerror should be tested. */
+#define GNULIB_TEST_STRERROR 1
+
+/* Define to 1 when the gnulib module strerror_r should be tested. */
+#define GNULIB_TEST_STRERROR_R 1
+
+/* Define to 1 when the gnulib module strndup should be tested. */
+#define GNULIB_TEST_STRNDUP 1
+
+/* Define to 1 when the gnulib module strnlen should be tested. */
+#define GNULIB_TEST_STRNLEN 1
+
+/* Define to 1 when the gnulib module strstr should be tested. */
+#define GNULIB_TEST_STRSTR 1
+
+/* Define to 1 when the gnulib module symlink should be tested. */
+#define GNULIB_TEST_SYMLINK 1
+
+/* Define to 1 when the gnulib module unsetenv should be tested. */
+#define GNULIB_TEST_UNSETENV 1
+
+/* Define to 1 when the gnulib module usleep should be tested. */
+#define GNULIB_TEST_USLEEP 1
+
+/* Define to 1 when the gnulib module vasprintf should be tested. */
+#define GNULIB_TEST_VASPRINTF 1
+
+/* Define to 1 when the gnulib module wcrtomb should be tested. */
+#define GNULIB_TEST_WCRTOMB 1
+
+/* Define to 1 when the gnulib module wctob should be tested. */
+#define GNULIB_TEST_WCTOB 1
+
+/* Define to 1 when the gnulib module wctomb should be tested. */
+#define GNULIB_TEST_WCTOMB 1
+
+/* Define to 1 if you have 'alloca' after including <alloca.h>, a header that
+   may be supplied by this distribution. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#define HAVE_ALLOCA_H 1
+
+/* Define to 1 if you have the <argz.h> header file. */
+#define HAVE_ARGZ_H 1
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <bp-sym.h> header file. */
+/* #undef HAVE_BP_SYM_H */
+
+/* Define to 1 if you have the `btowc' function. */
+#define HAVE_BTOWC 1
+
+/* Define to 1 if nanosleep mishandles large arguments. */
+#define HAVE_BUG_BIG_NANOSLEEP 1
+
+/* Define to 1 if you have the `canonicalize_file_name' function. */
+#define HAVE_CANONICALIZE_FILE_NAME 1
+
+/* Define to 1 if you have the `catgets' function. */
+#define HAVE_CATGETS 1
+
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the Mac OS X function
+   CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if you have the `chsize' function. */
+/* #undef HAVE_CHSIZE */
+
+/* Define to 1 if you have the <crtdefs.h> header file. */
+/* #undef HAVE_CRTDEFS_H */
+
+/* Define to 1 if you have the declaration of `alarm', and to 0 if you don't.
+   */
+#define HAVE_DECL_ALARM 1
+
+/* Define to 1 if you have the declaration of `getc_unlocked', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_GETC_UNLOCKED */
+
+/* Define to 1 if you have the declaration of `getdelim', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETDELIM 1
+
+/* Define to 1 if you have the declaration of `getdtablesize', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETDTABLESIZE 1
+
+/* Define to 1 if you have the declaration of `getline', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETLINE 1
+
+/* Define to 1 if you have the declaration of `inet_pton', and to 0 if you
+   don't. */
+#define HAVE_DECL_INET_PTON 1
+
+/* Define to 1 if you have the declaration of `isblank', and to 0 if you
+   don't. */
+#define HAVE_DECL_ISBLANK 1
+
+/* Define to 1 if you have the declaration of `mbrtowc', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBRTOWC */
+
+/* Define to 1 if you have the declaration of `mbsinit', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBSINIT */
+
+/* Define to 1 if you have the declaration of `mbsrtowcs', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBSRTOWCS */
+
+/* Define to 1 if you have the declaration of `setenv', and to 0 if you don't.
+   */
+#define HAVE_DECL_SETENV 1
+
+/* Define to 1 if you have the declaration of `sleep', and to 0 if you don't.
+   */
+#define HAVE_DECL_SLEEP 1
+
+/* Define to 1 if you have the declaration of `stpncpy', and to 0 if you
+   don't. */
+#define HAVE_DECL_STPNCPY 1
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the declaration of `strndup', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRNDUP 1
+
+/* Define to 1 if you have the declaration of `strnlen', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRNLEN 1
+
+/* Define to 1 if you have the declaration of `towlower', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_TOWLOWER */
+
+/* Define to 1 if you have the declaration of `unsetenv', and to 0 if you
+   don't. */
+#define HAVE_DECL_UNSETENV 1
+
+/* Define to 1 if you have the declaration of `wcrtomb', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_WCRTOMB */
+
+/* Define to 1 if you have the declaration of `wctob', and to 0 if you don't.
+   */
+#define HAVE_DECL_WCTOB 1
+
+/* Define to 1 if you have the declaration of `_putenv', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL__PUTENV */
+
+/* Define to 1 if you have the declaration of `_snprintf', and to 0 if you
+   don't. */
+#define HAVE_DECL__SNPRINTF 0
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the 'dup2' function. */
+#define HAVE_DUP2 1
+
+/* Define to 1 if you have the `duplocale' function. */
+#define HAVE_DUPLOCALE 1
+
+/* Define if you have the declaration of environ. */
+#define HAVE_ENVIRON_DECL 1
+
+/* Define to 1 if the system has the type `error_t'. */
+#define HAVE_ERROR_T 1
+
+/* Define if the locale_t type contains insufficient information, as on
+   OpenBSD. */
+/* #undef HAVE_FAKE_LOCALES */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <features.h> header file. */
+#define HAVE_FEATURES_H 1
+
+/* Define to 1 if you have the `flockfile' function. */
+/* #undef HAVE_FLOCKFILE */
+
+/* Define to 1 if you have the `fnmatch' function. */
+#define HAVE_FNMATCH 1
+
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#define HAVE_FNMATCH_H 1
+
+/* Define to 1 if you have the `freelocale' function. */
+#define HAVE_FREELOCALE 1
+
+/* Define to 1 if you have the `fsync' function. */
+#define HAVE_FSYNC 1
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `funlockfile' function. */
+/* #undef HAVE_FUNLOCKFILE */
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `getdelim' function. */
+#define HAVE_GETDELIM 1
+
+/* Define to 1 if you have the `getdtablesize' function. */
+#define HAVE_GETDTABLESIZE 1
+
+/* Define to 1 if you have the `getlocalename_l' function. */
+/* #undef HAVE_GETLOCALENAME_L */
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getopt_long_only' function. */
+#define HAVE_GETOPT_LONG_ONLY 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+/* #undef HAVE_INET_PTON */
+
+/* Define if you have the 'intmax_t' type in <stdint.h> or <inttypes.h>. */
+#define HAVE_INTMAX_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if <inttypes.h> exists, doesn't clash with <sys/types.h>, and
+   declares uintmax_t. */
+#define HAVE_INTTYPES_H_WITH_UINTMAX 1
+
+/* Define to 1 if you have the `ioctl' function. */
+#define HAVE_IOCTL 1
+
+/* Define to 1 if <sys/socket.h> defines AF_INET. */
+#define HAVE_IPV4 1
+
+/* Define to 1 if <sys/socket.h> defines AF_INET6. */
+#define HAVE_IPV6 1
+
+/* Define to 1 if you have the `isblank' function. */
+#define HAVE_ISBLANK 1
+
+/* Define to 1 if you have the `iswcntrl' function. */
+#define HAVE_ISWCNTRL 1
+
+/* Define to 1 if you have the `iswctype' function. */
+#define HAVE_ISWCTYPE 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+#define HAVE_LANGINFO_CODESET 1
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define if your <locale.h> file defines LC_MESSAGES. */
+#define HAVE_LC_MESSAGES 1
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#define HAVE_LIBINTL_H 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if the system has the type 'long long int'. */
+#define HAVE_LONG_LONG_INT 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define HAVE_LSTAT 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define if the 'malloc' function is POSIX compliant. */
+#define HAVE_MALLOC_POSIX 1
+
+/* Define to 1 if mmap()'s MAP_ANONYMOUS flag is available after including
+   config.h and <sys/mman.h>. */
+#define HAVE_MAP_ANONYMOUS 1
+
+/* Define to 1 if you have the `mbrtowc' function. */
+#define HAVE_MBRTOWC 1
+
+/* Define to 1 if you have the `mbsinit' function. */
+#define HAVE_MBSINIT 1
+
+/* Define to 1 if you have the `mbsrtowcs' function. */
+#define HAVE_MBSRTOWCS 1
+
+/* Define to 1 if <wchar.h> declares mbstate_t. */
+#define HAVE_MBSTATE_T 1
+
+/* Define to 1 if you have the `mbtowc' function. */
+#define HAVE_MBTOWC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mempcpy' function. */
+#define HAVE_MEMPCPY 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the `mprotect' function. */
+#define HAVE_MPROTECT 1
+
+/* Define to 1 on MSVC platforms that have the "invalid parameter handler"
+   concept. */
+/* #undef HAVE_MSVC_INVALID_PARAMETER_HANDLER */
+
+/* Define if the locale_t type does not contain the name of each locale
+   category. */
+/* #undef HAVE_NAMELESS_LOCALES */
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the `newlocale' function. */
+#define HAVE_NEWLOCALE 1
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#define HAVE_NL_LANGINFO 1
+
+/* Define to 1 if you have the `open_memstream' function. */
+#define HAVE_OPEN_MEMSTREAM 1
+
+/* Define to 1 if you have the <OS.h> header file. */
+/* #undef HAVE_OS_H */
+
+/* Define to 1 if you have the `pipe' function. */
+#define HAVE_PIPE 1
+
+/* Define to 1 if you have the `pthread_atfork' function. */
+#define HAVE_PTHREAD_ATFORK 1
+
+/* Define if the <pthread.h> defines PTHREAD_MUTEX_RECURSIVE. */
+#define HAVE_PTHREAD_MUTEX_RECURSIVE 1
+
+/* Define if the POSIX multithreading library has read/write locks. */
+#define HAVE_PTHREAD_RWLOCK 1
+
+/* Define if the 'pthread_rwlock_rdlock' function prefers a writer to a
+   reader. */
+/* #undef HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER */
+
+/* Define to 1 if the pthread_sigmask function can be used (despite bugs). */
+/* #undef HAVE_PTHREAD_SIGMASK */
+
+/* Define to 1 if you have the `raise' function. */
+#define HAVE_RAISE 1
+
+/* Define to 1 if you have the `rawmemchr' function. */
+#define HAVE_RAWMEMCHR 1
+
+/* Define to 1 if you have the `readlink' function. */
+#define HAVE_READLINK 1
+
+/* Define to 1 if you have the `realpath' function. */
+#define HAVE_REALPATH 1
+
+/* Define to 1 if the system has the type `sa_family_t'. */
+#define HAVE_SA_FAMILY_T 1
+
+/* Define to 1 if you have the <search.h> header file. */
+#define HAVE_SEARCH_H 1
+
+/* Define to 1 if you have the <selinux/context.h> header file. */
+/* #undef HAVE_SELINUX_CONTEXT_H */
+
+/* Define to 1 if you have the <selinux/selinux.h> header file. */
+#define HAVE_SELINUX_SELINUX_H 0
+
+/* Define to 1 if you have the <semaphore.h> header file. */
+#define HAVE_SEMAPHORE_H 1
+
+/* Define to 1 if you have the `setdtablesize' function. */
+/* #undef HAVE_SETDTABLESIZE */
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if you have the `shutdown' function. */
+#define HAVE_SHUTDOWN 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `sigaltstack' function. */
+#define HAVE_SIGALTSTACK 1
+
+/* Define to 1 if the system has the type `siginfo_t'. */
+/* #undef HAVE_SIGINFO_T */
+
+/* Define to 1 if you have the `siginterrupt' function. */
+#define HAVE_SIGINTERRUPT 1
+
+/* Define to 1 if 'sig_atomic_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_SIG_ATOMIC_T */
+
+/* Define to 1 if 'wchar_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_WCHAR_T */
+
+/* Define to 1 if 'wint_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_WINT_T */
+
+/* Define to 1 if the system has the type `sigset_t'. */
+#define HAVE_SIGSET_T 1
+
+/* Define to 1 if you have the `sleep' function. */
+#define HAVE_SLEEP 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define if the return value of the snprintf function is the number of of
+   bytes (excluding the terminating NUL) that would have been produced if the
+   buffer had been large enough. */
+#define HAVE_SNPRINTF_RETVAL_C99 1
+
+/* Define if the locale_t type is as on Solaris 11.4. */
+/* #undef HAVE_SOLARIS114_LOCALES */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define if <stdint.h> exists, doesn't clash with <sys/types.h>, and declares
+   uintmax_t. */
+#define HAVE_STDINT_H_WITH_UINTMAX 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define if you have the stpncpy() function and it works. */
+#define HAVE_STPNCPY 1
+
+/* Define to 1 if you have the `strchrnul' function. */
+#define HAVE_STRCHRNUL 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if `decimal_point' is a member of `struct lconv'. */
+/* #undef HAVE_STRUCT_LCONV_DECIMAL_POINT */
+
+/* Define to 1 if `sa_sigaction' is a member of `struct sigaction'. */
+#define HAVE_STRUCT_SIGACTION_SA_SIGACTION 1
+
+/* Define to 1 if the system has the type `struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+
+/* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
+
+/* Define to 1 if `st_atimensec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMENSEC */
+
+/* Define to 1 if `st_atimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_atim.st__tim.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC */
+
+/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 1
+
+/* Define to 1 if `st_birthtimensec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC */
+
+/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_birthtim.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC */
+
+/* Define to 1 if you have the `symlink' function. */
+#define HAVE_SYMLINK 1
+
+/* Define to 1 if you have the <sys/bitypes.h> header file. */
+/* #undef HAVE_SYS_BITYPES_H */
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+#define HAVE_SYS_CDEFS_H 1
+
+/* Define to 1 if you have the <sys/inttypes.h> header file. */
+/* #undef HAVE_SYS_INTTYPES_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define HAVE_SYS_UIO_H 1
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the `towlower' function. */
+#define HAVE_TOWLOWER 1
+
+/* Define to 1 if you have the `tsearch' function. */
+#define HAVE_TSEARCH 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define HAVE_UNSETENV 1
+
+/* Define to 1 if the system has the type 'unsigned long long int'. */
+#define HAVE_UNSIGNED_LONG_LONG_INT 1
+
+/* Define to 1 if you have the `uselocale' function. */
+#define HAVE_USELOCALE 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Define to 1 if you have the `vasnprintf' function. */
+/* #undef HAVE_VASNPRINTF */
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define if you have the 'wchar_t' type. */
+#define HAVE_WCHAR_T 1
+
+/* Define to 1 if you have the `wcrtomb' function. */
+#define HAVE_WCRTOMB 1
+
+/* Define to 1 if you have the `wcslen' function. */
+#define HAVE_WCSLEN 1
+
+/* Define to 1 if you have the `wcsnlen' function. */
+#define HAVE_WCSNLEN 1
+
+/* Define to 1 if you have the `wctob' function. */
+#define HAVE_WCTOB 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+/* #undef HAVE_WINSOCK2_H */
+
+/* Define if you have the 'wint_t' type. */
+#define HAVE_WINT_T 1
+
+/* Define to 1 if you have the `wmemchr' function. */
+#define HAVE_WMEMCHR 1
+
+/* Define to 1 if you have the `wmemcpy' function. */
+#define HAVE_WMEMCPY 1
+
+/* Define to 1 if you have the `wmempcpy' function. */
+#define HAVE_WMEMPCPY 1
+
+/* This value is set to 1 to indicate that the system argz facility works */
+#define HAVE_WORKING_ARGZ 1
+
+/* Define to 1 if O_NOATIME works. */
+#define HAVE_WORKING_O_NOATIME 1
+
+/* Define to 1 if O_NOFOLLOW works. */
+#define HAVE_WORKING_O_NOFOLLOW 1
+
+/* Define if the uselocale function exists any may safely be called. */
+#define HAVE_WORKING_USELOCALE 1
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+/* #undef HAVE_WS2TCPIP_H */
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define to 1 if the system has the type `_Bool'. */
+#define HAVE__BOOL 1
+
+/* Define to 1 if you have the `_set_invalid_parameter_handler' function. */
+/* #undef HAVE__SET_INVALID_PARAMETER_HANDLER */
+
+/* Define to 1 if the compiler supports __builtin_expect,
+   and to 2 if <builtins.h> does.  */
+#define HAVE___BUILTIN_EXPECT 1
+#ifndef HAVE___BUILTIN_EXPECT
+# define __builtin_expect(e, c) (e)
+#elif HAVE___BUILTIN_EXPECT == 2
+# include <builtins.h>
+#endif
+    
+
+/* Define to 1 if the compiler supports the keyword '__inline'. */
+#define HAVE___INLINE 1
+
+/* Define to 1 if you have the `__xpg_strerror_r' function. */
+#define HAVE___XPG_STRERROR_R 1
+
+/* Define to 1 if 'lstat' dereferences a symlink specified with a trailing
+   slash. */
+#define LSTAT_FOLLOWS_SLASHED_SYMLINK 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* If malloc(0) is != NULL, define this to 1. Otherwise define this to 0. */
+#define MALLOC_0_IS_NONNULL 1
+
+/* Define to a substitute value for mmap()'s MAP_ANONYMOUS flag. */
+/* #undef MAP_ANONYMOUS */
+
+/* Define if the mbrtowc function does not return (size_t) -2 for empty input.
+   */
+/* #undef MBRTOWC_EMPTY_INPUT_BUG */
+
+/* Define if the mbrtowc function has the NULL pwc argument bug. */
+/* #undef MBRTOWC_NULL_ARG1_BUG */
+
+/* Define if the mbrtowc function has the NULL string argument bug. */
+/* #undef MBRTOWC_NULL_ARG2_BUG */
+
+/* Define if the mbrtowc function does not return 0 for a NUL character. */
+/* #undef MBRTOWC_NUL_RETVAL_BUG */
+
+/* Define if the mbrtowc function returns a wrong return value. */
+/* #undef MBRTOWC_RETVAL_BUG */
+
+/* Use GNU style printf and scanf.  */
+#ifndef __USE_MINGW_ANSI_STDIO
+# define __USE_MINGW_ANSI_STDIO 1
+#endif
+
+
+/* Define to 1 if open() fails to recognize a trailing slash. */
+/* #undef OPEN_TRAILING_SLASH_BUG */
+
+/* Name of package */
+#define PACKAGE "augeas"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "augeas"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "augeas 1.12.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "augeas"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.12.0"
+
+/* Define if <inttypes.h> exists and defines unusable PRI* macros. */
+/* #undef PRI_MACROS_BROKEN */
+
+/* Define to the type that is the result of default argument promotions of
+   type mode_t. */
+#define PROMOTED_MODE_T mode_t
+
+/* Define if the pthread_in_use() detection is hard. */
+/* #undef PTHREAD_IN_USE_DETECTION_HARD */
+
+/* Define to 1 if pthread_sigmask(), when it fails, returns -1 and sets errno.
+   */
+/* #undef PTHREAD_SIGMASK_FAILS_WITH_ERRNO */
+
+/* Define to 1 if pthread_sigmask may return 0 and have no effect. */
+/* #undef PTHREAD_SIGMASK_INEFFECTIVE */
+
+/* Define to 1 if pthread_sigmask() unblocks signals incorrectly. */
+/* #undef PTHREAD_SIGMASK_UNBLOCK_BUG */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'ptrdiff_t'. */
+/* #undef PTRDIFF_T_SUFFIX */
+
+/* Define to 1 if readlink fails to recognize a trailing slash. */
+/* #undef READLINK_TRAILING_SLASH_BUG */
+
+/* Define to 1 if stat needs help when passed a file name with a trailing
+   slash */
+/* #undef REPLACE_FUNC_STAT_FILE */
+
+/* Define if nl_langinfo exists but is overridden by gnulib. */
+/* #undef REPLACE_NL_LANGINFO */
+
+/* Define to 1 if strerror(0) does not return a message implying success. */
+/* #undef REPLACE_STRERROR_0 */
+
+/* Define if vasnprintf exists but is overridden by gnulib. */
+/* #undef REPLACE_VASNPRINTF */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'sig_atomic_t'. */
+/* #undef SIG_ATOMIC_T_SUFFIX */
+
+/* Define as the maximum value of type 'size_t', if the system doesn't define
+   it. */
+#ifndef SIZE_MAX
+/* # undef SIZE_MAX */
+#endif
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'size_t'. */
+/* #undef SIZE_T_SUFFIX */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if the type of the st_atim member of a struct stat is struct
+   timespec. */
+#define TYPEOF_STRUCT_STAT_ST_ATIM_IS_STRUCT_TIMESPEC 1
+
+/* Define if the POSIX multithreading library can be used. */
+#define USE_POSIX_THREADS 1
+
+/* Define if references to the POSIX multithreading library should be made
+   weak. */
+#define USE_POSIX_THREADS_WEAK 1
+
+/* Define if the GNU Pth multithreading library can be used. */
+/* #undef USE_PTH_THREADS */
+
+/* Define if references to the GNU Pth multithreading library should be made
+   weak. */
+/* #undef USE_PTH_THREADS_WEAK */
+
+/* Define if the old Solaris multithreading library can be used. */
+/* #undef USE_SOLARIS_THREADS */
+
+/* Define if references to the old Solaris multithreading library should be
+   made weak. */
+/* #undef USE_SOLARIS_THREADS_WEAK */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable general extensions on macOS.  */
+#ifndef _DARWIN_C_SOURCE
+# define _DARWIN_C_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable NetBSD extensions on NetBSD.  */
+#ifndef _NETBSD_SOURCE
+# define _NETBSD_SOURCE 1
+#endif
+/* Enable OpenBSD extensions on NetBSD.  */
+#ifndef _OPENBSD_SOURCE
+# define _OPENBSD_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-5:2014.  */
+#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__
+# define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-1:2014.  */
+#ifndef __STDC_WANT_IEC_60559_BFP_EXT__
+# define __STDC_WANT_IEC_60559_BFP_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-2:2015.  */
+#ifndef __STDC_WANT_IEC_60559_DFP_EXT__
+# define __STDC_WANT_IEC_60559_DFP_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-4:2015.  */
+#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__
+# define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-3:2015.  */
+#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__
+# define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TR 24731-2:2010.  */
+#ifndef __STDC_WANT_LIB_EXT2__
+# define __STDC_WANT_LIB_EXT2__ 1
+#endif
+/* Enable extensions specified by ISO/IEC 24747:2009.  */
+#ifndef __STDC_WANT_MATH_SPEC_FUNCS__
+# define __STDC_WANT_MATH_SPEC_FUNCS__ 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable X/Open extensions if necessary.  HP-UX 11.11 defines
+   mbstate_t only if _XOPEN_SOURCE is defined to 500, regardless of
+   whether compiling with -Ae or -D_HPUX_SOURCE=1.  */
+#ifndef _XOPEN_SOURCE
+/* # undef _XOPEN_SOURCE */
+#endif
+/* Enable X/Open compliant socket functions that do not require linking
+   with -lxnet on HP-UX 11.11.  */
+#ifndef _HPUX_ALT_XOPEN_SOCKET_API
+# define _HPUX_ALT_XOPEN_SOCKET_API 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Define if the native Windows multithreading API can be used. */
+/* #undef USE_WINDOWS_THREADS */
+
+/* Version number of package */
+#define VERSION "1.12.0"
+
+/* Define to 1 if unsetenv returns void instead of int. */
+/* #undef VOID_UNSETENV */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'wchar_t'. */
+/* #undef WCHAR_T_SUFFIX */
+
+/* Define if WSAStartup is needed. */
+/* #undef WINDOWS_SOCKETS */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'wint_t'. */
+/* #undef WINT_T_SUFFIX */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+/* #undef YYTEXT_POINTER */
+
+/* Enable large inode numbers on Mac OS X 10.5. */
+#define _DARWIN_USE_64_BIT_INODE 1
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 on Solaris. */
+/* #undef _LCONV_C99 */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 1 to make NetBSD features available. MINIX 3 needs this. */
+#define _NETBSD_SOURCE 1
+
+/* The _Noreturn keyword of C11.  */
+#ifndef _Noreturn
+# if (defined __cplusplus \
+      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
+          || (defined _MSC_VER && 1900 <= _MSC_VER)))
+#  define _Noreturn [[noreturn]]
+# elif ((!defined __cplusplus || defined __clang__) \
+        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0)  \
+            || 4 < __GNUC__ + (7 <= __GNUC_MINOR__)))
+   /* _Noreturn works as-is.  */
+# elif 2 < __GNUC__ + (8 <= __GNUC_MINOR__) || 0x5110 <= __SUNPRO_C
+#  define _Noreturn __attribute__ ((__noreturn__))
+# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn
+# endif
+#endif
+
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 in order to get the POSIX compatible declarations of socket
+   functions. */
+/* #undef _POSIX_PII_SOCKET */
+
+/* Define to 1 if you need to in order for 'stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define if you want <regex.h> to include <limits.h>, so that it consistently
+   overrides <limits.h>'s RE_DUP_MAX. */
+#define _REGEX_INCLUDE_LIMITS_H 1
+
+/* Define if you want regoff_t to be at least as wide POSIX requires. */
+#define _REGEX_LARGE_OFFSETS 1
+
+/* For standard stat data types on VMS. */
+#define _USE_STD_STAT 1
+
+/* Define to rpl_ if the getopt replacement functions and variables should be
+   used. */
+/* #undef __GETOPT_PREFIX */
+
+/* Define to 1 if the system <stdint.h> predates C++11. */
+/* #undef __STDC_CONSTANT_MACROS */
+
+/* Define to 1 if the system <stdint.h> predates C++11. */
+/* #undef __STDC_LIMIT_MACROS */
+
+/* Define so that glibc/gnulib argp.h does not typedef error_t. */
+/* #undef __error_t_defined */
+
+/* The _GL_ASYNC_SAFE marker should be attached to functions that are
+   signal handlers (for signals other than SIGABRT, SIGPIPE) or can be
+   invoked from such signal handlers.  Such functions have some restrictions:
+     * All functions that it calls should be marked _GL_ASYNC_SAFE as well,
+       or should be listed as async-signal-safe in POSIX
+       <http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04>
+       section 2.4.3.  Note that malloc(), sprintf(), and fwrite(), in
+       particular, are NOT async-signal-safe.
+     * All memory locations (variables and struct fields) that these functions
+       access must be marked 'volatile'.  This holds for both read and write
+       accesses.  Otherwise the compiler might optimize away stores to and
+       reads from such locations that occur in the program, depending on its
+       data flow analysis.  For example, when the program contains a loop
+       that is intended to inspect a variable set from within a signal handler
+           while (!signal_occurred)
+             ;
+       the compiler is allowed to transform this into an endless loop if the
+       variable 'signal_occurred' is not declared 'volatile'.
+   Additionally, recall that:
+     * A signal handler should not modify errno (except if it is a handler
+       for a fatal signal and ends by raising the same signal again, thus
+       provoking the termination of the process).  If it invokes a function
+       that may clobber errno, it needs to save and restore the value of
+       errno.  */
+#define _GL_ASYNC_SAFE
+
+
+/* Define to a type to use for 'error_t' if it is not otherwise available. */
+/* #undef error_t */
+
+/* Please see the Gnulib manual for how to use these macros.
+
+   Suppress extern inline with HP-UX cc, as it appears to be broken; see
+   <https://lists.gnu.org/r/bug-texinfo/2013-02/msg00030.html>.
+
+   Suppress extern inline with Sun C in standards-conformance mode, as it
+   mishandles inline functions that call each other.  E.g., for 'inline void f
+   (void) { } inline void g (void) { f (); }', c99 incorrectly complains
+   'reference to static identifier "f" in extern inline function'.
+   This bug was observed with Sun C 5.12 SunOS_i386 2011/11/16.
+
+   Suppress extern inline (with or without __attribute__ ((__gnu_inline__)))
+   on configurations that mistakenly use 'static inline' to implement
+   functions or macros in standard C headers like <ctype.h>.  For example,
+   if isdigit is mistakenly implemented via a static inline function,
+   a program containing an extern inline function that calls isdigit
+   may not work since the C standard prohibits extern inline functions
+   from calling static functions (ISO C 99 section 6.7.4.(3).
+   This bug is known to occur on:
+
+     OS X 10.8 and earlier; see:
+     https://lists.gnu.org/r/bug-gnulib/2012-12/msg00023.html
+
+     DragonFly; see
+     http://muscles.dragonflybsd.org/bulk/bleeding-edge-potential/latest-per-pkg/ah-tty-0.3.12.log
+
+     FreeBSD; see:
+     https://lists.gnu.org/r/bug-gnulib/2014-07/msg00104.html
+
+   OS X 10.9 has a macro __header_inline indicating the bug is fixed for C and
+   for clang but remains for g++; see <https://trac.macports.org/ticket/41033>.
+   Assume DragonFly and FreeBSD will be similar.
+
+   GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  It defines a macro
+   __GNUC_STDC_INLINE__ to indicate this situation or a macro
+   __GNUC_GNU_INLINE__ to indicate the opposite situation.
+   GCC 4.2 with -std=c99 or -std=gnu99 implements the GNU C inline
+   semantics but warns, unless -fgnu89-inline is used:
+     warning: C99 inline functions are not supported; using GNU89
+     warning: to disable this warning use -fgnu89-inline or the gnu_inline function attribute
+   It defines a macro __GNUC_GNU_INLINE__ to indicate this situation.
+ */
+#if (((defined __APPLE__ && defined __MACH__) \
+      || defined __DragonFly__ || defined __FreeBSD__) \
+     && (defined __header_inline \
+         ? (defined __cplusplus && defined __GNUC_STDC_INLINE__ \
+            && ! defined __clang__) \
+         : ((! defined _DONT_USE_CTYPE_INLINE_ \
+             && (defined __GNUC__ || defined __cplusplus)) \
+            || (defined _FORTIFY_SOURCE && 0 < _FORTIFY_SOURCE \
+                && defined __GNUC__ && ! defined __cplusplus))))
+# define _GL_EXTERN_INLINE_STDHEADER_BUG
+#endif
+#if ((__GNUC__ \
+      ? defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__ \
+      : (199901L <= __STDC_VERSION__ \
+         && !defined __HP_cc \
+         && !defined __PGI \
+         && !(defined __SUNPRO_C && __STDC__))) \
+     && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
+# define _GL_INLINE inline
+# define _GL_EXTERN_INLINE extern inline
+# define _GL_EXTERN_INLINE_IN_USE
+#elif (2 < __GNUC__ + (7 <= __GNUC_MINOR__) && !defined __STRICT_ANSI__ \
+       && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
+# if defined __GNUC_GNU_INLINE__ && __GNUC_GNU_INLINE__
+   /* __gnu_inline__ suppresses a GCC 4.2 diagnostic.  */
+#  define _GL_INLINE extern inline __attribute__ ((__gnu_inline__))
+# else
+#  define _GL_INLINE extern inline
+# endif
+# define _GL_EXTERN_INLINE extern
+# define _GL_EXTERN_INLINE_IN_USE
+#else
+# define _GL_INLINE static _GL_UNUSED
+# define _GL_EXTERN_INLINE static _GL_UNUSED
+#endif
+
+/* In GCC 4.6 (inclusive) to 5.1 (exclusive),
+   suppress bogus "no previous prototype for 'FOO'"
+   and "no previous declaration for 'FOO'" diagnostics,
+   when FOO is an inline function in the header; see
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54113> and
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63877>.  */
+#if __GNUC__ == 4 && 6 <= __GNUC_MINOR__
+# if defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__
+#  define _GL_INLINE_HEADER_CONST_PRAGMA
+# else
+#  define _GL_INLINE_HEADER_CONST_PRAGMA \
+     _Pragma ("GCC diagnostic ignored \"-Wsuggest-attribute=const\"")
+# endif
+# define _GL_INLINE_HEADER_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wmissing-prototypes\"") \
+    _Pragma ("GCC diagnostic ignored \"-Wmissing-declarations\"") \
+    _GL_INLINE_HEADER_CONST_PRAGMA
+# define _GL_INLINE_HEADER_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define _GL_INLINE_HEADER_BEGIN
+# define _GL_INLINE_HEADER_END
+#endif
+
+/* Always use our fgetfilecon wrapper. */
+/* #undef fgetfilecon */
+
+/* Always use our getfilecon wrapper. */
+/* #undef getfilecon */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to long or long long if <stdint.h> and <inttypes.h> don't define. */
+/* #undef intmax_t */
+
+/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
+   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
+   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
+   __APPLE__ && __MACH__ test for Mac OS X.
+   __APPLE_CC__ tests for the Apple compiler and its version.
+   __STDC_VERSION__ tests for the C99 mode.  */
+#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
+# define __GNUC_STDC_INLINE__ 1
+#endif
+
+/* Always use our lgetfilecon wrapper. */
+/* #undef lgetfilecon */
+
+/* Define to a type if <wchar.h> does not define. */
+/* #undef mbstate_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to the type of st_nlink in struct stat, or a supertype. */
+/* #undef nlink_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define as the type of the result of subtracting two pointers, if the system
+   doesn't define it. */
+/* #undef ptrdiff_t */
+
+/* Define to rpl_re_comp if the replacement should be used. */
+#define re_comp rpl_re_comp
+
+/* Define to rpl_re_compile_fastmap if the replacement should be used. */
+#define re_compile_fastmap rpl_re_compile_fastmap
+
+/* Define to rpl_re_compile_pattern if the replacement should be used. */
+#define re_compile_pattern rpl_re_compile_pattern
+
+/* Define to rpl_re_exec if the replacement should be used. */
+#define re_exec rpl_re_exec
+
+/* Define to rpl_re_match if the replacement should be used. */
+#define re_match rpl_re_match
+
+/* Define to rpl_re_match_2 if the replacement should be used. */
+#define re_match_2 rpl_re_match_2
+
+/* Define to rpl_re_search if the replacement should be used. */
+#define re_search rpl_re_search
+
+/* Define to rpl_re_search_2 if the replacement should be used. */
+#define re_search_2 rpl_re_search_2
+
+/* Define to rpl_re_set_registers if the replacement should be used. */
+#define re_set_registers rpl_re_set_registers
+
+/* Define to rpl_re_set_syntax if the replacement should be used. */
+#define re_set_syntax rpl_re_set_syntax
+
+/* Define to rpl_re_syntax_options if the replacement should be used. */
+#define re_syntax_options rpl_re_syntax_options
+
+/* Define to rpl_regcomp if the replacement should be used. */
+#define regcomp rpl_regcomp
+
+/* Define to rpl_regerror if the replacement should be used. */
+#define regerror rpl_regerror
+
+/* Define to rpl_regexec if the replacement should be used. */
+#define regexec rpl_regexec
+
+/* Define to rpl_regfree if the replacement should be used. */
+#define regfree rpl_regfree
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#define restrict __restrict
+/* Work around a bug in Sun C++: it does not support _Restrict or
+   __restrict__, even though the corresponding Sun C compiler ends up with
+   "#define restrict _Restrict" or "#define restrict __restrict__" in the
+   previous line.  Perhaps some future version of Sun C++ will work with
+   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+# define __restrict__
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* type to use in place of socklen_t if not defined */
+/* #undef socklen_t */
+
+/* Define as a signed type of the same size as size_t. */
+/* #undef ssize_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Define as a marker that can be attached to declarations that might not
+    be used.  This helps to reduce warnings, such as from
+    GCC -Wunused-parameter.  */
+#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+# define _GL_UNUSED __attribute__ ((__unused__))
+#else
+# define _GL_UNUSED
+#endif
+/* The name _UNUSED_PARAMETER_ is an earlier spelling, although the name
+   is a misnomer outside of parameter lists.  */
+#define _UNUSED_PARAMETER_ _GL_UNUSED
+
+/* gcc supports the "unused" attribute on possibly unused labels, and
+   g++ has since version 4.5.  Note to support C++ as well as C,
+   _GL_UNUSED_LABEL should be used with a trailing ;  */
+#if !defined __cplusplus || __GNUC__ > 4 \
+    || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+# define _GL_UNUSED_LABEL _GL_UNUSED
+#else
+# define _GL_UNUSED_LABEL
+#endif
+
+/* The __pure__ attribute was added in gcc 2.96.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
+#endif
+
+/* The __const__ attribute was added in gcc 2.95.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
+# define _GL_ATTRIBUTE_CONST __attribute__ ((__const__))
+#else
+# define _GL_ATTRIBUTE_CONST /* empty */
+#endif
+
+/* The __malloc__ attribute was added in gcc 3.  */
+#if 3 <= __GNUC__
+# define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+#else
+# define _GL_ATTRIBUTE_MALLOC /* empty */
+#endif
+
+
+/* Define to an unsigned 32-bit type if <sys/types.h> lacks this type. */
+/* #undef useconds_t */
diff --git a/libraries/cmake/source/augeas/generated/linux/ppc64le/config/datadir.h b/libraries/cmake/source/augeas/generated/linux/ppc64le/config/datadir.h
new file mode 100644
index 000000000..fffefb3af
--- /dev/null
+++ b/libraries/cmake/source/augeas/generated/linux/ppc64le/config/datadir.h
@@ -0,0 +1 @@
+#define DATADIR "/usr/local/share"
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/config/config.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/config/config.h
new file mode 100644
index 000000000..0462c3960
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/config/config.h
@@ -0,0 +1,1572 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define to the number of bits in type 'ptrdiff_t'. */
+/* #undef BITSIZEOF_PTRDIFF_T */
+
+/* Define to the number of bits in type 'sig_atomic_t'. */
+/* #undef BITSIZEOF_SIG_ATOMIC_T */
+
+/* Define to the number of bits in type 'size_t'. */
+/* #undef BITSIZEOF_SIZE_T */
+
+/* Define to the number of bits in type 'wchar_t'. */
+/* #undef BITSIZEOF_WCHAR_T */
+
+/* Define to the number of bits in type 'wint_t'. */
+/* #undef BITSIZEOF_WINT_T */
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to 1 if the C locale may have encoding errors. */
+#define C_LOCALE_MAYBE_EILSEQ 1
+
+/* Define as the bit index in the word where to find bit 0 of the exponent of
+   'double'. */
+#define DBL_EXPBIT0_BIT 20
+
+/* Define as the word index where to find the exponent of 'double'. */
+#define DBL_EXPBIT0_WORD 1
+
+/* Define to 1 if // is a file system root distinct from /. */
+/* #undef DOUBLE_SLASH_IS_DISTINCT_ROOT */
+
+/* whether debugging is enabled */
+#define ENABLE_DEBUG 1
+
+/* Define this to 1 if F_DUPFD behavior does not match POSIX */
+/* #undef FCNTL_DUPFD_BUGGY */
+
+/* Define to nothing if C supports flexible array members, and to 1 if it does
+   not. That way, with a declaration like 'struct s { int n; double
+   d[FLEXIBLE_ARRAY_MEMBER]; };', the struct hack can be used with pre-C99
+   compilers. When computing the size of such an object, don't use 'sizeof
+   (struct s)' as it overestimates the size. Use 'offsetof (struct s, d)'
+   instead. Don't use 'offsetof (struct s, d[0])', as this doesn't work with
+   MSVC and with C++ compilers. */
+#define FLEXIBLE_ARRAY_MEMBER /**/
+
+/* Enable compile-time and run-time bounds-checking, and some warnings,
+        without upsetting newer glibc. */
+     #if !defined _FORTIFY_SOURCE && defined __OPTIMIZE__ && __OPTIMIZE__
+     # define _FORTIFY_SOURCE 2
+     #endif
+    
+
+/* Define to 1 if mkdir mistakenly creates a directory given with a trailing
+   dot component. */
+/* #undef FUNC_MKDIR_DOT_BUG */
+
+/* Define to 1 if nl_langinfo (YESEXPR) returns a non-empty string. */
+#define FUNC_NL_LANGINFO_YESEXPR_WORKS 1
+
+/* Define to 1 if realpath() can malloc memory, always gives an absolute path,
+   and handles trailing slash correctly. */
+#define FUNC_REALPATH_WORKS 1
+
+/* Define if gettimeofday clobbers the localtime buffer. */
+/* #undef GETTIMEOFDAY_CLOBBERS_LOCALTIME */
+
+/* Define this to 'void' or 'struct timezone' to match the system's
+   declaration of the second argument to gettimeofday. */
+#define GETTIMEOFDAY_TIMEZONE struct timezone
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module canonicalize-lgpl shall be considered present. */
+#define GNULIB_CANONICALIZE_LGPL 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module fscanf shall be considered present. */
+#define GNULIB_FSCANF 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module lock shall be considered present. */
+#define GNULIB_LOCK 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module msvc-nothrow shall be considered present. */
+#define GNULIB_MSVC_NOTHROW IN_AUGEAS_GNULIB_TESTS
+
+/* Define to 1 if printf and friends should be labeled with attribute
+   "__gnu_printf__" instead of "__printf__" */
+/* #undef GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU */
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module scanf shall be considered present. */
+#define GNULIB_SCANF 1
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module strerror shall be considered present. */
+#define GNULIB_STRERROR IN_AUGEAS_GNULIB_TESTS
+
+/* Define to a C preprocessor expression that evaluates to 1 or 0, depending
+   whether the gnulib module strerror_r-posix shall be considered present. */
+#define GNULIB_STRERROR_R_POSIX IN_AUGEAS_GNULIB_TESTS
+
+/* Define to 1 when the gnulib module accept should be tested. */
+#define GNULIB_TEST_ACCEPT 1
+
+/* Define to 1 when the gnulib module bind should be tested. */
+#define GNULIB_TEST_BIND 1
+
+/* Define to 1 when the gnulib module btowc should be tested. */
+#define GNULIB_TEST_BTOWC 1
+
+/* Define to 1 when the gnulib module canonicalize_file_name should be tested.
+   */
+#define GNULIB_TEST_CANONICALIZE_FILE_NAME 1
+
+/* Define to 1 when the gnulib module cloexec should be tested. */
+#define GNULIB_TEST_CLOEXEC 1
+
+/* Define to 1 when the gnulib module close should be tested. */
+#define GNULIB_TEST_CLOSE 1
+
+/* Define to 1 when the gnulib module connect should be tested. */
+#define GNULIB_TEST_CONNECT 1
+
+/* Define to 1 when the gnulib module dup2 should be tested. */
+#define GNULIB_TEST_DUP2 1
+
+/* Define to 1 when the gnulib module environ should be tested. */
+#define GNULIB_TEST_ENVIRON 1
+
+/* Define to 1 when the gnulib module fcntl should be tested. */
+#define GNULIB_TEST_FCNTL 1
+
+/* Define to 1 when the gnulib module fdopen should be tested. */
+#define GNULIB_TEST_FDOPEN 1
+
+/* Define to 1 when the gnulib module fnmatch should be tested. */
+#define GNULIB_TEST_FNMATCH 1
+
+/* Define to 1 when the gnulib module fstat should be tested. */
+#define GNULIB_TEST_FSTAT 1
+
+/* Define to 1 when the gnulib module ftruncate should be tested. */
+#define GNULIB_TEST_FTRUNCATE 1
+
+/* Define to 1 when the gnulib module getcwd should be tested. */
+#define GNULIB_TEST_GETCWD 1
+
+/* Define to 1 when the gnulib module getdelim should be tested. */
+#define GNULIB_TEST_GETDELIM 1
+
+/* Define to 1 when the gnulib module getdtablesize should be tested. */
+#define GNULIB_TEST_GETDTABLESIZE 1
+
+/* Define to 1 when the gnulib module getline should be tested. */
+#define GNULIB_TEST_GETLINE 1
+
+/* Define to 1 when the gnulib module getpagesize should be tested. */
+#define GNULIB_TEST_GETPAGESIZE 1
+
+/* Define to 1 when the gnulib module gettimeofday should be tested. */
+#define GNULIB_TEST_GETTIMEOFDAY 1
+
+/* Define to 1 when the gnulib module ioctl should be tested. */
+#define GNULIB_TEST_IOCTL 1
+
+/* Define to 1 when the gnulib module listen should be tested. */
+#define GNULIB_TEST_LISTEN 1
+
+/* Define to 1 when the gnulib module localeconv should be tested. */
+#define GNULIB_TEST_LOCALECONV 1
+
+/* Define to 1 when the gnulib module localename should be tested. */
+#define GNULIB_TEST_LOCALENAME 1
+
+/* Define to 1 when the gnulib module lstat should be tested. */
+#define GNULIB_TEST_LSTAT 1
+
+/* Define to 1 when the gnulib module malloc-posix should be tested. */
+#define GNULIB_TEST_MALLOC_POSIX 1
+
+/* Define to 1 when the gnulib module mbrtowc should be tested. */
+#define GNULIB_TEST_MBRTOWC 1
+
+/* Define to 1 when the gnulib module mbsinit should be tested. */
+#define GNULIB_TEST_MBSINIT 1
+
+/* Define to 1 when the gnulib module mbsrtowcs should be tested. */
+#define GNULIB_TEST_MBSRTOWCS 1
+
+/* Define to 1 when the gnulib module mbtowc should be tested. */
+#define GNULIB_TEST_MBTOWC 1
+
+/* Define to 1 when the gnulib module memchr should be tested. */
+#define GNULIB_TEST_MEMCHR 1
+
+/* Define to 1 when the gnulib module mempcpy should be tested. */
+#define GNULIB_TEST_MEMPCPY 1
+
+/* Define to 1 when the gnulib module mkstemp should be tested. */
+#define GNULIB_TEST_MKSTEMP 1
+
+/* Define to 1 when the gnulib module nanosleep should be tested. */
+#define GNULIB_TEST_NANOSLEEP 1
+
+/* Define to 1 when the gnulib module nl_langinfo should be tested. */
+#define GNULIB_TEST_NL_LANGINFO 1
+
+/* Define to 1 when the gnulib module open should be tested. */
+#define GNULIB_TEST_OPEN 1
+
+/* Define to 1 when the gnulib module perror should be tested. */
+#define GNULIB_TEST_PERROR 1
+
+/* Define to 1 when the gnulib module pipe should be tested. */
+#define GNULIB_TEST_PIPE 1
+
+/* Define to 1 when the gnulib module pthread_sigmask should be tested. */
+#define GNULIB_TEST_PTHREAD_SIGMASK 1
+
+/* Define to 1 when the gnulib module putenv should be tested. */
+#define GNULIB_TEST_PUTENV 1
+
+/* Define to 1 when the gnulib module raise should be tested. */
+#define GNULIB_TEST_RAISE 1
+
+/* Define to 1 when the gnulib module rawmemchr should be tested. */
+#define GNULIB_TEST_RAWMEMCHR 1
+
+/* Define to 1 when the gnulib module readlink should be tested. */
+#define GNULIB_TEST_READLINK 1
+
+/* Define to 1 when the gnulib module realpath should be tested. */
+#define GNULIB_TEST_REALPATH 1
+
+/* Define to 1 when the gnulib module select should be tested. */
+#define GNULIB_TEST_SELECT 1
+
+/* Define to 1 when the gnulib module setenv should be tested. */
+#define GNULIB_TEST_SETENV 1
+
+/* Define to 1 when the gnulib module setlocale should be tested. */
+#define GNULIB_TEST_SETLOCALE 1
+
+/* Define to 1 when the gnulib module setsockopt should be tested. */
+#define GNULIB_TEST_SETSOCKOPT 1
+
+/* Define to 1 when the gnulib module sigaction should be tested. */
+#define GNULIB_TEST_SIGACTION 1
+
+/* Define to 1 when the gnulib module sigprocmask should be tested. */
+#define GNULIB_TEST_SIGPROCMASK 1
+
+/* Define to 1 when the gnulib module sleep should be tested. */
+#define GNULIB_TEST_SLEEP 1
+
+/* Define to 1 when the gnulib module socket should be tested. */
+#define GNULIB_TEST_SOCKET 1
+
+/* Define to 1 when the gnulib module stat should be tested. */
+#define GNULIB_TEST_STAT 1
+
+/* Define to 1 when the gnulib module stpcpy should be tested. */
+#define GNULIB_TEST_STPCPY 1
+
+/* Define to 1 when the gnulib module stpncpy should be tested. */
+#define GNULIB_TEST_STPNCPY 1
+
+/* Define to 1 when the gnulib module strchrnul should be tested. */
+#define GNULIB_TEST_STRCHRNUL 1
+
+/* Define to 1 when the gnulib module strerror should be tested. */
+#define GNULIB_TEST_STRERROR 1
+
+/* Define to 1 when the gnulib module strerror_r should be tested. */
+#define GNULIB_TEST_STRERROR_R 1
+
+/* Define to 1 when the gnulib module strndup should be tested. */
+#define GNULIB_TEST_STRNDUP 1
+
+/* Define to 1 when the gnulib module strnlen should be tested. */
+#define GNULIB_TEST_STRNLEN 1
+
+/* Define to 1 when the gnulib module strstr should be tested. */
+#define GNULIB_TEST_STRSTR 1
+
+/* Define to 1 when the gnulib module symlink should be tested. */
+#define GNULIB_TEST_SYMLINK 1
+
+/* Define to 1 when the gnulib module unsetenv should be tested. */
+#define GNULIB_TEST_UNSETENV 1
+
+/* Define to 1 when the gnulib module usleep should be tested. */
+#define GNULIB_TEST_USLEEP 1
+
+/* Define to 1 when the gnulib module vasprintf should be tested. */
+#define GNULIB_TEST_VASPRINTF 1
+
+/* Define to 1 when the gnulib module wcrtomb should be tested. */
+#define GNULIB_TEST_WCRTOMB 1
+
+/* Define to 1 when the gnulib module wctob should be tested. */
+#define GNULIB_TEST_WCTOB 1
+
+/* Define to 1 when the gnulib module wctomb should be tested. */
+#define GNULIB_TEST_WCTOMB 1
+
+/* Define to 1 if you have 'alloca' after including <alloca.h>, a header that
+   may be supplied by this distribution. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#define HAVE_ALLOCA_H 1
+
+/* Define to 1 if you have the <argz.h> header file. */
+#define HAVE_ARGZ_H 1
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <bp-sym.h> header file. */
+/* #undef HAVE_BP_SYM_H */
+
+/* Define to 1 if you have the `btowc' function. */
+#define HAVE_BTOWC 1
+
+/* Define to 1 if nanosleep mishandles large arguments. */
+#define HAVE_BUG_BIG_NANOSLEEP 1
+
+/* Define to 1 if you have the `canonicalize_file_name' function. */
+#define HAVE_CANONICALIZE_FILE_NAME 1
+
+/* Define to 1 if you have the `catgets' function. */
+#define HAVE_CATGETS 1
+
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the Mac OS X function
+   CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if you have the `chsize' function. */
+/* #undef HAVE_CHSIZE */
+
+/* Define to 1 if you have the <crtdefs.h> header file. */
+/* #undef HAVE_CRTDEFS_H */
+
+/* Define to 1 if you have the declaration of `alarm', and to 0 if you don't.
+   */
+#define HAVE_DECL_ALARM 1
+
+/* Define to 1 if you have the declaration of `getc_unlocked', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_GETC_UNLOCKED */
+
+/* Define to 1 if you have the declaration of `getdelim', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETDELIM 1
+
+/* Define to 1 if you have the declaration of `getdtablesize', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETDTABLESIZE 1
+
+/* Define to 1 if you have the declaration of `getline', and to 0 if you
+   don't. */
+#define HAVE_DECL_GETLINE 1
+
+/* Define to 1 if you have the declaration of `inet_pton', and to 0 if you
+   don't. */
+#define HAVE_DECL_INET_PTON 1
+
+/* Define to 1 if you have the declaration of `isblank', and to 0 if you
+   don't. */
+#define HAVE_DECL_ISBLANK 1
+
+/* Define to 1 if you have the declaration of `mbrtowc', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBRTOWC */
+
+/* Define to 1 if you have the declaration of `mbsinit', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBSINIT */
+
+/* Define to 1 if you have the declaration of `mbsrtowcs', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_MBSRTOWCS */
+
+/* Define to 1 if you have the declaration of `setenv', and to 0 if you don't.
+   */
+#define HAVE_DECL_SETENV 1
+
+/* Define to 1 if you have the declaration of `sleep', and to 0 if you don't.
+   */
+#define HAVE_DECL_SLEEP 1
+
+/* Define to 1 if you have the declaration of `stpncpy', and to 0 if you
+   don't. */
+#define HAVE_DECL_STPNCPY 1
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the declaration of `strndup', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRNDUP 1
+
+/* Define to 1 if you have the declaration of `strnlen', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRNLEN 1
+
+/* Define to 1 if you have the declaration of `towlower', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_TOWLOWER */
+
+/* Define to 1 if you have the declaration of `unsetenv', and to 0 if you
+   don't. */
+#define HAVE_DECL_UNSETENV 1
+
+/* Define to 1 if you have the declaration of `wcrtomb', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_WCRTOMB */
+
+/* Define to 1 if you have the declaration of `wctob', and to 0 if you don't.
+   */
+#define HAVE_DECL_WCTOB 1
+
+/* Define to 1 if you have the declaration of `_putenv', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL__PUTENV */
+
+/* Define to 1 if you have the declaration of `_snprintf', and to 0 if you
+   don't. */
+#define HAVE_DECL__SNPRINTF 0
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the 'dup2' function. */
+#define HAVE_DUP2 1
+
+/* Define to 1 if you have the `duplocale' function. */
+#define HAVE_DUPLOCALE 1
+
+/* Define if you have the declaration of environ. */
+#define HAVE_ENVIRON_DECL 1
+
+/* Define to 1 if the system has the type `error_t'. */
+#define HAVE_ERROR_T 1
+
+/* Define if the locale_t type contains insufficient information, as on
+   OpenBSD. */
+/* #undef HAVE_FAKE_LOCALES */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <features.h> header file. */
+#define HAVE_FEATURES_H 1
+
+/* Define to 1 if you have the `flockfile' function. */
+/* #undef HAVE_FLOCKFILE */
+
+/* Define to 1 if you have the `fnmatch' function. */
+#define HAVE_FNMATCH 1
+
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#define HAVE_FNMATCH_H 1
+
+/* Define to 1 if you have the `freelocale' function. */
+#define HAVE_FREELOCALE 1
+
+/* Define to 1 if you have the `fsync' function. */
+#define HAVE_FSYNC 1
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `funlockfile' function. */
+/* #undef HAVE_FUNLOCKFILE */
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `getdelim' function. */
+#define HAVE_GETDELIM 1
+
+/* Define to 1 if you have the `getdtablesize' function. */
+#define HAVE_GETDTABLESIZE 1
+
+/* Define to 1 if you have the `getlocalename_l' function. */
+/* #undef HAVE_GETLOCALENAME_L */
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getopt_long_only' function. */
+#define HAVE_GETOPT_LONG_ONLY 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define to 1 if you have the `inet_pton' function. */
+/* #undef HAVE_INET_PTON */
+
+/* Define if you have the 'intmax_t' type in <stdint.h> or <inttypes.h>. */
+#define HAVE_INTMAX_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if <inttypes.h> exists, doesn't clash with <sys/types.h>, and
+   declares uintmax_t. */
+#define HAVE_INTTYPES_H_WITH_UINTMAX 1
+
+/* Define to 1 if you have the `ioctl' function. */
+#define HAVE_IOCTL 1
+
+/* Define to 1 if <sys/socket.h> defines AF_INET. */
+#define HAVE_IPV4 1
+
+/* Define to 1 if <sys/socket.h> defines AF_INET6. */
+#define HAVE_IPV6 1
+
+/* Define to 1 if you have the `isblank' function. */
+#define HAVE_ISBLANK 1
+
+/* Define to 1 if you have the `iswcntrl' function. */
+#define HAVE_ISWCNTRL 1
+
+/* Define to 1 if you have the `iswctype' function. */
+#define HAVE_ISWCTYPE 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+#define HAVE_LANGINFO_CODESET 1
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define if your <locale.h> file defines LC_MESSAGES. */
+#define HAVE_LC_MESSAGES 1
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#define HAVE_LIBINTL_H 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if the system has the type 'long long int'. */
+#define HAVE_LONG_LONG_INT 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define HAVE_LSTAT 1
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#define HAVE_MALLOC_H 1
+
+/* Define if the 'malloc' function is POSIX compliant. */
+#define HAVE_MALLOC_POSIX 1
+
+/* Define to 1 if mmap()'s MAP_ANONYMOUS flag is available after including
+   config.h and <sys/mman.h>. */
+#define HAVE_MAP_ANONYMOUS 1
+
+/* Define to 1 if you have the `mbrtowc' function. */
+#define HAVE_MBRTOWC 1
+
+/* Define to 1 if you have the `mbsinit' function. */
+#define HAVE_MBSINIT 1
+
+/* Define to 1 if you have the `mbsrtowcs' function. */
+#define HAVE_MBSRTOWCS 1
+
+/* Define to 1 if <wchar.h> declares mbstate_t. */
+#define HAVE_MBSTATE_T 1
+
+/* Define to 1 if you have the `mbtowc' function. */
+#define HAVE_MBTOWC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mempcpy' function. */
+#define HAVE_MEMPCPY 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the `mprotect' function. */
+#define HAVE_MPROTECT 1
+
+/* Define to 1 on MSVC platforms that have the "invalid parameter handler"
+   concept. */
+/* #undef HAVE_MSVC_INVALID_PARAMETER_HANDLER */
+
+/* Define if the locale_t type does not contain the name of each locale
+   category. */
+/* #undef HAVE_NAMELESS_LOCALES */
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the `newlocale' function. */
+#define HAVE_NEWLOCALE 1
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#define HAVE_NL_LANGINFO 1
+
+/* Define to 1 if you have the `open_memstream' function. */
+#define HAVE_OPEN_MEMSTREAM 1
+
+/* Define to 1 if you have the <OS.h> header file. */
+/* #undef HAVE_OS_H */
+
+/* Define to 1 if you have the `pipe' function. */
+#define HAVE_PIPE 1
+
+/* Define to 1 if you have the `pthread_atfork' function. */
+#define HAVE_PTHREAD_ATFORK 1
+
+/* Define if the <pthread.h> defines PTHREAD_MUTEX_RECURSIVE. */
+#define HAVE_PTHREAD_MUTEX_RECURSIVE 1
+
+/* Define if the POSIX multithreading library has read/write locks. */
+#define HAVE_PTHREAD_RWLOCK 1
+
+/* Define if the 'pthread_rwlock_rdlock' function prefers a writer to a
+   reader. */
+/* #undef HAVE_PTHREAD_RWLOCK_RDLOCK_PREFER_WRITER */
+
+/* Define to 1 if the pthread_sigmask function can be used (despite bugs). */
+/* #undef HAVE_PTHREAD_SIGMASK */
+
+/* Define to 1 if you have the `raise' function. */
+#define HAVE_RAISE 1
+
+/* Define to 1 if you have the `rawmemchr' function. */
+#define HAVE_RAWMEMCHR 1
+
+/* Define to 1 if you have the `readlink' function. */
+#define HAVE_READLINK 1
+
+/* Define to 1 if you have the `realpath' function. */
+#define HAVE_REALPATH 1
+
+/* Define to 1 if the system has the type `sa_family_t'. */
+#define HAVE_SA_FAMILY_T 1
+
+/* Define to 1 if you have the <search.h> header file. */
+#define HAVE_SEARCH_H 1
+
+/* Define to 1 if you have the <selinux/context.h> header file. */
+/* #undef HAVE_SELINUX_CONTEXT_H */
+
+/* Define to 1 if you have the <selinux/selinux.h> header file. */
+#define HAVE_SELINUX_SELINUX_H 0
+
+/* Define to 1 if you have the <semaphore.h> header file. */
+#define HAVE_SEMAPHORE_H 1
+
+/* Define to 1 if you have the `setdtablesize' function. */
+/* #undef HAVE_SETDTABLESIZE */
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if you have the `shutdown' function. */
+#define HAVE_SHUTDOWN 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define HAVE_SIGACTION 1
+
+/* Define to 1 if you have the `sigaltstack' function. */
+#define HAVE_SIGALTSTACK 1
+
+/* Define to 1 if the system has the type `siginfo_t'. */
+/* #undef HAVE_SIGINFO_T */
+
+/* Define to 1 if you have the `siginterrupt' function. */
+#define HAVE_SIGINTERRUPT 1
+
+/* Define to 1 if 'sig_atomic_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_SIG_ATOMIC_T */
+
+/* Define to 1 if 'wchar_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_WCHAR_T */
+
+/* Define to 1 if 'wint_t' is a signed integer type. */
+/* #undef HAVE_SIGNED_WINT_T */
+
+/* Define to 1 if the system has the type `sigset_t'. */
+#define HAVE_SIGSET_T 1
+
+/* Define to 1 if you have the `sleep' function. */
+#define HAVE_SLEEP 1
+
+/* Define to 1 if you have the `snprintf' function. */
+#define HAVE_SNPRINTF 1
+
+/* Define if the return value of the snprintf function is the number of of
+   bytes (excluding the terminating NUL) that would have been produced if the
+   buffer had been large enough. */
+#define HAVE_SNPRINTF_RETVAL_C99 1
+
+/* Define if the locale_t type is as on Solaris 11.4. */
+/* #undef HAVE_SOLARIS114_LOCALES */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define if <stdint.h> exists, doesn't clash with <sys/types.h>, and declares
+   uintmax_t. */
+#define HAVE_STDINT_H_WITH_UINTMAX 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define if you have the stpncpy() function and it works. */
+#define HAVE_STPNCPY 1
+
+/* Define to 1 if you have the `strchrnul' function. */
+#define HAVE_STRCHRNUL 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if `decimal_point' is a member of `struct lconv'. */
+/* #undef HAVE_STRUCT_LCONV_DECIMAL_POINT */
+
+/* Define to 1 if `sa_sigaction' is a member of `struct sigaction'. */
+#define HAVE_STRUCT_SIGACTION_SA_SIGACTION 1
+
+/* Define to 1 if the system has the type `struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE 1
+
+/* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */
+#define HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
+
+/* Define to 1 if `st_atimensec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMENSEC */
+
+/* Define to 1 if `st_atimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_atim.st__tim.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC */
+
+/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 1
+
+/* Define to 1 if `st_birthtimensec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMENSEC */
+
+/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_birthtim.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIM_TV_NSEC */
+
+/* Define to 1 if you have the `symlink' function. */
+#define HAVE_SYMLINK 1
+
+/* Define to 1 if you have the <sys/bitypes.h> header file. */
+/* #undef HAVE_SYS_BITYPES_H */
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+#define HAVE_SYS_CDEFS_H 1
+
+/* Define to 1 if you have the <sys/inttypes.h> header file. */
+/* #undef HAVE_SYS_INTTYPES_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#define HAVE_SYS_UIO_H 1
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the `towlower' function. */
+#define HAVE_TOWLOWER 1
+
+/* Define to 1 if you have the `tsearch' function. */
+#define HAVE_TSEARCH 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define HAVE_UNSETENV 1
+
+/* Define to 1 if the system has the type 'unsigned long long int'. */
+#define HAVE_UNSIGNED_LONG_LONG_INT 1
+
+/* Define to 1 if you have the `uselocale' function. */
+#define HAVE_USELOCALE 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Define to 1 if you have the `vasnprintf' function. */
+/* #undef HAVE_VASNPRINTF */
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define if you have the 'wchar_t' type. */
+#define HAVE_WCHAR_T 1
+
+/* Define to 1 if you have the `wcrtomb' function. */
+#define HAVE_WCRTOMB 1
+
+/* Define to 1 if you have the `wcslen' function. */
+#define HAVE_WCSLEN 1
+
+/* Define to 1 if you have the `wcsnlen' function. */
+#define HAVE_WCSNLEN 1
+
+/* Define to 1 if you have the `wctob' function. */
+#define HAVE_WCTOB 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+/* #undef HAVE_WINSOCK2_H */
+
+/* Define if you have the 'wint_t' type. */
+#define HAVE_WINT_T 1
+
+/* Define to 1 if you have the `wmemchr' function. */
+#define HAVE_WMEMCHR 1
+
+/* Define to 1 if you have the `wmemcpy' function. */
+#define HAVE_WMEMCPY 1
+
+/* Define to 1 if you have the `wmempcpy' function. */
+#define HAVE_WMEMPCPY 1
+
+/* This value is set to 1 to indicate that the system argz facility works */
+#define HAVE_WORKING_ARGZ 1
+
+/* Define to 1 if O_NOATIME works. */
+#define HAVE_WORKING_O_NOATIME 1
+
+/* Define to 1 if O_NOFOLLOW works. */
+#define HAVE_WORKING_O_NOFOLLOW 1
+
+/* Define if the uselocale function exists any may safely be called. */
+#define HAVE_WORKING_USELOCALE 1
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+/* #undef HAVE_WS2TCPIP_H */
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define to 1 if the system has the type `_Bool'. */
+#define HAVE__BOOL 1
+
+/* Define to 1 if you have the `_set_invalid_parameter_handler' function. */
+/* #undef HAVE__SET_INVALID_PARAMETER_HANDLER */
+
+/* Define to 1 if the compiler supports __builtin_expect,
+   and to 2 if <builtins.h> does.  */
+#define HAVE___BUILTIN_EXPECT 1
+#ifndef HAVE___BUILTIN_EXPECT
+# define __builtin_expect(e, c) (e)
+#elif HAVE___BUILTIN_EXPECT == 2
+# include <builtins.h>
+#endif
+    
+
+/* Define to 1 if the compiler supports the keyword '__inline'. */
+#define HAVE___INLINE 1
+
+/* Define to 1 if you have the `__xpg_strerror_r' function. */
+#define HAVE___XPG_STRERROR_R 1
+
+/* Define to 1 if 'lstat' dereferences a symlink specified with a trailing
+   slash. */
+#define LSTAT_FOLLOWS_SLASHED_SYMLINK 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* If malloc(0) is != NULL, define this to 1. Otherwise define this to 0. */
+#define MALLOC_0_IS_NONNULL 1
+
+/* Define to a substitute value for mmap()'s MAP_ANONYMOUS flag. */
+/* #undef MAP_ANONYMOUS */
+
+/* Define if the mbrtowc function does not return (size_t) -2 for empty input.
+   */
+/* #undef MBRTOWC_EMPTY_INPUT_BUG */
+
+/* Define if the mbrtowc function has the NULL pwc argument bug. */
+/* #undef MBRTOWC_NULL_ARG1_BUG */
+
+/* Define if the mbrtowc function has the NULL string argument bug. */
+/* #undef MBRTOWC_NULL_ARG2_BUG */
+
+/* Define if the mbrtowc function does not return 0 for a NUL character. */
+/* #undef MBRTOWC_NUL_RETVAL_BUG */
+
+/* Define if the mbrtowc function returns a wrong return value. */
+/* #undef MBRTOWC_RETVAL_BUG */
+
+/* Use GNU style printf and scanf.  */
+#ifndef __USE_MINGW_ANSI_STDIO
+# define __USE_MINGW_ANSI_STDIO 1
+#endif
+
+
+/* Define to 1 if open() fails to recognize a trailing slash. */
+/* #undef OPEN_TRAILING_SLASH_BUG */
+
+/* Name of package */
+#define PACKAGE "augeas"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "augeas"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "augeas 1.12.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "augeas"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.12.0"
+
+/* Define if <inttypes.h> exists and defines unusable PRI* macros. */
+/* #undef PRI_MACROS_BROKEN */
+
+/* Define to the type that is the result of default argument promotions of
+   type mode_t. */
+#define PROMOTED_MODE_T mode_t
+
+/* Define if the pthread_in_use() detection is hard. */
+/* #undef PTHREAD_IN_USE_DETECTION_HARD */
+
+/* Define to 1 if pthread_sigmask(), when it fails, returns -1 and sets errno.
+   */
+/* #undef PTHREAD_SIGMASK_FAILS_WITH_ERRNO */
+
+/* Define to 1 if pthread_sigmask may return 0 and have no effect. */
+/* #undef PTHREAD_SIGMASK_INEFFECTIVE */
+
+/* Define to 1 if pthread_sigmask() unblocks signals incorrectly. */
+/* #undef PTHREAD_SIGMASK_UNBLOCK_BUG */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'ptrdiff_t'. */
+/* #undef PTRDIFF_T_SUFFIX */
+
+/* Define to 1 if readlink fails to recognize a trailing slash. */
+/* #undef READLINK_TRAILING_SLASH_BUG */
+
+/* Define to 1 if stat needs help when passed a file name with a trailing
+   slash */
+/* #undef REPLACE_FUNC_STAT_FILE */
+
+/* Define if nl_langinfo exists but is overridden by gnulib. */
+/* #undef REPLACE_NL_LANGINFO */
+
+/* Define to 1 if strerror(0) does not return a message implying success. */
+/* #undef REPLACE_STRERROR_0 */
+
+/* Define if vasnprintf exists but is overridden by gnulib. */
+/* #undef REPLACE_VASNPRINTF */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'sig_atomic_t'. */
+/* #undef SIG_ATOMIC_T_SUFFIX */
+
+/* Define as the maximum value of type 'size_t', if the system doesn't define
+   it. */
+#ifndef SIZE_MAX
+/* # undef SIZE_MAX */
+#endif
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'size_t'. */
+/* #undef SIZE_T_SUFFIX */
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if the `S_IS*' macros in <sys/stat.h> do not work properly. */
+/* #undef STAT_MACROS_BROKEN */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if the type of the st_atim member of a struct stat is struct
+   timespec. */
+#define TYPEOF_STRUCT_STAT_ST_ATIM_IS_STRUCT_TIMESPEC 1
+
+/* Define if the POSIX multithreading library can be used. */
+#define USE_POSIX_THREADS 1
+
+/* Define if references to the POSIX multithreading library should be made
+   weak. */
+#define USE_POSIX_THREADS_WEAK 1
+
+/* Define if the GNU Pth multithreading library can be used. */
+/* #undef USE_PTH_THREADS */
+
+/* Define if references to the GNU Pth multithreading library should be made
+   weak. */
+/* #undef USE_PTH_THREADS_WEAK */
+
+/* Define if the old Solaris multithreading library can be used. */
+/* #undef USE_SOLARIS_THREADS */
+
+/* Define if references to the old Solaris multithreading library should be
+   made weak. */
+/* #undef USE_SOLARIS_THREADS_WEAK */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable general extensions on macOS.  */
+#ifndef _DARWIN_C_SOURCE
+# define _DARWIN_C_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable NetBSD extensions on NetBSD.  */
+#ifndef _NETBSD_SOURCE
+# define _NETBSD_SOURCE 1
+#endif
+/* Enable OpenBSD extensions on NetBSD.  */
+#ifndef _OPENBSD_SOURCE
+# define _OPENBSD_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-5:2014.  */
+#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__
+# define __STDC_WANT_IEC_60559_ATTRIBS_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-1:2014.  */
+#ifndef __STDC_WANT_IEC_60559_BFP_EXT__
+# define __STDC_WANT_IEC_60559_BFP_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-2:2015.  */
+#ifndef __STDC_WANT_IEC_60559_DFP_EXT__
+# define __STDC_WANT_IEC_60559_DFP_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-4:2015.  */
+#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__
+# define __STDC_WANT_IEC_60559_FUNCS_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TS 18661-3:2015.  */
+#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__
+# define __STDC_WANT_IEC_60559_TYPES_EXT__ 1
+#endif
+/* Enable extensions specified by ISO/IEC TR 24731-2:2010.  */
+#ifndef __STDC_WANT_LIB_EXT2__
+# define __STDC_WANT_LIB_EXT2__ 1
+#endif
+/* Enable extensions specified by ISO/IEC 24747:2009.  */
+#ifndef __STDC_WANT_MATH_SPEC_FUNCS__
+# define __STDC_WANT_MATH_SPEC_FUNCS__ 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable X/Open extensions if necessary.  HP-UX 11.11 defines
+   mbstate_t only if _XOPEN_SOURCE is defined to 500, regardless of
+   whether compiling with -Ae or -D_HPUX_SOURCE=1.  */
+#ifndef _XOPEN_SOURCE
+/* # undef _XOPEN_SOURCE */
+#endif
+/* Enable X/Open compliant socket functions that do not require linking
+   with -lxnet on HP-UX 11.11.  */
+#ifndef _HPUX_ALT_XOPEN_SOCKET_API
+# define _HPUX_ALT_XOPEN_SOCKET_API 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Define if the native Windows multithreading API can be used. */
+/* #undef USE_WINDOWS_THREADS */
+
+/* Version number of package */
+#define VERSION "1.12.0"
+
+/* Define to 1 if unsetenv returns void instead of int. */
+/* #undef VOID_UNSETENV */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'wchar_t'. */
+/* #undef WCHAR_T_SUFFIX */
+
+/* Define if WSAStartup is needed. */
+/* #undef WINDOWS_SOCKETS */
+
+/* Define to l, ll, u, ul, ull, etc., as suitable for constants of type
+   'wint_t'. */
+/* #undef WINT_T_SUFFIX */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Define to 1 if `lex' declares `yytext' as a `char *' by default, not a
+   `char[]'. */
+/* #undef YYTEXT_POINTER */
+
+/* Enable large inode numbers on Mac OS X 10.5. */
+#define _DARWIN_USE_64_BIT_INODE 1
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 on Solaris. */
+/* #undef _LCONV_C99 */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 1 to make NetBSD features available. MINIX 3 needs this. */
+#define _NETBSD_SOURCE 1
+
+/* The _Noreturn keyword of C11.  */
+#ifndef _Noreturn
+# if (defined __cplusplus \
+      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
+          || (defined _MSC_VER && 1900 <= _MSC_VER)))
+#  define _Noreturn [[noreturn]]
+# elif ((!defined __cplusplus || defined __clang__) \
+        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0)  \
+            || 4 < __GNUC__ + (7 <= __GNUC_MINOR__)))
+   /* _Noreturn works as-is.  */
+# elif 2 < __GNUC__ + (8 <= __GNUC_MINOR__) || 0x5110 <= __SUNPRO_C
+#  define _Noreturn __attribute__ ((__noreturn__))
+# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn
+# endif
+#endif
+
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 in order to get the POSIX compatible declarations of socket
+   functions. */
+/* #undef _POSIX_PII_SOCKET */
+
+/* Define to 1 if you need to in order for 'stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define if you want <regex.h> to include <limits.h>, so that it consistently
+   overrides <limits.h>'s RE_DUP_MAX. */
+#define _REGEX_INCLUDE_LIMITS_H 1
+
+/* Define if you want regoff_t to be at least as wide POSIX requires. */
+#define _REGEX_LARGE_OFFSETS 1
+
+/* For standard stat data types on VMS. */
+#define _USE_STD_STAT 1
+
+/* Define to rpl_ if the getopt replacement functions and variables should be
+   used. */
+/* #undef __GETOPT_PREFIX */
+
+/* Define to 1 if the system <stdint.h> predates C++11. */
+/* #undef __STDC_CONSTANT_MACROS */
+
+/* Define to 1 if the system <stdint.h> predates C++11. */
+/* #undef __STDC_LIMIT_MACROS */
+
+/* Define so that glibc/gnulib argp.h does not typedef error_t. */
+/* #undef __error_t_defined */
+
+/* The _GL_ASYNC_SAFE marker should be attached to functions that are
+   signal handlers (for signals other than SIGABRT, SIGPIPE) or can be
+   invoked from such signal handlers.  Such functions have some restrictions:
+     * All functions that it calls should be marked _GL_ASYNC_SAFE as well,
+       or should be listed as async-signal-safe in POSIX
+       <http://pubs.opengroup.org/onlinepubs/9699919799/functions/V2_chap02.html#tag_15_04>
+       section 2.4.3.  Note that malloc(), sprintf(), and fwrite(), in
+       particular, are NOT async-signal-safe.
+     * All memory locations (variables and struct fields) that these functions
+       access must be marked 'volatile'.  This holds for both read and write
+       accesses.  Otherwise the compiler might optimize away stores to and
+       reads from such locations that occur in the program, depending on its
+       data flow analysis.  For example, when the program contains a loop
+       that is intended to inspect a variable set from within a signal handler
+           while (!signal_occurred)
+             ;
+       the compiler is allowed to transform this into an endless loop if the
+       variable 'signal_occurred' is not declared 'volatile'.
+   Additionally, recall that:
+     * A signal handler should not modify errno (except if it is a handler
+       for a fatal signal and ends by raising the same signal again, thus
+       provoking the termination of the process).  If it invokes a function
+       that may clobber errno, it needs to save and restore the value of
+       errno.  */
+#define _GL_ASYNC_SAFE
+
+
+/* Define to a type to use for 'error_t' if it is not otherwise available. */
+/* #undef error_t */
+
+/* Please see the Gnulib manual for how to use these macros.
+
+   Suppress extern inline with HP-UX cc, as it appears to be broken; see
+   <https://lists.gnu.org/r/bug-texinfo/2013-02/msg00030.html>.
+
+   Suppress extern inline with Sun C in standards-conformance mode, as it
+   mishandles inline functions that call each other.  E.g., for 'inline void f
+   (void) { } inline void g (void) { f (); }', c99 incorrectly complains
+   'reference to static identifier "f" in extern inline function'.
+   This bug was observed with Sun C 5.12 SunOS_i386 2011/11/16.
+
+   Suppress extern inline (with or without __attribute__ ((__gnu_inline__)))
+   on configurations that mistakenly use 'static inline' to implement
+   functions or macros in standard C headers like <ctype.h>.  For example,
+   if isdigit is mistakenly implemented via a static inline function,
+   a program containing an extern inline function that calls isdigit
+   may not work since the C standard prohibits extern inline functions
+   from calling static functions (ISO C 99 section 6.7.4.(3).
+   This bug is known to occur on:
+
+     OS X 10.8 and earlier; see:
+     https://lists.gnu.org/r/bug-gnulib/2012-12/msg00023.html
+
+     DragonFly; see
+     http://muscles.dragonflybsd.org/bulk/bleeding-edge-potential/latest-per-pkg/ah-tty-0.3.12.log
+
+     FreeBSD; see:
+     https://lists.gnu.org/r/bug-gnulib/2014-07/msg00104.html
+
+   OS X 10.9 has a macro __header_inline indicating the bug is fixed for C and
+   for clang but remains for g++; see <https://trac.macports.org/ticket/41033>.
+   Assume DragonFly and FreeBSD will be similar.
+
+   GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  It defines a macro
+   __GNUC_STDC_INLINE__ to indicate this situation or a macro
+   __GNUC_GNU_INLINE__ to indicate the opposite situation.
+   GCC 4.2 with -std=c99 or -std=gnu99 implements the GNU C inline
+   semantics but warns, unless -fgnu89-inline is used:
+     warning: C99 inline functions are not supported; using GNU89
+     warning: to disable this warning use -fgnu89-inline or the gnu_inline function attribute
+   It defines a macro __GNUC_GNU_INLINE__ to indicate this situation.
+ */
+#if (((defined __APPLE__ && defined __MACH__) \
+      || defined __DragonFly__ || defined __FreeBSD__) \
+     && (defined __header_inline \
+         ? (defined __cplusplus && defined __GNUC_STDC_INLINE__ \
+            && ! defined __clang__) \
+         : ((! defined _DONT_USE_CTYPE_INLINE_ \
+             && (defined __GNUC__ || defined __cplusplus)) \
+            || (defined _FORTIFY_SOURCE && 0 < _FORTIFY_SOURCE \
+                && defined __GNUC__ && ! defined __cplusplus))))
+# define _GL_EXTERN_INLINE_STDHEADER_BUG
+#endif
+#if ((__GNUC__ \
+      ? defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__ \
+      : (199901L <= __STDC_VERSION__ \
+         && !defined __HP_cc \
+         && !defined __PGI \
+         && !(defined __SUNPRO_C && __STDC__))) \
+     && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
+# define _GL_INLINE inline
+# define _GL_EXTERN_INLINE extern inline
+# define _GL_EXTERN_INLINE_IN_USE
+#elif (2 < __GNUC__ + (7 <= __GNUC_MINOR__) && !defined __STRICT_ANSI__ \
+       && !defined _GL_EXTERN_INLINE_STDHEADER_BUG)
+# if defined __GNUC_GNU_INLINE__ && __GNUC_GNU_INLINE__
+   /* __gnu_inline__ suppresses a GCC 4.2 diagnostic.  */
+#  define _GL_INLINE extern inline __attribute__ ((__gnu_inline__))
+# else
+#  define _GL_INLINE extern inline
+# endif
+# define _GL_EXTERN_INLINE extern
+# define _GL_EXTERN_INLINE_IN_USE
+#else
+# define _GL_INLINE static _GL_UNUSED
+# define _GL_EXTERN_INLINE static _GL_UNUSED
+#endif
+
+/* In GCC 4.6 (inclusive) to 5.1 (exclusive),
+   suppress bogus "no previous prototype for 'FOO'"
+   and "no previous declaration for 'FOO'" diagnostics,
+   when FOO is an inline function in the header; see
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54113> and
+   <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63877>.  */
+#if __GNUC__ == 4 && 6 <= __GNUC_MINOR__
+# if defined __GNUC_STDC_INLINE__ && __GNUC_STDC_INLINE__
+#  define _GL_INLINE_HEADER_CONST_PRAGMA
+# else
+#  define _GL_INLINE_HEADER_CONST_PRAGMA \
+     _Pragma ("GCC diagnostic ignored \"-Wsuggest-attribute=const\"")
+# endif
+# define _GL_INLINE_HEADER_BEGIN \
+    _Pragma ("GCC diagnostic push") \
+    _Pragma ("GCC diagnostic ignored \"-Wmissing-prototypes\"") \
+    _Pragma ("GCC diagnostic ignored \"-Wmissing-declarations\"") \
+    _GL_INLINE_HEADER_CONST_PRAGMA
+# define _GL_INLINE_HEADER_END \
+    _Pragma ("GCC diagnostic pop")
+#else
+# define _GL_INLINE_HEADER_BEGIN
+# define _GL_INLINE_HEADER_END
+#endif
+
+/* Always use our fgetfilecon wrapper. */
+/* #undef fgetfilecon */
+
+/* Always use our getfilecon wrapper. */
+/* #undef getfilecon */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to long or long long if <stdint.h> and <inttypes.h> don't define. */
+/* #undef intmax_t */
+
+/* Work around a bug in Apple GCC 4.0.1 build 5465: In C99 mode, it supports
+   the ISO C 99 semantics of 'extern inline' (unlike the GNU C semantics of
+   earlier versions), but does not display it by setting __GNUC_STDC_INLINE__.
+   __APPLE__ && __MACH__ test for Mac OS X.
+   __APPLE_CC__ tests for the Apple compiler and its version.
+   __STDC_VERSION__ tests for the C99 mode.  */
+#if defined __APPLE__ && defined __MACH__ && __APPLE_CC__ >= 5465 && !defined __cplusplus && __STDC_VERSION__ >= 199901L && !defined __GNUC_STDC_INLINE__
+# define __GNUC_STDC_INLINE__ 1
+#endif
+
+/* Always use our lgetfilecon wrapper. */
+/* #undef lgetfilecon */
+
+/* Define to a type if <wchar.h> does not define. */
+/* #undef mbstate_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to the type of st_nlink in struct stat, or a supertype. */
+/* #undef nlink_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define as the type of the result of subtracting two pointers, if the system
+   doesn't define it. */
+/* #undef ptrdiff_t */
+
+/* Define to rpl_re_comp if the replacement should be used. */
+#define re_comp rpl_re_comp
+
+/* Define to rpl_re_compile_fastmap if the replacement should be used. */
+#define re_compile_fastmap rpl_re_compile_fastmap
+
+/* Define to rpl_re_compile_pattern if the replacement should be used. */
+#define re_compile_pattern rpl_re_compile_pattern
+
+/* Define to rpl_re_exec if the replacement should be used. */
+#define re_exec rpl_re_exec
+
+/* Define to rpl_re_match if the replacement should be used. */
+#define re_match rpl_re_match
+
+/* Define to rpl_re_match_2 if the replacement should be used. */
+#define re_match_2 rpl_re_match_2
+
+/* Define to rpl_re_search if the replacement should be used. */
+#define re_search rpl_re_search
+
+/* Define to rpl_re_search_2 if the replacement should be used. */
+#define re_search_2 rpl_re_search_2
+
+/* Define to rpl_re_set_registers if the replacement should be used. */
+#define re_set_registers rpl_re_set_registers
+
+/* Define to rpl_re_set_syntax if the replacement should be used. */
+#define re_set_syntax rpl_re_set_syntax
+
+/* Define to rpl_re_syntax_options if the replacement should be used. */
+#define re_syntax_options rpl_re_syntax_options
+
+/* Define to rpl_regcomp if the replacement should be used. */
+#define regcomp rpl_regcomp
+
+/* Define to rpl_regerror if the replacement should be used. */
+#define regerror rpl_regerror
+
+/* Define to rpl_regexec if the replacement should be used. */
+#define regexec rpl_regexec
+
+/* Define to rpl_regfree if the replacement should be used. */
+#define regfree rpl_regfree
+
+/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#define restrict __restrict
+/* Work around a bug in Sun C++: it does not support _Restrict or
+   __restrict__, even though the corresponding Sun C compiler ends up with
+   "#define restrict _Restrict" or "#define restrict __restrict__" in the
+   previous line.  Perhaps some future version of Sun C++ will work with
+   restrict; if so, hopefully it defines __RESTRICT like Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+# define __restrict__
+#endif
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* type to use in place of socklen_t if not defined */
+/* #undef socklen_t */
+
+/* Define as a signed type of the same size as size_t. */
+/* #undef ssize_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Define as a marker that can be attached to declarations that might not
+    be used.  This helps to reduce warnings, such as from
+    GCC -Wunused-parameter.  */
+#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+# define _GL_UNUSED __attribute__ ((__unused__))
+#else
+# define _GL_UNUSED
+#endif
+/* The name _UNUSED_PARAMETER_ is an earlier spelling, although the name
+   is a misnomer outside of parameter lists.  */
+#define _UNUSED_PARAMETER_ _GL_UNUSED
+
+/* gcc supports the "unused" attribute on possibly unused labels, and
+   g++ has since version 4.5.  Note to support C++ as well as C,
+   _GL_UNUSED_LABEL should be used with a trailing ;  */
+#if !defined __cplusplus || __GNUC__ > 4 \
+    || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
+# define _GL_UNUSED_LABEL _GL_UNUSED
+#else
+# define _GL_UNUSED_LABEL
+#endif
+
+/* The __pure__ attribute was added in gcc 2.96.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
+#endif
+
+/* The __const__ attribute was added in gcc 2.95.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
+# define _GL_ATTRIBUTE_CONST __attribute__ ((__const__))
+#else
+# define _GL_ATTRIBUTE_CONST /* empty */
+#endif
+
+/* The __malloc__ attribute was added in gcc 3.  */
+#if 3 <= __GNUC__
+# define _GL_ATTRIBUTE_MALLOC __attribute__ ((__malloc__))
+#else
+# define _GL_ATTRIBUTE_MALLOC /* empty */
+#endif
+
+
+/* Define to an unsigned 32-bit type if <sys/types.h> lacks this type. */
+/* #undef useconds_t */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/alloca.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/alloca.h
new file mode 100644
index 000000000..32cbc53f3
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/alloca.h
@@ -0,0 +1,72 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Memory allocation on the stack.
+
+   Copyright (C) 1995, 1999, 2001-2004, 2006-2019 Free Software Foundation,
+   Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program; if not, see
+   <https://www.gnu.org/licenses/>.
+  */
+
+/* Avoid using the symbol _ALLOCA_H here, as Bison assumes _ALLOCA_H
+   means there is a real alloca function.  */
+#ifndef _GL_ALLOCA_H
+#define _GL_ALLOCA_H
+
+/* alloca (N) returns a pointer to N bytes of memory
+   allocated on the stack, which will last until the function returns.
+   Use of alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns,
+     - for huge N (say, N >= 65536) - you never know how large (or small)
+       the stack is, and when the stack cannot fulfill the memory allocation
+       request, the program just crashes.
+ */
+
+#ifndef alloca
+# ifdef __GNUC__
+   /* Some version of mingw have an <alloca.h> that causes trouble when
+      included after 'alloca' gets defined as a macro.  As a workaround, include
+      this <alloca.h> first and define 'alloca' as a macro afterwards.  */
+#  if (defined _WIN32 && ! defined __CYGWIN__) && 1
+#   include_next <alloca.h>
+#  endif
+#  define alloca __builtin_alloca
+# elif defined _AIX
+#  define alloca __alloca
+# elif defined _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# elif defined __DECC && defined __VMS
+#  define alloca __ALLOCA
+# elif defined __TANDEM && defined _TNS_E_TARGET
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *_alloca (unsigned short);
+#  pragma intrinsic (_alloca)
+#  define alloca _alloca
+# elif defined __MVS__
+#  include <stdlib.h>
+# else
+#  include <stddef.h>
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *alloca (size_t);
+# endif
+#endif
+
+#endif /* _GL_ALLOCA_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/ctype.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/ctype.h
new file mode 100644
index 000000000..4ddbc0c37
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/ctype.h
@@ -0,0 +1,505 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C99 <ctype.h>, for platforms on which it is incomplete.
+
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible.  */
+
+/*
+ * ISO C 99 <ctype.h> for platforms on which it is incomplete.
+ * <http://www.opengroup.org/onlinepubs/9699919799/basedefs/ctype.h.html>
+ */
+
+#ifndef _GL_CTYPE_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* Include the original <ctype.h>.  */
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <ctype.h>
+
+#ifndef _GL_CTYPE_H
+#define _GL_CTYPE_H
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Return non-zero if c is a blank, i.e. a space or tab character.  */
+#if 1
+# if !1
+_GL_EXTERN_C int isblank (int c);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef isblank
+# if HAVE_RAW_DECL_ISBLANK
+_GL_WARN_ON_USE (isblank, "isblank is unportable - "
+                 "use gnulib module isblank for portability");
+# endif
+#endif
+
+#endif /* _GL_CTYPE_H */
+#endif /* _GL_CTYPE_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/fcntl.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/fcntl.h
new file mode 100644
index 000000000..e4c25a082
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/fcntl.h
@@ -0,0 +1,840 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Like <fcntl.h>, but with non-working flags defined to 0.
+
+   Copyright (C) 2006-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* written by Paul Eggert */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if defined __need_system_fcntl_h
+/* Special invocation convention.  */
+
+/* Needed before <sys/stat.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+/* On some systems other than glibc, <sys/stat.h> is a prerequisite of
+   <fcntl.h>.  On glibc systems, we would like to avoid namespace pollution.
+   But on glibc systems, <fcntl.h> includes <sys/stat.h> inside an
+   extern "C" { ... } block, which leads to errors in C++ mode with the
+   overridden <sys/stat.h> from gnulib.  These errors are known to be gone
+   with g++ version >= 4.3.  */
+#if !(defined __GLIBC__ || defined __UCLIBC__) || (defined __cplusplus && defined GNULIB_NAMESPACE && (defined __ICC || !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))))
+# include <sys/stat.h>
+#endif
+#include_next <fcntl.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_FCNTL_H
+
+/* Needed before <sys/stat.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+/* On some systems other than glibc, <sys/stat.h> is a prerequisite of
+   <fcntl.h>.  On glibc systems, we would like to avoid namespace pollution.
+   But on glibc systems, <fcntl.h> includes <sys/stat.h> inside an
+   extern "C" { ... } block, which leads to errors in C++ mode with the
+   overridden <sys/stat.h> from gnulib.  These errors are known to be gone
+   with g++ version >= 4.3.  */
+#if !(defined __GLIBC__ || defined __UCLIBC__) || (defined __cplusplus && defined GNULIB_NAMESPACE && (defined __ICC || !(__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))))
+# include <sys/stat.h>
+#endif
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <fcntl.h>
+
+#ifndef _GL_FCNTL_H
+#define _GL_FCNTL_H
+
+#ifndef __GLIBC__ /* Avoid namespace pollution on glibc systems.  */
+# include <unistd.h>
+#endif
+
+/* Native Windows platforms declare open(), creat() in <io.h>.  */
+#if (IN_AUGEAS_GNULIB_TESTS || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Declare overridden functions.  */
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fcntl
+#   define fcntl rpl_fcntl
+#  endif
+_GL_FUNCDECL_RPL (fcntl, int, (int fd, int action, ...));
+_GL_CXXALIAS_RPL (fcntl, int, (int fd, int action, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fcntl, int, (int fd, int action, ...));
+#  endif
+_GL_CXXALIAS_SYS (fcntl, int, (int fd, int action, ...));
+# endif
+_GL_CXXALIASWARN (fcntl);
+#elif defined GNULIB_POSIXCHECK
+# undef fcntl
+# if HAVE_RAW_DECL_FCNTL
+_GL_WARN_ON_USE (fcntl, "fcntl is not always POSIX compliant - "
+                 "use gnulib module fcntl for portability");
+# endif
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef open
+#   define open rpl_open
+#  endif
+_GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                             _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+# else
+_GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+# endif
+/* On HP-UX 11, in C++ mode, open() is defined as an inline function with a
+   default argument.  _GL_CXXALIASWARN does not work in this case.  */
+# if !defined __hpux
+_GL_CXXALIASWARN (open);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef open
+/* Assume open is always declared.  */
+_GL_WARN_ON_USE (open, "open is not always POSIX compliant - "
+                 "use gnulib module open for portability");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef openat
+#   define openat rpl_openat
+#  endif
+_GL_FUNCDECL_RPL (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (openat, int,
+                  (int fd, char const *file, int flags, /* mode_t mode */ ...));
+# endif
+_GL_CXXALIASWARN (openat);
+#elif defined GNULIB_POSIXCHECK
+# undef openat
+# if HAVE_RAW_DECL_OPENAT
+_GL_WARN_ON_USE (openat, "openat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+/* Fix up the FD_* macros, only known to be missing on mingw.  */
+
+#ifndef FD_CLOEXEC
+# define FD_CLOEXEC 1
+#endif
+
+/* Fix up the supported F_* macros.  Intentionally leave other F_*
+   macros undefined.  Only known to be missing on mingw.  */
+
+#ifndef F_DUPFD_CLOEXEC
+# define F_DUPFD_CLOEXEC 0x40000000
+/* Witness variable: 1 if gnulib defined F_DUPFD_CLOEXEC, 0 otherwise.  */
+# define GNULIB_defined_F_DUPFD_CLOEXEC 1
+#else
+# define GNULIB_defined_F_DUPFD_CLOEXEC 0
+#endif
+
+#ifndef F_DUPFD
+# define F_DUPFD 1
+#endif
+
+#ifndef F_GETFD
+# define F_GETFD 2
+#endif
+
+/* Fix up the O_* macros.  */
+
+/* AIX 7.1 with XL C 12.1 defines O_CLOEXEC, O_NOFOLLOW, and O_TTY_INIT
+   to values outside 'int' range, so omit these misdefinitions.
+   But avoid namespace pollution on non-AIX systems.  */
+#ifdef _AIX
+# include <limits.h>
+# if defined O_CLOEXEC && ! (INT_MIN <= O_CLOEXEC && O_CLOEXEC <= INT_MAX)
+#  undef O_CLOEXEC
+# endif
+# if defined O_NOFOLLOW && ! (INT_MIN <= O_NOFOLLOW && O_NOFOLLOW <= INT_MAX)
+#  undef O_NOFOLLOW
+# endif
+# if defined O_TTY_INIT && ! (INT_MIN <= O_TTY_INIT && O_TTY_INIT <= INT_MAX)
+#  undef O_TTY_INIT
+# endif
+#endif
+
+#if !defined O_DIRECT && defined O_DIRECTIO
+/* Tru64 spells it 'O_DIRECTIO'.  */
+# define O_DIRECT O_DIRECTIO
+#endif
+
+#if !defined O_CLOEXEC && defined O_NOINHERIT
+/* Mingw spells it 'O_NOINHERIT'.  */
+# define O_CLOEXEC O_NOINHERIT
+#endif
+
+#ifndef O_CLOEXEC
+# define O_CLOEXEC 0x40000000 /* Try to not collide with system O_* flags.  */
+# define GNULIB_defined_O_CLOEXEC 1
+#else
+# define GNULIB_defined_O_CLOEXEC 0
+#endif
+
+#ifndef O_DIRECT
+# define O_DIRECT 0
+#endif
+
+#ifndef O_DIRECTORY
+# define O_DIRECTORY 0
+#endif
+
+#ifndef O_DSYNC
+# define O_DSYNC 0
+#endif
+
+#ifndef O_EXEC
+# define O_EXEC O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
+#ifndef O_IGNORE_CTTY
+# define O_IGNORE_CTTY 0
+#endif
+
+#ifndef O_NDELAY
+# define O_NDELAY 0
+#endif
+
+#ifndef O_NOATIME
+# define O_NOATIME 0
+#endif
+
+#ifndef O_NONBLOCK
+# define O_NONBLOCK O_NDELAY
+#endif
+
+/* If the gnulib module 'nonblocking' is in use, guarantee a working non-zero
+   value of O_NONBLOCK.  Otherwise, O_NONBLOCK is defined (above) to O_NDELAY
+   or to 0 as fallback.  */
+#if 0
+# if O_NONBLOCK
+#  define GNULIB_defined_O_NONBLOCK 0
+# else
+#  define GNULIB_defined_O_NONBLOCK 1
+#  undef O_NONBLOCK
+#  define O_NONBLOCK 0x40000000
+# endif
+#endif
+
+#ifndef O_NOCTTY
+# define O_NOCTTY 0
+#endif
+
+#ifndef O_NOFOLLOW
+# define O_NOFOLLOW 0
+#endif
+
+#ifndef O_NOLINK
+# define O_NOLINK 0
+#endif
+
+#ifndef O_NOLINKS
+# define O_NOLINKS 0
+#endif
+
+#ifndef O_NOTRANS
+# define O_NOTRANS 0
+#endif
+
+#ifndef O_RSYNC
+# define O_RSYNC 0
+#endif
+
+#ifndef O_SEARCH
+# define O_SEARCH O_RDONLY /* This is often close enough in older systems.  */
+#endif
+
+#ifndef O_SYNC
+# define O_SYNC 0
+#endif
+
+#ifndef O_TTY_INIT
+# define O_TTY_INIT 0
+#endif
+
+#if ~O_ACCMODE & (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH)
+# undef O_ACCMODE
+# define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR | O_EXEC | O_SEARCH)
+#endif
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in fcntl.h  */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+
+#if defined __BEOS__ || defined __HAIKU__
+  /* BeOS 5 and Haiku have O_BINARY and O_TEXT, but they have no effect.  */
+# undef O_BINARY
+# undef O_TEXT
+#endif
+
+#ifndef O_BINARY
+# define O_BINARY 0
+# define O_TEXT 0
+#endif
+
+/* Fix up the AT_* macros.  */
+
+/* Work around a bug in Solaris 9 and 10: AT_FDCWD is positive.  Its
+   value exceeds INT_MAX, so its use as an int doesn't conform to the
+   C standard, and GCC and Sun C complain in some cases.  If the bug
+   is present, undef AT_FDCWD here, so it can be redefined below.  */
+#if 0 < AT_FDCWD && AT_FDCWD == 0xffd19553
+# undef AT_FDCWD
+#endif
+
+/* Use the same bit pattern as Solaris 9, but with the proper
+   signedness.  The bit pattern is important, in case this actually is
+   Solaris with the above workaround.  */
+#ifndef AT_FDCWD
+# define AT_FDCWD (-3041965)
+#endif
+
+/* Use the same values as Solaris 9.  This shouldn't matter, but
+   there's no real reason to differ.  */
+#ifndef AT_SYMLINK_NOFOLLOW
+# define AT_SYMLINK_NOFOLLOW 4096
+#endif
+
+#ifndef AT_REMOVEDIR
+# define AT_REMOVEDIR 1
+#endif
+
+/* Solaris 9 lacks these two, so just pick unique values.  */
+#ifndef AT_SYMLINK_FOLLOW
+# define AT_SYMLINK_FOLLOW 2
+#endif
+
+#ifndef AT_EACCESS
+# define AT_EACCESS 4
+#endif
+
+
+#endif /* _GL_FCNTL_H */
+#endif /* _GL_FCNTL_H */
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/langinfo.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/langinfo.h
new file mode 100644
index 000000000..4c36a76d3
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/langinfo.h
@@ -0,0 +1,670 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for and wrapper around <langinfo.h>.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/*
+ * POSIX <langinfo.h> for platforms that lack it or have an incomplete one.
+ * <http://www.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html>
+ */
+
+#ifndef _GL_LANGINFO_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# include_next <langinfo.h>
+#endif
+
+#ifndef _GL_LANGINFO_H
+#define _GL_LANGINFO_H
+
+
+#if !1
+
+/* A platform that lacks <langinfo.h>.  */
+
+/* Assume that it also lacks <nl_types.h> and the nl_item type.  */
+# if !GNULIB_defined_nl_item
+typedef int nl_item;
+#  define GNULIB_defined_nl_item 1
+# endif
+
+/* nl_langinfo items of the LC_CTYPE category */
+# define CODESET     10000
+/* nl_langinfo items of the LC_NUMERIC category */
+# define RADIXCHAR   10001
+# define DECIMAL_POINT RADIXCHAR
+# define THOUSEP     10002
+# define THOUSANDS_SEP THOUSEP
+# define GROUPING    10114
+/* nl_langinfo items of the LC_TIME category */
+# define D_T_FMT     10003
+# define D_FMT       10004
+# define T_FMT       10005
+# define T_FMT_AMPM  10006
+# define AM_STR      10007
+# define PM_STR      10008
+# define DAY_1       10009
+# define DAY_2       (DAY_1 + 1)
+# define DAY_3       (DAY_1 + 2)
+# define DAY_4       (DAY_1 + 3)
+# define DAY_5       (DAY_1 + 4)
+# define DAY_6       (DAY_1 + 5)
+# define DAY_7       (DAY_1 + 6)
+# define ABDAY_1     10016
+# define ABDAY_2     (ABDAY_1 + 1)
+# define ABDAY_3     (ABDAY_1 + 2)
+# define ABDAY_4     (ABDAY_1 + 3)
+# define ABDAY_5     (ABDAY_1 + 4)
+# define ABDAY_6     (ABDAY_1 + 5)
+# define ABDAY_7     (ABDAY_1 + 6)
+# define MON_1       10023
+# define MON_2       (MON_1 + 1)
+# define MON_3       (MON_1 + 2)
+# define MON_4       (MON_1 + 3)
+# define MON_5       (MON_1 + 4)
+# define MON_6       (MON_1 + 5)
+# define MON_7       (MON_1 + 6)
+# define MON_8       (MON_1 + 7)
+# define MON_9       (MON_1 + 8)
+# define MON_10      (MON_1 + 9)
+# define MON_11      (MON_1 + 10)
+# define MON_12      (MON_1 + 11)
+# define ALTMON_1    10200
+# define ALTMON_2    (ALTMON_1 + 1)
+# define ALTMON_3    (ALTMON_1 + 2)
+# define ALTMON_4    (ALTMON_1 + 3)
+# define ALTMON_5    (ALTMON_1 + 4)
+# define ALTMON_6    (ALTMON_1 + 5)
+# define ALTMON_7    (ALTMON_1 + 6)
+# define ALTMON_8    (ALTMON_1 + 7)
+# define ALTMON_9    (ALTMON_1 + 8)
+# define ALTMON_10   (ALTMON_1 + 9)
+# define ALTMON_11   (ALTMON_1 + 10)
+# define ALTMON_12   (ALTMON_1 + 11)
+# define ABMON_1     10035
+# define ABMON_2     (ABMON_1 + 1)
+# define ABMON_3     (ABMON_1 + 2)
+# define ABMON_4     (ABMON_1 + 3)
+# define ABMON_5     (ABMON_1 + 4)
+# define ABMON_6     (ABMON_1 + 5)
+# define ABMON_7     (ABMON_1 + 6)
+# define ABMON_8     (ABMON_1 + 7)
+# define ABMON_9     (ABMON_1 + 8)
+# define ABMON_10    (ABMON_1 + 9)
+# define ABMON_11    (ABMON_1 + 10)
+# define ABMON_12    (ABMON_1 + 11)
+# define ERA         10047
+# define ERA_D_FMT   10048
+# define ERA_D_T_FMT 10049
+# define ERA_T_FMT   10050
+# define ALT_DIGITS  10051
+/* nl_langinfo items of the LC_MONETARY category */
+# define CRNCYSTR    10052
+# define CURRENCY_SYMBOL   CRNCYSTR
+# define INT_CURR_SYMBOL   10100
+# define MON_DECIMAL_POINT 10101
+# define MON_THOUSANDS_SEP 10102
+# define MON_GROUPING      10103
+# define POSITIVE_SIGN     10104
+# define NEGATIVE_SIGN     10105
+# define FRAC_DIGITS       10106
+# define INT_FRAC_DIGITS   10107
+# define P_CS_PRECEDES     10108
+# define N_CS_PRECEDES     10109
+# define P_SEP_BY_SPACE    10110
+# define N_SEP_BY_SPACE    10111
+# define P_SIGN_POSN       10112
+# define N_SIGN_POSN       10113
+/* nl_langinfo items of the LC_MESSAGES category */
+# define YESEXPR     10053
+# define NOEXPR      10054
+
+#else
+
+/* A platform that has <langinfo.h>.  */
+
+# if !1
+#  define CODESET     10000
+#  define GNULIB_defined_CODESET 1
+# endif
+
+# if !1
+#  define T_FMT_AMPM  10006
+#  define GNULIB_defined_T_FMT_AMPM 1
+# endif
+
+# if !1
+#  define ALTMON_1    10200
+#  define ALTMON_2    (ALTMON_1 + 1)
+#  define ALTMON_3    (ALTMON_1 + 2)
+#  define ALTMON_4    (ALTMON_1 + 3)
+#  define ALTMON_5    (ALTMON_1 + 4)
+#  define ALTMON_6    (ALTMON_1 + 5)
+#  define ALTMON_7    (ALTMON_1 + 6)
+#  define ALTMON_8    (ALTMON_1 + 7)
+#  define ALTMON_9    (ALTMON_1 + 8)
+#  define ALTMON_10   (ALTMON_1 + 9)
+#  define ALTMON_11   (ALTMON_1 + 10)
+#  define ALTMON_12   (ALTMON_1 + 11)
+#  define GNULIB_defined_ALTMON 1
+# endif
+
+# if !1
+#  define ERA         10047
+#  define ERA_D_FMT   10048
+#  define ERA_D_T_FMT 10049
+#  define ERA_T_FMT   10050
+#  define ALT_DIGITS  10051
+#  define GNULIB_defined_ERA 1
+# endif
+
+# if !1
+#  define YESEXPR     10053
+#  define NOEXPR      10054
+#  define GNULIB_defined_YESEXPR 1
+# endif
+
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Declare overridden functions.  */
+
+
+/* Return a piece of locale dependent information.
+   Note: The difference between nl_langinfo (CODESET) and locale_charset ()
+   is that the latter normalizes the encoding names to GNU conventions.  */
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef nl_langinfo
+#   define nl_langinfo rpl_nl_langinfo
+#  endif
+_GL_FUNCDECL_RPL (nl_langinfo, char *, (nl_item item));
+_GL_CXXALIAS_RPL (nl_langinfo, char *, (nl_item item));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (nl_langinfo, char *, (nl_item item));
+#  endif
+_GL_CXXALIAS_SYS (nl_langinfo, char *, (nl_item item));
+# endif
+_GL_CXXALIASWARN (nl_langinfo);
+#elif defined GNULIB_POSIXCHECK
+# undef nl_langinfo
+# if HAVE_RAW_DECL_NL_LANGINFO
+_GL_WARN_ON_USE (nl_langinfo, "nl_langinfo is not portable - "
+                 "use gnulib module nl_langinfo for portability");
+# endif
+#endif
+
+
+#endif /* _GL_LANGINFO_H */
+#endif /* _GL_LANGINFO_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/limits.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/limits.h
new file mode 100644
index 000000000..67785c851
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/limits.h
@@ -0,0 +1,105 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <limits.h>.
+
+   Copyright 2016-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_LIMITS_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <limits.h>
+
+#ifndef _GL_LIMITS_H
+#define _GL_LIMITS_H
+
+#ifndef LLONG_MIN
+# if defined LONG_LONG_MIN /* HP-UX 11.31 */
+#  define LLONG_MIN LONG_LONG_MIN
+# elif defined LONGLONG_MIN /* IRIX 6.5 */
+#  define LLONG_MIN LONGLONG_MIN
+# elif defined __GNUC__
+#  define LLONG_MIN (- __LONG_LONG_MAX__ - 1LL)
+# endif
+#endif
+#ifndef LLONG_MAX
+# if defined LONG_LONG_MAX /* HP-UX 11.31 */
+#  define LLONG_MAX LONG_LONG_MAX
+# elif defined LONGLONG_MAX /* IRIX 6.5 */
+#  define LLONG_MAX LONGLONG_MAX
+# elif defined __GNUC__
+#  define LLONG_MAX __LONG_LONG_MAX__
+# endif
+#endif
+#ifndef ULLONG_MAX
+# if defined ULONG_LONG_MAX /* HP-UX 11.31 */
+#  define ULLONG_MAX ULONG_LONG_MAX
+# elif defined ULONGLONG_MAX /* IRIX 6.5 */
+#  define ULLONG_MAX ULONGLONG_MAX
+# elif defined __GNUC__
+#  define ULLONG_MAX (__LONG_LONG_MAX__ * 2ULL + 1ULL)
+# endif
+#endif
+
+/* The number of usable bits in an unsigned or signed integer type
+   with minimum value MIN and maximum value MAX, as an int expression
+   suitable in #if.  Cover all known practical hosts.  This
+   implementation exploits the fact that MAX is 1 less than a power of
+   2, and merely counts the number of 1 bits in MAX; "COBn" means
+   "count the number of 1 bits in the low-order n bits").  */
+#define _GL_INTEGER_WIDTH(min, max) (((min) < 0) + _GL_COB128 (max))
+#define _GL_COB128(n) (_GL_COB64 ((n) >> 31 >> 31 >> 2) + _GL_COB64 (n))
+#define _GL_COB64(n) (_GL_COB32 ((n) >> 31 >> 1) + _GL_COB32 (n))
+#define _GL_COB32(n) (_GL_COB16 ((n) >> 16) + _GL_COB16 (n))
+#define _GL_COB16(n) (_GL_COB8 ((n) >> 8) + _GL_COB8 (n))
+#define _GL_COB8(n) (_GL_COB4 ((n) >> 4) + _GL_COB4 (n))
+#define _GL_COB4(n) (!!((n) & 8) + !!((n) & 4) + !!((n) & 2) + !!((n) & 1))
+
+#ifndef WORD_BIT
+/* Assume 'int' is 32 bits wide.  */
+# define WORD_BIT 32
+#endif
+#ifndef LONG_BIT
+/* Assume 'long' is 32 or 64 bits wide.  */
+# if LONG_MAX == INT_MAX
+#  define LONG_BIT 32
+# else
+#  define LONG_BIT 64
+# endif
+#endif
+
+/* Macros specified by ISO/IEC TS 18661-1:2014.  */
+
+#if (! defined ULLONG_WIDTH                                             \
+     && (defined _GNU_SOURCE || defined __STDC_WANT_IEC_60559_BFP_EXT__))
+# define CHAR_WIDTH _GL_INTEGER_WIDTH (CHAR_MIN, CHAR_MAX)
+# define SCHAR_WIDTH _GL_INTEGER_WIDTH (SCHAR_MIN, SCHAR_MAX)
+# define UCHAR_WIDTH _GL_INTEGER_WIDTH (0, UCHAR_MAX)
+# define SHRT_WIDTH _GL_INTEGER_WIDTH (SHRT_MIN, SHRT_MAX)
+# define USHRT_WIDTH _GL_INTEGER_WIDTH (0, USHRT_MAX)
+# define INT_WIDTH _GL_INTEGER_WIDTH (INT_MIN, INT_MAX)
+# define UINT_WIDTH _GL_INTEGER_WIDTH (0, UINT_MAX)
+# define LONG_WIDTH _GL_INTEGER_WIDTH (LONG_MIN, LONG_MAX)
+# define ULONG_WIDTH _GL_INTEGER_WIDTH (0, ULONG_MAX)
+# define LLONG_WIDTH _GL_INTEGER_WIDTH (LLONG_MIN, LLONG_MAX)
+# define ULLONG_WIDTH _GL_INTEGER_WIDTH (0, ULLONG_MAX)
+#endif /* !ULLONG_WIDTH && (_GNU_SOURCE || __STDC_WANT_IEC_60559_BFP_EXT__) */
+
+#endif /* _GL_LIMITS_H */
+#endif /* _GL_LIMITS_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/locale.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/locale.h
new file mode 100644
index 000000000..0f6d62cae
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/locale.h
@@ -0,0 +1,746 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A POSIX <locale.h>.
+   Copyright (C) 2007-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if (defined _WIN32 && !defined __CYGWIN__ && defined __need_locale_t) \
+    || defined _GL_ALREADY_INCLUDING_LOCALE_H
+
+/* Special invocation convention:
+   - Inside mingw header files,
+   - To handle Solaris header files (through Solaris 10) when combined
+     with gettext's libintl.h.  */
+
+#include_next <locale.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_LOCALE_H
+
+#define _GL_ALREADY_INCLUDING_LOCALE_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <locale.h>
+
+#undef _GL_ALREADY_INCLUDING_LOCALE_H
+
+#ifndef _GL_LOCALE_H
+#define _GL_LOCALE_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* Mac OS X 10.5 defines the locale_t type in <xlocale.h>.  */
+#if 0
+# include <xlocale.h>
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* The LC_MESSAGES locale category is specified in POSIX, but not in ISO C.
+   On systems that don't define it, use the same value as GNU libintl.  */
+#if !defined LC_MESSAGES
+# define LC_MESSAGES 1729
+#endif
+
+/* Bionic libc's 'struct lconv' is just a dummy.  */
+#if 0
+# define lconv rpl_lconv
+struct lconv
+{
+  /* All 'char *' are actually 'const char *'.  */
+
+  /* Members that depend on the LC_NUMERIC category of the locale.  See
+     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_04> */
+
+  /* Symbol used as decimal point.  */
+  char *decimal_point;
+  /* Symbol used to separate groups of digits to the left of the decimal
+     point.  */
+  char *thousands_sep;
+  /* Definition of the size of groups of digits to the left of the decimal
+     point.  */
+  char *grouping;
+
+  /* Members that depend on the LC_MONETARY category of the locale.  See
+     <http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_03> */
+
+  /* Symbol used as decimal point.  */
+  char *mon_decimal_point;
+  /* Symbol used to separate groups of digits to the left of the decimal
+     point.  */
+  char *mon_thousands_sep;
+  /* Definition of the size of groups of digits to the left of the decimal
+     point.  */
+  char *mon_grouping;
+  /* Sign used to indicate a value >= 0.  */
+  char *positive_sign;
+  /* Sign used to indicate a value < 0.  */
+  char *negative_sign;
+
+  /* For formatting local currency.  */
+  /* Currency symbol (3 characters) followed by separator (1 character).  */
+  char *currency_symbol;
+  /* Number of digits after the decimal point.  */
+  char frac_digits;
+  /* For values >= 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char p_cs_precedes;
+  /* For values >= 0: Position of the sign.  */
+  char p_sign_posn;
+  /* For values >= 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char p_sep_by_space;
+  /* For values < 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char n_cs_precedes;
+  /* For values < 0: Position of the sign.  */
+  char n_sign_posn;
+  /* For values < 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char n_sep_by_space;
+
+  /* For formatting international currency.  */
+  /* Currency symbol (3 characters) followed by separator (1 character).  */
+  char *int_curr_symbol;
+  /* Number of digits after the decimal point.  */
+  char int_frac_digits;
+  /* For values >= 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char int_p_cs_precedes;
+  /* For values >= 0: Position of the sign.  */
+  char int_p_sign_posn;
+  /* For values >= 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char int_p_sep_by_space;
+  /* For values < 0: 1 if the currency symbol precedes the number, 0 if it
+     comes after the number.  */
+  char int_n_cs_precedes;
+  /* For values < 0: Position of the sign.  */
+  char int_n_sign_posn;
+  /* For values < 0: Placement of spaces between currency symbol, sign, and
+     number.  */
+  char int_n_sep_by_space;
+};
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef localeconv
+#   define localeconv rpl_localeconv
+#  endif
+_GL_FUNCDECL_RPL (localeconv, struct lconv *, (void));
+_GL_CXXALIAS_RPL (localeconv, struct lconv *, (void));
+# else
+_GL_CXXALIAS_SYS (localeconv, struct lconv *, (void));
+# endif
+_GL_CXXALIASWARN (localeconv);
+#elif 0
+# undef localeconv
+# define localeconv localeconv_used_without_requesting_gnulib_module_localeconv
+#elif defined GNULIB_POSIXCHECK
+# undef localeconv
+# if HAVE_RAW_DECL_LOCALECONV
+_GL_WARN_ON_USE (localeconv,
+                 "localeconv returns too few information on some platforms - "
+                 "use gnulib module localeconv for portability");
+# endif
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setlocale
+#   define setlocale rpl_setlocale
+#   define GNULIB_defined_setlocale 1
+#  endif
+_GL_FUNCDECL_RPL (setlocale, char *, (int category, const char *locale));
+_GL_CXXALIAS_RPL (setlocale, char *, (int category, const char *locale));
+# else
+_GL_CXXALIAS_SYS (setlocale, char *, (int category, const char *locale));
+# endif
+_GL_CXXALIASWARN (setlocale);
+#elif defined GNULIB_POSIXCHECK
+# undef setlocale
+# if HAVE_RAW_DECL_SETLOCALE
+_GL_WARN_ON_USE (setlocale, "setlocale works differently on native Windows - "
+                 "use gnulib module setlocale for portability");
+# endif
+#endif
+
+#if /*@GNULIB_NEWLOCALE@ ||*/ (IN_AUGEAS_GNULIB_TESTS && 1)
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef newlocale
+#   define newlocale rpl_newlocale
+#   define GNULIB_defined_newlocale 1
+#  endif
+_GL_FUNCDECL_RPL (newlocale, locale_t,
+                  (int category_mask, const char *name, locale_t base)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (newlocale, locale_t,
+                  (int category_mask, const char *name, locale_t base));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (newlocale, locale_t,
+                  (int category_mask, const char *name, locale_t base));
+#  endif
+# endif
+# if 1
+_GL_CXXALIASWARN (newlocale);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef newlocale
+# if HAVE_RAW_DECL_NEWLOCALE
+_GL_WARN_ON_USE (newlocale, "newlocale is not portable");
+# endif
+#endif
+
+#if 0 || (IN_AUGEAS_GNULIB_TESTS && 1)
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef duplocale
+#   define duplocale rpl_duplocale
+#   define GNULIB_defined_duplocale 1
+#  endif
+_GL_FUNCDECL_RPL (duplocale, locale_t, (locale_t locale) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (duplocale, locale_t, (locale_t locale));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (duplocale, locale_t, (locale_t locale));
+#  endif
+# endif
+# if 1
+_GL_CXXALIASWARN (duplocale);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef duplocale
+# if HAVE_RAW_DECL_DUPLOCALE
+_GL_WARN_ON_USE (duplocale, "duplocale is buggy on some glibc systems - "
+                 "use gnulib module duplocale for portability");
+# endif
+#endif
+
+#if /*@GNULIB_FREELOCALE@ ||*/ (IN_AUGEAS_GNULIB_TESTS && 1)
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef freelocale
+#   define freelocale rpl_freelocale
+#   define GNULIB_defined_freelocale 1
+#  endif
+_GL_FUNCDECL_RPL (freelocale, void, (locale_t locale) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (freelocale, void, (locale_t locale));
+# else
+#  if 1
+_GL_CXXALIAS_SYS (freelocale, void, (locale_t locale));
+#  endif
+# endif
+# if 1
+_GL_CXXALIASWARN (freelocale);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef freelocale
+# if HAVE_RAW_DECL_FREELOCALE
+_GL_WARN_ON_USE (freelocale, "freelocale is not portable");
+# endif
+#endif
+
+#endif /* _GL_LOCALE_H */
+#endif /* _GL_LOCALE_H */
+#endif /* !(__need_locale_t || _GL_ALREADY_INCLUDING_LOCALE_H) */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/selinux/context.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/selinux/context.h
new file mode 100644
index 000000000..db1f9d2fc
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/selinux/context.h
@@ -0,0 +1,83 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+#ifndef SELINUX_CONTEXT_H
+# define SELINUX_CONTEXT_H
+
+# include <errno.h>
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef SE_CONTEXT_INLINE
+# define SE_CONTEXT_INLINE _GL_INLINE
+#endif
+
+/* The definition of _GL_UNUSED_PARAMETER is copied here.  */
+/* A C macro for declaring that specific function parameters are not used.
+   Copyright (C) 2008-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_UNUSED_PARAMETER is a marker that can be appended to function parameter
+   declarations for parameters that are not used.  This helps to reduce
+   warnings, such as from GCC -Wunused-parameter.  The syntax is as follows:
+       type param _GL_UNUSED_PARAMETER
+   or more generally
+       param_decl _GL_UNUSED_PARAMETER
+   For example:
+       int param _GL_UNUSED_PARAMETER
+       int *(*param)(void) _GL_UNUSED_PARAMETER
+   Other possible, but obscure and discouraged syntaxes:
+       int _GL_UNUSED_PARAMETER *(*param)(void)
+       _GL_UNUSED_PARAMETER int *(*param)(void)
+ */
+#ifndef _GL_UNUSED_PARAMETER
+# if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+#  define _GL_UNUSED_PARAMETER __attribute__ ((__unused__))
+# else
+#  define _GL_UNUSED_PARAMETER
+# endif
+#endif
+
+typedef int context_t;
+SE_CONTEXT_INLINE context_t context_new (char const *s _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return 0; }
+SE_CONTEXT_INLINE char *context_str (context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE void context_free (context_t c _GL_UNUSED_PARAMETER) {}
+
+SE_CONTEXT_INLINE int context_user_set (context_t sc _GL_UNUSED_PARAMETER,
+                                        char const *s _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE int context_role_set (context_t sc _GL_UNUSED_PARAMETER,
+                                        char const *s _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE int context_range_set (context_t sc _GL_UNUSED_PARAMETER,
+                                         char const *s _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE int context_type_set (context_t sc _GL_UNUSED_PARAMETER,
+                                        char const *s _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_CONTEXT_INLINE char *context_type_get (context_t sc _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE char *context_range_get (context_t sc _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE char *context_role_get (context_t sc _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return (void *) 0; }
+SE_CONTEXT_INLINE char *context_user_get (context_t sc _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return (void *) 0; }
+
+_GL_INLINE_HEADER_END
+
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/selinux/selinux.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/selinux/selinux.h
new file mode 100644
index 000000000..c76910e60
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/selinux/selinux.h
@@ -0,0 +1,156 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Replacement <selinux/selinux.h> for platforms that lack it.
+   Copyright (C) 2008-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if HAVE_SELINUX_SELINUX_H
+
+#include_next 
+
+#else
+# if !defined _GL_SELINUX_SELINUX_H
+#  define _GL_SELINUX_SELINUX_H
+
+#  include <sys/types.h>
+#  include <errno.h>
+
+#  ifndef _GL_INLINE_HEADER_BEGIN
+    #error "Please include config.h first."
+#  endif
+_GL_INLINE_HEADER_BEGIN
+#  ifndef SE_SELINUX_INLINE
+#   define SE_SELINUX_INLINE _GL_INLINE
+#  endif
+
+/* The definition of _GL_UNUSED_PARAMETER is copied here.  */
+/* A C macro for declaring that specific function parameters are not used.
+   Copyright (C) 2008-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_UNUSED_PARAMETER is a marker that can be appended to function parameter
+   declarations for parameters that are not used.  This helps to reduce
+   warnings, such as from GCC -Wunused-parameter.  The syntax is as follows:
+       type param _GL_UNUSED_PARAMETER
+   or more generally
+       param_decl _GL_UNUSED_PARAMETER
+   For example:
+       int param _GL_UNUSED_PARAMETER
+       int *(*param)(void) _GL_UNUSED_PARAMETER
+   Other possible, but obscure and discouraged syntaxes:
+       int _GL_UNUSED_PARAMETER *(*param)(void)
+       _GL_UNUSED_PARAMETER int *(*param)(void)
+ */
+#ifndef _GL_UNUSED_PARAMETER
+# if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+#  define _GL_UNUSED_PARAMETER __attribute__ ((__unused__))
+# else
+#  define _GL_UNUSED_PARAMETER
+# endif
+#endif
+
+#  if !GNULIB_defined_security_types
+
+typedef unsigned short security_class_t;
+typedef char *security_context_t;
+#   define is_selinux_enabled() 0
+
+SE_SELINUX_INLINE int
+getcon (security_context_t *con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE void
+freecon (security_context_t con _GL_UNUSED_PARAMETER) {}
+
+SE_SELINUX_INLINE int
+getfscreatecon (security_context_t *con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+setfscreatecon (security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+matchpathcon (char const *file _GL_UNUSED_PARAMETER,
+              mode_t m _GL_UNUSED_PARAMETER,
+  security_context_t *con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+getfilecon (char const *file _GL_UNUSED_PARAMETER,
+            security_context_t *con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+lgetfilecon (char const *file _GL_UNUSED_PARAMETER,
+             security_context_t *con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+fgetfilecon (int fd, security_context_t *con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+setfilecon (char const *file _GL_UNUSED_PARAMETER,
+            security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+lsetfilecon (char const *file _GL_UNUSED_PARAMETER,
+             security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+fsetfilecon (int fd _GL_UNUSED_PARAMETER,
+             security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+
+SE_SELINUX_INLINE int
+security_check_context (security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+security_check_context_raw (security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+setexeccon (security_context_t con _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE int
+security_compute_create (security_context_t scon _GL_UNUSED_PARAMETER,
+                         security_context_t tcon _GL_UNUSED_PARAMETER,
+                         security_class_t tclass _GL_UNUSED_PARAMETER,
+                         security_context_t *newcon _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+SE_SELINUX_INLINE security_class_t
+string_to_security_class (char const *name)
+  { errno = ENOTSUP; return 0; }
+SE_SELINUX_INLINE int
+matchpathcon_init_prefix (char const *path _GL_UNUSED_PARAMETER,
+                          char const *prefix _GL_UNUSED_PARAMETER)
+  { errno = ENOTSUP; return -1; }
+
+#   define GNULIB_defined_security_types 1
+#  endif
+
+_GL_INLINE_HEADER_END
+
+# endif
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/stdio.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/stdio.h
new file mode 100644
index 000000000..e4b08b776
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/stdio.h
@@ -0,0 +1,1858 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <stdio.h>.
+
+   Copyright (C) 2004, 2007-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if defined __need_FILE || defined __need___FILE || defined _GL_ALREADY_INCLUDING_STDIO_H
+/* Special invocation convention:
+   - Inside glibc header files.
+   - On OSF/1 5.1 we have a sequence of nested includes
+     <stdio.h> -> <getopt.h> -> <ctype.h> -> <sys/localedef.h> ->
+     <sys/lc_core.h> -> <nl_types.h> -> <mesg.h> -> <stdio.h>.
+     In this situation, the functions are not yet declared, therefore we cannot
+     provide the C++ aliases.  */
+
+#include_next <stdio.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDIO_H
+
+#define _GL_ALREADY_INCLUDING_STDIO_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <stdio.h>
+
+#undef _GL_ALREADY_INCLUDING_STDIO_H
+
+#ifndef _GL_STDIO_H
+#define _GL_STDIO_H
+
+/* Get va_list.  Needed on many systems, including glibc 2.8.  */
+#include <stdarg.h>
+
+#include <stddef.h>
+
+/* Get off_t and ssize_t.  Needed on many systems, including glibc 2.8
+   and eglibc 2.11.2.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The __-protected variants of the attributes 'format' and 'printf' are
+   accepted by gcc versions 2.6.4 (effectively 2.7) and later.
+   We enable _GL_ATTRIBUTE_FORMAT only if these are supported too, because
+   gnulib and libintl do '#define printf __printf__' when they override
+   the 'printf' function.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)
+# define _GL_ATTRIBUTE_FORMAT(spec) __attribute__ ((__format__ spec))
+#else
+# define _GL_ATTRIBUTE_FORMAT(spec) /* empty */
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT_PRINTF
+   indicates to GCC that the function takes a format string and arguments,
+   where the format string directives are the ones standardized by ISO C99
+   and POSIX.  */
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+# define _GL_ATTRIBUTE_FORMAT_PRINTF(formatstring_parameter, first_argument) \
+   _GL_ATTRIBUTE_FORMAT ((__gnu_printf__, formatstring_parameter, first_argument))
+#else
+# define _GL_ATTRIBUTE_FORMAT_PRINTF(formatstring_parameter, first_argument) \
+   _GL_ATTRIBUTE_FORMAT ((__printf__, formatstring_parameter, first_argument))
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM is like _GL_ATTRIBUTE_FORMAT_PRINTF,
+   except that it indicates to GCC that the supported format string directives
+   are the ones of the system printf(), rather than the ones standardized by
+   ISO C99 and POSIX.  */
+#if GNULIB_PRINTF_ATTRIBUTE_FLAVOR_GNU
+# define _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM(formatstring_parameter, first_argument) \
+  _GL_ATTRIBUTE_FORMAT_PRINTF (formatstring_parameter, first_argument)
+#else
+# define _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM(formatstring_parameter, first_argument) \
+  _GL_ATTRIBUTE_FORMAT ((__printf__, formatstring_parameter, first_argument))
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT_SCANF
+   indicates to GCC that the function takes a format string and arguments,
+   where the format string directives are the ones standardized by ISO C99
+   and POSIX.  */
+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4)
+# define _GL_ATTRIBUTE_FORMAT_SCANF(formatstring_parameter, first_argument) \
+   _GL_ATTRIBUTE_FORMAT ((__gnu_scanf__, formatstring_parameter, first_argument))
+#else
+# define _GL_ATTRIBUTE_FORMAT_SCANF(formatstring_parameter, first_argument) \
+   _GL_ATTRIBUTE_FORMAT ((__scanf__, formatstring_parameter, first_argument))
+#endif
+
+/* _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM is like _GL_ATTRIBUTE_FORMAT_SCANF,
+   except that it indicates to GCC that the supported format string directives
+   are the ones of the system scanf(), rather than the ones standardized by
+   ISO C99 and POSIX.  */
+#define _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM(formatstring_parameter, first_argument) \
+  _GL_ATTRIBUTE_FORMAT ((__scanf__, formatstring_parameter, first_argument))
+
+/* Solaris 10 and NetBSD 7.0 declare renameat in <unistd.h>, not in <stdio.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && (defined __sun || defined __NetBSD__) \
+    && ! defined __GLIBC__
+# include <unistd.h>
+#endif
+
+/* Android 4.3 declares renameat in <sys/stat.h>, not in <stdio.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && defined __ANDROID__ \
+    && ! defined __GLIBC__
+# include <sys/stat.h>
+#endif
+
+/* MSVC declares 'perror' in <stdlib.h>, not in <stdio.h>.  We must include
+   it before we  #define perror rpl_perror.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (IN_AUGEAS_GNULIB_TESTS || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__) \
+    && ! defined __GLIBC__
+# include <stdlib.h>
+#endif
+
+/* MSVC declares 'remove' in <io.h>, not in <stdio.h>.  We must include
+   it before we  #define remove rpl_remove.  */
+/* MSVC declares 'rename' in <io.h>, not in <stdio.h>.  We must include
+   it before we  #define rename rpl_rename.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || 0 || defined GNULIB_POSIXCHECK) \
+    && (defined _WIN32 && ! defined __CYGWIN__) \
+    && ! defined __GLIBC__
+# include <io.h>
+#endif
+
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Macros for stringification.  */
+#define _GL_STDIO_STRINGIZE(token) #token
+#define _GL_STDIO_MACROEXPAND_AND_STRINGIZE(token) _GL_STDIO_STRINGIZE(token)
+
+/* When also using extern inline, suppress the use of static inline in
+   standard headers of problematic Apple configurations, as Libc at
+   least through Libc-825.26 (2013-04-09) mishandles it; see, e.g.,
+   <https://lists.gnu.org/r/bug-gnulib/2012-12/msg00023.html>.
+   Perhaps Apple will fix this some day.  */
+#if (defined _GL_EXTERN_INLINE_IN_USE && defined __APPLE__ \
+     && defined __GNUC__ && defined __STDC__)
+# undef putc_unlocked
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dprintf rpl_dprintf
+#  endif
+_GL_FUNCDECL_RPL (dprintf, int, (int fd, const char *format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                                _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (dprintf, int, (int fd, const char *format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (dprintf, int, (int fd, const char *format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                                _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (dprintf, int, (int fd, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (dprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef dprintf
+# if HAVE_RAW_DECL_DPRINTF
+_GL_WARN_ON_USE (dprintf, "dprintf is unportable - "
+                 "use gnulib module dprintf for portability");
+# endif
+#endif
+
+#if 0
+/* Close STREAM and its underlying file descriptor.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fclose rpl_fclose
+#  endif
+_GL_FUNCDECL_RPL (fclose, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fclose, int, (FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fclose, int, (FILE *stream));
+# endif
+_GL_CXXALIASWARN (fclose);
+#elif defined GNULIB_POSIXCHECK
+# undef fclose
+/* Assume fclose is always declared.  */
+_GL_WARN_ON_USE (fclose, "fclose is not always POSIX compliant - "
+                 "use gnulib module fclose for portable POSIX compliance");
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fdopen
+#   define fdopen rpl_fdopen
+#  endif
+_GL_FUNCDECL_RPL (fdopen, FILE *, (int fd, const char *mode)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fdopen, FILE *, (int fd, const char *mode));
+# else
+_GL_CXXALIAS_SYS (fdopen, FILE *, (int fd, const char *mode));
+# endif
+_GL_CXXALIASWARN (fdopen);
+#elif defined GNULIB_POSIXCHECK
+# undef fdopen
+/* Assume fdopen is always declared.  */
+_GL_WARN_ON_USE (fdopen, "fdopen on native Windows platforms is not POSIX compliant - "
+                 "use gnulib module fdopen for portability");
+#endif
+
+#if 0
+/* Flush all pending data on STREAM according to POSIX rules.  Both
+   output and seekable input streams are supported.
+   Note! LOSS OF DATA can occur if fflush is applied on an input stream
+   that is _not_seekable_ or on an update stream that is _not_seekable_
+   and in which the most recent operation was input.  Seekability can
+   be tested with lseek(fileno(fp),0,SEEK_CUR).  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fflush rpl_fflush
+#  endif
+_GL_FUNCDECL_RPL (fflush, int, (FILE *gl_stream));
+_GL_CXXALIAS_RPL (fflush, int, (FILE *gl_stream));
+# else
+_GL_CXXALIAS_SYS (fflush, int, (FILE *gl_stream));
+# endif
+_GL_CXXALIASWARN (fflush);
+#elif defined GNULIB_POSIXCHECK
+# undef fflush
+/* Assume fflush is always declared.  */
+_GL_WARN_ON_USE (fflush, "fflush is not always POSIX compliant - "
+                 "use gnulib module fflush for portable POSIX compliance");
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fgetc
+#   define fgetc rpl_fgetc
+#  endif
+_GL_FUNCDECL_RPL (fgetc, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fgetc, int, (FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fgetc, int, (FILE *stream));
+# endif
+_GL_CXXALIASWARN (fgetc);
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fgets
+#   define fgets rpl_fgets
+#  endif
+_GL_FUNCDECL_RPL (fgets, char *, (char *s, int n, FILE *stream)
+                                 _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (fgets, char *, (char *s, int n, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fgets, char *, (char *s, int n, FILE *stream));
+# endif
+_GL_CXXALIASWARN (fgets);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fopen
+#   define fopen rpl_fopen
+#  endif
+_GL_FUNCDECL_RPL (fopen, FILE *, (const char *filename, const char *mode)
+                                 _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (fopen, FILE *, (const char *filename, const char *mode));
+# else
+_GL_CXXALIAS_SYS (fopen, FILE *, (const char *filename, const char *mode));
+# endif
+_GL_CXXALIASWARN (fopen);
+#elif defined GNULIB_POSIXCHECK
+# undef fopen
+/* Assume fopen is always declared.  */
+_GL_WARN_ON_USE (fopen, "fopen on native Windows platforms is not POSIX compliant - "
+                 "use gnulib module fopen for portability");
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fprintf rpl_fprintf
+#  endif
+#  define GNULIB_overrides_fprintf 1
+#  if 0 || 0
+_GL_FUNCDECL_RPL (fprintf, int, (FILE *fp, const char *format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                                _GL_ARG_NONNULL ((1, 2)));
+#  else
+_GL_FUNCDECL_RPL (fprintf, int, (FILE *fp, const char *format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (2, 3)
+                                _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_RPL (fprintf, int, (FILE *fp, const char *format, ...));
+# else
+_GL_CXXALIAS_SYS (fprintf, int, (FILE *fp, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (fprintf);
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_fprintf
+#  undef fprintf
+# endif
+/* Assume fprintf is always declared.  */
+_GL_WARN_ON_USE (fprintf, "fprintf is not always POSIX compliant - "
+                 "use gnulib module fprintf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 0
+/* Discard all pending buffered I/O data on STREAM.
+   STREAM must not be wide-character oriented.
+   When discarding pending output, the file position is set back to where it
+   was before the write calls.  When discarding pending input, the file
+   position is advanced to match the end of the previously read input.
+   Return 0 if successful.  Upon error, return -1 and set errno.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define fpurge rpl_fpurge
+#  endif
+_GL_FUNCDECL_RPL (fpurge, int, (FILE *gl_stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fpurge, int, (FILE *gl_stream));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fpurge, int, (FILE *gl_stream) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (fpurge, int, (FILE *gl_stream));
+# endif
+_GL_CXXALIASWARN (fpurge);
+#elif defined GNULIB_POSIXCHECK
+# undef fpurge
+# if HAVE_RAW_DECL_FPURGE
+_GL_WARN_ON_USE (fpurge, "fpurge is not always present - "
+                 "use gnulib module fpurge for portability");
+# endif
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fputc
+#   define fputc rpl_fputc
+#  endif
+_GL_FUNCDECL_RPL (fputc, int, (int c, FILE *stream) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fputc, int, (int c, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fputc, int, (int c, FILE *stream));
+# endif
+_GL_CXXALIASWARN (fputc);
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fputs
+#   define fputs rpl_fputs
+#  endif
+_GL_FUNCDECL_RPL (fputs, int, (const char *string, FILE *stream)
+                              _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (fputs, int, (const char *string, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fputs, int, (const char *string, FILE *stream));
+# endif
+_GL_CXXALIASWARN (fputs);
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fread
+#   define fread rpl_fread
+#  endif
+_GL_FUNCDECL_RPL (fread, size_t, (void *ptr, size_t s, size_t n, FILE *stream)
+                                 _GL_ARG_NONNULL ((4)));
+_GL_CXXALIAS_RPL (fread, size_t, (void *ptr, size_t s, size_t n, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fread, size_t, (void *ptr, size_t s, size_t n, FILE *stream));
+# endif
+_GL_CXXALIASWARN (fread);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef freopen
+#   define freopen rpl_freopen
+#  endif
+_GL_FUNCDECL_RPL (freopen, FILE *,
+                  (const char *filename, const char *mode, FILE *stream)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (freopen, FILE *,
+                  (const char *filename, const char *mode, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (freopen, FILE *,
+                  (const char *filename, const char *mode, FILE *stream));
+# endif
+_GL_CXXALIASWARN (freopen);
+#elif defined GNULIB_POSIXCHECK
+# undef freopen
+/* Assume freopen is always declared.  */
+_GL_WARN_ON_USE (freopen,
+                 "freopen on native Windows platforms is not POSIX compliant - "
+                 "use gnulib module freopen for portability");
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fscanf
+#   define fscanf rpl_fscanf
+#  endif
+_GL_FUNCDECL_RPL (fscanf, int, (FILE *stream, const char *format, ...)
+                               _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (2, 3)
+                               _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (fscanf, int, (FILE *stream, const char *format, ...));
+# else
+_GL_CXXALIAS_SYS (fscanf, int, (FILE *stream, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (fscanf);
+#endif
+
+
+/* Set up the following warnings, based on which modules are in use.
+   GNU Coding Standards discourage the use of fseek, since it imposes
+   an arbitrary limitation on some 32-bit hosts.  Remember that the
+   fseek module depends on the fseeko module, so we only have three
+   cases to consider:
+
+   1. The developer is not using either module.  Issue a warning under
+   GNULIB_POSIXCHECK for both functions, to remind them that both
+   functions have bugs on some systems.  _GL_NO_LARGE_FILES has no
+   impact on this warning.
+
+   2. The developer is using both modules.  They may be unaware of the
+   arbitrary limitations of fseek, so issue a warning under
+   GNULIB_POSIXCHECK.  On the other hand, they may be using both
+   modules intentionally, so the developer can define
+   _GL_NO_LARGE_FILES in the compilation units where the use of fseek
+   is safe, to silence the warning.
+
+   3. The developer is using the fseeko module, but not fseek.  Gnulib
+   guarantees that fseek will still work around platform bugs in that
+   case, but we presume that the developer is aware of the pitfalls of
+   fseek and was trying to avoid it, so issue a warning even when
+   GNULIB_POSIXCHECK is undefined.  Again, _GL_NO_LARGE_FILES can be
+   defined to silence the warning in particular compilation units.
+   In C++ compilations with GNULIB_NAMESPACE, in order to avoid that
+   fseek gets defined as a macro, it is recommended that the developer
+   uses the fseek module, even if he is not calling the fseek function.
+
+   Most gnulib clients that perform stream operations should fall into
+   category 3.  */
+
+#if 0
+# if defined GNULIB_POSIXCHECK && !defined _GL_NO_LARGE_FILES
+#  define _GL_FSEEK_WARN /* Category 2, above.  */
+#  undef fseek
+# endif
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fseek
+#   define fseek rpl_fseek
+#  endif
+_GL_FUNCDECL_RPL (fseek, int, (FILE *fp, long offset, int whence)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fseek, int, (FILE *fp, long offset, int whence));
+# else
+_GL_CXXALIAS_SYS (fseek, int, (FILE *fp, long offset, int whence));
+# endif
+_GL_CXXALIASWARN (fseek);
+#endif
+
+#if 0
+# if !0 && !defined _GL_NO_LARGE_FILES
+#  define _GL_FSEEK_WARN /* Category 3, above.  */
+#  undef fseek
+# endif
+# if 0
+/* Provide an fseeko function that is aware of a preceding fflush(), and which
+   detects pipes.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fseeko
+#   define fseeko rpl_fseeko
+#  endif
+_GL_FUNCDECL_RPL (fseeko, int, (FILE *fp, off_t offset, int whence)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (fseeko, int, (FILE *fp, off_t offset, int whence));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (fseeko, int, (FILE *fp, off_t offset, int whence)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (fseeko, int, (FILE *fp, off_t offset, int whence));
+# endif
+_GL_CXXALIASWARN (fseeko);
+#elif defined GNULIB_POSIXCHECK
+# define _GL_FSEEK_WARN /* Category 1, above.  */
+# undef fseek
+# undef fseeko
+# if HAVE_RAW_DECL_FSEEKO
+_GL_WARN_ON_USE (fseeko, "fseeko is unportable - "
+                 "use gnulib module fseeko for portability");
+# endif
+#endif
+
+#ifdef _GL_FSEEK_WARN
+# undef _GL_FSEEK_WARN
+/* Here, either fseek is undefined (but C89 guarantees that it is
+   declared), or it is defined as rpl_fseek (declared above).  */
+_GL_WARN_ON_USE (fseek, "fseek cannot handle files larger than 4 GB "
+                 "on 32-bit platforms - "
+                 "use fseeko function for handling of large files");
+#endif
+
+
+/* ftell, ftello.  See the comments on fseek/fseeko.  */
+
+#if 0
+# if defined GNULIB_POSIXCHECK && !defined _GL_NO_LARGE_FILES
+#  define _GL_FTELL_WARN /* Category 2, above.  */
+#  undef ftell
+# endif
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ftell
+#   define ftell rpl_ftell
+#  endif
+_GL_FUNCDECL_RPL (ftell, long, (FILE *fp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ftell, long, (FILE *fp));
+# else
+_GL_CXXALIAS_SYS (ftell, long, (FILE *fp));
+# endif
+_GL_CXXALIASWARN (ftell);
+#endif
+
+#if 0
+# if !0 && !defined _GL_NO_LARGE_FILES
+#  define _GL_FTELL_WARN /* Category 3, above.  */
+#  undef ftell
+# endif
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ftello
+#   define ftello rpl_ftello
+#  endif
+_GL_FUNCDECL_RPL (ftello, off_t, (FILE *fp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ftello, off_t, (FILE *fp));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (ftello, off_t, (FILE *fp) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (ftello, off_t, (FILE *fp));
+# endif
+_GL_CXXALIASWARN (ftello);
+#elif defined GNULIB_POSIXCHECK
+# define _GL_FTELL_WARN /* Category 1, above.  */
+# undef ftell
+# undef ftello
+# if HAVE_RAW_DECL_FTELLO
+_GL_WARN_ON_USE (ftello, "ftello is unportable - "
+                 "use gnulib module ftello for portability");
+# endif
+#endif
+
+#ifdef _GL_FTELL_WARN
+# undef _GL_FTELL_WARN
+/* Here, either ftell is undefined (but C89 guarantees that it is
+   declared), or it is defined as rpl_ftell (declared above).  */
+_GL_WARN_ON_USE (ftell, "ftell cannot handle files larger than 4 GB "
+                 "on 32-bit platforms - "
+                 "use ftello function for handling of large files");
+#endif
+
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fwrite
+#   define fwrite rpl_fwrite
+#  endif
+_GL_FUNCDECL_RPL (fwrite, size_t,
+                  (const void *ptr, size_t s, size_t n, FILE *stream)
+                  _GL_ARG_NONNULL ((1, 4)));
+_GL_CXXALIAS_RPL (fwrite, size_t,
+                  (const void *ptr, size_t s, size_t n, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (fwrite, size_t,
+                  (const void *ptr, size_t s, size_t n, FILE *stream));
+
+/* Work around bug 11959 when fortifying glibc 2.4 through 2.15
+   <https://sourceware.org/bugzilla/show_bug.cgi?id=11959>,
+   which sometimes causes an unwanted diagnostic for fwrite calls.
+   This affects only function declaration attributes under certain
+   versions of gcc and clang, and is not needed for C++.  */
+#  if (0 < __USE_FORTIFY_LEVEL                                          \
+       && __GLIBC__ == 2 && 4 <= __GLIBC_MINOR__ && __GLIBC_MINOR__ <= 15 \
+       && 3 < __GNUC__ + (4 <= __GNUC_MINOR__)                          \
+       && !defined __cplusplus)
+#   undef fwrite
+#   undef fwrite_unlocked
+extern size_t __REDIRECT (rpl_fwrite,
+                          (const void *__restrict, size_t, size_t,
+                           FILE *__restrict),
+                          fwrite);
+extern size_t __REDIRECT (rpl_fwrite_unlocked,
+                          (const void *__restrict, size_t, size_t,
+                           FILE *__restrict),
+                          fwrite_unlocked);
+#   define fwrite rpl_fwrite
+#   define fwrite_unlocked rpl_fwrite_unlocked
+#  endif
+# endif
+_GL_CXXALIASWARN (fwrite);
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getc
+#   define getc rpl_fgetc
+#  endif
+_GL_FUNCDECL_RPL (fgetc, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL_1 (getc, rpl_fgetc, int, (FILE *stream));
+# else
+_GL_CXXALIAS_SYS (getc, int, (FILE *stream));
+# endif
+_GL_CXXALIASWARN (getc);
+#endif
+
+#if 1
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getchar
+#   define getchar rpl_getchar
+#  endif
+_GL_FUNCDECL_RPL (getchar, int, (void));
+_GL_CXXALIAS_RPL (getchar, int, (void));
+# else
+_GL_CXXALIAS_SYS (getchar, int, (void));
+# endif
+_GL_CXXALIASWARN (getchar);
+#endif
+
+#if 1
+/* Read input, up to (and including) the next occurrence of DELIMITER, from
+   STREAM, store it in *LINEPTR (and NUL-terminate it).
+   *LINEPTR is a pointer returned from malloc (or NULL), pointing to *LINESIZE
+   bytes of space.  It is realloc'd as necessary.
+   Return the number of bytes read and stored at *LINEPTR (not including the
+   NUL terminator), or -1 on error or EOF.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getdelim
+#   define getdelim rpl_getdelim
+#  endif
+_GL_FUNCDECL_RPL (getdelim, ssize_t,
+                  (char **lineptr, size_t *linesize, int delimiter,
+                   FILE *stream)
+                  _GL_ARG_NONNULL ((1, 2, 4)));
+_GL_CXXALIAS_RPL (getdelim, ssize_t,
+                  (char **lineptr, size_t *linesize, int delimiter,
+                   FILE *stream));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getdelim, ssize_t,
+                  (char **lineptr, size_t *linesize, int delimiter,
+                   FILE *stream)
+                  _GL_ARG_NONNULL ((1, 2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (getdelim, ssize_t,
+                  (char **lineptr, size_t *linesize, int delimiter,
+                   FILE *stream));
+# endif
+_GL_CXXALIASWARN (getdelim);
+#elif defined GNULIB_POSIXCHECK
+# undef getdelim
+# if HAVE_RAW_DECL_GETDELIM
+_GL_WARN_ON_USE (getdelim, "getdelim is unportable - "
+                 "use gnulib module getdelim for portability");
+# endif
+#endif
+
+#if 1
+/* Read a line, up to (and including) the next newline, from STREAM, store it
+   in *LINEPTR (and NUL-terminate it).
+   *LINEPTR is a pointer returned from malloc (or NULL), pointing to *LINESIZE
+   bytes of space.  It is realloc'd as necessary.
+   Return the number of bytes read and stored at *LINEPTR (not including the
+   NUL terminator), or -1 on error or EOF.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getline
+#   define getline rpl_getline
+#  endif
+_GL_FUNCDECL_RPL (getline, ssize_t,
+                  (char **lineptr, size_t *linesize, FILE *stream)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+_GL_CXXALIAS_RPL (getline, ssize_t,
+                  (char **lineptr, size_t *linesize, FILE *stream));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getline, ssize_t,
+                  (char **lineptr, size_t *linesize, FILE *stream)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (getline, ssize_t,
+                  (char **lineptr, size_t *linesize, FILE *stream));
+# endif
+# if 1
+_GL_CXXALIASWARN (getline);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getline
+# if HAVE_RAW_DECL_GETLINE
+_GL_WARN_ON_USE (getline, "getline is unportable - "
+                 "use gnulib module getline for portability");
+# endif
+#endif
+
+/* It is very rare that the developer ever has full control of stdin,
+   so any use of gets warrants an unconditional warning; besides, C11
+   removed it.  */
+#undef gets
+#if HAVE_RAW_DECL_GETS && !defined __cplusplus
+_GL_WARN_ON_USE (gets, "gets is a security hole - use fgets instead");
+#endif
+
+#if 0 || 0
+struct obstack;
+/* Grow an obstack with formatted output.  Return the number of
+   bytes added to OBS.  No trailing nul byte is added, and the
+   object should be closed with obstack_finish before use.  Upon
+   memory allocation error, call obstack_alloc_failed_handler.  Upon
+   other error, return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define obstack_printf rpl_obstack_printf
+#  endif
+_GL_FUNCDECL_RPL (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (obstack_printf, int,
+                  (struct obstack *obs, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (obstack_printf);
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define obstack_vprintf rpl_obstack_vprintf
+#  endif
+_GL_FUNCDECL_RPL (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (obstack_vprintf, int,
+                  (struct obstack *obs, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (obstack_vprintf);
+#endif
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (pclose, int, (FILE *stream) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (pclose, int, (FILE *stream));
+_GL_CXXALIASWARN (pclose);
+#elif defined GNULIB_POSIXCHECK
+# undef pclose
+# if HAVE_RAW_DECL_PCLOSE
+_GL_WARN_ON_USE (pclose, "pclose is unportable - "
+                 "use gnulib module pclose for more portability");
+# endif
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Print a message to standard error, describing the value of ERRNO,
+   (if STRING is not NULL and not empty) prefixed with STRING and ": ",
+   and terminated with a newline.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define perror rpl_perror
+#  endif
+_GL_FUNCDECL_RPL (perror, void, (const char *string));
+_GL_CXXALIAS_RPL (perror, void, (const char *string));
+# else
+_GL_CXXALIAS_SYS (perror, void, (const char *string));
+# endif
+_GL_CXXALIASWARN (perror);
+#elif defined GNULIB_POSIXCHECK
+# undef perror
+/* Assume perror is always declared.  */
+_GL_WARN_ON_USE (perror, "perror is not always POSIX compliant - "
+                 "use gnulib module perror for portability");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef popen
+#   define popen rpl_popen
+#  endif
+_GL_FUNCDECL_RPL (popen, FILE *, (const char *cmd, const char *mode)
+                                 _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (popen, FILE *, (const char *cmd, const char *mode));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (popen, FILE *, (const char *cmd, const char *mode)
+                                 _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (popen, FILE *, (const char *cmd, const char *mode));
+# endif
+_GL_CXXALIASWARN (popen);
+#elif defined GNULIB_POSIXCHECK
+# undef popen
+# if HAVE_RAW_DECL_POPEN
+_GL_WARN_ON_USE (popen, "popen is buggy on some platforms - "
+                 "use gnulib module popen or pipe for more portability");
+# endif
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if defined __GNUC__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+/* Don't break __attribute__((format(printf,M,N))).  */
+#    define printf __printf__
+#   endif
+#   if 0 || 0
+_GL_FUNCDECL_RPL_1 (__printf__, int,
+                    (const char *format, ...)
+                    __asm__ (
+                             _GL_STDIO_MACROEXPAND_AND_STRINGIZE(rpl_printf))
+                    _GL_ATTRIBUTE_FORMAT_PRINTF (1, 2)
+                    _GL_ARG_NONNULL ((1)));
+#   else
+_GL_FUNCDECL_RPL_1 (__printf__, int,
+                    (const char *format, ...)
+                    __asm__ (
+                             _GL_STDIO_MACROEXPAND_AND_STRINGIZE(rpl_printf))
+                    _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (1, 2)
+                    _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_RPL_1 (printf, __printf__, int, (const char *format, ...));
+#  else
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define printf rpl_printf
+#   endif
+_GL_FUNCDECL_RPL (printf, int,
+                  (const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (1, 2)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (printf, int, (const char *format, ...));
+#  endif
+#  define GNULIB_overrides_printf 1
+# else
+_GL_CXXALIAS_SYS (printf, int, (const char *format, ...));
+# endif
+_GL_CXXALIASWARN (printf);
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_printf
+#  undef printf
+# endif
+/* Assume printf is always declared.  */
+_GL_WARN_ON_USE (printf, "printf is not always POSIX compliant - "
+                 "use gnulib module printf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putc
+#   define putc rpl_fputc
+#  endif
+_GL_FUNCDECL_RPL (fputc, int, (int c, FILE *stream) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL_1 (putc, rpl_fputc, int, (int c, FILE *stream));
+# else
+_GL_CXXALIAS_SYS (putc, int, (int c, FILE *stream));
+# endif
+_GL_CXXALIASWARN (putc);
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putchar
+#   define putchar rpl_putchar
+#  endif
+_GL_FUNCDECL_RPL (putchar, int, (int c));
+_GL_CXXALIAS_RPL (putchar, int, (int c));
+# else
+_GL_CXXALIAS_SYS (putchar, int, (int c));
+# endif
+_GL_CXXALIASWARN (putchar);
+#endif
+
+#if 1
+# if 0 && (0 || 0)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef puts
+#   define puts rpl_puts
+#  endif
+_GL_FUNCDECL_RPL (puts, int, (const char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (puts, int, (const char *string));
+# else
+_GL_CXXALIAS_SYS (puts, int, (const char *string));
+# endif
+_GL_CXXALIASWARN (puts);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef remove
+#   define remove rpl_remove
+#  endif
+_GL_FUNCDECL_RPL (remove, int, (const char *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (remove, int, (const char *name));
+# else
+_GL_CXXALIAS_SYS (remove, int, (const char *name));
+# endif
+_GL_CXXALIASWARN (remove);
+#elif defined GNULIB_POSIXCHECK
+# undef remove
+/* Assume remove is always declared.  */
+_GL_WARN_ON_USE (remove, "remove cannot handle directories on some platforms - "
+                 "use gnulib module remove for more portability");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef rename
+#   define rename rpl_rename
+#  endif
+_GL_FUNCDECL_RPL (rename, int,
+                  (const char *old_filename, const char *new_filename)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (rename, int,
+                  (const char *old_filename, const char *new_filename));
+# else
+_GL_CXXALIAS_SYS (rename, int,
+                  (const char *old_filename, const char *new_filename));
+# endif
+_GL_CXXALIASWARN (rename);
+#elif defined GNULIB_POSIXCHECK
+# undef rename
+/* Assume rename is always declared.  */
+_GL_WARN_ON_USE (rename, "rename is buggy on some platforms - "
+                 "use gnulib module rename for more portability");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef renameat
+#   define renameat rpl_renameat
+#  endif
+_GL_FUNCDECL_RPL (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (renameat, int,
+                  (int fd1, char const *file1, int fd2, char const *file2));
+# endif
+_GL_CXXALIASWARN (renameat);
+#elif defined GNULIB_POSIXCHECK
+# undef renameat
+# if HAVE_RAW_DECL_RENAMEAT
+_GL_WARN_ON_USE (renameat, "renameat is not portable - "
+                 "use gnulib module renameat for portability");
+# endif
+#endif
+
+#if 1
+# if 0 && 0
+#  if defined __GNUC__
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef scanf
+/* Don't break __attribute__((format(scanf,M,N))).  */
+#    define scanf __scanf__
+#   endif
+_GL_FUNCDECL_RPL_1 (__scanf__, int,
+                    (const char *format, ...)
+                    __asm__ (
+                             _GL_STDIO_MACROEXPAND_AND_STRINGIZE(rpl_scanf))
+                    _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (1, 2)
+                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL_1 (scanf, __scanf__, int, (const char *format, ...));
+#  else
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef scanf
+#    define scanf rpl_scanf
+#   endif
+_GL_FUNCDECL_RPL (scanf, int, (const char *format, ...)
+                              _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (1, 2)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (scanf, int, (const char *format, ...));
+#  endif
+# else
+_GL_CXXALIAS_SYS (scanf, int, (const char *format, ...));
+# endif
+_GL_CXXALIASWARN (scanf);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define snprintf rpl_snprintf
+#  endif
+_GL_FUNCDECL_RPL (snprintf, int,
+                  (char *str, size_t size, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (3, 4)
+                  _GL_ARG_NONNULL ((3)));
+_GL_CXXALIAS_RPL (snprintf, int,
+                  (char *str, size_t size, const char *format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (snprintf, int,
+                  (char *str, size_t size, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (3, 4)
+                  _GL_ARG_NONNULL ((3)));
+#  endif
+_GL_CXXALIAS_SYS (snprintf, int,
+                  (char *str, size_t size, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (snprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef snprintf
+# if HAVE_RAW_DECL_SNPRINTF
+_GL_WARN_ON_USE (snprintf, "snprintf is unportable - "
+                 "use gnulib module snprintf for portability");
+# endif
+#endif
+
+/* Some people would argue that all sprintf uses should be warned about
+   (for example, OpenBSD issues a link warning for it),
+   since it can cause security holes due to buffer overruns.
+   However, we believe that sprintf can be used safely, and is more
+   efficient than snprintf in those safe cases; and as proof of our
+   belief, we use sprintf in several gnulib modules.  So this header
+   intentionally avoids adding a warning to sprintf except when
+   GNULIB_POSIXCHECK is defined.  */
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define sprintf rpl_sprintf
+#  endif
+_GL_FUNCDECL_RPL (sprintf, int, (char *str, const char *format, ...)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                                _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (sprintf, int, (char *str, const char *format, ...));
+# else
+_GL_CXXALIAS_SYS (sprintf, int, (char *str, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (sprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef sprintf
+/* Assume sprintf is always declared.  */
+_GL_WARN_ON_USE (sprintf, "sprintf is not always POSIX compliant - "
+                 "use gnulib module sprintf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define tmpfile rpl_tmpfile
+#  endif
+_GL_FUNCDECL_RPL (tmpfile, FILE *, (void));
+_GL_CXXALIAS_RPL (tmpfile, FILE *, (void));
+# else
+_GL_CXXALIAS_SYS (tmpfile, FILE *, (void));
+# endif
+_GL_CXXALIASWARN (tmpfile);
+#elif defined GNULIB_POSIXCHECK
+# undef tmpfile
+# if HAVE_RAW_DECL_TMPFILE
+_GL_WARN_ON_USE (tmpfile, "tmpfile is not usable on mingw - "
+                 "use gnulib module tmpfile for portability");
+# endif
+#endif
+
+#if 1
+/* Write formatted output to a string dynamically allocated with malloc().
+   If the memory allocation succeeds, store the address of the string in
+   *RESULT and return the number of resulting bytes, excluding the trailing
+   NUL.  Upon memory allocation error, or some other error, return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define asprintf rpl_asprintf
+#  endif
+_GL_FUNCDECL_RPL (asprintf, int,
+                  (char **result, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (asprintf, int,
+                  (char **result, const char *format, ...));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (asprintf, int,
+                  (char **result, const char *format, ...)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 3)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (asprintf, int,
+                  (char **result, const char *format, ...));
+# endif
+_GL_CXXALIASWARN (asprintf);
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vasprintf rpl_vasprintf
+#  endif
+_GL_FUNCDECL_RPL (vasprintf, int,
+                  (char **result, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (vasprintf, int,
+                  (char **result, const char *format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (vasprintf, int,
+                  (char **result, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (vasprintf, int,
+                  (char **result, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vasprintf);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vdprintf rpl_vdprintf
+#  endif
+_GL_FUNCDECL_RPL (vdprintf, int, (int fd, const char *format, va_list args)
+                                 _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (vdprintf, int, (int fd, const char *format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (vdprintf, int, (int fd, const char *format, va_list args)
+                                 _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+/* Need to cast, because on Solaris, the third parameter will likely be
+                                                    __va_list args.  */
+_GL_CXXALIAS_SYS_CAST (vdprintf, int,
+                       (int fd, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vdprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef vdprintf
+# if HAVE_RAW_DECL_VDPRINTF
+_GL_WARN_ON_USE (vdprintf, "vdprintf is unportable - "
+                 "use gnulib module vdprintf for portability");
+# endif
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vfprintf rpl_vfprintf
+#  endif
+#  define GNULIB_overrides_vfprintf 1
+#  if 0
+_GL_FUNCDECL_RPL (vfprintf, int, (FILE *fp, const char *format, va_list args)
+                                 _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                                 _GL_ARG_NONNULL ((1, 2)));
+#  else
+_GL_FUNCDECL_RPL (vfprintf, int, (FILE *fp, const char *format, va_list args)
+                                 _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (2, 0)
+                                 _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_RPL (vfprintf, int, (FILE *fp, const char *format, va_list args));
+# else
+/* Need to cast, because on Solaris, the third parameter is
+                                                      __va_list args
+   and GCC's fixincludes did not change this to __gnuc_va_list.  */
+_GL_CXXALIAS_SYS_CAST (vfprintf, int,
+                       (FILE *fp, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vfprintf);
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_vfprintf
+#  undef vfprintf
+# endif
+/* Assume vfprintf is always declared.  */
+_GL_WARN_ON_USE (vfprintf, "vfprintf is not always POSIX compliant - "
+                 "use gnulib module vfprintf-posix for portable "
+                      "POSIX compliance");
+#endif
+
+#if 0
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef vfscanf
+#   define vfscanf rpl_vfscanf
+#  endif
+_GL_FUNCDECL_RPL (vfscanf, int,
+                  (FILE *stream, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (vfscanf, int,
+                  (FILE *stream, const char *format, va_list args));
+# else
+_GL_CXXALIAS_SYS (vfscanf, int,
+                  (FILE *stream, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vfscanf);
+#endif
+
+#if 0 || 1
+# if (0 && 0) \
+     || (1 && 0 && (0 || 0))
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vprintf rpl_vprintf
+#  endif
+#  define GNULIB_overrides_vprintf 1
+#  if 0 || 0
+_GL_FUNCDECL_RPL (vprintf, int, (const char *format, va_list args)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF (1, 0)
+                                _GL_ARG_NONNULL ((1)));
+#  else
+_GL_FUNCDECL_RPL (vprintf, int, (const char *format, va_list args)
+                                _GL_ATTRIBUTE_FORMAT_PRINTF_SYSTEM (1, 0)
+                                _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_RPL (vprintf, int, (const char *format, va_list args));
+# else
+/* Need to cast, because on Solaris, the second parameter is
+                                                          __va_list args
+   and GCC's fixincludes did not change this to __gnuc_va_list.  */
+_GL_CXXALIAS_SYS_CAST (vprintf, int, (const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vprintf);
+#endif
+#if !0 && defined GNULIB_POSIXCHECK
+# if !GNULIB_overrides_vprintf
+#  undef vprintf
+# endif
+/* Assume vprintf is always declared.  */
+_GL_WARN_ON_USE (vprintf, "vprintf is not always POSIX compliant - "
+                 "use gnulib module vprintf-posix for portable "
+                 "POSIX compliance");
+#endif
+
+#if 0
+# if 0 && 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef vscanf
+#   define vscanf rpl_vscanf
+#  endif
+_GL_FUNCDECL_RPL (vscanf, int, (const char *format, va_list args)
+                               _GL_ATTRIBUTE_FORMAT_SCANF_SYSTEM (1, 0)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (vscanf, int, (const char *format, va_list args));
+# else
+_GL_CXXALIAS_SYS (vscanf, int, (const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vscanf);
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vsnprintf rpl_vsnprintf
+#  endif
+_GL_FUNCDECL_RPL (vsnprintf, int,
+                  (char *str, size_t size, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (3, 0)
+                  _GL_ARG_NONNULL ((3)));
+_GL_CXXALIAS_RPL (vsnprintf, int,
+                  (char *str, size_t size, const char *format, va_list args));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (vsnprintf, int,
+                  (char *str, size_t size, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (3, 0)
+                  _GL_ARG_NONNULL ((3)));
+#  endif
+_GL_CXXALIAS_SYS (vsnprintf, int,
+                  (char *str, size_t size, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vsnprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef vsnprintf
+# if HAVE_RAW_DECL_VSNPRINTF
+_GL_WARN_ON_USE (vsnprintf, "vsnprintf is unportable - "
+                 "use gnulib module vsnprintf for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define vsprintf rpl_vsprintf
+#  endif
+_GL_FUNCDECL_RPL (vsprintf, int,
+                  (char *str, const char *format, va_list args)
+                  _GL_ATTRIBUTE_FORMAT_PRINTF (2, 0)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (vsprintf, int,
+                  (char *str, const char *format, va_list args));
+# else
+/* Need to cast, because on Solaris, the third parameter is
+                                                       __va_list args
+   and GCC's fixincludes did not change this to __gnuc_va_list.  */
+_GL_CXXALIAS_SYS_CAST (vsprintf, int,
+                       (char *str, const char *format, va_list args));
+# endif
+_GL_CXXALIASWARN (vsprintf);
+#elif defined GNULIB_POSIXCHECK
+# undef vsprintf
+/* Assume vsprintf is always declared.  */
+_GL_WARN_ON_USE (vsprintf, "vsprintf is not always POSIX compliant - "
+                 "use gnulib module vsprintf-posix for portable "
+                      "POSIX compliance");
+#endif
+
+#endif /* _GL_STDIO_H */
+#endif /* _GL_STDIO_H */
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/stdlib.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/stdlib.h
new file mode 100644
index 000000000..6aa0cbf36
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/stdlib.h
@@ -0,0 +1,1595 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <stdlib.h>.
+
+   Copyright (C) 1995, 2001-2004, 2006-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if defined __need_system_stdlib_h || defined __need_malloc_and_calloc
+/* Special invocation conventions inside some gnulib header files,
+   and inside some glibc header files, respectively.  */
+
+#include_next <stdlib.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDLIB_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <stdlib.h>
+
+#ifndef _GL_STDLIB_H
+#define _GL_STDLIB_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* MirBSD 10 defines WEXITSTATUS in <sys/wait.h>, not in <stdlib.h>.  */
+#if 0 && !defined WEXITSTATUS
+# include <sys/wait.h>
+#endif
+
+/* Solaris declares getloadavg() in <sys/loadavg.h>.  */
+#if (0 || defined GNULIB_POSIXCHECK) && 0
+/* OpenIndiana has a bug: <sys/time.h> must be included before
+   <sys/loadavg.h>.  */
+# include <sys/time.h>
+# include <sys/loadavg.h>
+#endif
+
+/* Native Windows platforms declare mktemp() in <io.h>.  */
+#if 0 && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+#if 0
+
+/* OSF/1 5.1 declares 'struct random_data' in <random.h>, which is included
+   from <stdlib.h> if _REENTRANT is defined.  Include it whenever we need
+   'struct random_data'.  */
+# if 1
+#  include <random.h>
+# endif
+
+# if !1 || 0 || !1
+#  include <stdint.h>
+# endif
+
+# if !1
+/* Define 'struct random_data'.
+   But allow multiple gnulib generated <stdlib.h> replacements to coexist.  */
+#  if !GNULIB_defined_struct_random_data
+struct random_data
+{
+  int32_t *fptr;                /* Front pointer.  */
+  int32_t *rptr;                /* Rear pointer.  */
+  int32_t *state;               /* Array of state values.  */
+  int rand_type;                /* Type of random number generator.  */
+  int rand_deg;                 /* Degree of random number generator.  */
+  int rand_sep;                 /* Distance between front and rear.  */
+  int32_t *end_ptr;             /* Pointer behind state table.  */
+};
+#   define GNULIB_defined_struct_random_data 1
+#  endif
+# endif
+#endif
+
+#if (1 || 0 || 0 || 0 || 0 || defined GNULIB_POSIXCHECK) && ! defined __GLIBC__ && !(defined _WIN32 && ! defined __CYGWIN__)
+/* On Mac OS X 10.3, only <unistd.h> declares mkstemp.  */
+/* On Mac OS X 10.5, only <unistd.h> declares mkstemps.  */
+/* On Mac OS X 10.13, only <unistd.h> declares mkostemp and mkostemps.  */
+/* On Cygwin 1.7.1, only <unistd.h> declares getsubopt.  */
+/* But avoid namespace pollution on glibc systems and native Windows.  */
+# include <unistd.h>
+#endif
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The attribute __pure__ was added in gcc 2.96.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
+#endif
+
+/* The definition of _Noreturn is copied here.  */
+/* A C macro for declaring that a function does not return.
+   Copyright (C) 2011-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _Noreturn
+# if (defined __cplusplus \
+      && ((201103 <= __cplusplus && !(__GNUC__ == 4 && __GNUC_MINOR__ == 7)) \
+          || (defined _MSC_VER && 1900 <= _MSC_VER)))
+#  define _Noreturn [[noreturn]]
+# elif ((!defined __cplusplus || defined __clang__)                     \
+        && (201112 <= (defined __STDC_VERSION__ ? __STDC_VERSION__ : 0)  \
+            || 4 < __GNUC__ + (7 <= __GNUC_MINOR__)))
+   /* _Noreturn works as-is.  */
+# elif 2 < __GNUC__ + (8 <= __GNUC_MINOR__) || 0x5110 <= __SUNPRO_C
+#  define _Noreturn __attribute__ ((__noreturn__))
+# elif 1200 <= (defined _MSC_VER ? _MSC_VER : 0)
+#  define _Noreturn __declspec (noreturn)
+# else
+#  define _Noreturn
+# endif
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Some systems do not define EXIT_*, despite otherwise supporting C89.  */
+#ifndef EXIT_SUCCESS
+# define EXIT_SUCCESS 0
+#endif
+/* Tandem/NSK and other platforms that define EXIT_FAILURE as -1 interfere
+   with proper operation of xargs.  */
+#ifndef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#elif EXIT_FAILURE != 1
+# undef EXIT_FAILURE
+# define EXIT_FAILURE 1
+#endif
+
+
+#if 0
+/* Terminate the current process with the given return code, without running
+   the 'atexit' handlers.  */
+# if !1
+_GL_FUNCDECL_SYS (_Exit, _Noreturn void, (int status));
+# endif
+_GL_CXXALIAS_SYS (_Exit, void, (int status));
+_GL_CXXALIASWARN (_Exit);
+#elif defined GNULIB_POSIXCHECK
+# undef _Exit
+# if HAVE_RAW_DECL__EXIT
+_GL_WARN_ON_USE (_Exit, "_Exit is unportable - "
+                 "use gnulib module _Exit for portability");
+# endif
+#endif
+
+
+#if 0
+/* Parse a signed decimal integer.
+   Returns the value of the integer.  Errors are not detected.  */
+# if !1
+_GL_FUNCDECL_SYS (atoll, long long, (const char *string)
+                                    _GL_ATTRIBUTE_PURE
+                                    _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (atoll, long long, (const char *string));
+_GL_CXXALIASWARN (atoll);
+#elif defined GNULIB_POSIXCHECK
+# undef atoll
+# if HAVE_RAW_DECL_ATOLL
+_GL_WARN_ON_USE (atoll, "atoll is unportable - "
+                 "use gnulib module atoll for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef calloc
+#   define calloc rpl_calloc
+#  endif
+_GL_FUNCDECL_RPL (calloc, void *, (size_t nmemb, size_t size));
+_GL_CXXALIAS_RPL (calloc, void *, (size_t nmemb, size_t size));
+# else
+_GL_CXXALIAS_SYS (calloc, void *, (size_t nmemb, size_t size));
+# endif
+_GL_CXXALIASWARN (calloc);
+#elif defined GNULIB_POSIXCHECK
+# undef calloc
+/* Assume calloc is always declared.  */
+_GL_WARN_ON_USE (calloc, "calloc is not POSIX compliant everywhere - "
+                 "use gnulib module calloc-posix for portability");
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define canonicalize_file_name rpl_canonicalize_file_name
+#  endif
+_GL_FUNCDECL_RPL (canonicalize_file_name, char *, (const char *name)
+                                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (canonicalize_file_name, char *, (const char *name));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (canonicalize_file_name, char *, (const char *name)
+                                                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (canonicalize_file_name, char *, (const char *name));
+# endif
+_GL_CXXALIASWARN (canonicalize_file_name);
+#elif defined GNULIB_POSIXCHECK
+# undef canonicalize_file_name
+# if HAVE_RAW_DECL_CANONICALIZE_FILE_NAME
+_GL_WARN_ON_USE (canonicalize_file_name,
+                 "canonicalize_file_name is unportable - "
+                 "use gnulib module canonicalize-lgpl for portability");
+# endif
+#endif
+
+#if 0
+/* Store max(NELEM,3) load average numbers in LOADAVG[].
+   The three numbers are the load average of the last 1 minute, the last 5
+   minutes, and the last 15 minutes, respectively.
+   LOADAVG is an array of NELEM numbers.  */
+# if !1
+_GL_FUNCDECL_SYS (getloadavg, int, (double loadavg[], int nelem)
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (getloadavg, int, (double loadavg[], int nelem));
+_GL_CXXALIASWARN (getloadavg);
+#elif defined GNULIB_POSIXCHECK
+# undef getloadavg
+# if HAVE_RAW_DECL_GETLOADAVG
+_GL_WARN_ON_USE (getloadavg, "getloadavg is not portable - "
+                 "use gnulib module getloadavg for portability");
+# endif
+#endif
+
+#if 0
+/* Assuming *OPTIONP is a comma separated list of elements of the form
+   "token" or "token=value", getsubopt parses the first of these elements.
+   If the first element refers to a "token" that is member of the given
+   NULL-terminated array of tokens:
+     - It replaces the comma with a NUL byte, updates *OPTIONP to point past
+       the first option and the comma, sets *VALUEP to the value of the
+       element (or NULL if it doesn't contain an "=" sign),
+     - It returns the index of the "token" in the given array of tokens.
+   Otherwise it returns -1, and *OPTIONP and *VALUEP are undefined.
+   For more details see the POSIX:2001 specification.
+   http://www.opengroup.org/susv3xsh/getsubopt.html */
+# if !1
+_GL_FUNCDECL_SYS (getsubopt, int,
+                  (char **optionp, char *const *tokens, char **valuep)
+                  _GL_ARG_NONNULL ((1, 2, 3)));
+# endif
+_GL_CXXALIAS_SYS (getsubopt, int,
+                  (char **optionp, char *const *tokens, char **valuep));
+_GL_CXXALIASWARN (getsubopt);
+#elif defined GNULIB_POSIXCHECK
+# undef getsubopt
+# if HAVE_RAW_DECL_GETSUBOPT
+_GL_WARN_ON_USE (getsubopt, "getsubopt is unportable - "
+                 "use gnulib module getsubopt for portability");
+# endif
+#endif
+
+#if 0
+/* Change the ownership and access permission of the slave side of the
+   pseudo-terminal whose master side is specified by FD.  */
+# if !1
+_GL_FUNCDECL_SYS (grantpt, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (grantpt, int, (int fd));
+_GL_CXXALIASWARN (grantpt);
+#elif defined GNULIB_POSIXCHECK
+# undef grantpt
+# if HAVE_RAW_DECL_GRANTPT
+_GL_WARN_ON_USE (grantpt, "grantpt is not portable - "
+                 "use gnulib module grantpt for portability");
+# endif
+#endif
+
+/* If _GL_USE_STDLIB_ALLOC is nonzero, the including module does not
+   rely on GNU or POSIX semantics for malloc and realloc (for example,
+   by never specifying a zero size), so it does not need malloc or
+   realloc to be redefined.  */
+#if 1
+# if 0
+#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \
+        || _GL_USE_STDLIB_ALLOC)
+#   undef malloc
+#   define malloc rpl_malloc
+#  endif
+_GL_FUNCDECL_RPL (malloc, void *, (size_t size));
+_GL_CXXALIAS_RPL (malloc, void *, (size_t size));
+# else
+_GL_CXXALIAS_SYS (malloc, void *, (size_t size));
+# endif
+_GL_CXXALIASWARN (malloc);
+#elif defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC
+# undef malloc
+/* Assume malloc is always declared.  */
+_GL_WARN_ON_USE (malloc, "malloc is not POSIX compliant everywhere - "
+                 "use gnulib module malloc-posix for portability");
+#endif
+
+/* Convert a multibyte character to a wide character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbtowc
+#   define mbtowc rpl_mbtowc
+#  endif
+_GL_FUNCDECL_RPL (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));
+_GL_CXXALIAS_RPL (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));
+#  endif
+_GL_CXXALIAS_SYS (mbtowc, int, (wchar_t *pwc, const char *s, size_t n));
+# endif
+_GL_CXXALIASWARN (mbtowc);
+#elif defined GNULIB_POSIXCHECK
+# undef mbtowc
+# if HAVE_RAW_DECL_MBTOWC
+_GL_WARN_ON_USE (mbtowc, "mbtowc is not portable - "
+                 "use gnulib module mbtowc for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary directory from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the directory name unique.
+   Returns TEMPLATE, or a null pointer if it cannot get a unique name.
+   The directory is created mode 700.  */
+# if !1
+_GL_FUNCDECL_SYS (mkdtemp, char *, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkdtemp, char *, (char * /*template*/));
+_GL_CXXALIASWARN (mkdtemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdtemp
+# if HAVE_RAW_DECL_MKDTEMP
+_GL_WARN_ON_USE (mkdtemp, "mkdtemp is unportable - "
+                 "use gnulib module mkdtemp for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   The file is then created, with the specified flags, ensuring it didn't exist
+   before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !1
+_GL_FUNCDECL_SYS (mkostemp, int, (char * /*template*/, int /*flags*/)
+                                 _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkostemp, int, (char * /*template*/, int /*flags*/));
+_GL_CXXALIASWARN (mkostemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkostemp
+# if HAVE_RAW_DECL_MKOSTEMP
+_GL_WARN_ON_USE (mkostemp, "mkostemp is unportable - "
+                 "use gnulib module mkostemp for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE before a suffix of length
+   SUFFIXLEN must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   The file is then created, with the specified flags, ensuring it didn't exist
+   before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !1
+_GL_FUNCDECL_SYS (mkostemps, int,
+                  (char * /*template*/, int /*suffixlen*/, int /*flags*/)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkostemps, int,
+                  (char * /*template*/, int /*suffixlen*/, int /*flags*/));
+_GL_CXXALIASWARN (mkostemps);
+#elif defined GNULIB_POSIXCHECK
+# undef mkostemps
+# if HAVE_RAW_DECL_MKOSTEMPS
+_GL_WARN_ON_USE (mkostemps, "mkostemps is unportable - "
+                 "use gnulib module mkostemps for portability");
+# endif
+#endif
+
+#if 1
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mkstemp rpl_mkstemp
+#  endif
+_GL_FUNCDECL_RPL (mkstemp, int, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkstemp, int, (char * /*template*/));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (mkstemp, int, (char * /*template*/) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mkstemp, int, (char * /*template*/));
+# endif
+_GL_CXXALIASWARN (mkstemp);
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemp
+# if HAVE_RAW_DECL_MKSTEMP
+_GL_WARN_ON_USE (mkstemp, "mkstemp is unportable - "
+                 "use gnulib module mkstemp for portability");
+# endif
+#endif
+
+#if 0
+/* Create a unique temporary file from TEMPLATE.
+   The last six characters of TEMPLATE prior to a suffix of length
+   SUFFIXLEN must be "XXXXXX";
+   they are replaced with a string that makes the file name unique.
+   The file is then created, ensuring it didn't exist before.
+   The file is created read-write (mask at least 0600 & ~umask), but it may be
+   world-readable and world-writable (mask 0666 & ~umask), depending on the
+   implementation.
+   Returns the open file descriptor if successful, otherwise -1 and errno
+   set.  */
+# if !1
+_GL_FUNCDECL_SYS (mkstemps, int, (char * /*template*/, int /*suffixlen*/)
+                                 _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (mkstemps, int, (char * /*template*/, int /*suffixlen*/));
+_GL_CXXALIASWARN (mkstemps);
+#elif defined GNULIB_POSIXCHECK
+# undef mkstemps
+# if HAVE_RAW_DECL_MKSTEMPS
+_GL_WARN_ON_USE (mkstemps, "mkstemps is unportable - "
+                 "use gnulib module mkstemps for portability");
+# endif
+#endif
+
+#if 0
+/* Return an FD open to the master side of a pseudo-terminal.  Flags should
+   include O_RDWR, and may also include O_NOCTTY.  */
+# if !1
+_GL_FUNCDECL_SYS (posix_openpt, int, (int flags));
+# endif
+_GL_CXXALIAS_SYS (posix_openpt, int, (int flags));
+_GL_CXXALIASWARN (posix_openpt);
+#elif defined GNULIB_POSIXCHECK
+# undef posix_openpt
+# if HAVE_RAW_DECL_POSIX_OPENPT
+_GL_WARN_ON_USE (posix_openpt, "posix_openpt is not portable - "
+                 "use gnulib module posix_openpt for portability");
+# endif
+#endif
+
+#if 0
+/* Return the pathname of the pseudo-terminal slave associated with
+   the master FD is open on, or NULL on errors.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ptsname
+#   define ptsname rpl_ptsname
+#  endif
+_GL_FUNCDECL_RPL (ptsname, char *, (int fd));
+_GL_CXXALIAS_RPL (ptsname, char *, (int fd));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ptsname, char *, (int fd));
+#  endif
+_GL_CXXALIAS_SYS (ptsname, char *, (int fd));
+# endif
+_GL_CXXALIASWARN (ptsname);
+#elif defined GNULIB_POSIXCHECK
+# undef ptsname
+# if HAVE_RAW_DECL_PTSNAME
+_GL_WARN_ON_USE (ptsname, "ptsname is not portable - "
+                 "use gnulib module ptsname for portability");
+# endif
+#endif
+
+#if 0
+/* Set the pathname of the pseudo-terminal slave associated with
+   the master FD is open on and return 0, or set errno and return
+   non-zero on errors.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ptsname_r
+#   define ptsname_r rpl_ptsname_r
+#  endif
+_GL_FUNCDECL_RPL (ptsname_r, int, (int fd, char *buf, size_t len));
+_GL_CXXALIAS_RPL (ptsname_r, int, (int fd, char *buf, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ptsname_r, int, (int fd, char *buf, size_t len));
+#  endif
+_GL_CXXALIAS_SYS (ptsname_r, int, (int fd, char *buf, size_t len));
+# endif
+_GL_CXXALIASWARN (ptsname_r);
+#elif defined GNULIB_POSIXCHECK
+# undef ptsname_r
+# if HAVE_RAW_DECL_PTSNAME_R
+_GL_WARN_ON_USE (ptsname_r, "ptsname_r is not portable - "
+                 "use gnulib module ptsname_r for portability");
+# endif
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef putenv
+#   define putenv rpl_putenv
+#  endif
+_GL_FUNCDECL_RPL (putenv, int, (char *string) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (putenv, int, (char *string));
+# else
+_GL_CXXALIAS_SYS (putenv, int, (char *string));
+# endif
+_GL_CXXALIASWARN (putenv);
+#endif
+
+#if 0
+/* Sort an array of NMEMB elements, starting at address BASE, each element
+   occupying SIZE bytes, in ascending order according to the comparison
+   function COMPARE.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef qsort_r
+#   define qsort_r rpl_qsort_r
+#  endif
+_GL_FUNCDECL_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  int (*compare) (void const *, void const *,
+                                                  void *),
+                                  void *arg) _GL_ARG_NONNULL ((1, 4)));
+_GL_CXXALIAS_RPL (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  int (*compare) (void const *, void const *,
+                                                  void *),
+                                  void *arg));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  int (*compare) (void const *, void const *,
+                                                  void *),
+                                  void *arg) _GL_ARG_NONNULL ((1, 4)));
+#  endif
+_GL_CXXALIAS_SYS (qsort_r, void, (void *base, size_t nmemb, size_t size,
+                                  int (*compare) (void const *, void const *,
+                                                  void *),
+                                  void *arg));
+# endif
+_GL_CXXALIASWARN (qsort_r);
+#elif defined GNULIB_POSIXCHECK
+# undef qsort_r
+# if HAVE_RAW_DECL_QSORT_R
+_GL_WARN_ON_USE (qsort_r, "qsort_r is not portable - "
+                 "use gnulib module qsort_r for portability");
+# endif
+#endif
+
+
+#if 0
+# if !1
+#  ifndef RAND_MAX
+#   define RAND_MAX 2147483647
+#  endif
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef random
+#   define random rpl_random
+#  endif
+_GL_FUNCDECL_RPL (random, long, (void));
+_GL_CXXALIAS_RPL (random, long, (void));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (random, long, (void));
+#  endif
+_GL_CXXALIAS_SYS (random, long, (void));
+# endif
+_GL_CXXALIASWARN (random);
+#elif defined GNULIB_POSIXCHECK
+# undef random
+# if HAVE_RAW_DECL_RANDOM
+_GL_WARN_ON_USE (random, "random is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef srandom
+#   define srandom rpl_srandom
+#  endif
+_GL_FUNCDECL_RPL (srandom, void, (unsigned int seed));
+_GL_CXXALIAS_RPL (srandom, void, (unsigned int seed));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (srandom, void, (unsigned int seed));
+#  endif
+_GL_CXXALIAS_SYS (srandom, void, (unsigned int seed));
+# endif
+_GL_CXXALIASWARN (srandom);
+#elif defined GNULIB_POSIXCHECK
+# undef srandom
+# if HAVE_RAW_DECL_SRANDOM
+_GL_WARN_ON_USE (srandom, "srandom is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef initstate
+#   define initstate rpl_initstate
+#  endif
+_GL_FUNCDECL_RPL (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size));
+# else
+#  if !1 || !1
+_GL_FUNCDECL_SYS (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (initstate, char *,
+                  (unsigned int seed, char *buf, size_t buf_size));
+# endif
+_GL_CXXALIASWARN (initstate);
+#elif defined GNULIB_POSIXCHECK
+# undef initstate
+# if HAVE_RAW_DECL_INITSTATE
+_GL_WARN_ON_USE (initstate, "initstate is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setstate
+#   define setstate rpl_setstate
+#  endif
+_GL_FUNCDECL_RPL (setstate, char *, (char *arg_state) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (setstate, char *, (char *arg_state));
+# else
+#  if !1 || !1
+_GL_FUNCDECL_SYS (setstate, char *, (char *arg_state) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (setstate, char *, (char *arg_state));
+# endif
+_GL_CXXALIASWARN (setstate);
+#elif defined GNULIB_POSIXCHECK
+# undef setstate
+# if HAVE_RAW_DECL_SETSTATE
+_GL_WARN_ON_USE (setstate, "setstate is unportable - "
+                 "use gnulib module random for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef random_r
+#   define random_r rpl_random_r
+#  endif
+_GL_FUNCDECL_RPL (random_r, int, (struct random_data *buf, int32_t *result)
+                                 _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (random_r, int, (struct random_data *buf, int32_t *result));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (random_r, int, (struct random_data *buf, int32_t *result)
+                                 _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (random_r, int, (struct random_data *buf, int32_t *result));
+# endif
+_GL_CXXALIASWARN (random_r);
+#elif defined GNULIB_POSIXCHECK
+# undef random_r
+# if HAVE_RAW_DECL_RANDOM_R
+_GL_WARN_ON_USE (random_r, "random_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef srandom_r
+#   define srandom_r rpl_srandom_r
+#  endif
+_GL_FUNCDECL_RPL (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (srandom_r, int,
+                  (unsigned int seed, struct random_data *rand_state));
+# endif
+_GL_CXXALIASWARN (srandom_r);
+#elif defined GNULIB_POSIXCHECK
+# undef srandom_r
+# if HAVE_RAW_DECL_SRANDOM_R
+_GL_WARN_ON_USE (srandom_r, "srandom_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef initstate_r
+#   define initstate_r rpl_initstate_r
+#  endif
+_GL_FUNCDECL_RPL (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (initstate_r, int,
+                  (unsigned int seed, char *buf, size_t buf_size,
+                   struct random_data *rand_state));
+# endif
+_GL_CXXALIASWARN (initstate_r);
+#elif defined GNULIB_POSIXCHECK
+# undef initstate_r
+# if HAVE_RAW_DECL_INITSTATE_R
+_GL_WARN_ON_USE (initstate_r, "initstate_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setstate_r
+#   define setstate_r rpl_setstate_r
+#  endif
+_GL_FUNCDECL_RPL (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (setstate_r, int,
+                  (char *arg_state, struct random_data *rand_state));
+# endif
+_GL_CXXALIASWARN (setstate_r);
+#elif defined GNULIB_POSIXCHECK
+# undef setstate_r
+# if HAVE_RAW_DECL_SETSTATE_R
+_GL_WARN_ON_USE (setstate_r, "setstate_r is unportable - "
+                 "use gnulib module random_r for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !((defined __cplusplus && defined GNULIB_NAMESPACE) \
+        || _GL_USE_STDLIB_ALLOC)
+#   undef realloc
+#   define realloc rpl_realloc
+#  endif
+_GL_FUNCDECL_RPL (realloc, void *, (void *ptr, size_t size));
+_GL_CXXALIAS_RPL (realloc, void *, (void *ptr, size_t size));
+# else
+_GL_CXXALIAS_SYS (realloc, void *, (void *ptr, size_t size));
+# endif
+_GL_CXXALIASWARN (realloc);
+#elif defined GNULIB_POSIXCHECK && !_GL_USE_STDLIB_ALLOC
+# undef realloc
+/* Assume realloc is always declared.  */
+_GL_WARN_ON_USE (realloc, "realloc is not POSIX compliant everywhere - "
+                 "use gnulib module realloc-posix for portability");
+#endif
+
+
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (reallocarray, void *,
+                  (void *ptr, size_t nmemb, size_t size));
+# endif
+_GL_CXXALIAS_SYS (reallocarray, void *,
+                  (void *ptr, size_t nmemb, size_t size));
+_GL_CXXALIASWARN (reallocarray);
+#elif defined GNULIB_POSIXCHECK
+# undef reallocarray
+# if HAVE_RAW_DECL_REALLOCARRAY
+_GL_WARN_ON_USE (reallocarray, "reallocarray is not portable - "
+                 "use gnulib module reallocarray for portability");
+# endif
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define realpath rpl_realpath
+#  endif
+_GL_FUNCDECL_RPL (realpath, char *, (const char *name, char *resolved)
+                                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (realpath, char *, (const char *name, char *resolved));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (realpath, char *, (const char *name, char *resolved)
+                                    _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (realpath, char *, (const char *name, char *resolved));
+# endif
+_GL_CXXALIASWARN (realpath);
+#elif defined GNULIB_POSIXCHECK
+# undef realpath
+# if HAVE_RAW_DECL_REALPATH
+_GL_WARN_ON_USE (realpath, "realpath is unportable - use gnulib module "
+                 "canonicalize or canonicalize-lgpl for portability");
+# endif
+#endif
+
+#if 0
+/* Test a user response to a question.
+   Return 1 if it is affirmative, 0 if it is negative, or -1 if not clear.  */
+# if !1
+_GL_FUNCDECL_SYS (rpmatch, int, (const char *response) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (rpmatch, int, (const char *response));
+_GL_CXXALIASWARN (rpmatch);
+#elif defined GNULIB_POSIXCHECK
+# undef rpmatch
+# if HAVE_RAW_DECL_RPMATCH
+_GL_WARN_ON_USE (rpmatch, "rpmatch is unportable - "
+                 "use gnulib module rpmatch for portability");
+# endif
+#endif
+
+#if 0
+/* Look up NAME in the environment, returning 0 in insecure situations.  */
+# if !1
+_GL_FUNCDECL_SYS (secure_getenv, char *,
+                  (char const *name) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (secure_getenv, char *, (char const *name));
+_GL_CXXALIASWARN (secure_getenv);
+#elif defined GNULIB_POSIXCHECK
+# undef secure_getenv
+# if HAVE_RAW_DECL_SECURE_GETENV
+_GL_WARN_ON_USE (secure_getenv, "secure_getenv is unportable - "
+                 "use gnulib module secure_getenv for portability");
+# endif
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Set NAME to VALUE in the environment.
+   If REPLACE is nonzero, overwrite an existing value.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef setenv
+#   define setenv rpl_setenv
+#  endif
+_GL_FUNCDECL_RPL (setenv, int,
+                  (const char *name, const char *value, int replace)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (setenv, int,
+                  (const char *name, const char *value, int replace));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (setenv, int,
+                  (const char *name, const char *value, int replace)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (setenv, int,
+                  (const char *name, const char *value, int replace));
+# endif
+# if !(0 && !1)
+_GL_CXXALIASWARN (setenv);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef setenv
+# if HAVE_RAW_DECL_SETENV
+_GL_WARN_ON_USE (setenv, "setenv is unportable - "
+                 "use gnulib module setenv for portability");
+# endif
+#endif
+
+#if 0
+ /* Parse a double from STRING, updating ENDP if appropriate.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtod rpl_strtod
+#  endif
+#  define GNULIB_defined_strtod_function 1
+_GL_FUNCDECL_RPL (strtod, double, (const char *str, char **endp)
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtod, double, (const char *str, char **endp));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtod, double, (const char *str, char **endp)
+                                  _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtod, double, (const char *str, char **endp));
+# endif
+_GL_CXXALIASWARN (strtod);
+#elif defined GNULIB_POSIXCHECK
+# undef strtod
+# if HAVE_RAW_DECL_STRTOD
+_GL_WARN_ON_USE (strtod, "strtod is unportable - "
+                 "use gnulib module strtod for portability");
+# endif
+#endif
+
+#if 0
+ /* Parse a 'long double' from STRING, updating ENDP if appropriate.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strtold rpl_strtold
+#  endif
+#  define GNULIB_defined_strtold_function 1
+_GL_FUNCDECL_RPL (strtold, long double, (const char *str, char **endp)
+                                        _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strtold, long double, (const char *str, char **endp));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strtold, long double, (const char *str, char **endp)
+                                        _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strtold, long double, (const char *str, char **endp));
+# endif
+_GL_CXXALIASWARN (strtold);
+#elif defined GNULIB_POSIXCHECK
+# undef strtold
+# if HAVE_RAW_DECL_STRTOLD
+_GL_WARN_ON_USE (strtold, "strtold is unportable - "
+                 "use gnulib module strtold for portability");
+# endif
+#endif
+
+#if 0
+/* Parse a signed integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is LLONG_MAX or LLONG_MIN, and errno is set
+   to ERANGE.  */
+# if !1
+_GL_FUNCDECL_SYS (strtoll, long long,
+                  (const char *string, char **endptr, int base)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (strtoll, long long,
+                  (const char *string, char **endptr, int base));
+_GL_CXXALIASWARN (strtoll);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoll
+# if HAVE_RAW_DECL_STRTOLL
+_GL_WARN_ON_USE (strtoll, "strtoll is unportable - "
+                 "use gnulib module strtoll for portability");
+# endif
+#endif
+
+#if 0
+/* Parse an unsigned integer whose textual representation starts at STRING.
+   The integer is expected to be in base BASE (2 <= BASE <= 36); if BASE == 0,
+   it may be decimal or octal (with prefix "0") or hexadecimal (with prefix
+   "0x").
+   If ENDPTR is not NULL, the address of the first byte after the integer is
+   stored in *ENDPTR.
+   Upon overflow, the return value is ULLONG_MAX, and errno is set to
+   ERANGE.  */
+# if !1
+_GL_FUNCDECL_SYS (strtoull, unsigned long long,
+                  (const char *string, char **endptr, int base)
+                  _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (strtoull, unsigned long long,
+                  (const char *string, char **endptr, int base));
+_GL_CXXALIASWARN (strtoull);
+#elif defined GNULIB_POSIXCHECK
+# undef strtoull
+# if HAVE_RAW_DECL_STRTOULL
+_GL_WARN_ON_USE (strtoull, "strtoull is unportable - "
+                 "use gnulib module strtoull for portability");
+# endif
+#endif
+
+#if 0
+/* Unlock the slave side of the pseudo-terminal whose master side is specified
+   by FD, so that it can be opened.  */
+# if !1
+_GL_FUNCDECL_SYS (unlockpt, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (unlockpt, int, (int fd));
+_GL_CXXALIASWARN (unlockpt);
+#elif defined GNULIB_POSIXCHECK
+# undef unlockpt
+# if HAVE_RAW_DECL_UNLOCKPT
+_GL_WARN_ON_USE (unlockpt, "unlockpt is not portable - "
+                 "use gnulib module unlockpt for portability");
+# endif
+#endif
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Remove the variable NAME from the environment.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unsetenv
+#   define unsetenv rpl_unsetenv
+#  endif
+_GL_FUNCDECL_RPL (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (unsetenv, int, (const char *name));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (unsetenv, int, (const char *name) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (unsetenv, int, (const char *name));
+# endif
+# if !(0 && !1)
+_GL_CXXALIASWARN (unsetenv);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef unsetenv
+# if HAVE_RAW_DECL_UNSETENV
+_GL_WARN_ON_USE (unsetenv, "unsetenv is unportable - "
+                 "use gnulib module unsetenv for portability");
+# endif
+#endif
+
+/* Convert a wide character to a multibyte character.  */
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wctomb
+#   define wctomb rpl_wctomb
+#  endif
+_GL_FUNCDECL_RPL (wctomb, int, (char *s, wchar_t wc));
+_GL_CXXALIAS_RPL (wctomb, int, (char *s, wchar_t wc));
+# else
+_GL_CXXALIAS_SYS (wctomb, int, (char *s, wchar_t wc));
+# endif
+_GL_CXXALIASWARN (wctomb);
+#endif
+
+
+#endif /* _GL_STDLIB_H */
+#endif /* _GL_STDLIB_H */
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/string.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/string.h
new file mode 100644
index 000000000..1bcb679fc
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/string.h
@@ -0,0 +1,1537 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A GNU-like <string.h>.
+
+   Copyright (C) 1995-1996, 2001-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if defined _GL_ALREADY_INCLUDING_STRING_H
+/* Special invocation convention:
+   - On OS X/NetBSD we have a sequence of nested includes
+       <string.h> -> <strings.h> -> "string.h"
+     In this situation system _chk variants due to -D_FORTIFY_SOURCE
+     might be used after any replacements defined here.  */
+
+#include_next <string.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STRING_H
+
+#define _GL_ALREADY_INCLUDING_STRING_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <string.h>
+
+#undef _GL_ALREADY_INCLUDING_STRING_H
+
+#ifndef _GL_STRING_H
+#define _GL_STRING_H
+
+/* NetBSD 5.0 mis-defines NULL.  */
+#include <stddef.h>
+
+/* MirBSD defines mbslen as a macro.  */
+#if 0 && defined __MirBSD__
+# include <wchar.h>
+#endif
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The attribute __pure__ was added in gcc 2.96.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
+#endif
+
+/* NetBSD 5.0 declares strsignal in <unistd.h>, not in <string.h>.  */
+/* But in any case avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && defined __NetBSD__ \
+    && ! defined __GLIBC__
+# include <unistd.h>
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Clear a block of memory.  The compiler will not delete a call to
+   this function, even if the block is dead after the call.  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (explicit_bzero, void,
+                  (void *__dest, size_t __n) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (explicit_bzero, void, (void *__dest, size_t __n));
+_GL_CXXALIASWARN (explicit_bzero);
+#elif defined GNULIB_POSIXCHECK
+# undef explicit_bzero
+# if HAVE_RAW_DECL_EXPLICIT_BZERO
+_GL_WARN_ON_USE (explicit_bzero, "explicit_bzero is unportable - "
+                 "use gnulib module explicit_bzero for portability");
+# endif
+#endif
+
+/* Find the index of the least-significant set bit.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (ffsl, int, (long int i));
+# endif
+_GL_CXXALIAS_SYS (ffsl, int, (long int i));
+_GL_CXXALIASWARN (ffsl);
+#elif defined GNULIB_POSIXCHECK
+# undef ffsl
+# if HAVE_RAW_DECL_FFSL
+_GL_WARN_ON_USE (ffsl, "ffsl is not portable - use the ffsl module");
+# endif
+#endif
+
+
+/* Find the index of the least-significant set bit.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (ffsll, int, (long long int i));
+# endif
+_GL_CXXALIAS_SYS (ffsll, int, (long long int i));
+_GL_CXXALIASWARN (ffsll);
+#elif defined GNULIB_POSIXCHECK
+# undef ffsll
+# if HAVE_RAW_DECL_FFSLL
+_GL_WARN_ON_USE (ffsll, "ffsll is not portable - use the ffsll module");
+# endif
+#endif
+
+
+/* Return the first instance of C within N bytes of S, or NULL.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memchr rpl_memchr
+#  endif
+_GL_FUNCDECL_RPL (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (memchr, void *, (void const *__s, int __c, size_t __n));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (memchr, void *, (void const *__s, int __c, size_t __n)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const void * std::memchr (const void *, int, size_t); }
+       extern "C++" { void * std::memchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memchr,
+                        void *, (void const *__s, int __c, size_t __n),
+                        void const *, (void const *__s, int __c, size_t __n));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (memchr, void *, (void *__s, int __c, size_t __n));
+_GL_CXXALIASWARN1 (memchr, void const *,
+                   (void const *__s, int __c, size_t __n));
+# else
+_GL_CXXALIASWARN (memchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memchr
+/* Assume memchr is always declared.  */
+_GL_WARN_ON_USE (memchr, "memchr has platform-specific bugs - "
+                 "use gnulib module memchr for portability" );
+#endif
+
+/* Return the first occurrence of NEEDLE in HAYSTACK.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define memmem rpl_memmem
+#  endif
+_GL_FUNCDECL_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 3)));
+#  endif
+_GL_CXXALIAS_SYS (memmem, void *,
+                  (void const *__haystack, size_t __haystack_len,
+                   void const *__needle, size_t __needle_len));
+# endif
+_GL_CXXALIASWARN (memmem);
+#elif defined GNULIB_POSIXCHECK
+# undef memmem
+# if HAVE_RAW_DECL_MEMMEM
+_GL_WARN_ON_USE (memmem, "memmem is unportable and often quadratic - "
+                 "use gnulib module memmem-simple for portability, "
+                 "and module memmem for speed" );
+# endif
+#endif
+
+/* Copy N bytes of SRC to DEST, return pointer to bytes after the
+   last written byte.  */
+#if 1
+# if ! 1
+_GL_FUNCDECL_SYS (mempcpy, void *,
+                  (void *restrict __dest, void const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (mempcpy, void *,
+                  (void *restrict __dest, void const *restrict __src,
+                   size_t __n));
+_GL_CXXALIASWARN (mempcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef mempcpy
+# if HAVE_RAW_DECL_MEMPCPY
+_GL_WARN_ON_USE (mempcpy, "mempcpy is unportable - "
+                 "use gnulib module mempcpy for portability");
+# endif
+#endif
+
+/* Search backwards through a block for a byte (specified as an int).  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (memrchr, void *, (void const *, int, size_t)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::memrchr (const void *, int, size_t); }
+       extern "C++" { void * std::memrchr (void *, int, size_t); }  */
+_GL_CXXALIAS_SYS_CAST2 (memrchr,
+                        void *, (void const *, int, size_t),
+                        void const *, (void const *, int, size_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (memrchr, void *, (void *, int, size_t));
+_GL_CXXALIASWARN1 (memrchr, void const *, (void const *, int, size_t));
+# else
+_GL_CXXALIASWARN (memrchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef memrchr
+# if HAVE_RAW_DECL_MEMRCHR
+_GL_WARN_ON_USE (memrchr, "memrchr is unportable - "
+                 "use gnulib module memrchr for portability");
+# endif
+#endif
+
+/* Find the first occurrence of C in S.  More efficient than
+   memchr(S,C,N), at the expense of undefined behavior if C does not
+   occur within N bytes.  */
+#if 1
+# if ! 1
+_GL_FUNCDECL_SYS (rawmemchr, void *, (void const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const void * std::rawmemchr (const void *, int); }
+       extern "C++" { void * std::rawmemchr (void *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (rawmemchr,
+                        void *, (void const *__s, int __c_in),
+                        void const *, (void const *__s, int __c_in));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (rawmemchr, void *, (void *__s, int __c_in));
+_GL_CXXALIASWARN1 (rawmemchr, void const *, (void const *__s, int __c_in));
+# else
+_GL_CXXALIASWARN (rawmemchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef rawmemchr
+# if HAVE_RAW_DECL_RAWMEMCHR
+_GL_WARN_ON_USE (rawmemchr, "rawmemchr is unportable - "
+                 "use gnulib module rawmemchr for portability");
+# endif
+#endif
+
+/* Copy SRC to DST, returning the address of the terminating '\0' in DST.  */
+#if 1
+# if ! 1
+_GL_FUNCDECL_SYS (stpcpy, char *,
+                  (char *restrict __dst, char const *restrict __src)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (stpcpy, char *,
+                  (char *restrict __dst, char const *restrict __src));
+_GL_CXXALIASWARN (stpcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef stpcpy
+# if HAVE_RAW_DECL_STPCPY
+_GL_WARN_ON_USE (stpcpy, "stpcpy is unportable - "
+                 "use gnulib module stpcpy for portability");
+# endif
+#endif
+
+/* Copy no more than N bytes of SRC to DST, returning a pointer past the
+   last non-NUL byte written into DST.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef stpncpy
+#   define stpncpy rpl_stpncpy
+#  endif
+_GL_FUNCDECL_RPL (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (stpncpy, char *,
+                  (char *restrict __dst, char const *restrict __src,
+                   size_t __n));
+# endif
+_GL_CXXALIASWARN (stpncpy);
+#elif defined GNULIB_POSIXCHECK
+# undef stpncpy
+# if HAVE_RAW_DECL_STPNCPY
+_GL_WARN_ON_USE (stpncpy, "stpncpy is unportable - "
+                 "use gnulib module stpncpy for portability");
+# endif
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strchr
+/* Assume strchr is always declared.  */
+_GL_WARN_ON_USE (strchr, "strchr cannot work correctly on character strings "
+                 "in some multibyte locales - "
+                 "use mbschr if you care about internationalization");
+#endif
+
+/* Find the first occurrence of C in S or the final NUL byte.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strchrnul rpl_strchrnul
+#  endif
+_GL_FUNCDECL_RPL (strchrnul, char *, (const char *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strchrnul, char *,
+                  (const char *str, int ch));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strchrnul, char *, (char const *__s, int __c_in)
+                                     _GL_ATTRIBUTE_PURE
+                                     _GL_ARG_NONNULL ((1)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * std::strchrnul (const char *, int); }
+       extern "C++" { char * std::strchrnul (char *, int); }  */
+_GL_CXXALIAS_SYS_CAST2 (strchrnul,
+                        char *, (char const *__s, int __c_in),
+                        char const *, (char const *__s, int __c_in));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strchrnul, char *, (char *__s, int __c_in));
+_GL_CXXALIASWARN1 (strchrnul, char const *, (char const *__s, int __c_in));
+# else
+_GL_CXXALIASWARN (strchrnul);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strchrnul
+# if HAVE_RAW_DECL_STRCHRNUL
+_GL_WARN_ON_USE (strchrnul, "strchrnul is unportable - "
+                 "use gnulib module strchrnul for portability");
+# endif
+#endif
+
+/* Duplicate S, returning an identical malloc'd string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strdup
+#   define strdup rpl_strdup
+#  endif
+_GL_FUNCDECL_RPL (strdup, char *, (char const *__s) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strdup, char *, (char const *__s));
+# else
+#  if defined __cplusplus && defined GNULIB_NAMESPACE && defined strdup
+    /* strdup exists as a function and as a macro.  Get rid of the macro.  */
+#   undef strdup
+#  endif
+#  if !(1 || defined strdup)
+_GL_FUNCDECL_SYS (strdup, char *, (char const *__s) _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strdup, char *, (char const *__s));
+# endif
+_GL_CXXALIASWARN (strdup);
+#elif defined GNULIB_POSIXCHECK
+# undef strdup
+# if HAVE_RAW_DECL_STRDUP
+_GL_WARN_ON_USE (strdup, "strdup is unportable - "
+                 "use gnulib module strdup for portability");
+# endif
+#endif
+
+/* Append no more than N characters from SRC onto DEST.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strncat
+#   define strncat rpl_strncat
+#  endif
+_GL_FUNCDECL_RPL (strncat, char *, (char *dest, const char *src, size_t n)
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strncat, char *, (char *dest, const char *src, size_t n));
+# else
+_GL_CXXALIAS_SYS (strncat, char *, (char *dest, const char *src, size_t n));
+# endif
+_GL_CXXALIASWARN (strncat);
+#elif defined GNULIB_POSIXCHECK
+# undef strncat
+# if HAVE_RAW_DECL_STRNCAT
+_GL_WARN_ON_USE (strncat, "strncat is unportable - "
+                 "use gnulib module strncat for portability");
+# endif
+#endif
+
+/* Return a newly allocated copy of at most N bytes of STRING.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strndup
+#   define strndup rpl_strndup
+#  endif
+_GL_FUNCDECL_RPL (strndup, char *, (char const *__s, size_t __n)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strndup, char *, (char const *__s, size_t __n));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strndup, char *, (char const *__s, size_t __n)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strndup, char *, (char const *__s, size_t __n));
+# endif
+_GL_CXXALIASWARN (strndup);
+#elif defined GNULIB_POSIXCHECK
+# undef strndup
+# if HAVE_RAW_DECL_STRNDUP
+_GL_WARN_ON_USE (strndup, "strndup is unportable - "
+                 "use gnulib module strndup for portability");
+# endif
+#endif
+
+/* Find the length (number of bytes) of STRING, but scan at most
+   MAXLEN bytes.  If no '\0' terminator is found in that many bytes,
+   return MAXLEN.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strnlen
+#   define strnlen rpl_strnlen
+#  endif
+_GL_FUNCDECL_RPL (strnlen, size_t, (char const *__s, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (strnlen, size_t, (char const *__s, size_t __maxlen));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strnlen, size_t, (char const *__s, size_t __maxlen)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (strnlen, size_t, (char const *__s, size_t __maxlen));
+# endif
+_GL_CXXALIASWARN (strnlen);
+#elif defined GNULIB_POSIXCHECK
+# undef strnlen
+# if HAVE_RAW_DECL_STRNLEN
+_GL_WARN_ON_USE (strnlen, "strnlen is unportable - "
+                 "use gnulib module strnlen for portability");
+# endif
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strcspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+# undef strcspn
+/* Assume strcspn is always declared.  */
+_GL_WARN_ON_USE (strcspn, "strcspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbscspn if you care about internationalization");
+#endif
+
+/* Find the first occurrence in S of any character in ACCEPT.  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (strpbrk, char *, (char const *__s, char const *__accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C" { const char * strpbrk (const char *, const char *); }
+       extern "C++" { char * strpbrk (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strpbrk,
+                        char *, (char const *__s, char const *__accept),
+                        const char *, (char const *__s, char const *__accept));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strpbrk, char *, (char *__s, char const *__accept));
+_GL_CXXALIASWARN1 (strpbrk, char const *,
+                   (char const *__s, char const *__accept));
+# else
+_GL_CXXALIASWARN (strpbrk);
+# endif
+# if defined GNULIB_POSIXCHECK
+/* strpbrk() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it does not work with multibyte strings if the
+   locale encoding is GB18030 and one of the characters to be searched is a
+   digit.  */
+#  undef strpbrk
+_GL_WARN_ON_USE (strpbrk, "strpbrk cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbspbrk if you care about internationalization");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strpbrk
+# if HAVE_RAW_DECL_STRPBRK
+_GL_WARN_ON_USE (strpbrk, "strpbrk is unportable - "
+                 "use gnulib module strpbrk for portability");
+# endif
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strspn() assumes the second argument is a list of single-byte characters.
+   Even in this simple case, it cannot work with multibyte strings.  */
+# undef strspn
+/* Assume strspn is always declared.  */
+_GL_WARN_ON_USE (strspn, "strspn cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbsspn if you care about internationalization");
+#endif
+
+#if defined GNULIB_POSIXCHECK
+/* strrchr() does not work with multibyte strings if the locale encoding is
+   GB18030 and the character to be searched is a digit.  */
+# undef strrchr
+/* Assume strrchr is always declared.  */
+_GL_WARN_ON_USE (strrchr, "strrchr cannot work correctly on character strings "
+                 "in some multibyte locales - "
+                 "use mbsrchr if you care about internationalization");
+#endif
+
+/* Search the next delimiter (char listed in DELIM) starting at *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP
+   to point to the next char after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of strtok() that is multithread-safe and supports
+   empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strtok_r().  */
+#if 0
+# if ! 1
+_GL_FUNCDECL_SYS (strsep, char *,
+                  (char **restrict __stringp, char const *restrict __delim)
+                  _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (strsep, char *,
+                  (char **restrict __stringp, char const *restrict __delim));
+_GL_CXXALIASWARN (strsep);
+# if defined GNULIB_POSIXCHECK
+#  undef strsep
+_GL_WARN_ON_USE (strsep, "strsep cannot work correctly on character strings "
+                 "in multibyte locales - "
+                 "use mbssep if you care about internationalization");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strsep
+# if HAVE_RAW_DECL_STRSEP
+_GL_WARN_ON_USE (strsep, "strsep is unportable - "
+                 "use gnulib module strsep for portability");
+# endif
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strstr rpl_strstr
+#  endif
+_GL_FUNCDECL_RPL (strstr, char *, (const char *haystack, const char *needle)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strstr, char *, (const char *haystack, const char *needle));
+# else
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strstr (const char *, const char *); }
+       extern "C++" { char * strstr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strstr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strstr, char *, (char *haystack, const char *needle));
+_GL_CXXALIASWARN1 (strstr, const char *,
+                   (const char *haystack, const char *needle));
+# else
+_GL_CXXALIASWARN (strstr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strstr() does not work with multibyte strings if the locale encoding is
+   different from UTF-8:
+   POSIX says that it operates on "strings", and "string" in POSIX is defined
+   as a sequence of bytes, not of characters.  */
+# undef strstr
+/* Assume strstr is always declared.  */
+_GL_WARN_ON_USE (strstr, "strstr is quadratic on many systems, and cannot "
+                 "work correctly on character strings in most "
+                 "multibyte locales - "
+                 "use mbsstr if you care about internationalization, "
+                 "or use strstr if you care about speed");
+#endif
+
+/* Find the first occurrence of NEEDLE in HAYSTACK, using case-insensitive
+   comparison.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strcasestr rpl_strcasestr
+#  endif
+_GL_FUNCDECL_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (strcasestr, char *,
+                  (const char *haystack, const char *needle));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strcasestr, char *,
+                  (const char *haystack, const char *needle)
+                  _GL_ATTRIBUTE_PURE
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" { const char * strcasestr (const char *, const char *); }
+       extern "C++" { char * strcasestr (char *, const char *); }  */
+_GL_CXXALIAS_SYS_CAST2 (strcasestr,
+                        char *, (const char *haystack, const char *needle),
+                        const char *, (const char *haystack, const char *needle));
+# endif
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (strcasestr, char *, (char *haystack, const char *needle));
+_GL_CXXALIASWARN1 (strcasestr, const char *,
+                   (const char *haystack, const char *needle));
+# else
+_GL_CXXALIASWARN (strcasestr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+/* strcasestr() does not work with multibyte strings:
+   It is a glibc extension, and glibc implements it only for unibyte
+   locales.  */
+# undef strcasestr
+# if HAVE_RAW_DECL_STRCASESTR
+_GL_WARN_ON_USE (strcasestr, "strcasestr does work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbscasestr if you care about "
+                 "internationalization, or use c-strcasestr if you want "
+                 "a locale independent function");
+# endif
+#endif
+
+/* Parse S into tokens separated by characters in DELIM.
+   If S is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = strtok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = strtok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = strtok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
+
+   This is a variant of strtok() that is multithread-safe.
+
+   For the POSIX documentation for this function, see:
+   http://www.opengroup.org/susv3xsh/strtok.html
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+   Caveat: It doesn't work with multibyte strings unless all of the delimiter
+           characters are ASCII characters < 0x30.
+
+   See also strsep().  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strtok_r
+#   define strtok_r rpl_strtok_r
+#  endif
+_GL_FUNCDECL_RPL (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr));
+# else
+#  if 0 || defined GNULIB_POSIXCHECK
+#   undef strtok_r
+#  endif
+#  if ! 1
+_GL_FUNCDECL_SYS (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strtok_r, char *,
+                  (char *restrict s, char const *restrict delim,
+                   char **restrict save_ptr));
+# endif
+_GL_CXXALIASWARN (strtok_r);
+# if defined GNULIB_POSIXCHECK
+_GL_WARN_ON_USE (strtok_r, "strtok_r cannot work correctly on character "
+                 "strings in multibyte locales - "
+                 "use mbstok_r if you care about internationalization");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strtok_r
+# if HAVE_RAW_DECL_STRTOK_R
+_GL_WARN_ON_USE (strtok_r, "strtok_r is unportable - "
+                 "use gnulib module strtok_r for portability");
+# endif
+#endif
+
+
+/* The following functions are not specified by POSIX.  They are gnulib
+   extensions.  */
+
+#if 0
+/* Return the number of multibyte characters in the character string STRING.
+   This considers multibyte characters, unlike strlen, which counts bytes.  */
+# ifdef __MirBSD__  /* MirBSD defines mbslen as a macro.  Override it.  */
+#  undef mbslen
+# endif
+# if 0  /* AIX, OSF/1, MirBSD define mbslen already in libc.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbslen rpl_mbslen
+#  endif
+_GL_FUNCDECL_RPL (mbslen, size_t, (const char *string)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbslen, size_t, (const char *string));
+# else
+_GL_FUNCDECL_SYS (mbslen, size_t, (const char *string)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbslen, size_t, (const char *string));
+# endif
+_GL_CXXALIASWARN (mbslen);
+#endif
+
+#if 0
+/* Return the number of multibyte characters in the character string starting
+   at STRING and ending at STRING + LEN.  */
+_GL_EXTERN_C size_t mbsnlen (const char *string, size_t len)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1));
+#endif
+
+#if 0
+/* Locate the first single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbschr rpl_mbschr /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbschr, char *, (const char *string, int c)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbschr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbschr, char *, (const char *string, int c)
+                                  _GL_ATTRIBUTE_PURE
+                                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbschr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbschr);
+#endif
+
+#if 0
+/* Locate the last single-byte character C in the character string STRING,
+   and return a pointer to it.  Return NULL if C is not found in STRING.
+   Unlike strrchr(), this function works correctly in multibyte locales with
+   encodings such as GB18030.  */
+# if defined __hpux || defined __INTERIX
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbsrchr rpl_mbsrchr /* avoid collision with system function */
+#  endif
+_GL_FUNCDECL_RPL (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mbsrchr, char *, (const char *string, int c));
+# else
+_GL_FUNCDECL_SYS (mbsrchr, char *, (const char *string, int c)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (mbsrchr, char *, (const char *string, int c));
+# endif
+_GL_CXXALIASWARN (mbsrchr);
+#endif
+
+#if 0
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK.  Return NULL if NEEDLE is not found in HAYSTACK.
+   Unlike strstr(), this function works correctly in multibyte locales with
+   encodings different from UTF-8.  */
+_GL_EXTERN_C char * mbsstr (const char *haystack, const char *needle)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Compare the character strings S1 and S2, ignoring case, returning less than,
+   equal to or greater than zero if S1 is lexicographically less than, equal to
+   or greater than S2.
+   Note: This function may, in multibyte locales, return 0 for strings of
+   different lengths!
+   Unlike strcasecmp(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C int mbscasecmp (const char *s1, const char *s2)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Compare the initial segment of the character string S1 consisting of at most
+   N characters with the initial segment of the character string S2 consisting
+   of at most N characters, ignoring case, returning less than, equal to or
+   greater than zero if the initial segment of S1 is lexicographically less
+   than, equal to or greater than the initial segment of S2.
+   Note: This function may, in multibyte locales, return 0 for initial segments
+   of different lengths!
+   Unlike strncasecmp(), this function works correctly in multibyte locales.
+   But beware that N is not a byte count but a character count!  */
+_GL_EXTERN_C int mbsncasecmp (const char *s1, const char *s2, size_t n)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Compare the initial segment of the character string STRING consisting of
+   at most mbslen (PREFIX) characters with the character string PREFIX,
+   ignoring case.  If the two match, return a pointer to the first byte
+   after this prefix in STRING.  Otherwise, return NULL.
+   Note: This function may, in multibyte locales, return non-NULL if STRING
+   is of smaller length than PREFIX!
+   Unlike strncasecmp(), this function works correctly in multibyte
+   locales.  */
+_GL_EXTERN_C char * mbspcasecmp (const char *string, const char *prefix)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Find the first occurrence of the character string NEEDLE in the character
+   string HAYSTACK, using case-insensitive comparison.
+   Note: This function may, in multibyte locales, return success even if
+   strlen (haystack) < strlen (needle) !
+   Unlike strcasestr(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C char * mbscasestr (const char *haystack, const char *needle)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strcspn(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C size_t mbscspn (const char *string, const char *accept)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Find the first occurrence in the character string STRING of any character
+   in the character string ACCEPT.  Return the pointer to it, or NULL if none
+   exists.
+   Unlike strpbrk(), this function works correctly in multibyte locales.  */
+# if defined __hpux
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mbspbrk rpl_mbspbrk /* avoid collision with HP-UX function */
+#  endif
+_GL_FUNCDECL_RPL (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (mbspbrk, char *, (const char *string, const char *accept));
+# else
+_GL_FUNCDECL_SYS (mbspbrk, char *, (const char *string, const char *accept)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_SYS (mbspbrk, char *, (const char *string, const char *accept));
+# endif
+_GL_CXXALIASWARN (mbspbrk);
+#endif
+
+#if 0
+/* Find the first occurrence in the character string STRING of any character
+   not in the character string REJECT.  Return the number of bytes from the
+   beginning of the string to this occurrence, or to the end of the string
+   if none exists.
+   Unlike strspn(), this function works correctly in multibyte locales.  */
+_GL_EXTERN_C size_t mbsspn (const char *string, const char *reject)
+     _GL_ATTRIBUTE_PURE
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Search the next delimiter (multibyte character listed in the character
+   string DELIM) starting at the character string *STRINGP.
+   If one is found, overwrite it with a NUL, and advance *STRINGP to point
+   to the next multibyte character after it.  Otherwise, set *STRINGP to NULL.
+   If *STRINGP was already NULL, nothing happens.
+   Return the old value of *STRINGP.
+
+   This is a variant of mbstok_r() that supports empty fields.
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbstok_r().  */
+_GL_EXTERN_C char * mbssep (char **stringp, const char *delim)
+     _GL_ARG_NONNULL ((1, 2));
+#endif
+
+#if 0
+/* Parse the character string STRING into tokens separated by characters in
+   the character string DELIM.
+   If STRING is NULL, the saved pointer in SAVE_PTR is used as
+   the next starting point.  For example:
+        char s[] = "-abc-=-def";
+        char *sp;
+        x = mbstok_r(s, "-", &sp);      // x = "abc", sp = "=-def"
+        x = mbstok_r(NULL, "-=", &sp);  // x = "def", sp = NULL
+        x = mbstok_r(NULL, "=", &sp);   // x = NULL
+                // s = "abc\0-def\0"
+
+   Caveat: It modifies the original string.
+   Caveat: These functions cannot be used on constant strings.
+   Caveat: The identity of the delimiting character is lost.
+
+   See also mbssep().  */
+_GL_EXTERN_C char * mbstok_r (char *string, const char *delim, char **save_ptr)
+     _GL_ARG_NONNULL ((2, 3));
+#endif
+
+/* Map any int, typically from errno, into an error message.  */
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerror
+#   define strerror rpl_strerror
+#  endif
+_GL_FUNCDECL_RPL (strerror, char *, (int));
+_GL_CXXALIAS_RPL (strerror, char *, (int));
+# else
+_GL_CXXALIAS_SYS (strerror, char *, (int));
+# endif
+_GL_CXXALIASWARN (strerror);
+#elif defined GNULIB_POSIXCHECK
+# undef strerror
+/* Assume strerror is always declared.  */
+_GL_WARN_ON_USE (strerror, "strerror is unportable - "
+                 "use gnulib module strerror to guarantee non-NULL result");
+#endif
+
+/* Map any int, typically from errno, into an error message.  Multithread-safe.
+   Uses the POSIX declaration, not the glibc declaration.  */
+#if IN_AUGEAS_GNULIB_TESTS
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef strerror_r
+#   define strerror_r rpl_strerror_r
+#  endif
+_GL_FUNCDECL_RPL (strerror_r, int, (int errnum, char *buf, size_t buflen)
+                                   _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (strerror_r, int, (int errnum, char *buf, size_t buflen));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (strerror_r, int, (int errnum, char *buf, size_t buflen)
+                                   _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (strerror_r, int, (int errnum, char *buf, size_t buflen));
+# endif
+# if 1
+_GL_CXXALIASWARN (strerror_r);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef strerror_r
+# if HAVE_RAW_DECL_STRERROR_R
+_GL_WARN_ON_USE (strerror_r, "strerror_r is unportable - "
+                 "use gnulib module strerror_r-posix for portability");
+# endif
+#endif
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define strsignal rpl_strsignal
+#  endif
+_GL_FUNCDECL_RPL (strsignal, char *, (int __sig));
+_GL_CXXALIAS_RPL (strsignal, char *, (int __sig));
+# else
+#  if ! 1
+_GL_FUNCDECL_SYS (strsignal, char *, (int __sig));
+#  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is
+   'const char *'.  */
+_GL_CXXALIAS_SYS_CAST (strsignal, char *, (int __sig));
+# endif
+_GL_CXXALIASWARN (strsignal);
+#elif defined GNULIB_POSIXCHECK
+# undef strsignal
+# if HAVE_RAW_DECL_STRSIGNAL
+_GL_WARN_ON_USE (strsignal, "strsignal is unportable - "
+                 "use gnulib module strsignal for portability");
+# endif
+#endif
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (strverscmp, int, (const char *, const char *)
+                                   _GL_ATTRIBUTE_PURE
+                                   _GL_ARG_NONNULL ((1, 2)));
+# endif
+_GL_CXXALIAS_SYS (strverscmp, int, (const char *, const char *));
+_GL_CXXALIASWARN (strverscmp);
+#elif defined GNULIB_POSIXCHECK
+# undef strverscmp
+# if HAVE_RAW_DECL_STRVERSCMP
+_GL_WARN_ON_USE (strverscmp, "strverscmp is unportable - "
+                 "use gnulib module strverscmp for portability");
+# endif
+#endif
+
+
+#endif /* _GL_STRING_H */
+#endif /* _GL_STRING_H */
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/stat.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/stat.h
new file mode 100644
index 000000000..90d6bc768
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/stat.h
@@ -0,0 +1,1297 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Provide a more complete sys/stat.h header file.
+   Copyright (C) 2005-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake, Paul Eggert, and Jim Meyering.  */
+
+/* This file is supposed to be used on platforms where <sys/stat.h> is
+   incomplete.  It is intended to provide definitions and prototypes
+   needed by an application.  Start with what the system provides.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if defined __need_system_sys_stat_h
+/* Special invocation convention.  */
+
+#include_next <sys/stat.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_SYS_STAT_H
+
+/* Get nlink_t.
+   May also define off_t to a 64-bit type on native Windows.  */
+#include <sys/types.h>
+
+/* Get struct timespec.  */
+#include <time.h>
+
+/* The include_next requires a split double-inclusion guard.  */
+#include_next <sys/stat.h>
+
+#ifndef _GL_SYS_STAT_H
+#define _GL_SYS_STAT_H
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Before doing "#define mknod rpl_mknod" below, we need to include all
+   headers that may declare mknod().  OS/2 kLIBC declares mknod() in
+   <unistd.h>, not in <sys/stat.h>.  */
+#ifdef __KLIBC__
+# include <unistd.h>
+#endif
+
+/* Before doing "#define mkdir rpl_mkdir" below, we need to include all
+   headers that may declare mkdir().  Native Windows platforms declare mkdir
+   in <io.h> and/or <direct.h>, not in <sys/stat.h>.  */
+#if defined _WIN32 && ! defined __CYGWIN__
+# include <io.h>     /* mingw32, mingw64 */
+# include <direct.h> /* mingw64, MSVC 9 */
+#endif
+
+/* Native Windows platforms declare umask() in <io.h>.  */
+#if 0 && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+/* Large File Support on native Windows.  */
+#if 0
+# define stat _stati64
+#endif
+
+/* Optionally, override 'struct stat' on native Windows.  */
+#if 0
+
+# undef stat
+# if 1
+#  define stat rpl_stat
+# else
+   /* Provoke a clear link error if stat() is used as a function and
+      module 'stat' is not in use.  */
+#  define stat stat_used_without_requesting_gnulib_module_stat
+# endif
+
+# if !GNULIB_defined_struct_stat
+struct stat
+{
+  dev_t st_dev;
+  ino_t st_ino;
+  mode_t st_mode;
+  nlink_t st_nlink;
+#  if 0
+  uid_t st_uid;
+#  else /* uid_t is not defined by default on native Windows.  */
+  short st_uid;
+#  endif
+#  if 0
+  gid_t st_gid;
+#  else /* gid_t is not defined by default on native Windows.  */
+  short st_gid;
+#  endif
+  dev_t st_rdev;
+  off_t st_size;
+#  if 0
+  blksize_t st_blksize;
+  blkcnt_t st_blocks;
+#  endif
+
+#  if 0
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+#  else
+  time_t st_atime;
+  time_t st_mtime;
+  time_t st_ctime;
+#  endif
+};
+#  if 0
+#   define st_atime st_atim.tv_sec
+#   define st_mtime st_mtim.tv_sec
+#   define st_ctime st_ctim.tv_sec
+    /* Indicator, for gnulib internal purposes.  */
+#   define _GL_WINDOWS_STAT_TIMESPEC 1
+#  endif
+#  define GNULIB_defined_struct_stat 1
+# endif
+
+/* Other possible values of st_mode.  */
+# if 0
+#  define _S_IFBLK  0x6000
+# endif
+# if 0
+#  define _S_IFLNK  0xA000
+# endif
+# if 0
+#  define _S_IFSOCK 0xC000
+# endif
+
+#endif
+
+#ifndef S_IFIFO
+# ifdef _S_IFIFO
+#  define S_IFIFO _S_IFIFO
+# endif
+#endif
+
+#ifndef S_IFMT
+# define S_IFMT 0170000
+#endif
+
+#if STAT_MACROS_BROKEN
+# undef S_ISBLK
+# undef S_ISCHR
+# undef S_ISDIR
+# undef S_ISFIFO
+# undef S_ISLNK
+# undef S_ISNAM
+# undef S_ISMPB
+# undef S_ISMPC
+# undef S_ISNWK
+# undef S_ISREG
+# undef S_ISSOCK
+#endif
+
+#ifndef S_ISBLK
+# ifdef S_IFBLK
+#  define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
+# else
+#  define S_ISBLK(m) 0
+# endif
+#endif
+
+#ifndef S_ISCHR
+# ifdef S_IFCHR
+#  define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
+# else
+#  define S_ISCHR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDIR
+# ifdef S_IFDIR
+#  define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+# else
+#  define S_ISDIR(m) 0
+# endif
+#endif
+
+#ifndef S_ISDOOR /* Solaris 2.5 and up */
+# define S_ISDOOR(m) 0
+#endif
+
+#ifndef S_ISFIFO
+# ifdef S_IFIFO
+#  define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
+# else
+#  define S_ISFIFO(m) 0
+# endif
+#endif
+
+#ifndef S_ISLNK
+# ifdef S_IFLNK
+#  define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
+# else
+#  define S_ISLNK(m) 0
+# endif
+#endif
+
+#ifndef S_ISMPB /* V7 */
+# ifdef S_IFMPB
+#  define S_ISMPB(m) (((m) & S_IFMT) == S_IFMPB)
+#  define S_ISMPC(m) (((m) & S_IFMT) == S_IFMPC)
+# else
+#  define S_ISMPB(m) 0
+#  define S_ISMPC(m) 0
+# endif
+#endif
+
+#ifndef S_ISMPX /* AIX */
+# define S_ISMPX(m) 0
+#endif
+
+#ifndef S_ISNAM /* Xenix */
+# ifdef S_IFNAM
+#  define S_ISNAM(m) (((m) & S_IFMT) == S_IFNAM)
+# else
+#  define S_ISNAM(m) 0
+# endif
+#endif
+
+#ifndef S_ISNWK /* HP/UX */
+# ifdef S_IFNWK
+#  define S_ISNWK(m) (((m) & S_IFMT) == S_IFNWK)
+# else
+#  define S_ISNWK(m) 0
+# endif
+#endif
+
+#ifndef S_ISPORT /* Solaris 10 and up */
+# define S_ISPORT(m) 0
+#endif
+
+#ifndef S_ISREG
+# ifdef S_IFREG
+#  define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+# else
+#  define S_ISREG(m) 0
+# endif
+#endif
+
+#ifndef S_ISSOCK
+# ifdef S_IFSOCK
+#  define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)
+# else
+#  define S_ISSOCK(m) 0
+# endif
+#endif
+
+
+#ifndef S_TYPEISMQ
+# define S_TYPEISMQ(p) 0
+#endif
+
+#ifndef S_TYPEISTMO
+# define S_TYPEISTMO(p) 0
+#endif
+
+
+#ifndef S_TYPEISSEM
+# ifdef S_INSEM
+#  define S_TYPEISSEM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSEM)
+# else
+#  define S_TYPEISSEM(p) 0
+# endif
+#endif
+
+#ifndef S_TYPEISSHM
+# ifdef S_INSHD
+#  define S_TYPEISSHM(p) (S_ISNAM ((p)->st_mode) && (p)->st_rdev == S_INSHD)
+# else
+#  define S_TYPEISSHM(p) 0
+# endif
+#endif
+
+/* high performance ("contiguous data") */
+#ifndef S_ISCTG
+# define S_ISCTG(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with data  */
+#ifndef S_ISOFD
+# define S_ISOFD(p) 0
+#endif
+
+/* Cray DMF (data migration facility): off line, with no data  */
+#ifndef S_ISOFL
+# define S_ISOFL(p) 0
+#endif
+
+/* 4.4BSD whiteout */
+#ifndef S_ISWHT
+# define S_ISWHT(m) 0
+#endif
+
+/* If any of the following are undefined,
+   define them to their de facto standard values.  */
+#if !S_ISUID
+# define S_ISUID 04000
+#endif
+#if !S_ISGID
+# define S_ISGID 02000
+#endif
+
+/* S_ISVTX is a common extension to POSIX.  */
+#ifndef S_ISVTX
+# define S_ISVTX 01000
+#endif
+
+#if !S_IRUSR && S_IREAD
+# define S_IRUSR S_IREAD
+#endif
+#if !S_IRUSR
+# define S_IRUSR 00400
+#endif
+#if !S_IRGRP
+# define S_IRGRP (S_IRUSR >> 3)
+#endif
+#if !S_IROTH
+# define S_IROTH (S_IRUSR >> 6)
+#endif
+
+#if !S_IWUSR && S_IWRITE
+# define S_IWUSR S_IWRITE
+#endif
+#if !S_IWUSR
+# define S_IWUSR 00200
+#endif
+#if !S_IWGRP
+# define S_IWGRP (S_IWUSR >> 3)
+#endif
+#if !S_IWOTH
+# define S_IWOTH (S_IWUSR >> 6)
+#endif
+
+#if !S_IXUSR && S_IEXEC
+# define S_IXUSR S_IEXEC
+#endif
+#if !S_IXUSR
+# define S_IXUSR 00100
+#endif
+#if !S_IXGRP
+# define S_IXGRP (S_IXUSR >> 3)
+#endif
+#if !S_IXOTH
+# define S_IXOTH (S_IXUSR >> 6)
+#endif
+
+#if !S_IRWXU
+# define S_IRWXU (S_IRUSR | S_IWUSR | S_IXUSR)
+#endif
+#if !S_IRWXG
+# define S_IRWXG (S_IRGRP | S_IWGRP | S_IXGRP)
+#endif
+#if !S_IRWXO
+# define S_IRWXO (S_IROTH | S_IWOTH | S_IXOTH)
+#endif
+
+/* S_IXUGO is a common extension to POSIX.  */
+#if !S_IXUGO
+# define S_IXUGO (S_IXUSR | S_IXGRP | S_IXOTH)
+#endif
+
+#ifndef S_IRWXUGO
+# define S_IRWXUGO (S_IRWXU | S_IRWXG | S_IRWXO)
+#endif
+
+/* Macros for futimens and utimensat.  */
+#ifndef UTIME_NOW
+# define UTIME_NOW (-1)
+# define UTIME_OMIT (-2)
+#endif
+
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (fchmodat, int,
+                  (int fd, char const *file, mode_t mode, int flag));
+_GL_CXXALIASWARN (fchmodat);
+#elif defined GNULIB_POSIXCHECK
+# undef fchmodat
+# if HAVE_RAW_DECL_FCHMODAT
+_GL_WARN_ON_USE (fchmodat, "fchmodat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fstat
+#   define fstat rpl_fstat
+#  endif
+_GL_FUNCDECL_RPL (fstat, int, (int fd, struct stat *buf) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fstat, int, (int fd, struct stat *buf));
+# else
+_GL_CXXALIAS_SYS (fstat, int, (int fd, struct stat *buf));
+# endif
+_GL_CXXALIASWARN (fstat);
+#elif 0
+# undef fstat
+# define fstat fstat_used_without_requesting_gnulib_module_fstat
+#elif 0
+/* Above, we define stat to _stati64.  */
+# define fstat _fstati64
+#elif defined GNULIB_POSIXCHECK
+# undef fstat
+# if HAVE_RAW_DECL_FSTAT
+_GL_WARN_ON_USE (fstat, "fstat has portability problems - "
+                 "use gnulib module fstat for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fstatat
+#   define fstatat rpl_fstatat
+#  endif
+_GL_FUNCDECL_RPL (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (fstatat, int,
+                  (int fd, char const *name, struct stat *st, int flags));
+# endif
+_GL_CXXALIASWARN (fstatat);
+#elif 0
+# undef fstatat
+# define fstatat fstatat_used_without_requesting_gnulib_module_fstatat
+#elif defined GNULIB_POSIXCHECK
+# undef fstatat
+# if HAVE_RAW_DECL_FSTATAT
+_GL_WARN_ON_USE (fstatat, "fstatat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Use the rpl_ prefix also on Solaris <= 9, because on Solaris 9 our futimens
+   implementation relies on futimesat, which on Solaris 10 makes an invocation
+   to futimens that is meant to invoke the libc's futimens(), not gnulib's
+   futimens().  */
+# if 0 || (!1 && defined __sun)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef futimens
+#   define futimens rpl_futimens
+#  endif
+_GL_FUNCDECL_RPL (futimens, int, (int fd, struct timespec const times[2]));
+_GL_CXXALIAS_RPL (futimens, int, (int fd, struct timespec const times[2]));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (futimens, int, (int fd, struct timespec const times[2]));
+#  endif
+_GL_CXXALIAS_SYS (futimens, int, (int fd, struct timespec const times[2]));
+# endif
+# if 1
+_GL_CXXALIASWARN (futimens);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef futimens
+# if HAVE_RAW_DECL_FUTIMENS
+_GL_WARN_ON_USE (futimens, "futimens is not portable - "
+                 "use gnulib module futimens for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the mode of FILENAME to MODE, without dereferencing it if FILENAME
+   denotes a symbolic link.  */
+# if !1
+/* The lchmod replacement follows symbolic links.  Callers should take
+   this into account; lchmod should be applied only to arguments that
+   are known to not be symbolic links.  On hosts that lack lchmod,
+   this can lead to race conditions between the check and the
+   invocation of lchmod, but we know of no workarounds that are
+   reliable in general.  You might try requesting support for lchmod
+   from your operating system supplier.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lchmod chmod
+#  endif
+/* Need to cast, because on mingw, the second parameter of chmod is
+                                                int mode.  */
+_GL_CXXALIAS_RPL_CAST_1 (lchmod, chmod, int,
+                         (const char *filename, mode_t mode));
+# else
+#  if 0 /* assume already declared */
+_GL_FUNCDECL_SYS (lchmod, int, (const char *filename, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (lchmod, int, (const char *filename, mode_t mode));
+# endif
+# if 1
+_GL_CXXALIASWARN (lchmod);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef lchmod
+# if HAVE_RAW_DECL_LCHMOD
+_GL_WARN_ON_USE (lchmod, "lchmod is unportable - "
+                 "use gnulib module lchmod for portability");
+# endif
+#endif
+
+
+#if 1
+# if ! 1
+/* mingw does not support symlinks, therefore it does not have lstat.  But
+   without links, stat does just fine.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lstat stat
+#  endif
+_GL_CXXALIAS_RPL_1 (lstat, stat, int, (const char *name, struct stat *buf));
+# elif 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lstat
+#   define lstat rpl_lstat
+#  endif
+_GL_FUNCDECL_RPL (lstat, int, (const char *name, struct stat *buf)
+                              _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (lstat, int, (const char *name, struct stat *buf));
+# else
+_GL_CXXALIAS_SYS (lstat, int, (const char *name, struct stat *buf));
+# endif
+# if 1
+_GL_CXXALIASWARN (lstat);
+# endif
+#elif 0
+# undef lstat
+# define lstat lstat_used_without_requesting_gnulib_module_lstat
+#elif defined GNULIB_POSIXCHECK
+# undef lstat
+# if HAVE_RAW_DECL_LSTAT
+_GL_WARN_ON_USE (lstat, "lstat is unportable - "
+                 "use gnulib module lstat for portability");
+# endif
+#endif
+
+
+#if 0
+# if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#  undef mkdir
+#  define mkdir rpl_mkdir
+# endif
+_GL_FUNCDECL_RPL (mkdir, int, (char const *name, mode_t mode)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+#else
+/* mingw's _mkdir() function has 1 argument, but we pass 2 arguments.
+   Additionally, it declares _mkdir (and depending on compile flags, an
+   alias mkdir), only in the nonstandard includes <direct.h> and <io.h>,
+   which are included above.  */
+# if defined _WIN32 && ! defined __CYGWIN__
+
+#  if !GNULIB_defined_rpl_mkdir
+static int
+rpl_mkdir (char const *name, mode_t mode)
+{
+  return _mkdir (name);
+}
+#   define GNULIB_defined_rpl_mkdir 1
+#  endif
+
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define mkdir rpl_mkdir
+#  endif
+_GL_CXXALIAS_RPL (mkdir, int, (char const *name, mode_t mode));
+# else
+_GL_CXXALIAS_SYS (mkdir, int, (char const *name, mode_t mode));
+# endif
+#endif
+_GL_CXXALIASWARN (mkdir);
+
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (mkdirat, int, (int fd, char const *file, mode_t mode)
+                                _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mkdirat, int, (int fd, char const *file, mode_t mode));
+_GL_CXXALIASWARN (mkdirat);
+#elif defined GNULIB_POSIXCHECK
+# undef mkdirat
+# if HAVE_RAW_DECL_MKDIRAT
+_GL_WARN_ON_USE (mkdirat, "mkdirat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mkfifo
+#   define mkfifo rpl_mkfifo
+#  endif
+_GL_FUNCDECL_RPL (mkfifo, int, (char const *file, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mkfifo, int, (char const *file, mode_t mode));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mkfifo, int, (char const *file, mode_t mode)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (mkfifo, int, (char const *file, mode_t mode));
+# endif
+_GL_CXXALIASWARN (mkfifo);
+#elif defined GNULIB_POSIXCHECK
+# undef mkfifo
+# if HAVE_RAW_DECL_MKFIFO
+_GL_WARN_ON_USE (mkfifo, "mkfifo is not portable - "
+                 "use gnulib module mkfifo for portability");
+# endif
+#endif
+
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (mkfifoat, int, (int fd, char const *file, mode_t mode)
+                                 _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mkfifoat, int, (int fd, char const *file, mode_t mode));
+_GL_CXXALIASWARN (mkfifoat);
+#elif defined GNULIB_POSIXCHECK
+# undef mkfifoat
+# if HAVE_RAW_DECL_MKFIFOAT
+_GL_WARN_ON_USE (mkfifoat, "mkfifoat is not portable - "
+                 "use gnulib module mkfifoat for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mknod
+#   define mknod rpl_mknod
+#  endif
+_GL_FUNCDECL_RPL (mknod, int, (char const *file, mode_t mode, dev_t dev)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mknod, int, (char const *file, mode_t mode, dev_t dev));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mknod, int, (char const *file, mode_t mode, dev_t dev)
+                              _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on OSF/1 5.1, the third parameter is '...'.  */
+_GL_CXXALIAS_SYS_CAST (mknod, int, (char const *file, mode_t mode, dev_t dev));
+# endif
+_GL_CXXALIASWARN (mknod);
+#elif defined GNULIB_POSIXCHECK
+# undef mknod
+# if HAVE_RAW_DECL_MKNOD
+_GL_WARN_ON_USE (mknod, "mknod is not portable - "
+                 "use gnulib module mknod for portability");
+# endif
+#endif
+
+
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev)
+                  _GL_ARG_NONNULL ((2)));
+# endif
+_GL_CXXALIAS_SYS (mknodat, int,
+                  (int fd, char const *file, mode_t mode, dev_t dev));
+_GL_CXXALIASWARN (mknodat);
+#elif defined GNULIB_POSIXCHECK
+# undef mknodat
+# if HAVE_RAW_DECL_MKNODAT
+_GL_WARN_ON_USE (mknodat, "mknodat is not portable - "
+                 "use gnulib module mkfifoat for portability");
+# endif
+#endif
+
+
+#if 1
+# if 0
+#  if !0
+    /* We can't use the object-like #define stat rpl_stat, because of
+       struct stat.  This means that rpl_stat will not be used if the user
+       does (stat)(a,b).  Oh well.  */
+#   if defined _AIX && defined stat && defined _LARGE_FILES
+     /* With _LARGE_FILES defined, AIX (only) defines stat to stat64,
+        so we have to replace stat64() instead of stat(). */
+#    undef stat64
+#    define stat64(name, st) rpl_stat (name, st)
+#   elif 0
+     /* Above, we define stat to _stati64.  */
+#    if defined __MINGW32__ && defined _stati64
+#     ifndef _USE_32BIT_TIME_T
+       /* The system headers define _stati64 to _stat64.  */
+#      undef _stat64
+#      define _stat64(name, st) rpl_stat (name, st)
+#     endif
+#    elif defined _MSC_VER && defined _stati64
+#     ifdef _USE_32BIT_TIME_T
+       /* The system headers define _stati64 to _stat32i64.  */
+#      undef _stat32i64
+#      define _stat32i64(name, st) rpl_stat (name, st)
+#     else
+       /* The system headers define _stati64 to _stat64.  */
+#      undef _stat64
+#      define _stat64(name, st) rpl_stat (name, st)
+#     endif
+#    else
+#     undef _stati64
+#     define _stati64(name, st) rpl_stat (name, st)
+#    endif
+#   elif defined __MINGW32__ && defined stat
+#    ifdef _USE_32BIT_TIME_T
+      /* The system headers define stat to _stat32i64.  */
+#     undef _stat32i64
+#     define _stat32i64(name, st) rpl_stat (name, st)
+#    else
+      /* The system headers define stat to _stat64.  */
+#     undef _stat64
+#     define _stat64(name, st) rpl_stat (name, st)
+#    endif
+#   elif defined _MSC_VER && defined stat
+#    ifdef _USE_32BIT_TIME_T
+      /* The system headers define stat to _stat32.  */
+#     undef _stat32
+#     define _stat32(name, st) rpl_stat (name, st)
+#    else
+      /* The system headers define stat to _stat64i32.  */
+#     undef _stat64i32
+#     define _stat64i32(name, st) rpl_stat (name, st)
+#    endif
+#   else /* !(_AIX || __MINGW32__ || _MSC_VER) */
+#    undef stat
+#    define stat(name, st) rpl_stat (name, st)
+#   endif /* !_LARGE_FILES */
+#  endif /* !0 */
+_GL_EXTERN_C int stat (const char *name, struct stat *buf)
+                      _GL_ARG_NONNULL ((1, 2));
+# endif
+#elif 0
+/* see above:
+  #define stat stat_used_without_requesting_gnulib_module_stat
+ */
+#elif defined GNULIB_POSIXCHECK
+# undef stat
+# if HAVE_RAW_DECL_STAT
+_GL_WARN_ON_USE (stat, "stat is unportable - "
+                 "use gnulib module stat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Use the rpl_ prefix also on Solaris <= 9, because on Solaris 9 our utimensat
+   implementation relies on futimesat, which on Solaris 10 makes an invocation
+   to utimensat that is meant to invoke the libc's utimensat(), not gnulib's
+   utimensat().  */
+# if 0 || (!1 && defined __sun)
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef utimensat
+#   define utimensat rpl_utimensat
+#  endif
+_GL_FUNCDECL_RPL (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag)
+                                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (utimensat, int, (int fd, char const *name,
+                                   struct timespec const times[2], int flag));
+# endif
+# if 1
+_GL_CXXALIASWARN (utimensat);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef utimensat
+# if HAVE_RAW_DECL_UTIMENSAT
+_GL_WARN_ON_USE (utimensat, "utimensat is not portable - "
+                 "use gnulib module utimensat for portability");
+# endif
+#endif
+
+
+#endif /* _GL_SYS_STAT_H */
+#endif /* _GL_SYS_STAT_H */
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/time.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/time.h
new file mode 100644
index 000000000..c525aa948
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/time.h
@@ -0,0 +1,694 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Provide a more complete sys/time.h.
+
+   Copyright (C) 2007-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Paul Eggert.  */
+
+#ifndef _GL_SYS_TIME_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* On Cygwin and on many BSDish systems, <sys/time.h> includes itself
+   recursively via <sys/select.h>.
+   Simply delegate to the system's header in this case; it is a no-op.
+   Without this extra ifdef, the C++ gettimeofday declaration below
+   would be a forward declaration in gnulib's nested <sys/time.h>.  */
+#if defined _CYGWIN_SYS_TIME_H || defined _SYS_TIME_H || defined _SYS_TIME_H_
+# include_next <sys/time.h>
+#else
+
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# include_next <sys/time.h>
+#endif
+
+#ifndef _GL_SYS_TIME_H
+#define _GL_SYS_TIME_H
+
+#if ! 1
+# include <time.h>
+#endif
+
+/* On native Windows with MSVC, get the 'struct timeval' type.
+   Also, on native Windows with a 64-bit time_t, where we are overriding the
+   'struct timeval' type, get all declarations of system functions whose
+   signature contains 'struct timeval'.  */
+#if (defined _MSC_VER || 0) && 0 && !defined _GL_INCLUDING_WINSOCK2_H
+# define _GL_INCLUDING_WINSOCK2_H
+# include <winsock2.h>
+# undef _GL_INCLUDING_WINSOCK2_H
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if !1 || 0
+
+# if 0
+#  define timeval rpl_timeval
+# endif
+
+# if !GNULIB_defined_struct_timeval
+struct timeval
+{
+  time_t tv_sec;
+  long int tv_usec;
+};
+#  define GNULIB_defined_struct_timeval 1
+# endif
+
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef gettimeofday
+#   define gettimeofday rpl_gettimeofday
+#  endif
+_GL_FUNCDECL_RPL (gettimeofday, int,
+                  (struct timeval *restrict, void *restrict)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (gettimeofday, int,
+                  (struct timeval *restrict, void *restrict));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (gettimeofday, int,
+                  (struct timeval *restrict, void *restrict)
+                  _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on glibc systems, by default, the second argument is
+                                                  struct timezone *.  */
+_GL_CXXALIAS_SYS_CAST (gettimeofday, int,
+                       (struct timeval *restrict, void *restrict));
+# endif
+_GL_CXXALIASWARN (gettimeofday);
+# if defined __cplusplus && defined GNULIB_NAMESPACE
+namespace GNULIB_NAMESPACE {
+  typedef ::timeval
+#undef timeval
+    timeval;
+}
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef gettimeofday
+# if HAVE_RAW_DECL_GETTIMEOFDAY
+_GL_WARN_ON_USE (gettimeofday, "gettimeofday is unportable - "
+                 "use gnulib module gettimeofday for portability");
+# endif
+#endif
+
+/* Hide some function declarations from <winsock2.h>.  */
+
+#if defined _MSC_VER && 0
+# if !defined _GL_UNISTD_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef close
+#   define close close_used_without_including_unistd_h
+#  else
+     _GL_WARN_ON_USE (close,
+                      "close() used without including <unistd.h>");
+#  endif
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef gethostname
+#   define gethostname gethostname_used_without_including_unistd_h
+#  else
+     _GL_WARN_ON_USE (gethostname,
+                      "gethostname() used without including <unistd.h>");
+#  endif
+# endif
+# if !defined _GL_SYS_SOCKET_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef socket
+#   define socket              socket_used_without_including_sys_socket_h
+#   undef connect
+#   define connect             connect_used_without_including_sys_socket_h
+#   undef accept
+#   define accept              accept_used_without_including_sys_socket_h
+#   undef bind
+#   define bind                bind_used_without_including_sys_socket_h
+#   undef getpeername
+#   define getpeername         getpeername_used_without_including_sys_socket_h
+#   undef getsockname
+#   define getsockname         getsockname_used_without_including_sys_socket_h
+#   undef getsockopt
+#   define getsockopt          getsockopt_used_without_including_sys_socket_h
+#   undef listen
+#   define listen              listen_used_without_including_sys_socket_h
+#   undef recv
+#   define recv                recv_used_without_including_sys_socket_h
+#   undef send
+#   define send                send_used_without_including_sys_socket_h
+#   undef recvfrom
+#   define recvfrom            recvfrom_used_without_including_sys_socket_h
+#   undef sendto
+#   define sendto              sendto_used_without_including_sys_socket_h
+#   undef setsockopt
+#   define setsockopt          setsockopt_used_without_including_sys_socket_h
+#   undef shutdown
+#   define shutdown            shutdown_used_without_including_sys_socket_h
+#  else
+     _GL_WARN_ON_USE (socket,
+                      "socket() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (connect,
+                      "connect() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (accept,
+                      "accept() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (bind,
+                      "bind() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (getpeername,
+                      "getpeername() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (getsockname,
+                      "getsockname() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (getsockopt,
+                      "getsockopt() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (listen,
+                      "listen() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (recv,
+                      "recv() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (send,
+                      "send() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (recvfrom,
+                      "recvfrom() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (sendto,
+                      "sendto() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (setsockopt,
+                      "setsockopt() used without including <sys/socket.h>");
+     _GL_WARN_ON_USE (shutdown,
+                      "shutdown() used without including <sys/socket.h>");
+#  endif
+# endif
+# if !defined _GL_SYS_SELECT_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef select
+#   define select select_used_without_including_sys_select_h
+#  else
+     _GL_WARN_ON_USE (select,
+                      "select() used without including <sys/select.h>");
+#  endif
+# endif
+#endif
+
+#endif /* _GL_SYS_TIME_H */
+#endif /* _CYGWIN_SYS_TIME_H */
+#endif /* _GL_SYS_TIME_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/types.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/types.h
new file mode 100644
index 000000000..7f6128be1
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/types.h
@@ -0,0 +1,107 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Provide a more complete sys/types.h.
+
+   Copyright (C) 2011-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if defined _WIN32 && !defined __CYGWIN__ \
+    && (defined __need_off_t || defined __need___off64_t \
+        || defined __need_ssize_t || defined __need_time_t)
+
+/* Special invocation convention inside mingw header files.  */
+
+#include_next <sys/types.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_SYS_TYPES_H
+
+/* The include_next requires a split double-inclusion guard.  */
+# define _GL_INCLUDING_SYS_TYPES_H
+#include_next <sys/types.h>
+# undef _GL_INCLUDING_SYS_TYPES_H
+
+#ifndef _GL_SYS_TYPES_H
+#define _GL_SYS_TYPES_H
+
+/* Override off_t if Large File Support is requested on native Windows.  */
+#if 0
+/* Same as int64_t in <stdint.h>.  */
+# if defined _MSC_VER
+#  define off_t __int64
+# else
+#  define off_t long long int
+# endif
+/* Indicator, for gnulib internal purposes.  */
+# define _GL_WINDOWS_64_BIT_OFF_T 1
+#endif
+
+/* Override dev_t and ino_t if distinguishable inodes support is requested
+   on native Windows.  */
+#if 0
+
+# if 0 == 2
+/* Experimental, not useful in Windows 10.  */
+
+/* Define dev_t to a 64-bit type.  */
+#  if !defined GNULIB_defined_dev_t
+typedef unsigned long long int rpl_dev_t;
+#   undef dev_t
+#   define dev_t rpl_dev_t
+#   define GNULIB_defined_dev_t 1
+#  endif
+
+/* Define ino_t to a 128-bit type.  */
+#  if !defined GNULIB_defined_ino_t
+/* MSVC does not have a 128-bit integer type.
+   GCC has a 128-bit integer type __int128, but only on 64-bit targets.  */
+typedef struct { unsigned long long int _gl_ino[2]; } rpl_ino_t;
+#   undef ino_t
+#   define ino_t rpl_ino_t
+#   define GNULIB_defined_ino_t 1
+#  endif
+
+# else /* 0 == 1 */
+
+/* Define ino_t to a 64-bit type.  */
+#  if !defined GNULIB_defined_ino_t
+typedef unsigned long long int rpl_ino_t;
+#   undef ino_t
+#   define ino_t rpl_ino_t
+#   define GNULIB_defined_ino_t 1
+#  endif
+
+# endif
+
+/* Indicator, for gnulib internal purposes.  */
+# define _GL_WINDOWS_STAT_INODES 0
+
+#endif
+
+/* MSVC 9 defines size_t in <stddef.h>, not in <sys/types.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (defined _WIN32 && ! defined __CYGWIN__) && ! defined __GLIBC__
+# include <stddef.h>
+#endif
+
+#endif /* _GL_SYS_TYPES_H */
+#endif /* _GL_SYS_TYPES_H */
+#endif /* __need_XXX */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/wait.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/wait.h
new file mode 100644
index 000000000..f62858306
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/sys/wait.h
@@ -0,0 +1,577 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A POSIX-like <sys/wait.h>.
+   Copyright (C) 2001-2003, 2005-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+
+#ifndef _GL_SYS_WAIT_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* The include_next requires a split double-inclusion guard.  */
+#if !(defined _WIN32 && ! defined __CYGWIN__)
+# include_next <sys/wait.h>
+#endif
+
+#ifndef _GL_SYS_WAIT_H
+#define _GL_SYS_WAIT_H
+
+/* Get pid_t.  */
+#include <sys/types.h>
+
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+#if !(defined _WIN32 && ! defined __CYGWIN__)
+/* Unix API.  */
+
+/* The following macros apply to an argument x, that is a status of a process,
+   as returned by waitpid().
+   On nearly all systems, including Linux/x86, WEXITSTATUS are bits 15..8 and
+   WTERMSIG are bits 7..0, while BeOS uses the opposite.  Therefore programs
+   have to use the abstract macros.  */
+
+/* For valid x, exactly one of WIFSIGNALED(x), WIFEXITED(x), WIFSTOPPED(x)
+   is true.  */
+# ifndef WIFSIGNALED
+#  define WIFSIGNALED(x) (WTERMSIG (x) != 0 && WTERMSIG(x) != 0x7f)
+# endif
+# ifndef WIFEXITED
+#  define WIFEXITED(x) (WTERMSIG (x) == 0)
+# endif
+# ifndef WIFSTOPPED
+#  define WIFSTOPPED(x) (WTERMSIG (x) == 0x7f)
+# endif
+
+/* The termination signal. Only to be accessed if WIFSIGNALED(x) is true.  */
+# ifndef WTERMSIG
+#  define WTERMSIG(x) ((x) & 0x7f)
+# endif
+
+/* The exit status. Only to be accessed if WIFEXITED(x) is true.  */
+# ifndef WEXITSTATUS
+#  define WEXITSTATUS(x) (((x) >> 8) & 0xff)
+# endif
+
+/* The stopping signal. Only to be accessed if WIFSTOPPED(x) is true.  */
+# ifndef WSTOPSIG
+#  define WSTOPSIG(x) (((x) >> 8) & 0x7f)
+# endif
+
+/* True if the process dumped core.  Not standardized by POSIX.  */
+# ifndef WCOREDUMP
+#  define WCOREDUMP(x) ((x) & 0x80)
+# endif
+
+#else
+/* Native Windows API.  */
+
+# include <signal.h> /* for SIGTERM */
+
+/* The following macros apply to an argument x, that is a status of a process,
+   as returned by waitpid() or, equivalently, _cwait() or GetExitCodeProcess().
+   This value is simply an 'int', not composed of bit fields.  */
+
+/* When an unhandled fatal signal terminates a process, the exit code is 3.  */
+# define WIFSIGNALED(x) ((x) == 3)
+# define WIFEXITED(x) ((x) != 3)
+# define WIFSTOPPED(x) 0
+
+/* The signal that terminated a process is not known posthum.  */
+# define WTERMSIG(x) SIGTERM
+
+# define WEXITSTATUS(x) (x)
+
+/* There are no stopping signals.  */
+# define WSTOPSIG(x) 0
+
+/* There are no core dumps.  */
+# define WCOREDUMP(x) 0
+
+#endif
+
+
+/* Declarations of functions.  */
+
+#if 0
+# if defined _WIN32 && ! defined __CYGWIN__
+_GL_FUNCDECL_SYS (waitpid, pid_t, (pid_t pid, int *statusp, int options));
+# endif
+_GL_CXXALIAS_SYS (waitpid, pid_t, (pid_t pid, int *statusp, int options));
+_GL_CXXALIASWARN (waitpid);
+#elif defined GNULIB_POSIXCHECK
+# undef waitpid
+# if HAVE_RAW_DECL_WAITPID
+_GL_WARN_ON_USE (waitpid, "waitpid is unportable - "
+                 "use gnulib module sys_wait for portability");
+# endif
+#endif
+
+
+#endif /* _GL_SYS_WAIT_H */
+#endif /* _GL_SYS_WAIT_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/time.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/time.h
new file mode 100644
index 000000000..5ae829012
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/time.h
@@ -0,0 +1,824 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A more-standard <time.h>.
+
+   Copyright (C) 2007-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+/* Don't get in the way of glibc when it includes time.h merely to
+   declare a few standard symbols, rather than to declare all the
+   symbols.  (However, skip this for MinGW as it treats __need_time_t
+   incompatibly.)  Also, Solaris 8 <time.h> eventually includes itself
+   recursively; if that is happening, just include the system <time.h>
+   without adding our own declarations.  */
+#if (((defined __need_time_t || defined __need_clock_t \
+       || defined __need_timespec)                     \
+      && !defined __MINGW32__)                         \
+     || defined _GL_TIME_H)
+
+# include_next <time.h>
+
+#else
+
+# define _GL_TIME_H
+
+# include_next <time.h>
+
+/* NetBSD 5.0 mis-defines NULL.  */
+# include <stddef.h>
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Some systems don't define struct timespec (e.g., AIX 4.1).
+   Or they define it with the wrong member names or define it in <sys/time.h>
+   (e.g., FreeBSD circa 1997).  Stock Mingw prior to 3.0 does not define it,
+   but the pthreads-win32 library defines it in <pthread.h>.  */
+# if ! 1
+#  if 0
+#   include <sys/time.h>
+#  elif 0
+#   include <pthread.h>
+#  elif 0
+#   include <unistd.h>
+#  else
+
+#   ifdef __cplusplus
+extern "C" {
+#   endif
+
+#   if !GNULIB_defined_struct_timespec
+#    undef timespec
+#    define timespec rpl_timespec
+struct timespec
+{
+  time_t tv_sec;
+  long int tv_nsec;
+};
+#    define GNULIB_defined_struct_timespec 1
+#   endif
+
+#   ifdef __cplusplus
+}
+#   endif
+
+#  endif
+# endif
+
+# if !GNULIB_defined_struct_time_t_must_be_integral
+/* Per http://austingroupbugs.net/view.php?id=327, POSIX requires
+   time_t to be an integer type, even though C99 permits floating
+   point.  We don't know of any implementation that uses floating
+   point, and it is much easier to write code that doesn't have to
+   worry about that corner case, so we force the issue.  */
+struct __time_t_must_be_integral {
+  unsigned int __floating_time_t_unsupported : (time_t) 1;
+};
+#  define GNULIB_defined_struct_time_t_must_be_integral 1
+# endif
+
+/* Sleep for at least RQTP seconds unless interrupted,  If interrupted,
+   return -1 and store the remaining time into RMTP.  See
+   <http://www.opengroup.org/susv3xsh/nanosleep.html>.  */
+# if IN_AUGEAS_GNULIB_TESTS
+#  if 1
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define nanosleep rpl_nanosleep
+#   endif
+_GL_FUNCDECL_RPL (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp)
+                  _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp)
+                  _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_SYS (nanosleep, int,
+                  (struct timespec const *__rqtp, struct timespec *__rmtp));
+#  endif
+_GL_CXXALIASWARN (nanosleep);
+# endif
+
+/* Initialize time conversion information.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef tzset
+#    define tzset rpl_tzset
+#   endif
+_GL_FUNCDECL_RPL (tzset, void, (void));
+_GL_CXXALIAS_RPL (tzset, void, (void));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (tzset, void, (void));
+#   endif
+_GL_CXXALIAS_SYS (tzset, void, (void));
+#  endif
+_GL_CXXALIASWARN (tzset);
+# endif
+
+/* Return the 'time_t' representation of TP and normalize TP.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define mktime rpl_mktime
+#   endif
+_GL_FUNCDECL_RPL (mktime, time_t, (struct tm *__tp) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (mktime, time_t, (struct tm *__tp));
+#  else
+_GL_CXXALIAS_SYS (mktime, time_t, (struct tm *__tp));
+#  endif
+_GL_CXXALIASWARN (mktime);
+# endif
+
+/* Convert TIMER to RESULT, assuming local time and UTC respectively.  See
+   <http://www.opengroup.org/susv3xsh/localtime_r.html> and
+   <http://www.opengroup.org/susv3xsh/gmtime_r.html>.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef localtime_r
+#    define localtime_r rpl_localtime_r
+#   endif
+_GL_FUNCDECL_RPL (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result)
+                                            _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result)
+                                            _GL_ARG_NONNULL ((1, 2)));
+#   endif
+_GL_CXXALIAS_SYS (localtime_r, struct tm *, (time_t const *restrict __timer,
+                                             struct tm *restrict __result));
+#  endif
+#  if 1
+_GL_CXXALIASWARN (localtime_r);
+#  endif
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef gmtime_r
+#    define gmtime_r rpl_gmtime_r
+#   endif
+_GL_FUNCDECL_RPL (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result)
+                                         _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result)
+                                         _GL_ARG_NONNULL ((1, 2)));
+#   endif
+_GL_CXXALIAS_SYS (gmtime_r, struct tm *, (time_t const *restrict __timer,
+                                          struct tm *restrict __result));
+#  endif
+#  if 1
+_GL_CXXALIASWARN (gmtime_r);
+#  endif
+# endif
+
+/* Convert TIMER to RESULT, assuming local time and UTC respectively.  See
+   <http://www.opengroup.org/susv3xsh/localtime.html> and
+   <http://www.opengroup.org/susv3xsh/gmtime.html>.  */
+# if 0 || 0
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef localtime
+#    define localtime rpl_localtime
+#   endif
+_GL_FUNCDECL_RPL (localtime, struct tm *, (time_t const *__timer)
+                                          _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (localtime, struct tm *, (time_t const *__timer));
+#  else
+_GL_CXXALIAS_SYS (localtime, struct tm *, (time_t const *__timer));
+#  endif
+_GL_CXXALIASWARN (localtime);
+# endif
+
+# if 0 || 0
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef gmtime
+#    define gmtime rpl_gmtime
+#   endif
+_GL_FUNCDECL_RPL (gmtime, struct tm *, (time_t const *__timer)
+                                       _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (gmtime, struct tm *, (time_t const *__timer));
+#  else
+_GL_CXXALIAS_SYS (gmtime, struct tm *, (time_t const *__timer));
+#  endif
+_GL_CXXALIASWARN (gmtime);
+# endif
+
+/* Parse BUF as a timestamp, assuming FORMAT specifies its layout, and store
+   the resulting broken-down time into TM.  See
+   <http://www.opengroup.org/susv3xsh/strptime.html>.  */
+# if 0
+#  if ! 1
+_GL_FUNCDECL_SYS (strptime, char *, (char const *restrict __buf,
+                                     char const *restrict __format,
+                                     struct tm *restrict __tm)
+                                    _GL_ARG_NONNULL ((1, 2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (strptime, char *, (char const *restrict __buf,
+                                     char const *restrict __format,
+                                     struct tm *restrict __tm));
+_GL_CXXALIASWARN (strptime);
+# endif
+
+/* Convert *TP to a date and time string.  See
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/ctime.html>.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define ctime rpl_ctime
+#   endif
+_GL_FUNCDECL_RPL (ctime, char *, (time_t const *__tp)
+                                 _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (ctime, char *, (time_t const *__tp));
+#  else
+_GL_CXXALIAS_SYS (ctime, char *, (time_t const *__tp));
+#  endif
+_GL_CXXALIASWARN (ctime);
+# endif
+
+/* Convert *TP to a date and time string.  See
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define strftime rpl_strftime
+#   endif
+_GL_FUNCDECL_RPL (strftime, size_t, (char *__buf, size_t __bufsize,
+                                     const char *__fmt, const struct tm *__tp)
+                                    _GL_ARG_NONNULL ((1, 3, 4)));
+_GL_CXXALIAS_RPL (strftime, size_t, (char *__buf, size_t __bufsize,
+                                     const char *__fmt, const struct tm *__tp));
+#  else
+_GL_CXXALIAS_SYS (strftime, size_t, (char *__buf, size_t __bufsize,
+                                     const char *__fmt, const struct tm *__tp));
+#  endif
+_GL_CXXALIASWARN (strftime);
+# endif
+
+# if defined _GNU_SOURCE && 0 && ! 0
+typedef struct tm_zone *timezone_t;
+_GL_FUNCDECL_SYS (tzalloc, timezone_t, (char const *__name));
+_GL_CXXALIAS_SYS (tzalloc, timezone_t, (char const *__name));
+_GL_FUNCDECL_SYS (tzfree, void, (timezone_t __tz));
+_GL_CXXALIAS_SYS (tzfree, void, (timezone_t __tz));
+_GL_FUNCDECL_SYS (localtime_rz, struct tm *,
+                  (timezone_t __tz, time_t const *restrict __timer,
+                   struct tm *restrict __result) _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_SYS (localtime_rz, struct tm *,
+                  (timezone_t __tz, time_t const *restrict __timer,
+                   struct tm *restrict __result));
+_GL_FUNCDECL_SYS (mktime_z, time_t,
+                  (timezone_t __tz, struct tm *restrict __result)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_SYS (mktime_z, time_t,
+                  (timezone_t __tz, struct tm *restrict __result));
+# endif
+
+/* Convert TM to a time_t value, assuming UTC.  */
+# if 0
+#  if GNULIB_PORTCHECK
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    undef timegm
+#    define timegm rpl_timegm
+#   endif
+_GL_FUNCDECL_RPL (timegm, time_t, (struct tm *__tm) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (timegm, time_t, (struct tm *__tm));
+#  else
+#   if ! 1
+_GL_FUNCDECL_SYS (timegm, time_t, (struct tm *__tm) _GL_ARG_NONNULL ((1)));
+#   endif
+_GL_CXXALIAS_SYS (timegm, time_t, (struct tm *__tm));
+#  endif
+_GL_CXXALIASWARN (timegm);
+# endif
+
+/* Encourage applications to avoid unsafe functions that can overrun
+   buffers when given outlandish struct tm values.  Portable
+   applications should use strftime (or even sprintf) instead.  */
+# if defined GNULIB_POSIXCHECK
+#  undef asctime
+_GL_WARN_ON_USE (asctime, "asctime can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef asctime_r
+_GL_WARN_ON_USE (asctime, "asctime_r can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef ctime
+_GL_WARN_ON_USE (asctime, "ctime can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+# if defined GNULIB_POSIXCHECK
+#  undef ctime_r
+_GL_WARN_ON_USE (asctime, "ctime_r can overrun buffers in some cases - "
+                 "better use strftime (or even sprintf) instead");
+# endif
+
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/unistd.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/unistd.h
new file mode 100644
index 000000000..00f0946b7
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/unistd.h
@@ -0,0 +1,2151 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* Substitute for and wrapper around <unistd.h>.
+   Copyright (C) 2003-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_UNISTD_H
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#ifdef _GL_INCLUDING_UNISTD_H
+/* Special invocation convention:
+   - On Mac OS X 10.3.9 we have a sequence of nested includes
+     <unistd.h> -> <signal.h> -> <pthread.h> -> <unistd.h>
+     In this situation, the functions are not yet declared, therefore we cannot
+     provide the C++ aliases.  */
+
+#include_next <unistd.h>
+
+#else
+/* Normal invocation convention.  */
+
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# define _GL_INCLUDING_UNISTD_H
+# include_next <unistd.h>
+# undef _GL_INCLUDING_UNISTD_H
+#endif
+
+/* Get all possible declarations of gethostname().  */
+#if 0 && 0 \
+  && !defined _GL_INCLUDING_WINSOCK2_H
+# define _GL_INCLUDING_WINSOCK2_H
+# include <winsock2.h>
+# undef _GL_INCLUDING_WINSOCK2_H
+#endif
+
+#if !defined _GL_UNISTD_H && !defined _GL_INCLUDING_WINSOCK2_H
+#define _GL_UNISTD_H
+
+/* NetBSD 5.0 mis-defines NULL.  Also get size_t.  */
+#include <stddef.h>
+
+/* mingw doesn't define the SEEK_* or *_FILENO macros in <unistd.h>.  */
+/* MSVC declares 'unlink' in <stdio.h>, not in <unistd.h>.  We must include
+   it before we  #define unlink rpl_unlink.  */
+/* Cygwin 1.7.1 declares symlinkat in <stdio.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (!(defined SEEK_CUR && defined SEEK_END && defined SEEK_SET) \
+     || ((0 || defined GNULIB_POSIXCHECK) \
+         && (defined _WIN32 && ! defined __CYGWIN__)) \
+     || ((0 || defined GNULIB_POSIXCHECK) \
+         && defined __CYGWIN__)) \
+    && ! defined __GLIBC__
+# include <stdio.h>
+#endif
+
+/* Cygwin 1.7.1 and Android 4.3 declare unlinkat in <fcntl.h>, not in
+   <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) \
+    && (defined __CYGWIN__ || defined __ANDROID__) \
+    && ! defined __GLIBC__
+# include <fcntl.h>
+#endif
+
+/* mingw fails to declare _exit in <unistd.h>.  */
+/* mingw, MSVC, BeOS, Haiku declare environ in <stdlib.h>, not in
+   <unistd.h>.  */
+/* Solaris declares getcwd not only in <unistd.h> but also in <stdlib.h>.  */
+/* OSF Tru64 Unix cannot see gnulib rpl_strtod when system <stdlib.h> is
+   included here.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if !defined __GLIBC__ && !defined __osf__
+# define __need_system_stdlib_h
+# include <stdlib.h>
+# undef __need_system_stdlib_h
+#endif
+
+/* Native Windows platforms declare chdir, getcwd, rmdir in
+   <io.h> and/or <direct.h>, not in <unistd.h>.
+   They also declare access(), chmod(), close(), dup(), dup2(), isatty(),
+   lseek(), read(), unlink(), write() in <io.h>.  */
+#if ((0 || IN_AUGEAS_GNULIB_TESTS || 0 \
+      || defined GNULIB_POSIXCHECK) \
+     && (defined _WIN32 && ! defined __CYGWIN__))
+# include <io.h>     /* mingw32, mingw64 */
+# include <direct.h> /* mingw64, MSVC 9 */
+#elif (IN_AUGEAS_GNULIB_TESTS || 0 || IN_AUGEAS_GNULIB_TESTS || 0 \
+       || 0 || 0 || 0 || 0 \
+       || defined GNULIB_POSIXCHECK) \
+      && (defined _WIN32 && ! defined __CYGWIN__)
+# include <io.h>
+#endif
+
+/* AIX and OSF/1 5.1 declare getdomainname in <netdb.h>, not in <unistd.h>.
+   NonStop Kernel declares gethostname in <netdb.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if ((0 && (defined _AIX || defined __osf__)) \
+     || (0 && defined __TANDEM)) \
+    && !defined __GLIBC__
+# include <netdb.h>
+#endif
+
+/* Android 4.3 declares fchownat in <sys/stat.h>, not in <unistd.h>.  */
+/* But avoid namespace pollution on glibc systems.  */
+#if (0 || defined GNULIB_POSIXCHECK) && defined __ANDROID__ \
+    && !defined __GLIBC__
+# include <sys/stat.h>
+#endif
+
+/* MSVC defines off_t in <sys/types.h>.
+   May also define off_t to a 64-bit type on native Windows.  */
+#if !1 || 0
+/* Get off_t.  */
+# include <sys/types.h>
+#endif
+
+#if (0 || 0 \
+     || 1 || 0 \
+     || 0 || 0 || defined GNULIB_POSIXCHECK)
+/* Get ssize_t.  */
+# include <sys/types.h>
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Get getopt(), optarg, optind, opterr, optopt.  */
+#if 0 && !defined _GL_SYSTEM_GETOPT
+# include <getopt-cdefs.h>
+# include <getopt-pfx-core.h>
+#endif
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef _GL_UNISTD_INLINE
+# define _GL_UNISTD_INLINE _GL_INLINE
+#endif
+
+/* Hide some function declarations from <winsock2.h>.  */
+
+#if 0 && 0
+# if !defined _GL_SYS_SOCKET_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef socket
+#   define socket              socket_used_without_including_sys_socket_h
+#   undef connect
+#   define connect             connect_used_without_including_sys_socket_h
+#   undef accept
+#   define accept              accept_used_without_including_sys_socket_h
+#   undef bind
+#   define bind                bind_used_without_including_sys_socket_h
+#   undef getpeername
+#   define getpeername         getpeername_used_without_including_sys_socket_h
+#   undef getsockname
+#   define getsockname         getsockname_used_without_including_sys_socket_h
+#   undef getsockopt
+#   define getsockopt          getsockopt_used_without_including_sys_socket_h
+#   undef listen
+#   define listen              listen_used_without_including_sys_socket_h
+#   undef recv
+#   define recv                recv_used_without_including_sys_socket_h
+#   undef send
+#   define send                send_used_without_including_sys_socket_h
+#   undef recvfrom
+#   define recvfrom            recvfrom_used_without_including_sys_socket_h
+#   undef sendto
+#   define sendto              sendto_used_without_including_sys_socket_h
+#   undef setsockopt
+#   define setsockopt          setsockopt_used_without_including_sys_socket_h
+#   undef shutdown
+#   define shutdown            shutdown_used_without_including_sys_socket_h
+#  else
+    _GL_WARN_ON_USE (socket,
+                     "socket() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (connect,
+                     "connect() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (accept,
+                     "accept() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (bind,
+                     "bind() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (getpeername,
+                     "getpeername() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (getsockname,
+                     "getsockname() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (getsockopt,
+                     "getsockopt() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (listen,
+                     "listen() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (recv,
+                     "recv() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (send,
+                     "send() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (recvfrom,
+                     "recvfrom() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (sendto,
+                     "sendto() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (setsockopt,
+                     "setsockopt() used without including <sys/socket.h>");
+    _GL_WARN_ON_USE (shutdown,
+                     "shutdown() used without including <sys/socket.h>");
+#  endif
+# endif
+# if !defined _GL_SYS_SELECT_H
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef select
+#   define select              select_used_without_including_sys_select_h
+#  else
+    _GL_WARN_ON_USE (select,
+                     "select() used without including <sys/select.h>");
+#  endif
+# endif
+#endif
+
+
+/* OS/2 EMX lacks these macros.  */
+#ifndef STDIN_FILENO
+# define STDIN_FILENO 0
+#endif
+#ifndef STDOUT_FILENO
+# define STDOUT_FILENO 1
+#endif
+#ifndef STDERR_FILENO
+# define STDERR_FILENO 2
+#endif
+
+/* Ensure *_OK macros exist.  */
+#ifndef F_OK
+# define F_OK 0
+# define X_OK 1
+# define W_OK 2
+# define R_OK 4
+#endif
+
+
+/* Declare overridden functions.  */
+
+
+#if defined GNULIB_POSIXCHECK
+/* The access() function is a security risk.  */
+_GL_WARN_ON_USE (access, "the access function is a security risk - "
+                 "use the gnulib module faccessat instead");
+#endif
+
+
+#if 0
+_GL_CXXALIAS_SYS (chdir, int, (const char *file) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIASWARN (chdir);
+#elif defined GNULIB_POSIXCHECK
+# undef chdir
+# if HAVE_RAW_DECL_CHDIR
+_GL_WARN_ON_USE (chown, "chdir is not always in <unistd.h> - "
+                 "use gnulib module chdir for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
+   to GID (if GID is not -1).  Follow symbolic links.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/chown.html.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef chown
+#   define chown rpl_chown
+#  endif
+_GL_FUNCDECL_RPL (chown, int, (const char *file, uid_t uid, gid_t gid)
+                              _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (chown, int, (const char *file, uid_t uid, gid_t gid));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (chown, int, (const char *file, uid_t uid, gid_t gid)
+                              _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (chown, int, (const char *file, uid_t uid, gid_t gid));
+# endif
+_GL_CXXALIASWARN (chown);
+#elif defined GNULIB_POSIXCHECK
+# undef chown
+# if HAVE_RAW_DECL_CHOWN
+_GL_WARN_ON_USE (chown, "chown fails to follow symlinks on some systems and "
+                 "doesn't treat a uid or gid of -1 on some systems - "
+                 "use gnulib module chown for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+/* Automatically included by modules that need a replacement for close.  */
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef close
+#   define close rpl_close
+#  endif
+_GL_FUNCDECL_RPL (close, int, (int fd));
+_GL_CXXALIAS_RPL (close, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (close, int, (int fd));
+# endif
+_GL_CXXALIASWARN (close);
+#elif 0
+# undef close
+# define close close_used_without_requesting_gnulib_module_close
+#elif defined GNULIB_POSIXCHECK
+# undef close
+/* Assume close is always declared.  */
+_GL_WARN_ON_USE (close, "close does not portably work on sockets - "
+                 "use gnulib module close for portability");
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup rpl_dup
+#  endif
+_GL_FUNCDECL_RPL (dup, int, (int oldfd));
+_GL_CXXALIAS_RPL (dup, int, (int oldfd));
+# else
+_GL_CXXALIAS_SYS (dup, int, (int oldfd));
+# endif
+_GL_CXXALIASWARN (dup);
+#elif defined GNULIB_POSIXCHECK
+# undef dup
+# if HAVE_RAW_DECL_DUP
+_GL_WARN_ON_USE (dup, "dup is unportable - "
+                 "use gnulib module dup for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Copy the file descriptor OLDFD into file descriptor NEWFD.  Do nothing if
+   NEWFD = OLDFD, otherwise close NEWFD first if it is open.
+   Return newfd if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup2.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup2 rpl_dup2
+#  endif
+_GL_FUNCDECL_RPL (dup2, int, (int oldfd, int newfd));
+_GL_CXXALIAS_RPL (dup2, int, (int oldfd, int newfd));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (dup2, int, (int oldfd, int newfd));
+#  endif
+_GL_CXXALIAS_SYS (dup2, int, (int oldfd, int newfd));
+# endif
+_GL_CXXALIASWARN (dup2);
+#elif defined GNULIB_POSIXCHECK
+# undef dup2
+# if HAVE_RAW_DECL_DUP2
+_GL_WARN_ON_USE (dup2, "dup2 is unportable - "
+                 "use gnulib module dup2 for portability");
+# endif
+#endif
+
+
+#if 0
+/* Copy the file descriptor OLDFD into file descriptor NEWFD, with the
+   specified flags.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   Close NEWFD first if it is open.
+   Return newfd if successful, otherwise -1 and errno set.
+   See the Linux man page at
+   <https://www.kernel.org/doc/man-pages/online/pages/man2/dup3.2.html>.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define dup3 rpl_dup3
+#  endif
+_GL_FUNCDECL_RPL (dup3, int, (int oldfd, int newfd, int flags));
+_GL_CXXALIAS_RPL (dup3, int, (int oldfd, int newfd, int flags));
+# else
+_GL_FUNCDECL_SYS (dup3, int, (int oldfd, int newfd, int flags));
+_GL_CXXALIAS_SYS (dup3, int, (int oldfd, int newfd, int flags));
+# endif
+_GL_CXXALIASWARN (dup3);
+#elif defined GNULIB_POSIXCHECK
+# undef dup3
+# if HAVE_RAW_DECL_DUP3
+_GL_WARN_ON_USE (dup3, "dup3 is unportable - "
+                 "use gnulib module dup3 for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if defined __CYGWIN__ && !defined __i386__
+/* The 'environ' variable is defined in a DLL. Therefore its declaration needs
+   the '__declspec(dllimport)' attribute, but the system's <unistd.h> lacks it.
+   This leads to a link error on 64-bit Cygwin when the option
+   -Wl,--disable-auto-import is in use.  */
+_GL_EXTERN_C __declspec(dllimport) char **environ;
+# endif
+# if !1
+/* Set of environment variables and values.  An array of strings of the form
+   "VARIABLE=VALUE", terminated with a NULL.  */
+#  if defined __APPLE__ && defined __MACH__
+#   include <TargetConditionals.h>
+#   if !TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+#    define _GL_USE_CRT_EXTERNS
+#   endif
+#  endif
+#  ifdef _GL_USE_CRT_EXTERNS
+#   include <crt_externs.h>
+#   define environ (*_NSGetEnviron ())
+#  else
+#   ifdef __cplusplus
+extern "C" {
+#   endif
+extern char **environ;
+#   ifdef __cplusplus
+}
+#   endif
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# if HAVE_RAW_DECL_ENVIRON
+_GL_UNISTD_INLINE char ***
+_GL_WARN_ON_USE_ATTRIBUTE ("environ is unportable - "
+                           "use gnulib module environ for portability")
+rpl_environ (void)
+{
+  return &environ;
+}
+#  undef environ
+#  define environ (*rpl_environ ())
+# endif
+#endif
+
+
+#if 0
+/* Like access(), except that it uses the effective user id and group id of
+   the current process.  */
+# if !1
+_GL_FUNCDECL_SYS (euidaccess, int, (const char *filename, int mode)
+                                   _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (euidaccess, int, (const char *filename, int mode));
+_GL_CXXALIASWARN (euidaccess);
+# if defined GNULIB_POSIXCHECK
+/* Like access(), this function is a security risk.  */
+_GL_WARN_ON_USE (euidaccess, "the euidaccess function is a security risk - "
+                 "use the gnulib module faccessat instead");
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef euidaccess
+# if HAVE_RAW_DECL_EUIDACCESS
+_GL_WARN_ON_USE (euidaccess, "euidaccess is unportable - "
+                 "use gnulib module euidaccess for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef faccessat
+#   define faccessat rpl_faccessat
+#  endif
+_GL_FUNCDECL_RPL (faccessat, int,
+                  (int fd, char const *name, int mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (faccessat, int,
+                  (int fd, char const *name, int mode, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (faccessat, int,
+                  (int fd, char const *file, int mode, int flag)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (faccessat, int,
+                  (int fd, char const *file, int mode, int flag));
+# endif
+_GL_CXXALIASWARN (faccessat);
+#elif defined GNULIB_POSIXCHECK
+# undef faccessat
+# if HAVE_RAW_DECL_FACCESSAT
+_GL_WARN_ON_USE (faccessat, "faccessat is not portable - "
+                 "use gnulib module faccessat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the process' current working directory to the directory on which
+   the given file descriptor is open.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchdir.html>.  */
+# if ! 1
+_GL_FUNCDECL_SYS (fchdir, int, (int /*fd*/));
+
+/* Gnulib internal hooks needed to maintain the fchdir metadata.  */
+_GL_EXTERN_C int _gl_register_fd (int fd, const char *filename)
+     _GL_ARG_NONNULL ((2));
+_GL_EXTERN_C void _gl_unregister_fd (int fd);
+_GL_EXTERN_C int _gl_register_dup (int oldfd, int newfd);
+_GL_EXTERN_C const char *_gl_directory_name (int fd);
+
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fchdir, int, (int /*fd*/));
+#  endif
+# endif
+_GL_CXXALIAS_SYS (fchdir, int, (int /*fd*/));
+_GL_CXXALIASWARN (fchdir);
+#elif defined GNULIB_POSIXCHECK
+# undef fchdir
+# if HAVE_RAW_DECL_FCHDIR
+_GL_WARN_ON_USE (fchdir, "fchdir is unportable - "
+                 "use gnulib module fchdir for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef fchownat
+#   define fchownat rpl_fchownat
+#  endif
+_GL_FUNCDECL_RPL (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (fchownat, int, (int fd, char const *file,
+                                  uid_t owner, gid_t group, int flag));
+# endif
+_GL_CXXALIASWARN (fchownat);
+#elif defined GNULIB_POSIXCHECK
+# undef fchownat
+# if HAVE_RAW_DECL_FCHOWNAT
+_GL_WARN_ON_USE (fchownat, "fchownat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Synchronize changes to a file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/fdatasync.html>.  */
+# if !1 || !1
+_GL_FUNCDECL_SYS (fdatasync, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (fdatasync, int, (int fd));
+_GL_CXXALIASWARN (fdatasync);
+#elif defined GNULIB_POSIXCHECK
+# undef fdatasync
+# if HAVE_RAW_DECL_FDATASYNC
+_GL_WARN_ON_USE (fdatasync, "fdatasync is unportable - "
+                 "use gnulib module fdatasync for portability");
+# endif
+#endif
+
+
+#if 0
+/* Synchronize changes, including metadata, to a file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/fsync.html>.  */
+# if !1
+_GL_FUNCDECL_SYS (fsync, int, (int fd));
+# endif
+_GL_CXXALIAS_SYS (fsync, int, (int fd));
+_GL_CXXALIASWARN (fsync);
+#elif defined GNULIB_POSIXCHECK
+# undef fsync
+# if HAVE_RAW_DECL_FSYNC
+_GL_WARN_ON_USE (fsync, "fsync is unportable - "
+                 "use gnulib module fsync for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Change the size of the file to which FD is opened to become equal to LENGTH.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/ftruncate.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ftruncate
+#   define ftruncate rpl_ftruncate
+#  endif
+_GL_FUNCDECL_RPL (ftruncate, int, (int fd, off_t length));
+_GL_CXXALIAS_RPL (ftruncate, int, (int fd, off_t length));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ftruncate, int, (int fd, off_t length));
+#  endif
+_GL_CXXALIAS_SYS (ftruncate, int, (int fd, off_t length));
+# endif
+_GL_CXXALIASWARN (ftruncate);
+#elif defined GNULIB_POSIXCHECK
+# undef ftruncate
+# if HAVE_RAW_DECL_FTRUNCATE
+_GL_WARN_ON_USE (ftruncate, "ftruncate is unportable - "
+                 "use gnulib module ftruncate for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Get the name of the current working directory, and put it in SIZE bytes
+   of BUF.
+   Return BUF if successful, or NULL if the directory couldn't be determined
+   or SIZE was too small.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/getcwd.html>.
+   Additionally, the gnulib module 'getcwd' guarantees the following GNU
+   extension: If BUF is NULL, an array is allocated with 'malloc'; the array
+   is SIZE bytes long, unless SIZE == 0, in which case it is as big as
+   necessary.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getcwd rpl_getcwd
+#  endif
+_GL_FUNCDECL_RPL (getcwd, char *, (char *buf, size_t size));
+_GL_CXXALIAS_RPL (getcwd, char *, (char *buf, size_t size));
+# else
+/* Need to cast, because on mingw, the second parameter is
+                                                   int size.  */
+_GL_CXXALIAS_SYS_CAST (getcwd, char *, (char *buf, size_t size));
+# endif
+_GL_CXXALIASWARN (getcwd);
+#elif defined GNULIB_POSIXCHECK
+# undef getcwd
+# if HAVE_RAW_DECL_GETCWD
+_GL_WARN_ON_USE (getcwd, "getcwd is unportable - "
+                 "use gnulib module getcwd for portability");
+# endif
+#endif
+
+
+#if 0
+/* Return the NIS domain name of the machine.
+   WARNING! The NIS domain name is unrelated to the fully qualified host name
+            of the machine.  It is also unrelated to email addresses.
+   WARNING! The NIS domain name is usually the empty string or "(none)" when
+            not using NIS.
+
+   Put up to LEN bytes of the NIS domain name into NAME.
+   Null terminate it if the name is shorter than LEN.
+   If the NIS domain name is longer than LEN, set errno = EINVAL and return -1.
+   Return 0 if successful, otherwise set errno and return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getdomainname
+#   define getdomainname rpl_getdomainname
+#  endif
+_GL_FUNCDECL_RPL (getdomainname, int, (char *name, size_t len)
+                                      _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getdomainname, int, (char *name, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getdomainname, int, (char *name, size_t len)
+                                      _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (getdomainname, int, (char *name, size_t len));
+# endif
+_GL_CXXALIASWARN (getdomainname);
+#elif defined GNULIB_POSIXCHECK
+# undef getdomainname
+# if HAVE_RAW_DECL_GETDOMAINNAME
+_GL_WARN_ON_USE (getdomainname, "getdomainname is unportable - "
+                 "use gnulib module getdomainname for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Return the maximum number of file descriptors in the current process.
+   In POSIX, this is same as sysconf (_SC_OPEN_MAX).  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getdtablesize
+#   define getdtablesize rpl_getdtablesize
+#  endif
+_GL_FUNCDECL_RPL (getdtablesize, int, (void));
+_GL_CXXALIAS_RPL (getdtablesize, int, (void));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getdtablesize, int, (void));
+#  endif
+_GL_CXXALIAS_SYS (getdtablesize, int, (void));
+# endif
+_GL_CXXALIASWARN (getdtablesize);
+#elif defined GNULIB_POSIXCHECK
+# undef getdtablesize
+# if HAVE_RAW_DECL_GETDTABLESIZE
+_GL_WARN_ON_USE (getdtablesize, "getdtablesize is unportable - "
+                 "use gnulib module getdtablesize for portability");
+# endif
+#endif
+
+
+#if 0
+/* Return the supplemental groups that the current process belongs to.
+   It is unspecified whether the effective group id is in the list.
+   If N is 0, return the group count; otherwise, N describes how many
+   entries are available in GROUPS.  Return -1 and set errno if N is
+   not 0 and not large enough.  Fails with ENOSYS on some systems.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getgroups
+#   define getgroups rpl_getgroups
+#  endif
+_GL_FUNCDECL_RPL (getgroups, int, (int n, gid_t *groups));
+_GL_CXXALIAS_RPL (getgroups, int, (int n, gid_t *groups));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getgroups, int, (int n, gid_t *groups));
+#  endif
+_GL_CXXALIAS_SYS (getgroups, int, (int n, gid_t *groups));
+# endif
+_GL_CXXALIASWARN (getgroups);
+#elif defined GNULIB_POSIXCHECK
+# undef getgroups
+# if HAVE_RAW_DECL_GETGROUPS
+_GL_WARN_ON_USE (getgroups, "getgroups is unportable - "
+                 "use gnulib module getgroups for portability");
+# endif
+#endif
+
+
+#if 0
+/* Return the standard host name of the machine.
+   WARNING! The host name may or may not be fully qualified.
+
+   Put up to LEN bytes of the host name into NAME.
+   Null terminate it if the name is shorter than LEN.
+   If the host name is longer than LEN, set errno = EINVAL and return -1.
+   Return 0 if successful, otherwise set errno and return -1.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef gethostname
+#   define gethostname rpl_gethostname
+#  endif
+_GL_FUNCDECL_RPL (gethostname, int, (char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (gethostname, int, (char *name, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (gethostname, int, (char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on Solaris 10 and OSF/1 5.1 systems, the second
+   parameter is
+                                                      int len.  */
+_GL_CXXALIAS_SYS_CAST (gethostname, int, (char *name, size_t len));
+# endif
+_GL_CXXALIASWARN (gethostname);
+#elif 0
+# undef gethostname
+# define gethostname gethostname_used_without_requesting_gnulib_module_gethostname
+#elif defined GNULIB_POSIXCHECK
+# undef gethostname
+# if HAVE_RAW_DECL_GETHOSTNAME
+_GL_WARN_ON_USE (gethostname, "gethostname is unportable - "
+                 "use gnulib module gethostname for portability");
+# endif
+#endif
+
+
+#if 0
+/* Returns the user's login name, or NULL if it cannot be found.  Upon error,
+   returns NULL with errno set.
+
+   See <http://www.opengroup.org/susv3xsh/getlogin.html>.
+
+   Most programs don't need to use this function, because the information is
+   available through environment variables:
+     ${LOGNAME-$USER}        on Unix platforms,
+     $USERNAME               on native Windows platforms.
+ */
+# if !1
+_GL_FUNCDECL_SYS (getlogin, char *, (void));
+# endif
+_GL_CXXALIAS_SYS (getlogin, char *, (void));
+_GL_CXXALIASWARN (getlogin);
+#elif defined GNULIB_POSIXCHECK
+# undef getlogin
+# if HAVE_RAW_DECL_GETLOGIN
+_GL_WARN_ON_USE (getlogin, "getlogin is unportable - "
+                 "use gnulib module getlogin for portability");
+# endif
+#endif
+
+
+#if 0
+/* Copies the user's login name to NAME.
+   The array pointed to by NAME has room for SIZE bytes.
+
+   Returns 0 if successful.  Upon error, an error number is returned, or -1 in
+   the case that the login name cannot be found but no specific error is
+   provided (this case is hopefully rare but is left open by the POSIX spec).
+
+   See <http://www.opengroup.org/susv3xsh/getlogin.html>.
+
+   Most programs don't need to use this function, because the information is
+   available through environment variables:
+     ${LOGNAME-$USER}        on Unix platforms,
+     $USERNAME               on native Windows platforms.
+ */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getlogin_r rpl_getlogin_r
+#  endif
+_GL_FUNCDECL_RPL (getlogin_r, int, (char *name, size_t size)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getlogin_r, int, (char *name, size_t size));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getlogin_r, int, (char *name, size_t size)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+/* Need to cast, because on Solaris 10 systems, the second argument is
+                                                     int size.  */
+_GL_CXXALIAS_SYS_CAST (getlogin_r, int, (char *name, size_t size));
+# endif
+_GL_CXXALIASWARN (getlogin_r);
+#elif defined GNULIB_POSIXCHECK
+# undef getlogin_r
+# if HAVE_RAW_DECL_GETLOGIN_R
+_GL_WARN_ON_USE (getlogin_r, "getlogin_r is unportable - "
+                 "use gnulib module getlogin_r for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define getpagesize rpl_getpagesize
+#  endif
+_GL_FUNCDECL_RPL (getpagesize, int, (void));
+_GL_CXXALIAS_RPL (getpagesize, int, (void));
+# else
+#  if !1
+#   if !defined getpagesize
+/* This is for POSIX systems.  */
+#    if !defined _gl_getpagesize && defined _SC_PAGESIZE
+#     if ! (defined __VMS && __VMS_VER < 70000000)
+#      define _gl_getpagesize() sysconf (_SC_PAGESIZE)
+#     endif
+#    endif
+/* This is for older VMS.  */
+#    if !defined _gl_getpagesize && defined __VMS
+#     ifdef __ALPHA
+#      define _gl_getpagesize() 8192
+#     else
+#      define _gl_getpagesize() 512
+#     endif
+#    endif
+/* This is for BeOS.  */
+#    if !defined _gl_getpagesize && 0
+#     include <OS.h>
+#     if defined B_PAGE_SIZE
+#      define _gl_getpagesize() B_PAGE_SIZE
+#     endif
+#    endif
+/* This is for AmigaOS4.0.  */
+#    if !defined _gl_getpagesize && defined __amigaos4__
+#     define _gl_getpagesize() 2048
+#    endif
+/* This is for older Unix systems.  */
+#    if !defined _gl_getpagesize && 0
+#     include <sys/param.h>
+#     ifdef EXEC_PAGESIZE
+#      define _gl_getpagesize() EXEC_PAGESIZE
+#     else
+#      ifdef NBPG
+#       ifndef CLSIZE
+#        define CLSIZE 1
+#       endif
+#       define _gl_getpagesize() (NBPG * CLSIZE)
+#      else
+#       ifdef NBPC
+#        define _gl_getpagesize() NBPC
+#       endif
+#      endif
+#     endif
+#    endif
+#    if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#     define getpagesize() _gl_getpagesize ()
+#    else
+#     if !GNULIB_defined_getpagesize_function
+_GL_UNISTD_INLINE int
+getpagesize ()
+{
+  return _gl_getpagesize ();
+}
+#      define GNULIB_defined_getpagesize_function 1
+#     endif
+#    endif
+#   endif
+#  endif
+/* Need to cast, because on Cygwin 1.5.x systems, the return type is size_t.  */
+_GL_CXXALIAS_SYS_CAST (getpagesize, int, (void));
+# endif
+# if 1
+_GL_CXXALIASWARN (getpagesize);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getpagesize
+# if HAVE_RAW_DECL_GETPAGESIZE
+_GL_WARN_ON_USE (getpagesize, "getpagesize is unportable - "
+                 "use gnulib module getpagesize for portability");
+# endif
+#endif
+
+
+#if 0
+/* Function getpass() from module 'getpass':
+     Read a password from /dev/tty or stdin.
+   Function getpass() from module 'getpass-gnu':
+     Read a password of arbitrary length from /dev/tty or stdin.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef getpass
+#   define getpass rpl_getpass
+#  endif
+_GL_FUNCDECL_RPL (getpass, char *, (const char *prompt)
+                                   _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (getpass, char *, (const char *prompt));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (getpass, char *, (const char *prompt)
+                                   _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (getpass, char *, (const char *prompt));
+# endif
+_GL_CXXALIASWARN (getpass);
+#elif defined GNULIB_POSIXCHECK
+# undef getpass
+# if HAVE_RAW_DECL_GETPASS
+_GL_WARN_ON_USE (getpass, "getpass is unportable - "
+                 "use gnulib module getpass or getpass-gnu for portability");
+# endif
+#endif
+
+
+#if 0
+/* Return the next valid login shell on the system, or NULL when the end of
+   the list has been reached.  */
+# if !1
+_GL_FUNCDECL_SYS (getusershell, char *, (void));
+# endif
+_GL_CXXALIAS_SYS (getusershell, char *, (void));
+_GL_CXXALIASWARN (getusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef getusershell
+# if HAVE_RAW_DECL_GETUSERSHELL
+_GL_WARN_ON_USE (getusershell, "getusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+#if 0
+/* Rewind to pointer that is advanced at each getusershell() call.  */
+# if !1
+_GL_FUNCDECL_SYS (setusershell, void, (void));
+# endif
+_GL_CXXALIAS_SYS (setusershell, void, (void));
+_GL_CXXALIASWARN (setusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef setusershell
+# if HAVE_RAW_DECL_SETUSERSHELL
+_GL_WARN_ON_USE (setusershell, "setusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+#if 0
+/* Free the pointer that is advanced at each getusershell() call and
+   associated resources.  */
+# if !1
+_GL_FUNCDECL_SYS (endusershell, void, (void));
+# endif
+_GL_CXXALIAS_SYS (endusershell, void, (void));
+_GL_CXXALIASWARN (endusershell);
+#elif defined GNULIB_POSIXCHECK
+# undef endusershell
+# if HAVE_RAW_DECL_ENDUSERSHELL
+_GL_WARN_ON_USE (endusershell, "endusershell is unportable - "
+                 "use gnulib module getusershell for portability");
+# endif
+#endif
+
+
+#if 0
+/* Determine whether group id is in calling user's group list.  */
+# if !1
+_GL_FUNCDECL_SYS (group_member, int, (gid_t gid));
+# endif
+_GL_CXXALIAS_SYS (group_member, int, (gid_t gid));
+_GL_CXXALIASWARN (group_member);
+#elif defined GNULIB_POSIXCHECK
+# undef group_member
+# if HAVE_RAW_DECL_GROUP_MEMBER
+_GL_WARN_ON_USE (group_member, "group_member is unportable - "
+                 "use gnulib module group-member for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef isatty
+#   define isatty rpl_isatty
+#  endif
+_GL_FUNCDECL_RPL (isatty, int, (int fd));
+_GL_CXXALIAS_RPL (isatty, int, (int fd));
+# else
+_GL_CXXALIAS_SYS (isatty, int, (int fd));
+# endif
+_GL_CXXALIASWARN (isatty);
+#elif defined GNULIB_POSIXCHECK
+# undef isatty
+# if HAVE_RAW_DECL_ISATTY
+_GL_WARN_ON_USE (isatty, "isatty has portability problems on native Windows - "
+                 "use gnulib module isatty for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the owner of FILE to UID (if UID is not -1) and the group of FILE
+   to GID (if GID is not -1).  Do not follow symbolic links.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/lchown.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef lchown
+#   define lchown rpl_lchown
+#  endif
+_GL_FUNCDECL_RPL (lchown, int, (char const *file, uid_t owner, gid_t group)
+                               _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (lchown, int, (char const *file, uid_t owner, gid_t group));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (lchown, int, (char const *file, uid_t owner, gid_t group)
+                               _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (lchown, int, (char const *file, uid_t owner, gid_t group));
+# endif
+_GL_CXXALIASWARN (lchown);
+#elif defined GNULIB_POSIXCHECK
+# undef lchown
+# if HAVE_RAW_DECL_LCHOWN
+_GL_WARN_ON_USE (lchown, "lchown is unportable to pre-POSIX.1-2001 systems - "
+                 "use gnulib module lchown for portability");
+# endif
+#endif
+
+
+#if 0
+/* Create a new hard link for an existing file.
+   Return 0 if successful, otherwise -1 and errno set.
+   See POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/link.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define link rpl_link
+#  endif
+_GL_FUNCDECL_RPL (link, int, (const char *path1, const char *path2)
+                             _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (link, int, (const char *path1, const char *path2));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (link, int, (const char *path1, const char *path2)
+                             _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (link, int, (const char *path1, const char *path2));
+# endif
+_GL_CXXALIASWARN (link);
+#elif defined GNULIB_POSIXCHECK
+# undef link
+# if HAVE_RAW_DECL_LINK
+_GL_WARN_ON_USE (link, "link is unportable - "
+                 "use gnulib module link for portability");
+# endif
+#endif
+
+
+#if 0
+/* Create a new hard link for an existing file, relative to two
+   directories.  FLAG controls whether symlinks are followed.
+   Return 0 if successful, otherwise -1 and errno set.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef linkat
+#   define linkat rpl_linkat
+#  endif
+_GL_FUNCDECL_RPL (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag)
+                  _GL_ARG_NONNULL ((2, 4)));
+_GL_CXXALIAS_RPL (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag)
+                  _GL_ARG_NONNULL ((2, 4)));
+#  endif
+_GL_CXXALIAS_SYS (linkat, int,
+                  (int fd1, const char *path1, int fd2, const char *path2,
+                   int flag));
+# endif
+_GL_CXXALIASWARN (linkat);
+#elif defined GNULIB_POSIXCHECK
+# undef linkat
+# if HAVE_RAW_DECL_LINKAT
+_GL_WARN_ON_USE (linkat, "linkat is unportable - "
+                 "use gnulib module linkat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Set the offset of FD relative to SEEK_SET, SEEK_CUR, or SEEK_END.
+   Return the new offset if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define lseek rpl_lseek
+#  endif
+_GL_FUNCDECL_RPL (lseek, off_t, (int fd, off_t offset, int whence));
+_GL_CXXALIAS_RPL (lseek, off_t, (int fd, off_t offset, int whence));
+# else
+_GL_CXXALIAS_SYS (lseek, off_t, (int fd, off_t offset, int whence));
+# endif
+_GL_CXXALIASWARN (lseek);
+#elif defined GNULIB_POSIXCHECK
+# undef lseek
+# if HAVE_RAW_DECL_LSEEK
+_GL_WARN_ON_USE (lseek, "lseek does not fail with ESPIPE on pipes on some "
+                 "systems - use gnulib module lseek for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Create a pipe, defaulting to O_BINARY mode.
+   Store the read-end as fd[0] and the write-end as fd[1].
+   Return 0 upon success, or -1 with errno set upon failure.  */
+# if !1
+_GL_FUNCDECL_SYS (pipe, int, (int fd[2]) _GL_ARG_NONNULL ((1)));
+# endif
+_GL_CXXALIAS_SYS (pipe, int, (int fd[2]));
+_GL_CXXALIASWARN (pipe);
+#elif defined GNULIB_POSIXCHECK
+# undef pipe
+# if HAVE_RAW_DECL_PIPE
+_GL_WARN_ON_USE (pipe, "pipe is unportable - "
+                 "use gnulib module pipe-posix for portability");
+# endif
+#endif
+
+
+#if 0
+/* Create a pipe, applying the given flags when opening the read-end of the
+   pipe and the write-end of the pipe.
+   The flags are a bitmask, possibly including O_CLOEXEC (defined in <fcntl.h>)
+   and O_TEXT, O_BINARY (defined in "binary-io.h").
+   Store the read-end as fd[0] and the write-end as fd[1].
+   Return 0 upon success, or -1 with errno set upon failure.
+   See also the Linux man page at
+   <https://www.kernel.org/doc/man-pages/online/pages/man2/pipe2.2.html>.  */
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define pipe2 rpl_pipe2
+#  endif
+_GL_FUNCDECL_RPL (pipe2, int, (int fd[2], int flags) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (pipe2, int, (int fd[2], int flags));
+# else
+_GL_FUNCDECL_SYS (pipe2, int, (int fd[2], int flags) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_SYS (pipe2, int, (int fd[2], int flags));
+# endif
+_GL_CXXALIASWARN (pipe2);
+#elif defined GNULIB_POSIXCHECK
+# undef pipe2
+# if HAVE_RAW_DECL_PIPE2
+_GL_WARN_ON_USE (pipe2, "pipe2 is unportable - "
+                 "use gnulib module pipe2 for portability");
+# endif
+#endif
+
+
+#if 0
+/* Read at most BUFSIZE bytes from FD into BUF, starting at OFFSET.
+   Return the number of bytes placed into BUF if successful, otherwise
+   set errno and return -1.  0 indicates EOF.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/pread.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef pread
+#   define pread rpl_pread
+#  endif
+_GL_FUNCDECL_RPL (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (pread, ssize_t,
+                  (int fd, void *buf, size_t bufsize, off_t offset));
+# endif
+_GL_CXXALIASWARN (pread);
+#elif defined GNULIB_POSIXCHECK
+# undef pread
+# if HAVE_RAW_DECL_PREAD
+_GL_WARN_ON_USE (pread, "pread is unportable - "
+                 "use gnulib module pread for portability");
+# endif
+#endif
+
+
+#if 0
+/* Write at most BUFSIZE bytes from BUF into FD, starting at OFFSET.
+   Return the number of bytes written if successful, otherwise
+   set errno and return -1.  0 indicates nothing written.  See the
+   POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/pwrite.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef pwrite
+#   define pwrite rpl_pwrite
+#  endif
+_GL_FUNCDECL_RPL (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (pwrite, ssize_t,
+                  (int fd, const void *buf, size_t bufsize, off_t offset));
+# endif
+_GL_CXXALIASWARN (pwrite);
+#elif defined GNULIB_POSIXCHECK
+# undef pwrite
+# if HAVE_RAW_DECL_PWRITE
+_GL_WARN_ON_USE (pwrite, "pwrite is unportable - "
+                 "use gnulib module pwrite for portability");
+# endif
+#endif
+
+
+#if 0
+/* Read up to COUNT bytes from file descriptor FD into the buffer starting
+   at BUF.  See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/read.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef read
+#   define read rpl_read
+#  endif
+_GL_FUNCDECL_RPL (read, ssize_t, (int fd, void *buf, size_t count)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (read, ssize_t, (int fd, void *buf, size_t count));
+# else
+/* Need to cast, because on mingw, the third parameter is
+                                                          unsigned int count
+   and the return type is 'int'.  */
+_GL_CXXALIAS_SYS_CAST (read, ssize_t, (int fd, void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (read);
+#endif
+
+
+#if 1
+/* Read the contents of the symbolic link FILE and place the first BUFSIZE
+   bytes of it into BUF.  Return the number of bytes placed into BUF if
+   successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define readlink rpl_readlink
+#  endif
+_GL_FUNCDECL_RPL (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize)
+                  _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize)
+                  _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (readlink, ssize_t,
+                  (const char *file, char *buf, size_t bufsize));
+# endif
+_GL_CXXALIASWARN (readlink);
+#elif defined GNULIB_POSIXCHECK
+# undef readlink
+# if HAVE_RAW_DECL_READLINK
+_GL_WARN_ON_USE (readlink, "readlink is unportable - "
+                 "use gnulib module readlink for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define readlinkat rpl_readlinkat
+#  endif
+_GL_FUNCDECL_RPL (readlinkat, ssize_t,
+                  (int fd, char const *file, char *buf, size_t len)
+                  _GL_ARG_NONNULL ((2, 3)));
+_GL_CXXALIAS_RPL (readlinkat, ssize_t,
+                  (int fd, char const *file, char *buf, size_t len));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (readlinkat, ssize_t,
+                  (int fd, char const *file, char *buf, size_t len)
+                  _GL_ARG_NONNULL ((2, 3)));
+#  endif
+_GL_CXXALIAS_SYS (readlinkat, ssize_t,
+                  (int fd, char const *file, char *buf, size_t len));
+# endif
+_GL_CXXALIASWARN (readlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef readlinkat
+# if HAVE_RAW_DECL_READLINKAT
+_GL_WARN_ON_USE (readlinkat, "readlinkat is not portable - "
+                 "use gnulib module readlinkat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Remove the directory DIR.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define rmdir rpl_rmdir
+#  endif
+_GL_FUNCDECL_RPL (rmdir, int, (char const *name) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (rmdir, int, (char const *name));
+# else
+_GL_CXXALIAS_SYS (rmdir, int, (char const *name));
+# endif
+_GL_CXXALIASWARN (rmdir);
+#elif defined GNULIB_POSIXCHECK
+# undef rmdir
+# if HAVE_RAW_DECL_RMDIR
+_GL_WARN_ON_USE (rmdir, "rmdir is unportable - "
+                 "use gnulib module rmdir for portability");
+# endif
+#endif
+
+
+#if 0
+/* Set the host name of the machine.
+   The host name may or may not be fully qualified.
+
+   Put LEN bytes of NAME into the host name.
+   Return 0 if successful, otherwise, set errno and return -1.
+
+   Platforms with no ability to set the hostname return -1 and set
+   errno = ENOSYS.  */
+# if !1 || !1
+_GL_FUNCDECL_SYS (sethostname, int, (const char *name, size_t len)
+                                    _GL_ARG_NONNULL ((1)));
+# endif
+/* Need to cast, because on Solaris 11 2011-10, Mac OS X 10.5, IRIX 6.5
+   and FreeBSD 6.4 the second parameter is int.  On Solaris 11
+   2011-10, the first parameter is not const.  */
+_GL_CXXALIAS_SYS_CAST (sethostname, int, (const char *name, size_t len));
+_GL_CXXALIASWARN (sethostname);
+#elif defined GNULIB_POSIXCHECK
+# undef sethostname
+# if HAVE_RAW_DECL_SETHOSTNAME
+_GL_WARN_ON_USE (sethostname, "sethostname is unportable - "
+                 "use gnulib module sethostname for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Pause the execution of the current thread for N seconds.
+   Returns the number of seconds left to sleep.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/sleep.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef sleep
+#   define sleep rpl_sleep
+#  endif
+_GL_FUNCDECL_RPL (sleep, unsigned int, (unsigned int n));
+_GL_CXXALIAS_RPL (sleep, unsigned int, (unsigned int n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (sleep, unsigned int, (unsigned int n));
+#  endif
+_GL_CXXALIAS_SYS (sleep, unsigned int, (unsigned int n));
+# endif
+_GL_CXXALIASWARN (sleep);
+#elif defined GNULIB_POSIXCHECK
+# undef sleep
+# if HAVE_RAW_DECL_SLEEP
+_GL_WARN_ON_USE (sleep, "sleep is unportable - "
+                 "use gnulib module sleep for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef symlink
+#   define symlink rpl_symlink
+#  endif
+_GL_FUNCDECL_RPL (symlink, int, (char const *contents, char const *file)
+                                _GL_ARG_NONNULL ((1, 2)));
+_GL_CXXALIAS_RPL (symlink, int, (char const *contents, char const *file));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (symlink, int, (char const *contents, char const *file)
+                                _GL_ARG_NONNULL ((1, 2)));
+#  endif
+_GL_CXXALIAS_SYS (symlink, int, (char const *contents, char const *file));
+# endif
+_GL_CXXALIASWARN (symlink);
+#elif defined GNULIB_POSIXCHECK
+# undef symlink
+# if HAVE_RAW_DECL_SYMLINK
+_GL_WARN_ON_USE (symlink, "symlink is not portable - "
+                 "use gnulib module symlink for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef symlinkat
+#   define symlinkat rpl_symlinkat
+#  endif
+_GL_FUNCDECL_RPL (symlinkat, int,
+                  (char const *contents, int fd, char const *file)
+                  _GL_ARG_NONNULL ((1, 3)));
+_GL_CXXALIAS_RPL (symlinkat, int,
+                  (char const *contents, int fd, char const *file));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (symlinkat, int,
+                  (char const *contents, int fd, char const *file)
+                  _GL_ARG_NONNULL ((1, 3)));
+#  endif
+_GL_CXXALIAS_SYS (symlinkat, int,
+                  (char const *contents, int fd, char const *file));
+# endif
+_GL_CXXALIASWARN (symlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef symlinkat
+# if HAVE_RAW_DECL_SYMLINKAT
+_GL_WARN_ON_USE (symlinkat, "symlinkat is not portable - "
+                 "use gnulib module symlinkat for portability");
+# endif
+#endif
+
+
+#if 0
+/* Change the size of the file designated by FILENAME to become equal to LENGTH.
+   Return 0 if successful, otherwise -1 and errno set.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef truncate
+#   define truncate rpl_truncate
+#  endif
+_GL_FUNCDECL_RPL (truncate, int, (const char *filename, off_t length)
+                                 _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (truncate, int, (const char *filename, off_t length));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (truncate, int, (const char *filename, off_t length)
+                                 _GL_ARG_NONNULL ((1)));
+#  endif
+_GL_CXXALIAS_SYS (truncate, int, (const char *filename, off_t length));
+# endif
+_GL_CXXALIASWARN (truncate);
+#elif defined GNULIB_POSIXCHECK
+# undef truncate
+# if HAVE_RAW_DECL_TRUNCATE
+_GL_WARN_ON_USE (truncate, "truncate is unportable - "
+                 "use gnulib module truncate for portability");
+# endif
+#endif
+
+
+#if 0
+/* Store at most BUFLEN characters of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success, otherwise an error number.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef ttyname_r
+#   define ttyname_r rpl_ttyname_r
+#  endif
+_GL_FUNCDECL_RPL (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen) _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen) _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (ttyname_r, int,
+                  (int fd, char *buf, size_t buflen));
+# endif
+_GL_CXXALIASWARN (ttyname_r);
+#elif defined GNULIB_POSIXCHECK
+# undef ttyname_r
+# if HAVE_RAW_DECL_TTYNAME_R
+_GL_WARN_ON_USE (ttyname_r, "ttyname_r is not portable - "
+                 "use gnulib module ttyname_r for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlink
+#   define unlink rpl_unlink
+#  endif
+_GL_FUNCDECL_RPL (unlink, int, (char const *file) _GL_ARG_NONNULL ((1)));
+_GL_CXXALIAS_RPL (unlink, int, (char const *file));
+# else
+_GL_CXXALIAS_SYS (unlink, int, (char const *file));
+# endif
+_GL_CXXALIASWARN (unlink);
+#elif defined GNULIB_POSIXCHECK
+# undef unlink
+# if HAVE_RAW_DECL_UNLINK
+_GL_WARN_ON_USE (unlink, "unlink is not portable - "
+                 "use gnulib module unlink for portability");
+# endif
+#endif
+
+
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef unlinkat
+#   define unlinkat rpl_unlinkat
+#  endif
+_GL_FUNCDECL_RPL (unlinkat, int, (int fd, char const *file, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (unlinkat, int, (int fd, char const *file, int flag));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (unlinkat, int, (int fd, char const *file, int flag)
+                                 _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (unlinkat, int, (int fd, char const *file, int flag));
+# endif
+_GL_CXXALIASWARN (unlinkat);
+#elif defined GNULIB_POSIXCHECK
+# undef unlinkat
+# if HAVE_RAW_DECL_UNLINKAT
+_GL_WARN_ON_USE (unlinkat, "unlinkat is not portable - "
+                 "use gnulib module openat for portability");
+# endif
+#endif
+
+
+#if IN_AUGEAS_GNULIB_TESTS
+/* Pause the execution of the current thread for N microseconds.
+   Returns 0 on completion, or -1 on range error.
+   See the POSIX:2001 specification
+   <http://www.opengroup.org/susv3xsh/usleep.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef usleep
+#   define usleep rpl_usleep
+#  endif
+_GL_FUNCDECL_RPL (usleep, int, (useconds_t n));
+_GL_CXXALIAS_RPL (usleep, int, (useconds_t n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (usleep, int, (useconds_t n));
+#  endif
+_GL_CXXALIAS_SYS (usleep, int, (useconds_t n));
+# endif
+_GL_CXXALIASWARN (usleep);
+#elif defined GNULIB_POSIXCHECK
+# undef usleep
+# if HAVE_RAW_DECL_USLEEP
+_GL_WARN_ON_USE (usleep, "usleep is unportable - "
+                 "use gnulib module usleep for portability");
+# endif
+#endif
+
+
+#if 0
+/* Write up to COUNT bytes starting at BUF to file descriptor FD.
+   See the POSIX:2008 specification
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/write.html>.  */
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef write
+#   define write rpl_write
+#  endif
+_GL_FUNCDECL_RPL (write, ssize_t, (int fd, const void *buf, size_t count)
+                                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (write, ssize_t, (int fd, const void *buf, size_t count));
+# else
+/* Need to cast, because on mingw, the third parameter is
+                                                             unsigned int count
+   and the return type is 'int'.  */
+_GL_CXXALIAS_SYS_CAST (write, ssize_t, (int fd, const void *buf, size_t count));
+# endif
+_GL_CXXALIASWARN (write);
+#endif
+
+_GL_INLINE_HEADER_END
+
+#endif /* _GL_UNISTD_H */
+#endif /* _GL_INCLUDING_UNISTD_H */
+#endif /* _GL_UNISTD_H */
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/wchar.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/wchar.h
new file mode 100644
index 000000000..abd1f76d0
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/wchar.h
@@ -0,0 +1,1546 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
+
+   Copyright (C) 2007-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * ISO C 99 <wchar.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/wchar.h.html>
+ *
+ * For now, this just ensures proper prerequisite inclusion order and
+ * the declaration of wcwidth().
+ */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if (((defined __need_mbstate_t || defined __need_wint_t)               \
+      && !defined __MINGW32__)                                          \
+     || (defined __hpux                                                 \
+         && ((defined _INTTYPES_INCLUDED && !defined strtoimax)         \
+             || defined _GL_JUST_INCLUDE_SYSTEM_WCHAR_H))               \
+     || (defined __MINGW32__ && defined __STRING_H_SOURCED__)           \
+     || defined _GL_ALREADY_INCLUDING_WCHAR_H)
+/* Special invocation convention:
+   - Inside glibc and uClibc header files, but not MinGW.
+   - On HP-UX 11.00 we have a sequence of nested includes
+     <wchar.h> -> <stdlib.h> -> <stdint.h>, and the latter includes <wchar.h>,
+     once indirectly <stdint.h> -> <sys/types.h> -> <inttypes.h> -> <wchar.h>
+     and once directly.  In both situations 'wint_t' is not yet defined,
+     therefore we cannot provide the function overrides; instead include only
+     the system's <wchar.h>.
+   - With MinGW 3.22, when <string.h> includes <wchar.h>, only some part of
+     <wchar.h> is actually processed, and that doesn't include 'mbstate_t'.
+   - On IRIX 6.5, similarly, we have an include <wchar.h> -> <wctype.h>, and
+     the latter includes <wchar.h>.  But here, we have no way to detect whether
+     <wctype.h> is completely included or is still being included.  */
+
+#include_next <wchar.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCHAR_H
+
+#define _GL_ALREADY_INCLUDING_WCHAR_H
+
+#if 1
+# include <features.h> /* for __GLIBC__ */
+#endif
+
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.
+   In some builds of uClibc, <wchar.h> is nonexistent and wchar_t is defined
+   by <stddef.h>.
+   But avoid namespace pollution on glibc systems.  */
+#if !(defined __GLIBC__ && !defined __UCLIBC__)
+# include <stddef.h>
+#endif
+#ifndef __GLIBC__
+# include <stdio.h>
+# include <time.h>
+#endif
+
+/* Include the original <wchar.h> if it exists.
+   Some builds of uClibc lack it.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# include_next <wchar.h>
+#endif
+
+#undef _GL_ALREADY_INCLUDING_WCHAR_H
+
+#ifndef _GL_WCHAR_H
+#define _GL_WCHAR_H
+
+/* The __attribute__ feature is available in gcc versions 2.5 and later.
+   The attribute __pure__ was added in gcc 2.96.  */
+#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
+# define _GL_ATTRIBUTE_PURE __attribute__ ((__pure__))
+#else
+# define _GL_ATTRIBUTE_PURE /* empty */
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_ARG_NONNULL is copied here.  */
+/* A C macro for declaring that specific arguments must not be NULL.
+   Copyright (C) 2009-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_ARG_NONNULL((n,...,m)) tells the compiler and static analyzer tools
+   that the values passed as arguments n, ..., m must be non-NULL pointers.
+   n = 1 stands for the first argument, n = 2 for the second argument etc.  */
+#ifndef _GL_ARG_NONNULL
+# if (__GNUC__ == 3 && __GNUC_MINOR__ >= 3) || __GNUC__ > 3
+#  define _GL_ARG_NONNULL(params) __attribute__ ((__nonnull__ params))
+# else
+#  define _GL_ARG_NONNULL(params)
+# endif
+#endif
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+
+/* Define wint_t and WEOF.  (Also done in wctype.in.h.)  */
+#if !1 && !defined wint_t
+# define wint_t int
+# ifndef WEOF
+#  define WEOF -1
+# endif
+#else
+/* mingw and MSVC define wint_t as 'unsigned short' in <crtdefs.h> or
+   <stddef.h>.  This is too small: ISO C 99 section 7.24.1.(2) says that
+   wint_t must be "unchanged by default argument promotions".  Override it.  */
+# if 0
+#  if !GNULIB_defined_wint_t
+#   if 0
+#    include <crtdefs.h>
+#   else
+#    include <stddef.h>
+#   endif
+typedef unsigned int rpl_wint_t;
+#   undef wint_t
+#   define wint_t rpl_wint_t
+#   define GNULIB_defined_wint_t 1
+#  endif
+# endif
+# ifndef WEOF
+#  define WEOF ((wint_t) -1)
+# endif
+#endif
+
+
+/* Override mbstate_t if it is too small.
+   On IRIX 6.5, sizeof (mbstate_t) == 1, which is not sufficient for
+   implementing mbrtowc for encodings like UTF-8.  */
+#if !(1 && 1) || 0
+# if !GNULIB_defined_mbstate_t
+typedef int rpl_mbstate_t;
+#  undef mbstate_t
+#  define mbstate_t rpl_mbstate_t
+#  define GNULIB_defined_mbstate_t 1
+# endif
+#endif
+
+
+/* Convert a single-byte character to a wide character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef btowc
+#   define btowc rpl_btowc
+#  endif
+_GL_FUNCDECL_RPL (btowc, wint_t, (int c) _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (btowc, wint_t, (int c));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (btowc, wint_t, (int c) _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (btowc, wint_t, (int c));
+# endif
+_GL_CXXALIASWARN (btowc);
+#elif defined GNULIB_POSIXCHECK
+# undef btowc
+# if HAVE_RAW_DECL_BTOWC
+_GL_WARN_ON_USE (btowc, "btowc is unportable - "
+                 "use gnulib module btowc for portability");
+# endif
+#endif
+
+
+/* Convert a wide character to a single-byte character.  */
+#if IN_AUGEAS_GNULIB_TESTS
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wctob
+#   define wctob rpl_wctob
+#  endif
+_GL_FUNCDECL_RPL (wctob, int, (wint_t wc) _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (wctob, int, (wint_t wc));
+# else
+#  if !defined wctob && !1
+/* wctob is provided by gnulib, or wctob exists but is not declared.  */
+_GL_FUNCDECL_SYS (wctob, int, (wint_t wc) _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (wctob, int, (wint_t wc));
+# endif
+_GL_CXXALIASWARN (wctob);
+#elif defined GNULIB_POSIXCHECK
+# undef wctob
+# if HAVE_RAW_DECL_WCTOB
+_GL_WARN_ON_USE (wctob, "wctob is unportable - "
+                 "use gnulib module wctob for portability");
+# endif
+#endif
+
+
+/* Test whether *PS is in the initial state.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsinit
+#   define mbsinit rpl_mbsinit
+#  endif
+_GL_FUNCDECL_RPL (mbsinit, int, (const mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbsinit, int, (const mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbsinit, int, (const mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbsinit, int, (const mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbsinit);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsinit
+# if HAVE_RAW_DECL_MBSINIT
+_GL_WARN_ON_USE (mbsinit, "mbsinit is unportable - "
+                 "use gnulib module mbsinit for portability");
+# endif
+#endif
+
+
+/* Convert a multibyte character to a wide character.  */
+#if 1
+# if 1
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrtowc
+#   define mbrtowc rpl_mbrtowc
+#  endif
+_GL_FUNCDECL_RPL (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrtowc, size_t,
+                  (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbrtowc);
+#elif defined GNULIB_POSIXCHECK
+# undef mbrtowc
+# if HAVE_RAW_DECL_MBRTOWC
+_GL_WARN_ON_USE (mbrtowc, "mbrtowc is unportable - "
+                 "use gnulib module mbrtowc for portability");
+# endif
+#endif
+
+
+/* Recognize a multibyte character.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbrlen
+#   define mbrlen rpl_mbrlen
+#  endif
+_GL_FUNCDECL_RPL (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+_GL_CXXALIAS_RPL (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (mbrlen, size_t, (const char *s, size_t n, mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbrlen);
+#elif defined GNULIB_POSIXCHECK
+# undef mbrlen
+# if HAVE_RAW_DECL_MBRLEN
+_GL_WARN_ON_USE (mbrlen, "mbrlen is unportable - "
+                 "use gnulib module mbrlen for portability");
+# endif
+#endif
+
+
+/* Convert a string to a wide string.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsrtowcs
+#   define mbsrtowcs rpl_mbsrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbsrtowcs);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsrtowcs
+# if HAVE_RAW_DECL_MBSRTOWCS
+_GL_WARN_ON_USE (mbsrtowcs, "mbsrtowcs is unportable - "
+                 "use gnulib module mbsrtowcs for portability");
+# endif
+#endif
+
+
+/* Convert a string to a wide string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef mbsnrtowcs
+#   define mbsnrtowcs rpl_mbsnrtowcs
+#  endif
+_GL_FUNCDECL_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (mbsnrtowcs, size_t,
+                  (wchar_t *dest, const char **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (mbsnrtowcs);
+#elif defined GNULIB_POSIXCHECK
+# undef mbsnrtowcs
+# if HAVE_RAW_DECL_MBSNRTOWCS
+_GL_WARN_ON_USE (mbsnrtowcs, "mbsnrtowcs is unportable - "
+                 "use gnulib module mbsnrtowcs for portability");
+# endif
+#endif
+
+
+/* Convert a wide character to a multibyte character.  */
+#if 1
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcrtomb
+#   define wcrtomb rpl_wcrtomb
+#  endif
+_GL_FUNCDECL_RPL (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+_GL_CXXALIAS_RPL (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+#  endif
+_GL_CXXALIAS_SYS (wcrtomb, size_t, (char *s, wchar_t wc, mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (wcrtomb);
+#elif defined GNULIB_POSIXCHECK
+# undef wcrtomb
+# if HAVE_RAW_DECL_WCRTOMB
+_GL_WARN_ON_USE (wcrtomb, "wcrtomb is unportable - "
+                 "use gnulib module wcrtomb for portability");
+# endif
+#endif
+
+
+/* Convert a wide string to a string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsrtombs
+#   define wcsrtombs rpl_wcsrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len, mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (wcsrtombs);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsrtombs
+# if HAVE_RAW_DECL_WCSRTOMBS
+_GL_WARN_ON_USE (wcsrtombs, "wcsrtombs is unportable - "
+                 "use gnulib module wcsrtombs for portability");
+# endif
+#endif
+
+
+/* Convert a wide string to a string.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsnrtombs
+#   define wcsnrtombs rpl_wcsnrtombs
+#  endif
+_GL_FUNCDECL_RPL (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+_GL_CXXALIAS_RPL (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps)
+                  _GL_ARG_NONNULL ((2)));
+#  endif
+_GL_CXXALIAS_SYS (wcsnrtombs, size_t,
+                  (char *dest, const wchar_t **srcp, size_t srclen, size_t len,
+                   mbstate_t *ps));
+# endif
+_GL_CXXALIASWARN (wcsnrtombs);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsnrtombs
+# if HAVE_RAW_DECL_WCSNRTOMBS
+_GL_WARN_ON_USE (wcsnrtombs, "wcsnrtombs is unportable - "
+                 "use gnulib module wcsnrtombs for portability");
+# endif
+#endif
+
+
+/* Return the number of screen columns needed for WC.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcwidth
+#   define wcwidth rpl_wcwidth
+#  endif
+_GL_FUNCDECL_RPL (wcwidth, int, (wchar_t) _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (wcwidth, int, (wchar_t));
+# else
+#  if !1
+/* wcwidth exists but is not declared.  */
+_GL_FUNCDECL_SYS (wcwidth, int, (wchar_t) _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (wcwidth, int, (wchar_t));
+# endif
+_GL_CXXALIASWARN (wcwidth);
+#elif defined GNULIB_POSIXCHECK
+# undef wcwidth
+# if HAVE_RAW_DECL_WCWIDTH
+_GL_WARN_ON_USE (wcwidth, "wcwidth is unportable - "
+                 "use gnulib module wcwidth for portability");
+# endif
+#endif
+
+
+/* Search N wide characters of S for C.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemchr, wchar_t *, (const wchar_t *s, wchar_t c, size_t n)
+                                      _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wmemchr (const wchar_t *, wchar_t, size_t);
+         wchar_t * std::wmemchr (wchar_t *, wchar_t, size_t);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wmemchr,
+                        wchar_t *, (const wchar_t *, wchar_t, size_t),
+                        const wchar_t *, (const wchar_t *, wchar_t, size_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wmemchr, wchar_t *, (wchar_t *s, wchar_t c, size_t n));
+_GL_CXXALIASWARN1 (wmemchr, const wchar_t *,
+                   (const wchar_t *s, wchar_t c, size_t n));
+# else
+_GL_CXXALIASWARN (wmemchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wmemchr
+# if HAVE_RAW_DECL_WMEMCHR
+_GL_WARN_ON_USE (wmemchr, "wmemchr is unportable - "
+                 "use gnulib module wmemchr for portability");
+# endif
+#endif
+
+
+/* Compare N wide characters of S1 and S2.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemcmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wmemcmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n));
+_GL_CXXALIASWARN (wmemcmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wmemcmp
+# if HAVE_RAW_DECL_WMEMCMP
+_GL_WARN_ON_USE (wmemcmp, "wmemcmp is unportable - "
+                 "use gnulib module wmemcmp for portability");
+# endif
+#endif
+
+
+/* Copy N wide characters of SRC to DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemcpy, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmemcpy, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+_GL_CXXALIASWARN (wmemcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wmemcpy
+# if HAVE_RAW_DECL_WMEMCPY
+_GL_WARN_ON_USE (wmemcpy, "wmemcpy is unportable - "
+                 "use gnulib module wmemcpy for portability");
+# endif
+#endif
+
+
+/* Copy N wide characters of SRC to DEST, guaranteeing correct behavior for
+   overlapping memory areas.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemmove, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmemmove, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+_GL_CXXALIASWARN (wmemmove);
+#elif defined GNULIB_POSIXCHECK
+# undef wmemmove
+# if HAVE_RAW_DECL_WMEMMOVE
+_GL_WARN_ON_USE (wmemmove, "wmemmove is unportable - "
+                 "use gnulib module wmemmove for portability");
+# endif
+#endif
+
+
+/* Set N wide characters of S to C.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wmemset, wchar_t *, (wchar_t *s, wchar_t c, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wmemset, wchar_t *, (wchar_t *s, wchar_t c, size_t n));
+_GL_CXXALIASWARN (wmemset);
+#elif defined GNULIB_POSIXCHECK
+# undef wmemset
+# if HAVE_RAW_DECL_WMEMSET
+_GL_WARN_ON_USE (wmemset, "wmemset is unportable - "
+                 "use gnulib module wmemset for portability");
+# endif
+#endif
+
+
+/* Return the number of wide characters in S.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcslen, size_t, (const wchar_t *s) _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcslen, size_t, (const wchar_t *s));
+_GL_CXXALIASWARN (wcslen);
+#elif defined GNULIB_POSIXCHECK
+# undef wcslen
+# if HAVE_RAW_DECL_WCSLEN
+_GL_WARN_ON_USE (wcslen, "wcslen is unportable - "
+                 "use gnulib module wcslen for portability");
+# endif
+#endif
+
+
+/* Return the number of wide characters in S, but at most MAXLEN.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsnlen, size_t, (const wchar_t *s, size_t maxlen)
+                                   _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsnlen, size_t, (const wchar_t *s, size_t maxlen));
+_GL_CXXALIASWARN (wcsnlen);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsnlen
+# if HAVE_RAW_DECL_WCSNLEN
+_GL_WARN_ON_USE (wcsnlen, "wcsnlen is unportable - "
+                 "use gnulib module wcsnlen for portability");
+# endif
+#endif
+
+
+/* Copy SRC to DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscpy, wchar_t *, (wchar_t *dest, const wchar_t *src));
+# endif
+_GL_CXXALIAS_SYS (wcscpy, wchar_t *, (wchar_t *dest, const wchar_t *src));
+_GL_CXXALIASWARN (wcscpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscpy
+# if HAVE_RAW_DECL_WCSCPY
+_GL_WARN_ON_USE (wcscpy, "wcscpy is unportable - "
+                 "use gnulib module wcscpy for portability");
+# endif
+#endif
+
+
+/* Copy SRC to DEST, returning the address of the terminating L'\0' in DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcpcpy, wchar_t *, (wchar_t *dest, const wchar_t *src));
+# endif
+_GL_CXXALIAS_SYS (wcpcpy, wchar_t *, (wchar_t *dest, const wchar_t *src));
+_GL_CXXALIASWARN (wcpcpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wcpcpy
+# if HAVE_RAW_DECL_WCPCPY
+_GL_WARN_ON_USE (wcpcpy, "wcpcpy is unportable - "
+                 "use gnulib module wcpcpy for portability");
+# endif
+#endif
+
+
+/* Copy no more than N wide characters of SRC to DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncpy, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcsncpy, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+_GL_CXXALIASWARN (wcsncpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncpy
+# if HAVE_RAW_DECL_WCSNCPY
+_GL_WARN_ON_USE (wcsncpy, "wcsncpy is unportable - "
+                 "use gnulib module wcsncpy for portability");
+# endif
+#endif
+
+
+/* Copy no more than N characters of SRC to DEST, returning the address of
+   the last character written into DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcpncpy, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcpncpy, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+_GL_CXXALIASWARN (wcpncpy);
+#elif defined GNULIB_POSIXCHECK
+# undef wcpncpy
+# if HAVE_RAW_DECL_WCPNCPY
+_GL_WARN_ON_USE (wcpncpy, "wcpncpy is unportable - "
+                 "use gnulib module wcpncpy for portability");
+# endif
+#endif
+
+
+/* Append SRC onto DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscat, wchar_t *, (wchar_t *dest, const wchar_t *src));
+# endif
+_GL_CXXALIAS_SYS (wcscat, wchar_t *, (wchar_t *dest, const wchar_t *src));
+_GL_CXXALIASWARN (wcscat);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscat
+# if HAVE_RAW_DECL_WCSCAT
+_GL_WARN_ON_USE (wcscat, "wcscat is unportable - "
+                 "use gnulib module wcscat for portability");
+# endif
+#endif
+
+
+/* Append no more than N wide characters of SRC onto DEST.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncat, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcsncat, wchar_t *,
+                  (wchar_t *dest, const wchar_t *src, size_t n));
+_GL_CXXALIASWARN (wcsncat);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncat
+# if HAVE_RAW_DECL_WCSNCAT
+_GL_WARN_ON_USE (wcsncat, "wcsncat is unportable - "
+                 "use gnulib module wcsncat for portability");
+# endif
+#endif
+
+
+/* Compare S1 and S2.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscmp, int, (const wchar_t *s1, const wchar_t *s2)
+                               _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcscmp, int, (const wchar_t *s1, const wchar_t *s2));
+_GL_CXXALIASWARN (wcscmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscmp
+# if HAVE_RAW_DECL_WCSCMP
+_GL_WARN_ON_USE (wcscmp, "wcscmp is unportable - "
+                 "use gnulib module wcscmp for portability");
+# endif
+#endif
+
+
+/* Compare no more than N wide characters of S1 and S2.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsncmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n));
+_GL_CXXALIASWARN (wcsncmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncmp
+# if HAVE_RAW_DECL_WCSNCMP
+_GL_WARN_ON_USE (wcsncmp, "wcsncmp is unportable - "
+                 "use gnulib module wcsncmp for portability");
+# endif
+#endif
+
+
+/* Compare S1 and S2, ignoring case.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscasecmp, int, (const wchar_t *s1, const wchar_t *s2)
+                                   _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcscasecmp, int, (const wchar_t *s1, const wchar_t *s2));
+_GL_CXXALIASWARN (wcscasecmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscasecmp
+# if HAVE_RAW_DECL_WCSCASECMP
+_GL_WARN_ON_USE (wcscasecmp, "wcscasecmp is unportable - "
+                 "use gnulib module wcscasecmp for portability");
+# endif
+#endif
+
+
+/* Compare no more than N chars of S1 and S2, ignoring case.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsncasecmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsncasecmp, int,
+                  (const wchar_t *s1, const wchar_t *s2, size_t n));
+_GL_CXXALIASWARN (wcsncasecmp);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsncasecmp
+# if HAVE_RAW_DECL_WCSNCASECMP
+_GL_WARN_ON_USE (wcsncasecmp, "wcsncasecmp is unportable - "
+                 "use gnulib module wcsncasecmp for portability");
+# endif
+#endif
+
+
+/* Compare S1 and S2, both interpreted as appropriate to the LC_COLLATE
+   category of the current locale.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscoll, int, (const wchar_t *s1, const wchar_t *s2));
+# endif
+_GL_CXXALIAS_SYS (wcscoll, int, (const wchar_t *s1, const wchar_t *s2));
+_GL_CXXALIASWARN (wcscoll);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscoll
+# if HAVE_RAW_DECL_WCSCOLL
+_GL_WARN_ON_USE (wcscoll, "wcscoll is unportable - "
+                 "use gnulib module wcscoll for portability");
+# endif
+#endif
+
+
+/* Transform S2 into array pointed to by S1 such that if wcscmp is applied
+   to two transformed strings the result is the as applying 'wcscoll' to the
+   original strings.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsxfrm, size_t, (wchar_t *s1, const wchar_t *s2, size_t n));
+# endif
+_GL_CXXALIAS_SYS (wcsxfrm, size_t, (wchar_t *s1, const wchar_t *s2, size_t n));
+_GL_CXXALIASWARN (wcsxfrm);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsxfrm
+# if HAVE_RAW_DECL_WCSXFRM
+_GL_WARN_ON_USE (wcsxfrm, "wcsxfrm is unportable - "
+                 "use gnulib module wcsxfrm for portability");
+# endif
+#endif
+
+
+/* Duplicate S, returning an identical malloc'd string.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsdup, wchar_t *, (const wchar_t *s));
+# endif
+_GL_CXXALIAS_SYS (wcsdup, wchar_t *, (const wchar_t *s));
+_GL_CXXALIASWARN (wcsdup);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsdup
+# if HAVE_RAW_DECL_WCSDUP
+_GL_WARN_ON_USE (wcsdup, "wcsdup is unportable - "
+                 "use gnulib module wcsdup for portability");
+# endif
+#endif
+
+
+/* Find the first occurrence of WC in WCS.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcschr, wchar_t *, (const wchar_t *wcs, wchar_t wc)
+                                     _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcschr (const wchar_t *, wchar_t);
+         wchar_t * std::wcschr (wchar_t *, wchar_t);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcschr,
+                        wchar_t *, (const wchar_t *, wchar_t),
+                        const wchar_t *, (const wchar_t *, wchar_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcschr, wchar_t *, (wchar_t *wcs, wchar_t wc));
+_GL_CXXALIASWARN1 (wcschr, const wchar_t *, (const wchar_t *wcs, wchar_t wc));
+# else
+_GL_CXXALIASWARN (wcschr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcschr
+# if HAVE_RAW_DECL_WCSCHR
+_GL_WARN_ON_USE (wcschr, "wcschr is unportable - "
+                 "use gnulib module wcschr for portability");
+# endif
+#endif
+
+
+/* Find the last occurrence of WC in WCS.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsrchr, wchar_t *, (const wchar_t *wcs, wchar_t wc)
+                                      _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcsrchr (const wchar_t *, wchar_t);
+         wchar_t * std::wcsrchr (wchar_t *, wchar_t);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcsrchr,
+                        wchar_t *, (const wchar_t *, wchar_t),
+                        const wchar_t *, (const wchar_t *, wchar_t));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcsrchr, wchar_t *, (wchar_t *wcs, wchar_t wc));
+_GL_CXXALIASWARN1 (wcsrchr, const wchar_t *, (const wchar_t *wcs, wchar_t wc));
+# else
+_GL_CXXALIASWARN (wcsrchr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsrchr
+# if HAVE_RAW_DECL_WCSRCHR
+_GL_WARN_ON_USE (wcsrchr, "wcsrchr is unportable - "
+                 "use gnulib module wcsrchr for portability");
+# endif
+#endif
+
+
+/* Return the length of the initial segmet of WCS which consists entirely
+   of wide characters not in REJECT.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcscspn, size_t, (const wchar_t *wcs, const wchar_t *reject)
+                                   _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcscspn, size_t, (const wchar_t *wcs, const wchar_t *reject));
+_GL_CXXALIASWARN (wcscspn);
+#elif defined GNULIB_POSIXCHECK
+# undef wcscspn
+# if HAVE_RAW_DECL_WCSCSPN
+_GL_WARN_ON_USE (wcscspn, "wcscspn is unportable - "
+                 "use gnulib module wcscspn for portability");
+# endif
+#endif
+
+
+/* Return the length of the initial segmet of WCS which consists entirely
+   of wide characters in ACCEPT.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsspn, size_t, (const wchar_t *wcs, const wchar_t *accept)
+                                  _GL_ATTRIBUTE_PURE);
+# endif
+_GL_CXXALIAS_SYS (wcsspn, size_t, (const wchar_t *wcs, const wchar_t *accept));
+_GL_CXXALIASWARN (wcsspn);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsspn
+# if HAVE_RAW_DECL_WCSSPN
+_GL_WARN_ON_USE (wcsspn, "wcsspn is unportable - "
+                 "use gnulib module wcsspn for portability");
+# endif
+#endif
+
+
+/* Find the first occurrence in WCS of any character in ACCEPT.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcspbrk, wchar_t *,
+                  (const wchar_t *wcs, const wchar_t *accept)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcspbrk (const wchar_t *, const wchar_t *);
+         wchar_t * std::wcspbrk (wchar_t *, const wchar_t *);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcspbrk,
+                        wchar_t *, (const wchar_t *, const wchar_t *),
+                        const wchar_t *, (const wchar_t *, const wchar_t *));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcspbrk, wchar_t *,
+                   (wchar_t *wcs, const wchar_t *accept));
+_GL_CXXALIASWARN1 (wcspbrk, const wchar_t *,
+                   (const wchar_t *wcs, const wchar_t *accept));
+# else
+_GL_CXXALIASWARN (wcspbrk);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcspbrk
+# if HAVE_RAW_DECL_WCSPBRK
+_GL_WARN_ON_USE (wcspbrk, "wcspbrk is unportable - "
+                 "use gnulib module wcspbrk for portability");
+# endif
+#endif
+
+
+/* Find the first occurrence of NEEDLE in HAYSTACK.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcsstr, wchar_t *,
+                  (const wchar_t *haystack, const wchar_t *needle)
+                  _GL_ATTRIBUTE_PURE);
+# endif
+  /* On some systems, this function is defined as an overloaded function:
+       extern "C++" {
+         const wchar_t * std::wcsstr (const wchar_t *, const wchar_t *);
+         wchar_t * std::wcsstr (wchar_t *, const wchar_t *);
+       }  */
+_GL_CXXALIAS_SYS_CAST2 (wcsstr,
+                        wchar_t *, (const wchar_t *, const wchar_t *),
+                        const wchar_t *, (const wchar_t *, const wchar_t *));
+# if ((__GLIBC__ == 2 && __GLIBC_MINOR__ >= 10) && !defined __UCLIBC__) \
+     && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 4))
+_GL_CXXALIASWARN1 (wcsstr, wchar_t *,
+                   (wchar_t *haystack, const wchar_t *needle));
+_GL_CXXALIASWARN1 (wcsstr, const wchar_t *,
+                   (const wchar_t *haystack, const wchar_t *needle));
+# else
+_GL_CXXALIASWARN (wcsstr);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcsstr
+# if HAVE_RAW_DECL_WCSSTR
+_GL_WARN_ON_USE (wcsstr, "wcsstr is unportable - "
+                 "use gnulib module wcsstr for portability");
+# endif
+#endif
+
+
+/* Divide WCS into tokens separated by characters in DELIM.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wcstok, wchar_t *,
+                  (wchar_t *wcs, const wchar_t *delim, wchar_t **ptr));
+# endif
+_GL_CXXALIAS_SYS (wcstok, wchar_t *,
+                  (wchar_t *wcs, const wchar_t *delim, wchar_t **ptr));
+_GL_CXXALIASWARN (wcstok);
+#elif defined GNULIB_POSIXCHECK
+# undef wcstok
+# if HAVE_RAW_DECL_WCSTOK
+_GL_WARN_ON_USE (wcstok, "wcstok is unportable - "
+                 "use gnulib module wcstok for portability");
+# endif
+#endif
+
+
+/* Determine number of column positions required for first N wide
+   characters (or fewer if S ends before this) in S.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcswidth
+#   define wcswidth rpl_wcswidth
+#  endif
+_GL_FUNCDECL_RPL (wcswidth, int, (const wchar_t *s, size_t n)
+                                 _GL_ATTRIBUTE_PURE);
+_GL_CXXALIAS_RPL (wcswidth, int, (const wchar_t *s, size_t n));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcswidth, int, (const wchar_t *s, size_t n)
+                                 _GL_ATTRIBUTE_PURE);
+#  endif
+_GL_CXXALIAS_SYS (wcswidth, int, (const wchar_t *s, size_t n));
+# endif
+_GL_CXXALIASWARN (wcswidth);
+#elif defined GNULIB_POSIXCHECK
+# undef wcswidth
+# if HAVE_RAW_DECL_WCSWIDTH
+_GL_WARN_ON_USE (wcswidth, "wcswidth is unportable - "
+                 "use gnulib module wcswidth for portability");
+# endif
+#endif
+
+
+/* Convert *TP to a date and time wide string.  See
+   <http://pubs.opengroup.org/onlinepubs/9699919799/functions/wcsftime.html>.  */
+#if 0
+# if 0
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   undef wcsftime
+#   define wcsftime rpl_wcsftime
+#  endif
+_GL_FUNCDECL_RPL (wcsftime, size_t, (wchar_t *__buf, size_t __bufsize,
+                                     const wchar_t *__fmt, const struct tm *__tp)
+                                    _GL_ARG_NONNULL ((1, 3, 4)));
+_GL_CXXALIAS_RPL (wcsftime, size_t, (wchar_t *__buf, size_t __bufsize,
+                                     const wchar_t *__fmt, const struct tm *__tp));
+# else
+#  if !1
+_GL_FUNCDECL_SYS (wcsftime, size_t, (wchar_t *__buf, size_t __bufsize,
+                                     const wchar_t *__fmt, const struct tm *__tp)
+                                    _GL_ARG_NONNULL ((1, 3, 4)));
+#  endif
+_GL_CXXALIAS_SYS (wcsftime, size_t, (wchar_t *__buf, size_t __bufsize,
+                                     const wchar_t *__fmt, const struct tm *__tp));
+# endif
+_GL_CXXALIASWARN (wcsftime);
+#elif defined GNULIB_POSIXCHECK
+# undef wcsftime
+# if HAVE_RAW_DECL_WCSFTIME
+_GL_WARN_ON_USE (wcsftime, "wcsftime is unportable - "
+                 "use gnulib module wcsftime for portability");
+# endif
+#endif
+
+
+#endif /* _GL_WCHAR_H */
+#endif /* _GL_WCHAR_H */
+#endif
diff --git a/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/wctype.h b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/wctype.h
new file mode 100644
index 000000000..9c3aa2b36
--- /dev/null
+++ b/libraries/cmake/source/augeas/gnulib/generated/linux/ppc64le/lib/wctype.h
@@ -0,0 +1,981 @@
+/* DO NOT EDIT! GENERATED AUTOMATICALLY! */
+/* A substitute for ISO C99 <wctype.h>, for platforms that lack it.
+
+   Copyright (C) 2006-2019 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, see <https://www.gnu.org/licenses/>.  */
+
+/* Written by Bruno Haible and Paul Eggert.  */
+
+/*
+ * ISO C 99 <wctype.h> for platforms that lack it.
+ * <http://www.opengroup.org/susv3xbd/wctype.h.html>
+ *
+ * iswctype, towctrans, towlower, towupper, wctrans, wctype,
+ * wctrans_t, and wctype_t are not yet implemented.
+ */
+
+#if __GNUC__ >= 3
+#pragma GCC system_header
+#endif
+
+
+#if (defined __MINGW32__ && defined __CTYPE_H_SOURCED__)
+
+/* Special invocation convention:
+   - With MinGW 3.22, when <ctype.h> includes <wctype.h>, only some part of
+     <wctype.h> is being processed, which doesn't include the idempotency
+     guard.   */
+
+#include_next <wctype.h>
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_WCTYPE_H
+
+#if 1
+/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.
+   Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.  */
+# include <stddef.h>
+# include <stdio.h>
+# include <time.h>
+# include <wchar.h>
+#endif
+
+/* Native Windows (mingw, MSVC) have declarations of towupper, towlower, and
+   isw* functions in <ctype.h>, <wchar.h> as well as in <wctype.h>.  Include
+   <ctype.h>, <wchar.h> in advance to avoid rpl_ prefix being added to the
+   declarations.  */
+#if defined _WIN32 && ! defined __CYGWIN__
+# include <ctype.h>
+# include <wchar.h>
+#endif
+
+/* Include the original <wctype.h> if it exists.
+   BeOS 5 has the functions but no <wctype.h>.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if 1
+# include_next <wctype.h>
+#endif
+
+#ifndef _GL_WCTYPE_H
+#define _GL_WCTYPE_H
+
+#ifndef _GL_INLINE_HEADER_BEGIN
+ #error "Please include config.h first."
+#endif
+_GL_INLINE_HEADER_BEGIN
+#ifndef _GL_WCTYPE_INLINE
+# define _GL_WCTYPE_INLINE _GL_INLINE
+#endif
+
+/* The definitions of _GL_FUNCDECL_RPL etc. are copied here.  */
+/* C++ compatible function declaration macros.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_CXXDEFS_H
+#define _GL_CXXDEFS_H
+
+/* Begin/end the GNULIB_NAMESPACE namespace.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_BEGIN_NAMESPACE namespace GNULIB_NAMESPACE {
+# define _GL_END_NAMESPACE }
+#else
+# define _GL_BEGIN_NAMESPACE
+# define _GL_END_NAMESPACE
+#endif
+
+/* The three most frequent use cases of these macros are:
+
+   * For providing a substitute for a function that is missing on some
+     platforms, but is declared and works fine on the platforms on which
+     it exists:
+
+       #if @GNULIB_FOO@
+       # if !@HAVE_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       # endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on all platforms,
+     but is broken/insufficient and needs to be replaced on some platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+
+   * For providing a replacement for a function that exists on some platforms
+     but is broken/insufficient and needs to be replaced on some of them and
+     is additionally either missing or undeclared on some other platforms:
+
+       #if @GNULIB_FOO@
+       # if @REPLACE_FOO@
+       #  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+       #   undef foo
+       #   define foo rpl_foo
+       #  endif
+       _GL_FUNCDECL_RPL (foo, ...);
+       _GL_CXXALIAS_RPL (foo, ...);
+       # else
+       #  if !@HAVE_FOO@   or   if !@HAVE_DECL_FOO@
+       _GL_FUNCDECL_SYS (foo, ...);
+       #  endif
+       _GL_CXXALIAS_SYS (foo, ...);
+       # endif
+       _GL_CXXALIASWARN (foo);
+       #elif defined GNULIB_POSIXCHECK
+       ...
+       #endif
+*/
+
+/* _GL_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#if defined __cplusplus
+# define _GL_EXTERN_C extern "C"
+#else
+# define _GL_EXTERN_C extern
+#endif
+
+/* _GL_FUNCDECL_RPL (func, rettype, parameters_and_attributes);
+   declares a replacement function, named rpl_func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_RPL (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_RPL(func,rettype,parameters_and_attributes) \
+  _GL_FUNCDECL_RPL_1 (rpl_##func, rettype, parameters_and_attributes)
+#define _GL_FUNCDECL_RPL_1(rpl_func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype rpl_func parameters_and_attributes
+
+/* _GL_FUNCDECL_SYS (func, rettype, parameters_and_attributes);
+   declares the system function, named func, with the given prototype,
+   consisting of return type, parameters, and attributes.
+   Example:
+     _GL_FUNCDECL_SYS (open, int, (const char *filename, int flags, ...)
+                                  _GL_ARG_NONNULL ((1)));
+ */
+#define _GL_FUNCDECL_SYS(func,rettype,parameters_and_attributes) \
+  _GL_EXTERN_C rettype func parameters_and_attributes
+
+/* _GL_CXXALIAS_RPL (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to rpl_func, if GNULIB_NAMESPACE is defined.
+   Example:
+     _GL_CXXALIAS_RPL (open, int, (const char *filename, int flags, ...));
+
+   Wrapping rpl_func in an object with an inline conversion operator
+   avoids a reference to rpl_func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#define _GL_CXXALIAS_RPL(func,rettype,parameters) \
+  _GL_CXXALIAS_RPL_1 (func, rpl_##func, rettype, parameters)
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::rpl_func;                                  \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_RPL_CAST_1 (func, rpl_func, rettype, parameters);
+   is like  _GL_CXXALIAS_RPL_1 (func, rpl_func, rettype, parameters);
+   except that the C function rpl_func may have a slightly different
+   declaration.  A cast is used to silence the "invalid conversion" error
+   that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                                     \
+    {                                                              \
+      static const struct _gl_ ## func ## _wrapper                 \
+      {                                                            \
+        typedef rettype (*type) parameters;                        \
+                                                                   \
+        inline operator type () const                              \
+        {                                                          \
+          return reinterpret_cast<type>(::rpl_func);               \
+        }                                                          \
+      } func = {};                                                 \
+    }                                                              \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_RPL_CAST_1(func,rpl_func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS (func, rettype, parameters);
+   declares a C++ alias called GNULIB_NAMESPACE::func
+   that redirects to the system provided function func, if GNULIB_NAMESPACE
+   is defined.
+   Example:
+     _GL_CXXALIAS_SYS (open, int, (const char *filename, int flags, ...));
+
+   Wrapping func in an object with an inline conversion operator
+   avoids a reference to func unless GNULIB_NAMESPACE::func is
+   actually used in the program.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS(func,rettype,parameters)            \
+    namespace GNULIB_NAMESPACE                                \
+    {                                                         \
+      static const struct _gl_ ## func ## _wrapper            \
+      {                                                       \
+        typedef rettype (*type) parameters;                   \
+                                                              \
+        inline operator type () const                         \
+        {                                                     \
+          return ::func;                                      \
+        }                                                     \
+      } func = {};                                            \
+    }                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST (func, rettype, parameters);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function func may have a slightly different declaration.
+   A cast is used to silence the "invalid conversion" error that would
+   otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    namespace GNULIB_NAMESPACE                          \
+    {                                                   \
+      static const struct _gl_ ## func ## _wrapper      \
+      {                                                 \
+        typedef rettype (*type) parameters;             \
+                                                        \
+        inline operator type () const                   \
+        {                                               \
+          return reinterpret_cast<type>(::func);        \
+        }                                               \
+      } func = {};                                      \
+    }                                                   \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST(func,rettype,parameters) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIAS_SYS_CAST2 (func, rettype, parameters, rettype2, parameters2);
+   is like  _GL_CXXALIAS_SYS (func, rettype, parameters);
+   except that the C function is picked among a set of overloaded functions,
+   namely the one with rettype2 and parameters2.  Two consecutive casts
+   are used to silence the "cannot find a match" and "invalid conversion"
+   errors that would otherwise occur.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+  /* The outer cast must be a reinterpret_cast.
+     The inner cast: When the function is defined as a set of overloaded
+     functions, it works as a static_cast<>, choosing the designated variant.
+     When the function is defined as a single variant, it works as a
+     reinterpret_cast<>. The parenthesized cast syntax works both ways.  */
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    namespace GNULIB_NAMESPACE                                                \
+    {                                                                         \
+      static const struct _gl_ ## func ## _wrapper                            \
+      {                                                                       \
+        typedef rettype (*type) parameters;                                   \
+                                                                              \
+        inline operator type () const                                         \
+        {                                                                     \
+          return reinterpret_cast<type>((rettype2 (*) parameters2)(::func));  \
+        }                                                                     \
+      } func = {};                                                            \
+    }                                                                         \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#else
+# define _GL_CXXALIAS_SYS_CAST2(func,rettype,parameters,rettype2,parameters2) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN (func);
+   causes a warning to be emitted when ::func is used but not when
+   GNULIB_NAMESPACE::func is used.  func must be defined without overloaded
+   variants.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN(func) \
+   _GL_CXXALIASWARN_1 (func, GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN_1(func,namespace) \
+   _GL_CXXALIASWARN_2 (func, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+    _GL_WARN_ON_USE (func, \
+                     "The symbol ::" #func " refers to the system function. " \
+                     "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN_2(func,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN(func) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+/* _GL_CXXALIASWARN1 (func, rettype, parameters_and_attributes);
+   causes a warning to be emitted when the given overloaded variant of ::func
+   is used but not when GNULIB_NAMESPACE::func is used.  */
+#if defined __cplusplus && defined GNULIB_NAMESPACE
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+   _GL_CXXALIASWARN1_1 (func, rettype, parameters_and_attributes, \
+                        GNULIB_NAMESPACE)
+# define _GL_CXXALIASWARN1_1(func,rettype,parameters_and_attributes,namespace) \
+   _GL_CXXALIASWARN1_2 (func, rettype, parameters_and_attributes, namespace)
+/* To work around GCC bug <https://gcc.gnu.org/bugzilla/show_bug.cgi?id=43881>,
+   we enable the warning only when not optimizing.  */
+# if !__OPTIMIZE__
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+    _GL_WARN_ON_USE_CXX (func, rettype, parameters_and_attributes, \
+                         "The symbol ::" #func " refers to the system function. " \
+                         "Use " #namespace "::" #func " instead.")
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     extern __typeof__ (func) func
+# else
+#  define _GL_CXXALIASWARN1_2(func,rettype,parameters_and_attributes,namespace) \
+     _GL_EXTERN_C int _gl_cxxalias_dummy
+# endif
+#else
+# define _GL_CXXALIASWARN1(func,rettype,parameters_and_attributes) \
+    _GL_EXTERN_C int _gl_cxxalias_dummy
+#endif
+
+#endif /* _GL_CXXDEFS_H */
+
+/* The definition of _GL_WARN_ON_USE is copied here.  */
+/* A C macro for emitting warnings if a function is used.
+   Copyright (C) 2010-2019 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */
+
+/* _GL_WARN_ON_USE (function, "literal string") issues a declaration
+   for FUNCTION which will then trigger a compiler warning containing
+   the text of "literal string" anywhere that function is called, if
+   supported by the compiler.  If the compiler does not support this
+   feature, the macro expands to an unused extern declaration.
+
+   _GL_WARN_ON_USE_ATTRIBUTE ("literal string") expands to the
+   attribute used in _GL_WARN_ON_USE.  If the compiler does not support
+   this feature, it expands to empty.
+
+   These macros are useful for marking a function as a potential
+   portability trap, with the intent that "literal string" include
+   instructions on the replacement function that should be used
+   instead.
+   _GL_WARN_ON_USE is for functions with 'extern' linkage.
+   _GL_WARN_ON_USE_ATTRIBUTE is for functions with 'static' or 'inline'
+   linkage.
+
+   However, one of the reasons that a function is a portability trap is
+   if it has the wrong signature.  Declaring FUNCTION with a different
+   signature in C is a compilation error, so this macro must use the
+   same type as any existing declaration so that programs that avoid
+   the problematic FUNCTION do not fail to compile merely because they
+   included a header that poisoned the function.  But this implies that
+   _GL_WARN_ON_USE is only safe to use if FUNCTION is known to already
+   have a declaration.  Use of this macro implies that there must not
+   be any other macro hiding the declaration of FUNCTION; but
+   undefining FUNCTION first is part of the poisoning process anyway
+   (although for symbols that are provided only via a macro, the result
+   is a compilation error rather than a warning containing
+   "literal string").  Also note that in C++, it is only safe to use if
+   FUNCTION has no overloads.
+
+   For an example, it is possible to poison 'getline' by:
+   - adding a call to gl_WARN_ON_USE_PREPARE([[#include <stdio.h>]],
+     [getline]) in configure.ac, which potentially defines
+     HAVE_RAW_DECL_GETLINE
+   - adding this code to a header that wraps the system <stdio.h>:
+     #undef getline
+     #if HAVE_RAW_DECL_GETLINE
+     _GL_WARN_ON_USE (getline, "getline is required by POSIX 2008, but"
+       "not universally present; use the gnulib module getline");
+     #endif
+
+   It is not possible to directly poison global variables.  But it is
+   possible to write a wrapper accessor function, and poison that
+   (less common usage, like &environ, will cause a compilation error
+   rather than issue the nice warning, but the end result of informing
+   the developer about their portability problem is still achieved):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     rpl_environ (void) { return &environ; }
+     _GL_WARN_ON_USE (rpl_environ, "environ is not always properly declared");
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   or better (avoiding contradictory use of 'static' and 'extern'):
+     #if HAVE_RAW_DECL_ENVIRON
+     static char ***
+     _GL_WARN_ON_USE_ATTRIBUTE ("environ is not always properly declared")
+     rpl_environ (void) { return &environ; }
+     # undef environ
+     # define environ (*rpl_environ ())
+     #endif
+   */
+#ifndef _GL_WARN_ON_USE
+
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+/* A compiler attribute is available in gcc versions 4.3.0 and later.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function __attribute__ ((__warning__ (message)))
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message) \
+  __attribute__ ((__warning__ (message)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE(function, message) \
+extern __typeof__ (function) function
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE(function, message) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+#  define _GL_WARN_ON_USE_ATTRIBUTE(message)
+# endif
+#endif
+
+/* _GL_WARN_ON_USE_CXX (function, rettype, parameters_and_attributes, "string")
+   is like _GL_WARN_ON_USE (function, "string"), except that the function is
+   declared with the given prototype, consisting of return type, parameters,
+   and attributes.
+   This variant is useful for overloaded functions in C++. _GL_WARN_ON_USE does
+   not work in this case.  */
+#ifndef _GL_WARN_ON_USE_CXX
+# if 4 < __GNUC__ || (__GNUC__ == 4 && 3 <= __GNUC_MINOR__)
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes \
+     __attribute__ ((__warning__ (msg)))
+# elif __GNUC__ >= 3 && GNULIB_STRICT_CHECKING
+/* Verify the existence of the function.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+extern rettype function parameters_and_attributes
+# else /* Unsupported.  */
+#  define _GL_WARN_ON_USE_CXX(function,rettype,parameters_and_attributes,msg) \
+_GL_WARN_EXTERN_C int _gl_warn_on_use
+# endif
+#endif
+
+/* _GL_WARN_EXTERN_C declaration;
+   performs the declaration with C linkage.  */
+#ifndef _GL_WARN_EXTERN_C
+# if defined __cplusplus
+#  define _GL_WARN_EXTERN_C extern "C"
+# else
+#  define _GL_WARN_EXTERN_C extern
+# endif
+#endif
+
+/* Solaris 2.6 <wctype.h> includes <widec.h> which includes <euc.h> which
+   #defines a number of identifiers in the application namespace.  Revert
+   these #defines.  */
+#ifdef __sun
+# undef multibyte
+# undef eucw1
+# undef eucw2
+# undef eucw3
+# undef scrw1
+# undef scrw2
+# undef scrw3
+#endif
+
+/* Define wint_t and WEOF.  (Also done in wchar.in.h.)  */
+#if !1 && !defined wint_t
+# define wint_t int
+# ifndef WEOF
+#  define WEOF -1
+# endif
+#else
+/* mingw and MSVC define wint_t as 'unsigned short' in <crtdefs.h> or
+   <stddef.h>.  This is too small: ISO C 99 section 7.24.1.(2) says that
+   wint_t must be "unchanged by default argument promotions".  Override it.  */
+# if 0
+#  if !GNULIB_defined_wint_t
+#   if 0
+#    include <crtdefs.h>
+#   else
+#    include <stddef.h>
+#   endif
+typedef unsigned int rpl_wint_t;
+#   undef wint_t
+#   define wint_t rpl_wint_t
+#   define GNULIB_defined_wint_t 1
+#  endif
+# endif
+# ifndef WEOF
+#  define WEOF ((wint_t) -1)
+# endif
+#endif
+
+
+#if !GNULIB_defined_wctype_functions
+
+/* FreeBSD 4.4 to 4.11 has <wctype.h> but lacks the functions.
+   Linux libc5 has <wctype.h> and the functions but they are broken.
+   Assume all 11 functions (all isw* except iswblank) are implemented the
+   same way, or not at all.  */
+# if ! 1 || 0
+
+/* IRIX 5.3 has macros but no functions, its isw* macros refer to an
+   undefined variable _ctmp_ and to <ctype.h> macros like _P, and they
+   refer to system functions like _iswctype that are not in the
+   standard C library.  Rather than try to get ancient buggy
+   implementations like this to work, just disable them.  */
+#  undef iswalnum
+#  undef iswalpha
+#  undef iswblank
+#  undef iswcntrl
+#  undef iswdigit
+#  undef iswgraph
+#  undef iswlower
+#  undef iswprint
+#  undef iswpunct
+#  undef iswspace
+#  undef iswupper
+#  undef iswxdigit
+#  undef towlower
+#  undef towupper
+
+/* Linux libc5 has <wctype.h> and the functions but they are broken.  */
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define iswalnum rpl_iswalnum
+#    define iswalpha rpl_iswalpha
+#    define iswblank rpl_iswblank
+#    define iswcntrl rpl_iswcntrl
+#    define iswdigit rpl_iswdigit
+#    define iswgraph rpl_iswgraph
+#    define iswlower rpl_iswlower
+#    define iswprint rpl_iswprint
+#    define iswpunct rpl_iswpunct
+#    define iswspace rpl_iswspace
+#    define iswupper rpl_iswupper
+#    define iswxdigit rpl_iswxdigit
+#   endif
+#  endif
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define towlower rpl_towlower
+#    define towupper rpl_towupper
+#   endif
+#  endif
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswalnum
+#  else
+iswalnum
+#  endif
+         (wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+          || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z'));
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswalpha
+#  else
+iswalpha
+#  endif
+         (wint_t wc)
+{
+  return (wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswblank
+#  else
+iswblank
+#  endif
+         (wint_t wc)
+{
+  return wc == ' ' || wc == '\t';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswcntrl
+#  else
+iswcntrl
+#  endif
+        (wint_t wc)
+{
+  return (wc & ~0x1f) == 0 || wc == 0x7f;
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswdigit
+#  else
+iswdigit
+#  endif
+         (wint_t wc)
+{
+  return wc >= '0' && wc <= '9';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswgraph
+#  else
+iswgraph
+#  endif
+         (wint_t wc)
+{
+  return wc >= '!' && wc <= '~';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswlower
+#  else
+iswlower
+#  endif
+         (wint_t wc)
+{
+  return wc >= 'a' && wc <= 'z';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswprint
+#  else
+iswprint
+#  endif
+         (wint_t wc)
+{
+  return wc >= ' ' && wc <= '~';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswpunct
+#  else
+iswpunct
+#  endif
+         (wint_t wc)
+{
+  return (wc >= '!' && wc <= '~'
+          && !((wc >= '0' && wc <= '9')
+               || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'Z')));
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswspace
+#  else
+iswspace
+#  endif
+         (wint_t wc)
+{
+  return (wc == ' ' || wc == '\t'
+          || wc == '\n' || wc == '\v' || wc == '\f' || wc == '\r');
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswupper
+#  else
+iswupper
+#  endif
+         (wint_t wc)
+{
+  return wc >= 'A' && wc <= 'Z';
+}
+
+_GL_WCTYPE_INLINE int
+#  if 0
+rpl_iswxdigit
+#  else
+iswxdigit
+#  endif
+          (wint_t wc)
+{
+  return ((wc >= '0' && wc <= '9')
+          || ((wc & ~0x20) >= 'A' && (wc & ~0x20) <= 'F'));
+}
+
+_GL_WCTYPE_INLINE wint_t
+#  if 0
+rpl_towlower
+#  else
+towlower
+#  endif
+         (wint_t wc)
+{
+  return (wc >= 'A' && wc <= 'Z' ? wc - 'A' + 'a' : wc);
+}
+
+_GL_WCTYPE_INLINE wint_t
+#  if 0
+rpl_towupper
+#  else
+towupper
+#  endif
+         (wint_t wc)
+{
+  return (wc >= 'a' && wc <= 'z' ? wc - 'a' + 'A' : wc);
+}
+
+# elif 0 && (! 1 || 0)
+/* Only the iswblank function is missing.  */
+
+#  if 0
+#   if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#    define iswblank rpl_iswblank
+#   endif
+_GL_FUNCDECL_RPL (iswblank, int, (wint_t wc));
+#  else
+_GL_FUNCDECL_SYS (iswblank, int, (wint_t wc));
+#  endif
+
+# endif
+
+# if defined __MINGW32__
+
+/* On native Windows, wchar_t is uint16_t, and wint_t is uint32_t.
+   The functions towlower and towupper are implemented in the MSVCRT library
+   to take a wchar_t argument and return a wchar_t result.  mingw declares
+   these functions to take a wint_t argument and return a wint_t result.
+   This means that:
+   1. When the user passes an argument outside the range 0x0000..0xFFFF, the
+      function will look only at the lower 16 bits.  This is allowed according
+      to POSIX.
+   2. The return value is returned in the lower 16 bits of the result register.
+      The upper 16 bits are random: whatever happened to be in that part of the
+      result register.  We need to fix this by adding a zero-extend from
+      wchar_t to wint_t after the call.  */
+
+_GL_WCTYPE_INLINE wint_t
+rpl_towlower (wint_t wc)
+{
+  return (wint_t) (wchar_t) towlower (wc);
+}
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define towlower rpl_towlower
+#  endif
+
+_GL_WCTYPE_INLINE wint_t
+rpl_towupper (wint_t wc)
+{
+  return (wint_t) (wchar_t) towupper (wc);
+}
+#  if !(defined __cplusplus && defined GNULIB_NAMESPACE)
+#   define towupper rpl_towupper
+#  endif
+
+# endif /* __MINGW32__ */
+
+# define GNULIB_defined_wctype_functions 1
+#endif
+
+#if 0
+_GL_CXXALIAS_RPL (iswalnum, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswalpha, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswcntrl, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswdigit, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswgraph, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswlower, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswprint, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswpunct, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswspace, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswupper, int, (wint_t wc));
+_GL_CXXALIAS_RPL (iswxdigit, int, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (iswalnum, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswalpha, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswcntrl, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswdigit, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswgraph, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswlower, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswprint, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswpunct, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswspace, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswupper, int, (wint_t wc));
+_GL_CXXALIAS_SYS (iswxdigit, int, (wint_t wc));
+#endif
+_GL_CXXALIASWARN (iswalnum);
+_GL_CXXALIASWARN (iswalpha);
+_GL_CXXALIASWARN (iswcntrl);
+_GL_CXXALIASWARN (iswdigit);
+_GL_CXXALIASWARN (iswgraph);
+_GL_CXXALIASWARN (iswlower);
+_GL_CXXALIASWARN (iswprint);
+_GL_CXXALIASWARN (iswpunct);
+_GL_CXXALIASWARN (iswspace);
+_GL_CXXALIASWARN (iswupper);
+_GL_CXXALIASWARN (iswxdigit);
+
+#if 0
+# if 0 || 0
+_GL_CXXALIAS_RPL (iswblank, int, (wint_t wc));
+# else
+_GL_CXXALIAS_SYS (iswblank, int, (wint_t wc));
+# endif
+_GL_CXXALIASWARN (iswblank);
+#endif
+
+#if !1
+# if !GNULIB_defined_wctype_t
+typedef void * wctype_t;
+#  define GNULIB_defined_wctype_t 1
+# endif
+#endif
+
+/* Get a descriptor for a wide character property.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wctype, wctype_t, (const char *name));
+# endif
+_GL_CXXALIAS_SYS (wctype, wctype_t, (const char *name));
+_GL_CXXALIASWARN (wctype);
+#elif defined GNULIB_POSIXCHECK
+# undef wctype
+# if HAVE_RAW_DECL_WCTYPE
+_GL_WARN_ON_USE (wctype, "wctype is unportable - "
+                 "use gnulib module wctype for portability");
+# endif
+#endif
+
+/* Test whether a wide character has a given property.
+   The argument WC must be either a wchar_t value or WEOF.
+   The argument DESC must have been returned by the wctype() function.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (iswctype, int, (wint_t wc, wctype_t desc));
+# endif
+_GL_CXXALIAS_SYS (iswctype, int, (wint_t wc, wctype_t desc));
+_GL_CXXALIASWARN (iswctype);
+#elif defined GNULIB_POSIXCHECK
+# undef iswctype
+# if HAVE_RAW_DECL_ISWCTYPE
+_GL_WARN_ON_USE (iswctype, "iswctype is unportable - "
+                 "use gnulib module iswctype for portability");
+# endif
+#endif
+
+#if 0 || defined __MINGW32__
+_GL_CXXALIAS_RPL (towlower, wint_t, (wint_t wc));
+_GL_CXXALIAS_RPL (towupper, wint_t, (wint_t wc));
+#else
+_GL_CXXALIAS_SYS (towlower, wint_t, (wint_t wc));
+_GL_CXXALIAS_SYS (towupper, wint_t, (wint_t wc));
+#endif
+_GL_CXXALIASWARN (towlower);
+_GL_CXXALIASWARN (towupper);
+
+#if !1
+# if !GNULIB_defined_wctrans_t
+typedef void * wctrans_t;
+#  define GNULIB_defined_wctrans_t 1
+# endif
+#endif
+
+/* Get a descriptor for a wide character case conversion.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (wctrans, wctrans_t, (const char *name));
+# endif
+_GL_CXXALIAS_SYS (wctrans, wctrans_t, (const char *name));
+_GL_CXXALIASWARN (wctrans);
+#elif defined GNULIB_POSIXCHECK
+# undef wctrans
+# if HAVE_RAW_DECL_WCTRANS
+_GL_WARN_ON_USE (wctrans, "wctrans is unportable - "
+                 "use gnulib module wctrans for portability");
+# endif
+#endif
+
+/* Perform a given case conversion on a wide character.
+   The argument WC must be either a wchar_t value or WEOF.
+   The argument DESC must have been returned by the wctrans() function.  */
+#if 0
+# if !1
+_GL_FUNCDECL_SYS (towctrans, wint_t, (wint_t wc, wctrans_t desc));
+# endif
+_GL_CXXALIAS_SYS (towctrans, wint_t, (wint_t wc, wctrans_t desc));
+_GL_CXXALIASWARN (towctrans);
+#elif defined GNULIB_POSIXCHECK
+# undef towctrans
+# if HAVE_RAW_DECL_TOWCTRANS
+_GL_WARN_ON_USE (towctrans, "towctrans is unportable - "
+                 "use gnulib module towctrans for portability");
+# endif
+#endif
+
+_GL_INLINE_HEADER_END
+
+#endif /* _GL_WCTYPE_H */
+#endif /* _GL_WCTYPE_H */
+#endif
diff --git a/libraries/cmake/source/aws-sdk-cpp/CMakeLists.txt b/libraries/cmake/source/aws-sdk-cpp/CMakeLists.txt
index 0703276cd..71f9ef982 100644
--- a/libraries/cmake/source/aws-sdk-cpp/CMakeLists.txt
+++ b/libraries/cmake/source/aws-sdk-cpp/CMakeLists.txt
@@ -3246,6 +3246,14 @@ function(generateAwsChecksums)
       COMPILE_FLAGS
         "-march=armv8-a+crc"
     )
+
+  elseif(TARGET_PROCESSOR STREQUAL "ppc64le")
+    set(crc_impl_file "${library_root}/source/generic/crc32c_null.c")
+
+    target_sources(thirdparty_aws-checksums PRIVATE
+      "${crc_impl_file}"
+    )
+
   endif()
 
   target_include_directories(thirdparty_aws-checksums PRIVATE
@@ -3931,6 +3939,10 @@ function(generateAwsCCommon)
       target_sources(thirdparty_aws-c-common PRIVATE
         "${library_root}/source/arch/arm/asm/cpuid.c"
       )
+    elseif(TARGET_PROCESSOR STREQUAL "ppc64le")
+      target_sources(thirdparty_aws-c-common PRIVATE
+        "${library_root}/source/arch/generic/cpuid.c"
+      )
     endif()
 
   elseif(PLATFORM_WINDOWS)
diff --git a/libraries/cmake/source/aws-sdk-cpp/config/aws-c-common/linux/ppc64le/include/aws/common/config.h b/libraries/cmake/source/aws-sdk-cpp/config/aws-c-common/linux/ppc64le/include/aws/common/config.h
new file mode 100644
index 000000000..ff3ff3a60
--- /dev/null
+++ b/libraries/cmake/source/aws-sdk-cpp/config/aws-c-common/linux/ppc64le/include/aws/common/config.h
@@ -0,0 +1,22 @@
+#ifndef AWS_COMMON_CONFIG_H
+#define AWS_COMMON_CONFIG_H
+
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+/*
+ * This header exposes compiler feature test results determined during cmake
+ * configure time to inline function implementations. The macros defined here
+ * should be considered to be an implementation detail, and can change at any
+ * time.
+ */
+#define AWS_HAVE_GCC_OVERFLOW_MATH_EXTENSIONS
+#define AWS_HAVE_GCC_INLINE_ASM
+/* #undef AWS_HAVE_MSVC_MULX */
+#define AWS_HAVE_POSIX_LARGE_FILE_SUPPORT
+#define AWS_HAVE_EXECINFO
+/* #undef AWS_HAVE_WINAPI_DESKTOP */
+
+#endif
diff --git a/libraries/cmake/source/aws-sdk-cpp/config/aws-cpp-sdk-core/linux/ppc64le/aws/core/SDKConfig.h b/libraries/cmake/source/aws-sdk-cpp/config/aws-cpp-sdk-core/linux/ppc64le/aws/core/SDKConfig.h
new file mode 100644
index 000000000..9561d2025
--- /dev/null
+++ b/libraries/cmake/source/aws-sdk-cpp/config/aws-cpp-sdk-core/linux/ppc64le/aws/core/SDKConfig.h
@@ -0,0 +1,7 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+/* #undef USE_AWS_MEMORY_MANAGEMENT */
+
diff --git a/libraries/cmake/source/aws-sdk-cpp/config/aws-cpp-sdk-core/linux/ppc64le/aws/core/VersionConfig.h b/libraries/cmake/source/aws-sdk-cpp/config/aws-cpp-sdk-core/linux/ppc64le/aws/core/VersionConfig.h
new file mode 100644
index 000000000..3a78a4341
--- /dev/null
+++ b/libraries/cmake/source/aws-sdk-cpp/config/aws-cpp-sdk-core/linux/ppc64le/aws/core/VersionConfig.h
@@ -0,0 +1,9 @@
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+
+#define AWS_SDK_VERSION_STRING "1.9.116"
+#define AWS_SDK_VERSION_MAJOR 1
+#define AWS_SDK_VERSION_MINOR 9
+#define AWS_SDK_VERSION_PATCH 116
diff --git a/libraries/cmake/source/aws-sdk-cpp/config/aws-crt-cpp/linux/ppc64le/aws/crt/Config.h b/libraries/cmake/source/aws-sdk-cpp/config/aws-crt-cpp/linux/ppc64le/aws/crt/Config.h
new file mode 100644
index 000000000..b147760a5
--- /dev/null
+++ b/libraries/cmake/source/aws-sdk-cpp/config/aws-crt-cpp/linux/ppc64le/aws/crt/Config.h
@@ -0,0 +1,6 @@
+#pragma once
+/**
+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
+ * SPDX-License-Identifier: Apache-2.0.
+ */
+#define AWS_CRT_CPP_VERSION "v0.8.4-108-gc2d6ffa"
diff --git a/libraries/cmake/source/boost/CMakeLists.txt b/libraries/cmake/source/boost/CMakeLists.txt
index c233f33fe..158fcbd02 100644
--- a/libraries/cmake/source/boost/CMakeLists.txt
+++ b/libraries/cmake/source/boost/CMakeLists.txt
@@ -742,6 +742,13 @@ function(generateBoostContext)
           "${library_root}/src/asm/ontop_x86_64_sysv_elf_gas.S"
         )
 
+      elseif(TARGET_PROCESSOR STREQUAL "ppc64le")
+        set(source_file_list
+          "${library_root}/src/asm/jump_ppc64_sysv_elf_gas.S"
+          "${library_root}/src/asm/make_ppc64_sysv_elf_gas.S"
+          "${library_root}/src/asm/ontop_ppc64_sysv_elf_gas.S"
+        )
+
       elseif(TARGET_PROCESSOR STREQUAL "aarch64")
         set(source_file_list
           "${library_root}/src/asm/jump_arm64_aapcs_elf_gas.S"
diff --git a/libraries/cmake/source/dbus/config/ppc64le/config.h b/libraries/cmake/source/dbus/config/ppc64le/config.h
new file mode 100644
index 000000000..18f8d7674
--- /dev/null
+++ b/libraries/cmake/source/dbus/config/ppc64le/config.h
@@ -0,0 +1,309 @@
+/* config.h. Generated by cmake from config.h.cmake */
+
+#ifndef _DBUS_CONFIG_H
+#define _DBUS_CONFIG_H
+/****************************/
+/* indicate that we are building with cmake */
+#define DBUS_CMAKE 1
+
+/* On Windows, we expect to be using msvcrt.dll-compatible printf
+ * (%I64u instead of %llu) unless otherwise specified. This must be
+ * done near the beginning of config.h, before we have included any
+ * system headers that might check the value of this macro. */
+#ifndef __USE_MINGW_ANSI_STDIO
+#   define __USE_MINGW_ANSI_STDIO 0
+#endif
+
+/* generated by cmake macro autopackage */
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "https://bugs.freedesktop.org/enter_bug.cgi?product=dbus"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "dbus"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "dbus 1.12.24"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "dbus"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "http://dbus.freedesktop.org"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.12.24"
+
+/* defined by autotools package */
+#define PACKAGE "dbus"
+#define VERSION "1.12.24"
+
+
+/*
+ * Variables defined by AC_DEFINE in ../configure.ac
+ * should be placed in this file
+*/
+/* #undef HAVE_GNUC_VARARGS */
+
+/* #undef DBUS_CONSOLE_AUTH_DIR */
+#define DBUS_DATADIR  "/usr/local/share"
+#define DBUS_BINDIR   "/usr/local/bin"
+#define DBUS_PREFIX "/usr/local"
+#define DBUS_SYSTEM_CONFIG_FILE  "/dbus-1/system.conf"
+#define DBUS_SESSION_CONFIG_FILE "/dbus-1/session.conf"
+#define DBUS_DAEMON_NAME "dbus-daemon"
+#define DBUS_SYSTEM_BUS_DEFAULT_ADDRESS  "unix:path=/usr/local/var/run/dbus/system_bus_socket"
+#define DBUS_SESSION_BUS_CONNECT_ADDRESS  "autolaunch:"
+#define DBUS_MACHINE_UUID_FILE "/usr/local/var/lib/dbus/machine-id"
+#define DBUS_DAEMONDIR "/usr/local/bin"
+#define DBUS_RUNSTATEDIR "/usr/local/var/run"
+
+/* #undef DBUS_ENABLE_STATS */
+
+#define TEST_LISTEN       ""
+
+// test binaries
+#define DBUS_EXEEXT ""
+
+/* Some dbus features */
+/* #undef DBUS_ENABLE_ANSI */
+/* #undef DBUS_ENABLE_VERBOSE_MODE */
+/* #undef DBUS_DISABLE_ASSERT */
+#ifndef DBUS_DISABLE_ASSERT
+#  define DBUS_ENABLE_ASSERT 1
+#endif
+/* #undef DBUS_DISABLE_CHECKS */
+#ifndef DBUS_DISABLE_CHECKS
+#  define DBUS_ENABLE_CHECKS 1
+#endif
+/* xmldocs */
+/* doxygen */
+/* #undef DBUS_GCOV_ENABLED */
+
+/* selinux */
+/* kqueue */
+/* #undef HAVE_CONSOLE_OWNER_FILE */
+#define DBUS_CONSOLE_OWNER_FILE ""
+
+/* #undef DBUS_BUILD_X11 */
+/* For the moment, the cmake build system doesn't have an equivalent of
+ * the autoconf build system's --disable-x11-autolaunch */
+#ifdef DBUS_BUILD_X11
+# define DBUS_ENABLE_X11_AUTOLAUNCH 1
+#endif
+
+#define _DBUS_VA_COPY_ASSIGN(a1,a2) { a1 = a2; }
+
+#define DBUS_VA_COPY_FUNC
+#if (defined DBUS_VA_COPY_FUNC)
+# define DBUS_VA_COPY va_copy
+#endif
+
+#ifdef DBUS_VA_COPY_FUNC
+#undef DBUS_VA_COPY_FUNC
+#endif
+
+/* #undef DBUS_VA_COPY_AS_ARRAY */
+
+/* #undef DBUS_WITH_GLIB */
+/* #undef GLIB_VERSION_MIN_REQUIRED */
+/* #undef GLIB_VERSION_MAX_ALLOWED */
+
+// headers
+#define HAVE_ALLOCA_H
+#define HAVE_BYTESWAP_H
+/* #undef HAVE_CRT_EXTERNS_H */
+
+/* Define to 1 if you have dirent.h */
+#define   HAVE_DIRENT_H 1
+
+#define HAVE_DLFCN_H
+
+/* Define to 1 if you have errno.h */
+#define   HAVE_ERRNO_H 1
+
+#define HAVE_EXECINFO_H
+#define HAVE_EXPAT_H
+
+/* Define to 1 if you have grp.h */
+#define   HAVE_GRP_H 1
+
+/* Define to 1 if you have inttypes.h */
+#define   HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have io.h */
+/* #undef HAVE_IO_H */
+
+/* Define to 1 if you have locale.h */
+#define   HAVE_LOCALE_H 1
+
+#define HAVE_MEMORY_H
+
+/* Define to 1 if you have sys/poll.h */
+#define    HAVE_POLL 1
+
+/* Define to 1 if you have signal.h */
+#define   HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have stdint.h */
+#define   HAVE_STDINT_H 1
+
+#define HAVE_STDLIB_H
+
+/* Define to 1 if you have stdio.h */
+#define   HAVE_STDIO_H 1
+
+#define HAVE_STRINGS_H
+#define HAVE_STRING_H
+#define HAVE_SYSLOG_H
+/* #undef HAVE_SYS_EVENTS_H */
+#define HAVE_SYS_INOTIFY_H
+#define HAVE_SYS_PRCTL_H
+#define HAVE_SYS_RESOURCE_H
+#define HAVE_SYS_STAT_H
+
+/* Define to 1 if you have sys/syslimits.h */
+/* #undef HAVE_SYS_SYSLIMITS_H */
+
+/* Define to 1 if you have sys/time.h */
+#define    HAVE_SYS_TIME_H 1
+
+#define HAVE_SYS_TYPES_H
+
+#define HAVE_SYS_UIO_H
+
+/* Define to 1 if you have sys/wait.h */
+#define    HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have time.h */
+#define   HAVE_TIME_H 1
+
+/* Define to 1 if you have unistd.h */
+#define   HAVE_UNISTD_H 1
+
+/* Define to 1 if you have ws2tcpip.h */
+/* #undef HAVE_WS2TCPIP_H */
+
+// symbols
+/* Define to 1 if you have backtrace */
+#define   HAVE_BACKTRACE 1
+
+/* Define to 1 if you have getgrouplist */
+#define   HAVE_GETGROUPLIST 1
+
+/* Define to 1 if you have getpeerucred */
+/* #undef HAVE_GETPEERUCRED */
+
+/* Define to 1 if you have nanosleep */
+#define   HAVE_NANOSLEEP 1
+
+/* Define to 1 if you have getpwnam_r */
+/* #undef HAVE_POSIX_GETPWNAM_R */
+
+/* Define to 1 if you have socketpair */
+#define   HAVE_SOCKETPAIR 1
+
+/* Define to 1 if you have setenv */
+#define   HAVE_SETENV 1
+
+/* Define to 1 if you have unsetenv */
+#define   HAVE_UNSETENV 1
+
+/* Define to 1 if you have clearenv */
+#define   HAVE_CLEARENV 1
+
+/* Define to 1 if you have writev */
+#define   HAVE_WRITEV 1
+
+/* Define to 1 if you have socklen_t */
+#define   HAVE_SOCKLEN_T 1
+
+/* Define to 1 if you have setlocale */
+#define   HAVE_SETLOCALE 1
+
+/* Define to 1 if you have localeconv */
+#define   HAVE_LOCALECONV 1
+
+/* Define to 1 if you have strtoll */
+#define   HAVE_STRTOLL 1
+
+/* Define to 1 if you have strtoull */
+#define   HAVE_STRTOULL 1
+
+/* Define to 1 if you have pip2 */
+#define   HAVE_PIPE2
+
+#define HAVE_ACCEPT4 1
+#define HAVE_DIRFD 1
+#define HAVE_INOTIFY_INIT1 1
+#define HAVE_GETRLIMIT 1
+#define HAVE_PRLIMIT 1
+#define HAVE_SETRLIMIT 1
+#define HAVE_UNIX_FD_PASSING 1
+
+// structs
+/* Define to 1 if you have struct cmsgred */
+/* #undef HAVE_CMSGCRED */
+
+/* #undef FD_SETSIZE */
+
+#define DBUS_USER "messagebus"
+#define DBUS_TEST_USER "nobody"
+
+// system type defines
+#if defined(_WIN32) || defined(_WIN64) || defined (_WIN32_WCE)
+# define DBUS_WIN
+# define DBUS_WIN_FIXME 1
+# ifdef _WIN32_WCE
+#  define DBUS_WINCE
+# else
+#  define DBUS_WIN32
+# endif
+#else
+# define DBUS_UNIX
+#endif 
+
+#if defined(_WIN32) || defined(_WIN64)
+// mingw mode_t
+# ifdef HAVE_STDIO_H
+#  include <stdio.h>
+# endif
+# ifndef _MSC_VER
+#  define uid_t int
+#  define gid_t int
+# else
+#  define snprintf _snprintf
+   typedef int mode_t;
+#  if !defined(_WIN32_WCE)
+#    define strtoll _strtoi64
+#    define strtoull _strtoui64
+#    define HAVE_STRTOLL 1
+#    define HAVE_STRTOULL 1
+#  endif
+# endif
+#endif	// defined(_WIN32) || defined(_WIN64)
+
+#ifdef interface
+#undef interface
+#endif
+
+#ifndef SIGHUP
+#define SIGHUP	1
+#endif
+
+/* #undef DBUS_VERBOSE_C_S */
+#ifdef DBUS_VERBOSE_C_S
+#define _dbus_verbose_C_S printf
+#else
+#define _dbus_verbose_C_S _dbus_verbose
+#endif 
+
+# if defined(_MSC_VER) && !defined(inline)
+#define inline __inline
+#endif
+
+#ifdef DBUS_WIN
+#define FD_SETSIZE 
+#endif
+
+#endif  // _DBUS_CONFIG_H
diff --git a/libraries/cmake/source/dbus/generated/ppc64le/dbus/dbus-arch-deps.h b/libraries/cmake/source/dbus/generated/ppc64le/dbus/dbus-arch-deps.h
new file mode 100644
index 000000000..d611ed495
--- /dev/null
+++ b/libraries/cmake/source/dbus/generated/ppc64le/dbus/dbus-arch-deps.h
@@ -0,0 +1,61 @@
+/* -*- mode: C; c-file-style: "gnu" -*- */
+/* dbus-arch-deps.h Header with architecture/compiler specific information, installed to libdir
+ *
+ * Copyright (C) 2003 Red Hat, Inc.
+ *
+ * Licensed under the Academic Free License version 2.0
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ *
+ */
+#if !defined (DBUS_INSIDE_DBUS_H) && !defined (DBUS_COMPILATION)
+#error "Only <dbus/dbus.h> can be included directly, this file may disappear or change contents."
+#endif
+
+#ifndef DBUS_ARCH_DEPS_H
+#define DBUS_ARCH_DEPS_H
+
+#include <dbus/dbus-macros.h>
+
+DBUS_BEGIN_DECLS
+
+/* D-Bus no longer supports platforms with no 64-bit integer type. */
+#define DBUS_HAVE_INT64 1
+_DBUS_GNUC_EXTENSION typedef long dbus_int64_t;
+_DBUS_GNUC_EXTENSION typedef unsigned long dbus_uint64_t;
+
+#define DBUS_INT64_CONSTANT(val)  (_DBUS_GNUC_EXTENSION (val##L))
+#define DBUS_UINT64_CONSTANT(val) (_DBUS_GNUC_EXTENSION (val##UL))
+
+typedef int dbus_int32_t;
+typedef unsigned int dbus_uint32_t;
+
+typedef short dbus_int16_t;
+typedef unsigned short dbus_uint16_t;
+
+/* This is not really arch-dependent, but it's not worth
+ * creating an additional generated header just for this
+ */
+#define DBUS_MAJOR_VERSION 1
+#define DBUS_MINOR_VERSION 12
+#define DBUS_MICRO_VERSION 24
+
+#define DBUS_VERSION_STRING "1.12.24"
+
+#define DBUS_VERSION ((1 << 16) | (12 << 8) | (24)) 
+
+DBUS_END_DECLS
+
+#endif /* DBUS_ARCH_DEPS_H */
diff --git a/libraries/cmake/source/expat/config/ppc64le/expat_config.h b/libraries/cmake/source/expat/config/ppc64le/expat_config.h
new file mode 100644
index 000000000..2364daa59
--- /dev/null
+++ b/libraries/cmake/source/expat/config/ppc64le/expat_config.h
@@ -0,0 +1,122 @@
+/* expat_config.h.cmake.  Based upon generated expat_config.h.in.  */
+
+#ifndef EXPAT_CONFIG_H
+#define EXPAT_CONFIG_H 1
+
+/* 1234 = LIL_ENDIAN, 4321 = BIGENDIAN */
+#define BYTEORDER 1234
+
+/* Define to 1 if you have the `arc4random' function. */
+/* #undef HAVE_ARC4RANDOM */
+
+/* Define to 1 if you have the `arc4random_buf' function. */
+/* #undef HAVE_ARC4RANDOM_BUF */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H
+
+/* Define to 1 if you have the `getpagesize' function. */
+/* #undef HAVE_GETPAGESIZE */
+
+/* Define to 1 if you have the `getrandom' function. */
+#define HAVE_GETRANDOM
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `bsd' library (-lbsd). */
+/* #undef HAVE_LIBBSD */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H
+
+/* Define to 1 if you have a working `mmap' system call. */
+#define HAVE_MMAP
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H
+
+/* Define to 1 if you have `syscall' and `SYS_getrandom'. */
+#define HAVE_SYSCALL_GETRANDOM
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H
+
+/* Name of package */
+#define PACKAGE "expat"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "https://github.com/libexpat/libexpat/issues"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "expat"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "expat 2.7.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "expat"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.7.1"
+
+/* Define to 1 if you have the ANSI C header files. */
+#ifndef STDC_HEADERS
+#define STDC_HEADERS
+#endif
+
+/* whether byteorder is bigendian */
+/* #undef WORDS_BIGENDIAN */
+
+/* Define to allow retrieving the byte offsets for attribute names and values.
+ */
+/* #undef XML_ATTR_INFO */
+
+/* Define to specify how much context to retain around the current parse
+   point, 0 to disable. */
+#define XML_CONTEXT_BYTES 1024
+
+#if ! defined(_WIN32)
+/* Define to include code reading entropy from `/dev/urandom'. */
+/* #undef XML_DEV_URANDOM */
+#endif
+
+/* Define to make parameter entity parsing functionality available. */
+/* #undef XML_DTD */
+
+/* Define as 1/0 to enable/disable support for general entities. */
+#define XML_GE 1
+
+/* Define to make XML Namespaces functionality available. */
+/* #undef XML_NS */
+
+/* Define to __FUNCTION__ or "" if `__func__' does not conform to ANSI C. */
+#ifdef _MSC_VER
+#  define __func__ __FUNCTION__
+#endif
+
+/* Define to `long' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+#endif // ndef EXPAT_CONFIG_H
diff --git a/libraries/cmake/source/gflags/generated/linux/ppc64le/private/defines.h b/libraries/cmake/source/gflags/generated/linux/ppc64le/private/defines.h
new file mode 100644
index 000000000..f0be3dcb4
--- /dev/null
+++ b/libraries/cmake/source/gflags/generated/linux/ppc64le/private/defines.h
@@ -0,0 +1,48 @@
+/* Generated from defines.h.in during build configuration using CMake. */
+
+// Note: This header file is only used internally. It is not part of public interface!
+//       Any cmakedefine is defined using the -D flag instead when Bazel is used.
+//       For Bazel, this file is thus not used to avoid a private file in $(GENDIR).
+
+#ifndef GFLAGS_DEFINES_H_
+#define GFLAGS_DEFINES_H_
+
+
+// Define if you build this library for a MS Windows OS.
+/* #undef OS_WINDOWS */
+
+// Define if you have the <stdint.h> header file.
+#define HAVE_STDINT_H
+
+// Define if you have the <sys/types.h> header file.
+#define HAVE_SYS_TYPES_H
+
+// Define if you have the <inttypes.h> header file.
+#define HAVE_INTTYPES_H
+
+// Define if you have the <sys/stat.h> header file.
+#define HAVE_SYS_STAT_H
+
+// Define if you have the <unistd.h> header file.
+#define HAVE_UNISTD_H
+
+// Define if you have the <fnmatch.h> header file.
+#define HAVE_FNMATCH_H
+
+// Define if you have the <shlwapi.h> header file (Windows 2000/XP).
+/* #undef HAVE_SHLWAPI_H */
+
+// Define if you have the strtoll function.
+#define HAVE_STRTOLL
+
+// Define if you have the strtoq function.
+/* #undef HAVE_STRTOQ */
+
+// Define if you have the <pthread.h> header file.
+#define HAVE_PTHREAD
+
+// Define if your pthread library defines the type pthread_rwlock_t
+#define HAVE_RWLOCK
+
+
+#endif // GFLAGS_DEFINES_H_
diff --git a/libraries/cmake/source/gflags/generated/linux/ppc64le/public/gflags/gflags.h b/libraries/cmake/source/gflags/generated/linux/ppc64le/public/gflags/gflags.h
new file mode 100644
index 000000000..34ebd6fe2
--- /dev/null
+++ b/libraries/cmake/source/gflags/generated/linux/ppc64le/public/gflags/gflags.h
@@ -0,0 +1,626 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+// Revamped and reorganized by Craig Silverstein
+//
+// This is the file that should be included by any file which declares
+// or defines a command line flag or wants to parse command line flags
+// or print a program usage message (which will include information about
+// flags).  Executive summary, in the form of an example foo.cc file:
+//
+//    #include "foo.h"         // foo.h has a line "DECLARE_int32(start);"
+//    #include "validators.h"  // hypothetical file defining ValidateIsFile()
+//
+//    DEFINE_int32(end, 1000, "The last record to read");
+//
+//    DEFINE_string(filename, "my_file.txt", "The file to read");
+//    // Crash if the specified file does not exist.
+//    static bool dummy = RegisterFlagValidator(&FLAGS_filename,
+//                                              &ValidateIsFile);
+//
+//    DECLARE_bool(verbose); // some other file has a DEFINE_bool(verbose, ...)
+//
+//    void MyFunc() {
+//      if (FLAGS_verbose) printf("Records %d-%d\n", FLAGS_start, FLAGS_end);
+//    }
+//
+//    Then, at the command-line:
+//       ./foo --noverbose --start=5 --end=100
+//
+// For more details, see
+//    doc/gflags.html
+//
+// --- A note about thread-safety:
+//
+// We describe many functions in this routine as being thread-hostile,
+// thread-compatible, or thread-safe.  Here are the meanings we use:
+//
+// thread-safe: it is safe for multiple threads to call this routine
+//   (or, when referring to a class, methods of this class)
+//   concurrently.
+// thread-hostile: it is not safe for multiple threads to call this
+//   routine (or methods of this class) concurrently.  In gflags,
+//   most thread-hostile routines are intended to be called early in,
+//   or even before, main() -- that is, before threads are spawned.
+// thread-compatible: it is safe for multiple threads to read from
+//   this variable (when applied to variables), or to call const
+//   methods of this class (when applied to classes), as long as no
+//   other thread is writing to the variable or calling non-const
+//   methods of this class.
+
+#ifndef GFLAGS_GFLAGS_H_
+#define GFLAGS_GFLAGS_H_
+
+#include <string>
+#include <vector>
+
+#include "gflags/gflags_declare.h" // IWYU pragma: export
+
+
+// We always want to export variables defined in user code
+#ifndef GFLAGS_DLL_DEFINE_FLAG
+#  if GFLAGS_IS_A_DLL && defined(_MSC_VER)
+#    define GFLAGS_DLL_DEFINE_FLAG __declspec(dllexport)
+#  else
+#    define GFLAGS_DLL_DEFINE_FLAG
+#  endif
+#endif
+
+
+namespace GFLAGS_NAMESPACE {
+
+
+// --------------------------------------------------------------------
+// To actually define a flag in a file, use DEFINE_bool,
+// DEFINE_string, etc. at the bottom of this file.  You may also find
+// it useful to register a validator with the flag.  This ensures that
+// when the flag is parsed from the commandline, or is later set via
+// SetCommandLineOption, we call the validation function. It is _not_
+// called when you assign the value to the flag directly using the = operator.
+//
+// The validation function should return true if the flag value is valid, and
+// false otherwise. If the function returns false for the new setting of the
+// flag, the flag will retain its current value. If it returns false for the
+// default value, ParseCommandLineFlags() will die.
+//
+// This function is safe to call at global construct time (as in the
+// example below).
+//
+// Example use:
+//    static bool ValidatePort(const char* flagname, int32 value) {
+//       if (value > 0 && value < 32768)   // value is ok
+//         return true;
+//       printf("Invalid value for --%s: %d\n", flagname, (int)value);
+//       return false;
+//    }
+//    DEFINE_int32(port, 0, "What port to listen on");
+//    static bool dummy = RegisterFlagValidator(&FLAGS_port, &ValidatePort);
+
+// Returns true if successfully registered, false if not (because the
+// first argument doesn't point to a command-line flag, or because a
+// validator is already registered for this flag).
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const bool*        flag, bool (*validate_fn)(const char*, bool));
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const int32*       flag, bool (*validate_fn)(const char*, int32));
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const uint32*      flag, bool (*validate_fn)(const char*, uint32));
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const int64*       flag, bool (*validate_fn)(const char*, int64));
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const uint64*      flag, bool (*validate_fn)(const char*, uint64));
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const double*      flag, bool (*validate_fn)(const char*, double));
+extern GFLAGS_DLL_DECL bool RegisterFlagValidator(const std::string* flag, bool (*validate_fn)(const char*, const std::string&));
+
+// Convenience macro for the registration of a flag validator
+#define DEFINE_validator(name, validator) \
+    static const bool name##_validator_registered = \
+            GFLAGS_NAMESPACE::RegisterFlagValidator(&FLAGS_##name, validator)
+
+
+// --------------------------------------------------------------------
+// These methods are the best way to get access to info about the
+// list of commandline flags.  Note that these routines are pretty slow.
+//   GetAllFlags: mostly-complete info about the list, sorted by file.
+//   ShowUsageWithFlags: pretty-prints the list to stdout (what --help does)
+//   ShowUsageWithFlagsRestrict: limit to filenames with restrict as a substr
+//
+// In addition to accessing flags, you can also access argv[0] (the program
+// name) and argv (the entire commandline), which we sock away a copy of.
+// These variables are static, so you should only set them once.
+//
+// No need to export this data only structure from DLL, avoiding VS warning 4251.
+struct CommandLineFlagInfo {
+  std::string name;            // the name of the flag
+  std::string type;            // the type of the flag: int32, etc
+  std::string description;     // the "help text" associated with the flag
+  std::string current_value;   // the current value, as a string
+  std::string default_value;   // the default value, as a string
+  std::string filename;        // 'cleaned' version of filename holding the flag
+  bool has_validator_fn;       // true if RegisterFlagValidator called on this flag
+  bool is_default;             // true if the flag has the default value and
+                               // has not been set explicitly from the cmdline
+                               // or via SetCommandLineOption
+  const void* flag_ptr;        // pointer to the flag's current value (i.e. FLAGS_foo)
+};
+
+// Using this inside of a validator is a recipe for a deadlock.
+// TODO(user) Fix locking when validators are running, to make it safe to
+// call validators during ParseAllFlags.
+// Also make sure then to uncomment the corresponding unit test in
+// gflags_unittest.sh
+extern GFLAGS_DLL_DECL void GetAllFlags(std::vector<CommandLineFlagInfo>* OUTPUT);
+// These two are actually defined in gflags_reporting.cc.
+extern GFLAGS_DLL_DECL void ShowUsageWithFlags(const char *argv0);  // what --help does
+extern GFLAGS_DLL_DECL void ShowUsageWithFlagsRestrict(const char *argv0, const char *restrict);
+
+// Create a descriptive string for a flag.
+// Goes to some trouble to make pretty line breaks.
+extern GFLAGS_DLL_DECL std::string DescribeOneFlag(const CommandLineFlagInfo& flag);
+
+// Thread-hostile; meant to be called before any threads are spawned.
+extern GFLAGS_DLL_DECL void SetArgv(int argc, const char** argv);
+
+// The following functions are thread-safe as long as SetArgv() is
+// only called before any threads start.
+extern GFLAGS_DLL_DECL const std::vector<std::string>& GetArgvs();
+extern GFLAGS_DLL_DECL const char* GetArgv();                      // all of argv as a string
+extern GFLAGS_DLL_DECL const char* GetArgv0();                     // only argv0
+extern GFLAGS_DLL_DECL uint32 GetArgvSum();                        // simple checksum of argv
+extern GFLAGS_DLL_DECL const char* ProgramInvocationName();        // argv0, or "UNKNOWN" if not set
+extern GFLAGS_DLL_DECL const char* ProgramInvocationShortName();   // basename(argv0)
+
+// ProgramUsage() is thread-safe as long as SetUsageMessage() is only
+// called before any threads start.
+extern GFLAGS_DLL_DECL const char* ProgramUsage();                 // string set by SetUsageMessage()
+
+// VersionString() is thread-safe as long as SetVersionString() is only
+// called before any threads start.
+extern GFLAGS_DLL_DECL const char* VersionString();                // string set by SetVersionString()
+
+
+
+// --------------------------------------------------------------------
+// Normally you access commandline flags by just saying "if (FLAGS_foo)"
+// or whatever, and set them by calling "FLAGS_foo = bar" (or, more
+// commonly, via the DEFINE_foo macro).  But if you need a bit more
+// control, we have programmatic ways to get/set the flags as well.
+// These programmatic ways to access flags are thread-safe, but direct
+// access is only thread-compatible.
+
+// Return true iff the flagname was found.
+// OUTPUT is set to the flag's value, or unchanged if we return false.
+extern GFLAGS_DLL_DECL bool GetCommandLineOption(const char* name, std::string* OUTPUT);
+
+// Return true iff the flagname was found. OUTPUT is set to the flag's
+// CommandLineFlagInfo or unchanged if we return false.
+extern GFLAGS_DLL_DECL bool GetCommandLineFlagInfo(const char* name, CommandLineFlagInfo* OUTPUT);
+
+// Return the CommandLineFlagInfo of the flagname.  exit() if name not found.
+// Example usage, to check if a flag's value is currently the default value:
+//   if (GetCommandLineFlagInfoOrDie("foo").is_default) ...
+extern GFLAGS_DLL_DECL CommandLineFlagInfo GetCommandLineFlagInfoOrDie(const char* name);
+
+enum GFLAGS_DLL_DECL FlagSettingMode {
+  // update the flag's value (can call this multiple times).
+  SET_FLAGS_VALUE,
+  // update the flag's value, but *only if* it has not yet been updated
+  // with SET_FLAGS_VALUE, SET_FLAG_IF_DEFAULT, or "FLAGS_xxx = nondef".
+  SET_FLAG_IF_DEFAULT,
+  // set the flag's default value to this.  If the flag has not yet updated
+  // yet (via SET_FLAGS_VALUE, SET_FLAG_IF_DEFAULT, or "FLAGS_xxx = nondef")
+  // change the flag's current value to the new default value as well.
+  SET_FLAGS_DEFAULT
+};
+
+// Set a particular flag ("command line option").  Returns a string
+// describing the new value that the option has been set to.  The
+// return value API is not well-specified, so basically just depend on
+// it to be empty if the setting failed for some reason -- the name is
+// not a valid flag name, or the value is not a valid value -- and
+// non-empty else.
+
+// SetCommandLineOption uses set_mode == SET_FLAGS_VALUE (the common case)
+extern GFLAGS_DLL_DECL std::string SetCommandLineOption        (const char* name, const char* value);
+extern GFLAGS_DLL_DECL std::string SetCommandLineOptionWithMode(const char* name, const char* value, FlagSettingMode set_mode);
+
+
+// --------------------------------------------------------------------
+// Saves the states (value, default value, whether the user has set
+// the flag, registered validators, etc) of all flags, and restores
+// them when the FlagSaver is destroyed.  This is very useful in
+// tests, say, when you want to let your tests change the flags, but
+// make sure that they get reverted to the original states when your
+// test is complete.
+//
+// Example usage:
+//   void TestFoo() {
+//     FlagSaver s1;
+//     FLAG_foo = false;
+//     FLAG_bar = "some value";
+//
+//     // test happens here.  You can return at any time
+//     // without worrying about restoring the FLAG values.
+//   }
+//
+// Note: This class is marked with GFLAGS_ATTRIBUTE_UNUSED because all
+// the work is done in the constructor and destructor, so in the standard
+// usage example above, the compiler would complain that it's an
+// unused variable.
+//
+// This class is thread-safe.  However, its destructor writes to
+// exactly the set of flags that have changed value during its
+// lifetime, so concurrent _direct_ access to those flags
+// (i.e. FLAGS_foo instead of {Get,Set}CommandLineOption()) is unsafe.
+
+class GFLAGS_DLL_DECL FlagSaver {
+ public:
+  FlagSaver();
+  ~FlagSaver();
+
+ private:
+  class FlagSaverImpl* impl_;   // we use pimpl here to keep API steady
+
+  FlagSaver(const FlagSaver&);  // no copying!
+  void operator=(const FlagSaver&);
+};
+
+// --------------------------------------------------------------------
+// Some deprecated or hopefully-soon-to-be-deprecated functions.
+
+// This is often used for logging.  TODO(csilvers): figure out a better way
+extern GFLAGS_DLL_DECL std::string CommandlineFlagsIntoString();
+// Usually where this is used, a FlagSaver should be used instead.
+extern GFLAGS_DLL_DECL
+bool ReadFlagsFromString(const std::string& flagfilecontents,
+                         const char* prog_name,
+                         bool errors_are_fatal);  // uses SET_FLAGS_VALUE
+
+// These let you manually implement --flagfile functionality.
+// DEPRECATED.
+extern GFLAGS_DLL_DECL bool AppendFlagsIntoFile(const std::string& filename, const char* prog_name);
+extern GFLAGS_DLL_DECL bool ReadFromFlagsFile(const std::string& filename, const char* prog_name, bool errors_are_fatal);   // uses SET_FLAGS_VALUE
+
+
+// --------------------------------------------------------------------
+// Useful routines for initializing flags from the environment.
+// In each case, if 'varname' does not exist in the environment
+// return defval.  If 'varname' does exist but is not valid
+// (e.g., not a number for an int32 flag), abort with an error.
+// Otherwise, return the value.  NOTE: for booleans, for true use
+// 't' or 'T' or 'true' or '1', for false 'f' or 'F' or 'false' or '0'.
+
+extern GFLAGS_DLL_DECL bool BoolFromEnv(const char *varname, bool defval);
+extern GFLAGS_DLL_DECL int32 Int32FromEnv(const char *varname, int32 defval);
+extern GFLAGS_DLL_DECL uint32 Uint32FromEnv(const char *varname, uint32 defval);
+extern GFLAGS_DLL_DECL int64 Int64FromEnv(const char *varname, int64 defval);
+extern GFLAGS_DLL_DECL uint64 Uint64FromEnv(const char *varname, uint64 defval);
+extern GFLAGS_DLL_DECL double DoubleFromEnv(const char *varname, double defval);
+extern GFLAGS_DLL_DECL const char *StringFromEnv(const char *varname, const char *defval);
+
+
+// --------------------------------------------------------------------
+// The next two functions parse gflags from main():
+
+// Set the "usage" message for this program.  For example:
+//   string usage("This program does nothing.  Sample usage:\n");
+//   usage += argv[0] + " <uselessarg1> <uselessarg2>";
+//   SetUsageMessage(usage);
+// Do not include commandline flags in the usage: we do that for you!
+// Thread-hostile; meant to be called before any threads are spawned.
+extern GFLAGS_DLL_DECL void SetUsageMessage(const std::string& usage);
+
+// Sets the version string, which is emitted with --version.
+// For instance: SetVersionString("1.3");
+// Thread-hostile; meant to be called before any threads are spawned.
+extern GFLAGS_DLL_DECL void SetVersionString(const std::string& version);
+
+
+// Looks for flags in argv and parses them.  Rearranges argv to put
+// flags first, or removes them entirely if remove_flags is true.
+// If a flag is defined more than once in the command line or flag
+// file, the last definition is used.  Returns the index (into argv)
+// of the first non-flag argument.
+// See top-of-file for more details on this function.
+#ifndef SWIG   // In swig, use ParseCommandLineFlagsScript() instead.
+extern GFLAGS_DLL_DECL uint32 ParseCommandLineFlags(int *argc, char*** argv, bool remove_flags);
+#endif
+
+
+// Calls to ParseCommandLineNonHelpFlags and then to
+// HandleCommandLineHelpFlags can be used instead of a call to
+// ParseCommandLineFlags during initialization, in order to allow for
+// changing default values for some FLAGS (via
+// e.g. SetCommandLineOptionWithMode calls) between the time of
+// command line parsing and the time of dumping help information for
+// the flags as a result of command line parsing.  If a flag is
+// defined more than once in the command line or flag file, the last
+// definition is used.  Returns the index (into argv) of the first
+// non-flag argument.  (If remove_flags is true, will always return 1.)
+extern GFLAGS_DLL_DECL uint32 ParseCommandLineNonHelpFlags(int *argc, char*** argv, bool remove_flags);
+
+// This is actually defined in gflags_reporting.cc.
+// This function is misnamed (it also handles --version, etc.), but
+// it's too late to change that now. :-(
+extern GFLAGS_DLL_DECL void HandleCommandLineHelpFlags();   // in gflags_reporting.cc
+
+// Allow command line reparsing.  Disables the error normally
+// generated when an unknown flag is found, since it may be found in a
+// later parse.  Thread-hostile; meant to be called before any threads
+// are spawned.
+extern GFLAGS_DLL_DECL void AllowCommandLineReparsing();
+
+// Reparse the flags that have not yet been recognized.  Only flags
+// registered since the last parse will be recognized.  Any flag value
+// must be provided as part of the argument using "=", not as a
+// separate command line argument that follows the flag argument.
+// Intended for handling flags from dynamically loaded libraries,
+// since their flags are not registered until they are loaded.
+extern GFLAGS_DLL_DECL void ReparseCommandLineNonHelpFlags();
+
+// Clean up memory allocated by flags.  This is only needed to reduce
+// the quantity of "potentially leaked" reports emitted by memory
+// debugging tools such as valgrind.  It is not required for normal
+// operation, or for the google perftools heap-checker.  It must only
+// be called when the process is about to exit, and all threads that
+// might access flags are quiescent.  Referencing flags after this is
+// called will have unexpected consequences.  This is not safe to run
+// when multiple threads might be running: the function is
+// thread-hostile.
+extern GFLAGS_DLL_DECL void ShutDownCommandLineFlags();
+
+
+// --------------------------------------------------------------------
+// Now come the command line flag declaration/definition macros that
+// will actually be used.  They're kind of hairy.  A major reason
+// for this is initialization: we want people to be able to access
+// variables in global constructors and have that not crash, even if
+// their global constructor runs before the global constructor here.
+// (Obviously, we can't guarantee the flags will have the correct
+// default value in that case, but at least accessing them is safe.)
+// The only way to do that is have flags point to a static buffer.
+// So we make one, using a union to ensure proper alignment, and
+// then use placement-new to actually set up the flag with the
+// correct default value.  In the same vein, we have to worry about
+// flag access in global destructors, so FlagRegisterer has to be
+// careful never to destroy the flag-values it constructs.
+//
+// Note that when we define a flag variable FLAGS_<name>, we also
+// preemptively define a junk variable, FLAGS_no<name>.  This is to
+// cause a link-time error if someone tries to define 2 flags with
+// names like "logging" and "nologging".  We do this because a bool
+// flag FLAG can be set from the command line to true with a "-FLAG"
+// argument, and to false with a "-noFLAG" argument, and so this can
+// potentially avert confusion.
+//
+// We also put flags into their own namespace.  It is purposefully
+// named in an opaque way that people should have trouble typing
+// directly.  The idea is that DEFINE puts the flag in the weird
+// namespace, and DECLARE imports the flag from there into the current
+// namespace.  The net result is to force people to use DECLARE to get
+// access to a flag, rather than saying "extern GFLAGS_DLL_DECL bool FLAGS_whatever;"
+// or some such instead.  We want this so we can put extra
+// functionality (like sanity-checking) in DECLARE if we want, and
+// make sure it is picked up everywhere.
+//
+// We also put the type of the variable in the namespace, so that
+// people can't DECLARE_int32 something that they DEFINE_bool'd
+// elsewhere.
+
+class GFLAGS_DLL_DECL FlagRegisterer {
+ public:
+  // We instantiate this template ctor for all supported types,
+  // so it is possible to place implementation of the FlagRegisterer ctor in
+  // .cc file.
+  // Calling this constructor with unsupported type will produce linker error.
+  template <typename FlagType>
+  FlagRegisterer(const char* name,
+                 const char* help, const char* filename,
+                 FlagType* current_storage, FlagType* defvalue_storage);
+};
+
+// Force compiler to not generate code for the given template specialization.
+#if defined(_MSC_VER) && _MSC_VER < 1800 // Visual Studio 2013 version 12.0
+  #define GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(type)
+#else
+  #define GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(type)                  \
+    extern template GFLAGS_DLL_DECL FlagRegisterer::FlagRegisterer(  \
+        const char* name, const char* help, const char* filename,    \
+        type* current_storage, type* defvalue_storage)
+#endif
+
+// Do this for all supported flag types.
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(bool);
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(int32);
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(uint32);
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(int64);
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(uint64);
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(double);
+GFLAGS_DECLARE_FLAG_REGISTERER_CTOR(std::string);
+
+#undef GFLAGS_DECLARE_FLAG_REGISTERER_CTOR
+
+// If your application #defines STRIP_FLAG_HELP to a non-zero value
+// before #including this file, we remove the help message from the
+// binary file. This can reduce the size of the resulting binary
+// somewhat, and may also be useful for security reasons.
+
+extern GFLAGS_DLL_DECL const char kStrippedFlagHelp[];
+
+
+} // namespace GFLAGS_NAMESPACE
+
+
+#ifndef SWIG  // In swig, ignore the main flag declarations
+
+#if defined(STRIP_FLAG_HELP) && STRIP_FLAG_HELP > 0
+// Need this construct to avoid the 'defined but not used' warning.
+#define MAYBE_STRIPPED_HELP(txt) \
+   (false ? (txt) : GFLAGS_NAMESPACE::kStrippedFlagHelp)
+#else
+#define MAYBE_STRIPPED_HELP(txt) txt
+#endif
+
+// Each command-line flag has two variables associated with it: one
+// with the current value, and one with the default value.  However,
+// we have a third variable, which is where value is assigned; it's a
+// constant.  This guarantees that FLAG_##value is initialized at
+// static initialization time (e.g. before program-start) rather than
+// than global construction time (which is after program-start but
+// before main), at least when 'value' is a compile-time constant.  We
+// use a small trick for the "default value" variable, and call it
+// FLAGS_no<name>.  This serves the second purpose of assuring a
+// compile error if someone tries to define a flag named no<name>
+// which is illegal (--foo and --nofoo both affect the "foo" flag).
+#define DEFINE_VARIABLE(type, shorttype, name, value, help)             \
+  namespace fL##shorttype {                                             \
+    static const type FLAGS_nono##name = value;                         \
+    /* We always want to export defined variables, dll or no */         \
+    GFLAGS_DLL_DEFINE_FLAG type FLAGS_##name = FLAGS_nono##name;        \
+    static type FLAGS_no##name = FLAGS_nono##name;                      \
+    static GFLAGS_NAMESPACE::FlagRegisterer o_##name(                   \
+      #name, MAYBE_STRIPPED_HELP(help), __FILE__,                       \
+      &FLAGS_##name, &FLAGS_no##name);                                  \
+  }                                                                     \
+  using fL##shorttype::FLAGS_##name
+
+// For DEFINE_bool, we want to do the extra check that the passed-in
+// value is actually a bool, and not a string or something that can be
+// coerced to a bool.  These declarations (no definition needed!) will
+// help us do that, and never evaluate From, which is important.
+// We'll use 'sizeof(IsBool(val))' to distinguish. This code requires
+// that the compiler have different sizes for bool & double. Since
+// this is not guaranteed by the standard, we check it with a
+// COMPILE_ASSERT.
+namespace fLB {
+struct CompileAssert {};
+typedef CompileAssert expected_sizeof_double_neq_sizeof_bool[
+                      (sizeof(double) != sizeof(bool)) ? 1 : -1];
+template<typename From> double GFLAGS_DLL_DECL IsBoolFlag(const From& from);
+GFLAGS_DLL_DECL bool IsBoolFlag(bool from);
+}  // namespace fLB
+
+// Here are the actual DEFINE_*-macros. The respective DECLARE_*-macros
+// are in a separate include, gflags_declare.h, for reducing
+// the physical transitive size for DECLARE use.
+#define DEFINE_bool(name, val, txt)                                     \
+  namespace fLB {                                                       \
+    typedef ::fLB::CompileAssert FLAG_##name##_value_is_not_a_bool[     \
+            (sizeof(::fLB::IsBoolFlag(val)) != sizeof(double))? 1: -1]; \
+  }                                                                     \
+  DEFINE_VARIABLE(bool, B, name, val, txt)
+
+#define DEFINE_int32(name, val, txt) \
+   DEFINE_VARIABLE(GFLAGS_NAMESPACE::int32, I, \
+                   name, val, txt)
+
+#define DEFINE_uint32(name,val, txt) \
+   DEFINE_VARIABLE(GFLAGS_NAMESPACE::uint32, U, \
+                   name, val, txt)
+
+#define DEFINE_int64(name, val, txt) \
+   DEFINE_VARIABLE(GFLAGS_NAMESPACE::int64, I64, \
+                   name, val, txt)
+
+#define DEFINE_uint64(name,val, txt) \
+   DEFINE_VARIABLE(GFLAGS_NAMESPACE::uint64, U64, \
+                   name, val, txt)
+
+#define DEFINE_double(name, val, txt) \
+   DEFINE_VARIABLE(double, D, name, val, txt)
+
+// Strings are trickier, because they're not a POD, so we can't
+// construct them at static-initialization time (instead they get
+// constructed at global-constructor time, which is much later).  To
+// try to avoid crashes in that case, we use a char buffer to store
+// the string, which we can static-initialize, and then placement-new
+// into it later.  It's not perfect, but the best we can do.
+
+namespace fLS {
+
+inline clstring* dont_pass0toDEFINE_string(char *stringspot,
+                                           const char *value) {
+  return new(stringspot) clstring(value);
+}
+inline clstring* dont_pass0toDEFINE_string(char *stringspot,
+                                           const clstring &value) {
+  return new(stringspot) clstring(value);
+}
+inline clstring* dont_pass0toDEFINE_string(char *stringspot,
+                                           int value);
+
+// Auxiliary class used to explicitly call destructor of string objects
+// allocated using placement new during static program deinitialization.
+// The destructor MUST be an inline function such that the explicit
+// destruction occurs in the same compilation unit as the placement new.
+class StringFlagDestructor {
+  void *current_storage_;
+  void *defvalue_storage_;
+
+public: 
+
+  StringFlagDestructor(void *current, void *defvalue)
+  : current_storage_(current), defvalue_storage_(defvalue) {}
+
+  ~StringFlagDestructor() {
+    reinterpret_cast<clstring*>(current_storage_ )->~clstring();
+    reinterpret_cast<clstring*>(defvalue_storage_)->~clstring();
+  }
+};
+
+}  // namespace fLS
+
+// We need to define a var named FLAGS_no##name so people don't define
+// --string and --nostring.  And we need a temporary place to put val
+// so we don't have to evaluate it twice.  Two great needs that go
+// great together!
+// The weird 'using' + 'extern' inside the fLS namespace is to work around
+// an unknown compiler bug/issue with the gcc 4.2.1 on SUSE 10.  See
+//    http://code.google.com/p/google-gflags/issues/detail?id=20
+#define DEFINE_string(name, val, txt)                                       \
+  namespace fLS {                                                           \
+    using ::fLS::clstring;                                                  \
+    using ::fLS::StringFlagDestructor;                                      \
+    static union { void* align; char s[sizeof(clstring)]; } s_##name[2];    \
+    clstring* const FLAGS_no##name = ::fLS::                                \
+                                   dont_pass0toDEFINE_string(s_##name[0].s, \
+                                                             val);          \
+    static GFLAGS_NAMESPACE::FlagRegisterer o_##name(                       \
+        #name, MAYBE_STRIPPED_HELP(txt), __FILE__,                          \
+        FLAGS_no##name, new (s_##name[1].s) clstring(*FLAGS_no##name));     \
+    static StringFlagDestructor d_##name(s_##name[0].s, s_##name[1].s);     \
+    extern GFLAGS_DLL_DEFINE_FLAG clstring& FLAGS_##name;                   \
+    using fLS::FLAGS_##name;                                                \
+    clstring& FLAGS_##name = *FLAGS_no##name;                               \
+  }                                                                         \
+  using fLS::FLAGS_##name
+
+#endif  // SWIG
+
+
+
+
+
+#endif  // GFLAGS_GFLAGS_H_
diff --git a/libraries/cmake/source/gflags/generated/linux/ppc64le/public/gflags/gflags_declare.h b/libraries/cmake/source/gflags/generated/linux/ppc64le/public/gflags/gflags_declare.h
new file mode 100644
index 000000000..0ce802b29
--- /dev/null
+++ b/libraries/cmake/source/gflags/generated/linux/ppc64le/public/gflags/gflags_declare.h
@@ -0,0 +1,156 @@
+// Copyright (c) 1999, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+// ---
+//
+// Revamped and reorganized by Craig Silverstein
+//
+// This is the file that should be included by any file which declares
+// command line flag.
+
+#ifndef GFLAGS_DECLARE_H_
+#define GFLAGS_DECLARE_H_
+
+
+// ---------------------------------------------------------------------------
+// Namespace of gflags library symbols.
+#define GFLAGS_NAMESPACE gflags
+
+// ---------------------------------------------------------------------------
+// Windows DLL import/export.
+
+// Whether gflags library is a DLL.
+//
+// Set to 1 by default when the shared gflags library was built on Windows.
+// Must be overwritten when this header file is used with the optionally also
+// built static library instead; set by CMake's INTERFACE_COMPILE_DEFINITIONS.
+#ifndef GFLAGS_IS_A_DLL
+#  define GFLAGS_IS_A_DLL 0
+#endif
+
+// We always want to import the symbols of the gflags library.
+#ifndef GFLAGS_DLL_DECL
+#  if GFLAGS_IS_A_DLL && defined(_MSC_VER)
+#    define GFLAGS_DLL_DECL __declspec(dllimport)
+#  elif defined(__GNUC__) && __GNUC__ >= 4
+#    define GFLAGS_DLL_DECL __attribute__((visibility("default")))
+#  else
+#    define GFLAGS_DLL_DECL
+#  endif
+#endif
+
+// We always want to import variables declared in user code.
+#ifndef GFLAGS_DLL_DECLARE_FLAG
+#  if GFLAGS_IS_A_DLL && defined(_MSC_VER)
+#    define GFLAGS_DLL_DECLARE_FLAG __declspec(dllimport)
+#  elif defined(__GNUC__) && __GNUC__ >= 4
+#    define GFLAGS_DLL_DECLARE_FLAG __attribute__((visibility("default")))
+#  else
+#    define GFLAGS_DLL_DECLARE_FLAG
+#  endif
+#endif
+
+// ---------------------------------------------------------------------------
+// Flag types
+#include <string>
+#if 1
+#  include <stdint.h>                   // the normal place uint32_t is defined
+#elif 1
+#  include <sys/types.h>                // the normal place u_int32_t is defined
+#elif 1
+#  include <inttypes.h>                 // a third place for uint32_t or u_int32_t
+#endif
+
+namespace GFLAGS_NAMESPACE {
+
+#if 1 // C99
+typedef int32_t          int32;
+typedef uint32_t         uint32;
+typedef int64_t          int64;
+typedef uint64_t         uint64;
+#elif 0 // BSD
+typedef int32_t          int32;
+typedef u_int32_t        uint32;
+typedef int64_t          int64;
+typedef u_int64_t        uint64;
+#elif 0 // Windows
+typedef __int32          int32;
+typedef unsigned __int32 uint32;
+typedef __int64          int64;
+typedef unsigned __int64 uint64;
+#else
+#  error Do not know how to define a 32-bit integer quantity on your system
+#endif
+
+} // namespace GFLAGS_NAMESPACE
+
+
+namespace fLS {
+
+// The meaning of "string" might be different between now and when the
+// macros below get invoked (e.g., if someone is experimenting with
+// other string implementations that get defined after this file is
+// included).  Save the current meaning now and use it in the macros.
+typedef std::string clstring;
+
+} // namespace fLS
+
+
+#define DECLARE_VARIABLE(type, shorttype, name) \
+  /* We always want to import declared variables, dll or no */ \
+  namespace fL##shorttype { extern GFLAGS_DLL_DECLARE_FLAG type FLAGS_##name; } \
+  using fL##shorttype::FLAGS_##name
+
+#define DECLARE_bool(name) \
+  DECLARE_VARIABLE(bool, B, name)
+
+#define DECLARE_int32(name) \
+  DECLARE_VARIABLE(::GFLAGS_NAMESPACE::int32, I, name)
+
+#define DECLARE_uint32(name) \
+  DECLARE_VARIABLE(::GFLAGS_NAMESPACE::uint32, U, name)
+
+#define DECLARE_int64(name) \
+  DECLARE_VARIABLE(::GFLAGS_NAMESPACE::int64, I64, name)
+
+#define DECLARE_uint64(name) \
+  DECLARE_VARIABLE(::GFLAGS_NAMESPACE::uint64, U64, name)
+
+#define DECLARE_double(name) \
+  DECLARE_VARIABLE(double, D, name)
+
+#define DECLARE_string(name) \
+  /* We always want to import declared variables, dll or no */ \
+  namespace fLS { \
+  extern GFLAGS_DLL_DECLARE_FLAG ::fLS::clstring& FLAGS_##name; \
+  } \
+  using fLS::FLAGS_##name
+
+
+#endif  // GFLAGS_DECLARE_H_
diff --git a/libraries/cmake/source/glog/generated/linux/ppc64le/private/config.h b/libraries/cmake/source/glog/generated/linux/ppc64le/private/config.h
new file mode 100644
index 000000000..8c6b1ef43
--- /dev/null
+++ b/libraries/cmake/source/glog/generated/linux/ppc64le/private/config.h
@@ -0,0 +1,222 @@
+#ifndef GLOG_CONFIG_H
+#define GLOG_CONFIG_H
+
+/* define if glog doesn't use RTTI */
+/* #undef DISABLE_RTTI */
+
+/* Namespace for Google classes */
+#define GOOGLE_NAMESPACE google
+
+/* Define if you have the `dladdr' function */
+/* #undef HAVE_DLADDR */
+
+/* Define if you have the `snprintf' function */
+#define HAVE_SNPRINTF
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H
+
+/* Define to 1 if you have the <execinfo.h> header file. */
+#define HAVE_EXECINFO_H
+
+/* Define if you have the `fcntl' function */
+#define HAVE_FCNTL
+
+/* Define to 1 if you have the <glob.h> header file. */
+#define HAVE_GLOB_H
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+/* #undef HAVE_LIBPTHREAD */
+
+/* Define to 1 if you have the <libunwind.h> header file. */
+/* #undef HAVE_LIBUNWIND_H */
+
+/* define if you have google gflags library */
+#define HAVE_LIB_GFLAGS
+
+/* define if you have google gmock library */
+/* #undef HAVE_LIB_GMOCK */
+
+/* define if you have google gtest library */
+/* #undef HAVE_LIB_GTEST */
+
+/* define if you have libunwind */
+/* #undef HAVE_LIB_UNWIND */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H
+
+/* define to disable multithreading support. */
+/* #undef NO_THREADS */
+
+/* define if the compiler implements namespaces */
+#define HAVE_NAMESPACES
+
+/* Define if you have the 'pread' function */
+#define HAVE_PREAD
+
+/* Define if you have POSIX threads libraries and header files. */
+#define HAVE_PTHREAD
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H
+
+/* Define if you have the 'pwrite' function */
+#define HAVE_PWRITE
+
+/* define if the compiler implements pthread_rwlock_* */
+#define HAVE_RWLOCK
+
+/* Define if you have the 'sigaction' function */
+#define HAVE_SIGACTION
+
+/* Define if you have the `sigaltstack' function */
+/* #undef HAVE_SIGALTSTACK */
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H
+
+/* Define to 1 if you have the <syscall.h> header file. */
+#define HAVE_SYSCALL_H
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#define HAVE_SYSLOG_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/syscall.h> header file. */
+#define HAVE_SYS_SYSCALL_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/ucontext.h> header file. */
+/* #undef HAVE_SYS_UCONTEXT_H */
+
+/* Define to 1 if you have the <sys/utsname.h> header file. */
+#define HAVE_SYS_UTSNAME_H
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#define HAVE_SYS_WAIT_H
+
+/* Define to 1 if you have the <ucontext.h> header file. */
+#define HAVE_UCONTEXT_H
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <unwind.h> header file. */
+/* #undef HAVE_UNWIND_H */
+
+/* define if the compiler supports using expression for operator */
+#define HAVE_USING_OPERATOR
+
+/* define if your compiler has __attribute__ */
+#define HAVE___ATTRIBUTE__
+
+/* define if your compiler has __builtin_expect */
+#define HAVE___BUILTIN_EXPECT 1
+
+/* define if your compiler has __sync_val_compare_and_swap */
+#define HAVE___SYNC_VAL_COMPARE_AND_SWAP
+
+/* define if symbolize support is available */
+#define HAVE_SYMBOLIZE
+
+/* define if localtime_r is available in time.h */
+#define HAVE_LOCALTIME_R
+
+/* define if gmtime_r is available in time.h */
+/* #undef HAVE_GMTIME_R */
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+/* #undef LT_OBJDIR */
+
+/* Name of package */
+/* #undef PACKAGE */
+
+/* Define to the address where bug reports for this package should be sent. */
+/* #undef PACKAGE_BUGREPORT */
+
+/* Define to the full name of this package. */
+/* #undef PACKAGE_NAME */
+
+/* Define to the full name and version of this package. */
+/* #undef PACKAGE_STRING */
+
+/* Define to the one symbol short name of this package. */
+/* #undef PACKAGE_TARNAME */
+
+/* Define to the home page for this package. */
+/* #undef PACKAGE_URL */
+
+/* Define to the version of this package. */
+/* #undef PACKAGE_VERSION */
+
+/* How to access the PC from a struct ucontext */
+/* #undef PC_FROM_UCONTEXT */
+
+/* define if we should print file offsets in traces instead of symbolizing. */
+/* #undef PRINT_UNSYMBOLIZED_STACK_TRACES */
+
+/* Define to necessary symbol if this constant uses a non-standard name on
+   your system. */
+/* #undef PTHREAD_CREATE_JOINABLE */
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 8
+
+/* Define to 1 if you have the ANSI C header files. */
+/* #undef STDC_HEADERS */
+
+/* the namespace where STL code like vector<> is defined */
+/* #undef STL_NAMESPACE */
+
+/* location of source code */
+#define TEST_SRC_DIR ""
+
+/* Define to necessary thread-local storage attribute. */
+/* #undef GLOG_THREAD_LOCAL_STORAGE */
+
+/* Check whether aligned_storage and alignof present */
+#define HAVE_ALIGNED_STORAGE 1
+
+/* Check whether C++11 atomic is available */
+#define HAVE_CXX11_ATOMIC 1
+
+/* Check whether C++11 nullptr_t is available */
+#define HAVE_CXX11_NULLPTR_T 1
+
+/* Version number of package */
+/* #undef VERSION */
+
+#ifdef GLOG_BAZEL_BUILD
+
+/* TODO(rodrigoq): remove this workaround once bazel#3979 is resolved:
+ * https://github.com/bazelbuild/bazel/issues/3979 */
+#define _START_GOOGLE_NAMESPACE_ namespace GOOGLE_NAMESPACE {
+
+#define _END_GOOGLE_NAMESPACE_ }
+
+#else
+
+/* Stops putting the code inside the Google namespace */
+#define _END_GOOGLE_NAMESPACE_ }
+
+/* Puts following code inside the Google namespace */
+#define _START_GOOGLE_NAMESPACE_ namespace google {
+
+#endif
+
+#endif  // GLOG_CONFIG_H
diff --git a/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/export.h b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/export.h
new file mode 100644
index 000000000..3aec8b866
--- /dev/null
+++ b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/export.h
@@ -0,0 +1,42 @@
+
+#ifndef GOOGLE_GLOG_DLL_DECL_H
+#define GOOGLE_GLOG_DLL_DECL_H
+
+#ifdef GLOG_STATIC_DEFINE
+#  define GOOGLE_GLOG_DLL_DECL
+#  define GLOG_NO_EXPORT
+#else
+#  ifndef GOOGLE_GLOG_DLL_DECL
+#    ifdef GOOGLE_GLOG_IS_A_DLL
+        /* We are building this library */
+#      define GOOGLE_GLOG_DLL_DECL 
+#    else
+        /* We are using this library */
+#      define GOOGLE_GLOG_DLL_DECL 
+#    endif
+#  endif
+
+#  ifndef GLOG_NO_EXPORT
+#    define GLOG_NO_EXPORT 
+#  endif
+#endif
+
+#ifndef GLOG_DEPRECATED
+#  define GLOG_DEPRECATED __attribute__ ((__deprecated__))
+#endif
+
+#ifndef GLOG_DEPRECATED_EXPORT
+#  define GLOG_DEPRECATED_EXPORT GOOGLE_GLOG_DLL_DECL GLOG_DEPRECATED
+#endif
+
+#ifndef GLOG_DEPRECATED_NO_EXPORT
+#  define GLOG_DEPRECATED_NO_EXPORT GLOG_NO_EXPORT GLOG_DEPRECATED
+#endif
+
+#if 0 /* DEFINE_NO_DEPRECATED */
+#  ifndef GLOG_NO_DEPRECATED
+#    define GLOG_NO_DEPRECATED
+#  endif
+#endif
+
+#endif /* GOOGLE_GLOG_DLL_DECL_H */
diff --git a/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/logging.h b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/logging.h
new file mode 100644
index 000000000..6b5259161
--- /dev/null
+++ b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/logging.h
@@ -0,0 +1,1900 @@
+// Copyright (c) 1999, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Author: Ray Sidney
+//
+// This file contains #include information about logging-related stuff.
+// Pretty much everybody needs to #include this file so that they can
+// log various happenings.
+//
+#ifndef _LOGGING_H_
+#define _LOGGING_H_
+
+#include <cerrno>
+#include <cstddef>
+#include <cstring>
+#include <ctime>
+#include <iosfwd>
+#include <ostream>
+#include <sstream>
+#include <string>
+#if 1
+# include <unistd.h>
+#endif
+#include <vector>
+
+#if defined(_MSC_VER)
+#define GLOG_MSVC_PUSH_DISABLE_WARNING(n) __pragma(warning(push)) \
+                                     __pragma(warning(disable:n))
+#define GLOG_MSVC_POP_WARNING() __pragma(warning(pop))
+#else
+#define GLOG_MSVC_PUSH_DISABLE_WARNING(n)
+#define GLOG_MSVC_POP_WARNING()
+#endif
+
+#if 1
+#include "glog/export.h"
+#endif
+
+// Annoying stuff for windows -- makes sure clients can import these functions
+#ifndef GOOGLE_GLOG_DLL_DECL
+# if defined(_WIN32) && !defined(__CYGWIN__)
+#   define GOOGLE_GLOG_DLL_DECL  __declspec(dllimport)
+# else
+#   define GOOGLE_GLOG_DLL_DECL
+# endif
+#endif
+
+// We care a lot about number of bits things take up.  Unfortunately,
+// systems define their bit-specific ints in a lot of different ways.
+// We use our own way, and have a typedef to get there.
+// Note: these commands below may look like "#if 1" or "#if 0", but
+// that's because they were constructed that way at ./configure time.
+// Look at logging.h.in to see how they're calculated (based on your config).
+#if 1
+#include <stdint.h>             // the normal place uint16_t is defined
+#endif
+#if 1
+#include <sys/types.h>          // the normal place u_int16_t is defined
+#endif
+#if 1
+#include <inttypes.h>           // a third place for uint16_t or u_int16_t
+#endif
+
+#ifdef GFLAGS_DLL_DECLARE_FLAG
+#define GLOG_GFLAGS_DLL_DECLARE_FLAG_WAS_DEFINED
+#pragma push_macro("GFLAGS_DLL_DECLARE_FLAG")
+#undef GFLAGS_DLL_DECLARE_FLAG
+#endif // defined(GFLAGS_DLL_DECLARE_FLAG)
+
+#define GFLAGS_DLL_DECLARE_FLAG GOOGLE_GLOG_DLL_DECL
+
+#if 1
+#include <gflags/gflags.h>
+#endif
+
+#ifdef HAVE_CXX11_ATOMIC
+#include <atomic>
+#elif defined(OS_WINDOWS)
+#include <Windows.h>
+#endif
+
+namespace google {
+
+#if 1      // the C99 format
+typedef int32_t int32;
+typedef uint32_t uint32;
+typedef int64_t int64;
+typedef uint64_t uint64;
+#elif 1   // the BSD format
+typedef int32_t int32;
+typedef u_int32_t uint32;
+typedef int64_t int64;
+typedef u_int64_t uint64;
+#elif 0    // the windows (vc7) format
+typedef __int32 int32;
+typedef unsigned __int32 uint32;
+typedef __int64 int64;
+typedef unsigned __int64 uint64;
+#else
+#error Do not know how to define a 32-bit integer quantity on your system
+#endif
+
+}
+
+#ifdef GLOG_CUSTOM_PREFIX_SUPPORT
+struct LogMessageTime {
+  explicit LogMessageTime (const struct::tm& time_struct_,
+                           const time_t& timestamp_, const int32_t& usecs_):
+      time_struct(time_struct_), ts(timestamp_), usecs(usecs_) {}
+
+  const time_t& timestamp() const { return ts; }
+  const int& sec() const { return time_struct.tm_sec; }
+  const int32_t& usec() const { return usecs; }
+  const int& min() const { return time_struct.tm_min; }
+  const int& hour() const { return time_struct.tm_hour; }
+  const int& day() const { return time_struct.tm_mday; }
+  const int& month() const { return time_struct.tm_mon; }
+  const int& year() const { return time_struct.tm_year; }
+  const int& dayOfWeek() const { return time_struct.tm_wday; }
+  const int& dayInYear() const { return time_struct.tm_yday; }
+  const int& dst() const { return time_struct.tm_isdst; }
+
+  private:
+    const struct::tm& time_struct;
+    const time_t& ts;
+    const int32_t& usecs;
+};
+
+struct LogMessageInfo {
+  explicit LogMessageInfo(const char* const severity_,
+                          const char* const filename_,
+                          const int& line_number_,
+                          const int& thread_id_,
+                          const LogMessageTime& time_):
+      severity(severity_), filename(filename_), line_number(line_number_),
+      thread_id(thread_id_), time(time_)
+  {}
+
+  const char* const severity;
+  const char* const filename;
+  const int &line_number;
+  const int &thread_id;
+  const LogMessageTime& time;
+};
+
+typedef void(*CustomPrefixCallback)(std::ostream& s, const LogMessageInfo& l, void* data);
+#endif
+
+// The global value of GOOGLE_STRIP_LOG. All the messages logged to
+// LOG(XXX) with severity less than GOOGLE_STRIP_LOG will not be displayed.
+// If it can be determined at compile time that the message will not be
+// printed, the statement will be compiled out.
+//
+// Example: to strip out all INFO and WARNING messages, use the value
+// of 2 below. To make an exception for WARNING messages from a single
+// file, add "#define GOOGLE_STRIP_LOG 1" to that file _before_ including
+// base/logging.h
+#ifndef GOOGLE_STRIP_LOG
+#define GOOGLE_STRIP_LOG 0
+#endif
+
+// GCC can be told that a certain branch is not likely to be taken (for
+// instance, a CHECK failure), and use that information in static analysis.
+// Giving it this information can help it optimize for the common case in
+// the absence of better information (ie. -fprofile-arcs).
+//
+#ifndef GOOGLE_PREDICT_BRANCH_NOT_TAKEN
+#if 1
+#define GOOGLE_PREDICT_BRANCH_NOT_TAKEN(x) (__builtin_expect(x, 0))
+#else
+#define GOOGLE_PREDICT_BRANCH_NOT_TAKEN(x) x
+#endif
+#endif
+
+#ifndef GOOGLE_PREDICT_FALSE
+#if 1
+#define GOOGLE_PREDICT_FALSE(x) (__builtin_expect(x, 0))
+#else
+#define GOOGLE_PREDICT_FALSE(x) x
+#endif
+#endif
+
+#ifndef GOOGLE_PREDICT_TRUE
+#if 1
+#define GOOGLE_PREDICT_TRUE(x) (__builtin_expect(!!(x), 1))
+#else
+#define GOOGLE_PREDICT_TRUE(x) x
+#endif
+#endif
+
+
+// Make a bunch of macros for logging.  The way to log things is to stream
+// things to LOG(<a particular severity level>).  E.g.,
+//
+//   LOG(INFO) << "Found " << num_cookies << " cookies";
+//
+// You can capture log messages in a string, rather than reporting them
+// immediately:
+//
+//   vector<string> errors;
+//   LOG_STRING(ERROR, &errors) << "Couldn't parse cookie #" << cookie_num;
+//
+// This pushes back the new error onto 'errors'; if given a NULL pointer,
+// it reports the error via LOG(ERROR).
+//
+// You can also do conditional logging:
+//
+//   LOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
+//
+// You can also do occasional logging (log every n'th occurrence of an
+// event):
+//
+//   LOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th cookie";
+//
+// The above will cause log messages to be output on the 1st, 11th, 21st, ...
+// times it is executed.  Note that the special google::COUNTER value is used
+// to identify which repetition is happening.
+//
+// You can also do occasional conditional logging (log every n'th
+// occurrence of an event, when condition is satisfied):
+//
+//   LOG_IF_EVERY_N(INFO, (size > 1024), 10) << "Got the " << google::COUNTER
+//                                           << "th big cookie";
+//
+// You can log messages the first N times your code executes a line. E.g.
+//
+//   LOG_FIRST_N(INFO, 20) << "Got the " << google::COUNTER << "th cookie";
+//
+// Outputs log messages for the first 20 times it is executed.
+//
+// Analogous SYSLOG, SYSLOG_IF, and SYSLOG_EVERY_N macros are available.
+// These log to syslog as well as to the normal logs.  If you use these at
+// all, you need to be aware that syslog can drastically reduce performance,
+// especially if it is configured for remote logging!  Don't use these
+// unless you fully understand this and have a concrete need to use them.
+// Even then, try to minimize your use of them.
+//
+// There are also "debug mode" logging macros like the ones above:
+//
+//   DLOG(INFO) << "Found cookies";
+//
+//   DLOG_IF(INFO, num_cookies > 10) << "Got lots of cookies";
+//
+//   DLOG_EVERY_N(INFO, 10) << "Got the " << google::COUNTER << "th cookie";
+//
+// All "debug mode" logging is compiled away to nothing for non-debug mode
+// compiles.
+//
+// We also have
+//
+//   LOG_ASSERT(assertion);
+//   DLOG_ASSERT(assertion);
+//
+// which is syntactic sugar for {,D}LOG_IF(FATAL, assert fails) << assertion;
+//
+// There are "verbose level" logging macros.  They look like
+//
+//   VLOG(1) << "I'm printed when you run the program with --v=1 or more";
+//   VLOG(2) << "I'm printed when you run the program with --v=2 or more";
+//
+// These always log at the INFO log level (when they log at all).
+// The verbose logging can also be turned on module-by-module.  For instance,
+//    --vmodule=mapreduce=2,file=1,gfs*=3 --v=0
+// will cause:
+//   a. VLOG(2) and lower messages to be printed from mapreduce.{h,cc}
+//   b. VLOG(1) and lower messages to be printed from file.{h,cc}
+//   c. VLOG(3) and lower messages to be printed from files prefixed with "gfs"
+//   d. VLOG(0) and lower messages to be printed from elsewhere
+//
+// The wildcarding functionality shown by (c) supports both '*' (match
+// 0 or more characters) and '?' (match any single character) wildcards.
+//
+// There's also VLOG_IS_ON(n) "verbose level" condition macro. To be used as
+//
+//   if (VLOG_IS_ON(2)) {
+//     // do some logging preparation and logging
+//     // that can't be accomplished with just VLOG(2) << ...;
+//   }
+//
+// There are also VLOG_IF, VLOG_EVERY_N and VLOG_IF_EVERY_N "verbose level"
+// condition macros for sample cases, when some extra computation and
+// preparation for logs is not needed.
+//   VLOG_IF(1, (size > 1024))
+//      << "I'm printed when size is more than 1024 and when you run the "
+//         "program with --v=1 or more";
+//   VLOG_EVERY_N(1, 10)
+//      << "I'm printed every 10th occurrence, and when you run the program "
+//         "with --v=1 or more. Present occurence is " << google::COUNTER;
+//   VLOG_IF_EVERY_N(1, (size > 1024), 10)
+//      << "I'm printed on every 10th occurence of case when size is more "
+//         " than 1024, when you run the program with --v=1 or more. ";
+//         "Present occurence is " << google::COUNTER;
+//
+// The supported severity levels for macros that allow you to specify one
+// are (in increasing order of severity) INFO, WARNING, ERROR, and FATAL.
+// Note that messages of a given severity are logged not only in the
+// logfile for that severity, but also in all logfiles of lower severity.
+// E.g., a message of severity FATAL will be logged to the logfiles of
+// severity FATAL, ERROR, WARNING, and INFO.
+//
+// There is also the special severity of DFATAL, which logs FATAL in
+// debug mode, ERROR in normal mode.
+//
+// Very important: logging a message at the FATAL severity level causes
+// the program to terminate (after the message is logged).
+//
+// Unless otherwise specified, logs will be written to the filename
+// "<program name>.<hostname>.<user name>.log.<severity level>.", followed
+// by the date, time, and pid (you can't prevent the date, time, and pid
+// from being in the filename).
+//
+// The logging code takes two flags:
+//     --v=#           set the verbose level
+//     --logtostderr   log all the messages to stderr instead of to logfiles
+
+// LOG LINE PREFIX FORMAT
+//
+// Log lines have this form:
+//
+//     Lyyyymmdd hh:mm:ss.uuuuuu threadid file:line] msg...
+//
+// where the fields are defined as follows:
+//
+//   L                A single character, representing the log level
+//                    (eg 'I' for INFO)
+//   yyyy             The year
+//   mm               The month (zero padded; ie May is '05')
+//   dd               The day (zero padded)
+//   hh:mm:ss.uuuuuu  Time in hours, minutes and fractional seconds
+//   threadid         The space-padded thread ID as returned by GetTID()
+//                    (this matches the PID on Linux)
+//   file             The file name
+//   line             The line number
+//   msg              The user-supplied message
+//
+// Example:
+//
+//   I1103 11:57:31.739339 24395 google.cc:2341] Command line: ./some_prog
+//   I1103 11:57:31.739403 24395 google.cc:2342] Process id 24395
+//
+// NOTE: although the microseconds are useful for comparing events on
+// a single machine, clocks on different machines may not be well
+// synchronized.  Hence, use caution when comparing the low bits of
+// timestamps from different machines.
+
+#ifndef DECLARE_VARIABLE
+#define MUST_UNDEF_GFLAGS_DECLARE_MACROS
+#define DECLARE_VARIABLE(type, shorttype, name, tn)                     \
+  namespace fL##shorttype {                                             \
+    extern GOOGLE_GLOG_DLL_DECL type FLAGS_##name;                      \
+  }                                                                     \
+  using fL##shorttype::FLAGS_##name
+
+// bool specialization
+#define DECLARE_bool(name) \
+  DECLARE_VARIABLE(bool, B, name, bool)
+
+// int32 specialization
+#define DECLARE_int32(name) \
+  DECLARE_VARIABLE(google::int32, I, name, int32)
+
+// Special case for string, because we have to specify the namespace
+// std::string, which doesn't play nicely with our FLAG__namespace hackery.
+#define DECLARE_string(name)                                            \
+  namespace fLS {                                                       \
+    extern GOOGLE_GLOG_DLL_DECL std::string& FLAGS_##name;              \
+  }                                                                     \
+  using fLS::FLAGS_##name
+#endif
+
+// Set whether appending a timestamp to the log file name
+DECLARE_bool(timestamp_in_logfile_name);
+
+// Set whether log messages go to stderr instead of logfiles
+DECLARE_bool(logtostderr);
+
+// Set whether log messages go to stderr in addition to logfiles.
+DECLARE_bool(alsologtostderr);
+
+// Set color messages logged to stderr (if supported by terminal).
+DECLARE_bool(colorlogtostderr);
+
+// Log messages at a level >= this flag are automatically sent to
+// stderr in addition to log files.
+DECLARE_int32(stderrthreshold);
+
+// Set whether the log prefix should be prepended to each line of output.
+DECLARE_bool(log_prefix);
+
+// Log messages at a level <= this flag are buffered.
+// Log messages at a higher level are flushed immediately.
+DECLARE_int32(logbuflevel);
+
+// Sets the maximum number of seconds which logs may be buffered for.
+DECLARE_int32(logbufsecs);
+
+// Log suppression level: messages logged at a lower level than this
+// are suppressed.
+DECLARE_int32(minloglevel);
+
+// If specified, logfiles are written into this directory instead of the
+// default logging directory.
+DECLARE_string(log_dir);
+
+// Set the log file mode.
+DECLARE_int32(logfile_mode);
+
+// Sets the path of the directory into which to put additional links
+// to the log files.
+DECLARE_string(log_link);
+
+DECLARE_int32(v);  // in vlog_is_on.cc
+
+DECLARE_string(vmodule); // also in vlog_is_on.cc
+
+// Sets the maximum log file size (in MB).
+DECLARE_int32(max_log_size);
+
+// Sets whether to avoid logging to the disk if the disk is full.
+DECLARE_bool(stop_logging_if_full_disk);
+
+// Use UTC time for logging
+DECLARE_bool(log_utc_time);
+
+#ifdef MUST_UNDEF_GFLAGS_DECLARE_MACROS
+#undef MUST_UNDEF_GFLAGS_DECLARE_MACROS
+#undef DECLARE_VARIABLE
+#undef DECLARE_bool
+#undef DECLARE_int32
+#undef DECLARE_string
+#endif
+
+// Log messages below the GOOGLE_STRIP_LOG level will be compiled away for
+// security reasons. See LOG(severtiy) below.
+
+// A few definitions of macros that don't generate much code.  Since
+// LOG(INFO) and its ilk are used all over our code, it's
+// better to have compact code for these operations.
+
+#if GOOGLE_STRIP_LOG == 0
+#define COMPACT_GOOGLE_LOG_INFO google::LogMessage( \
+      __FILE__, __LINE__)
+#define LOG_TO_STRING_INFO(message) google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_INFO, message)
+#else
+#define COMPACT_GOOGLE_LOG_INFO google::NullStream()
+#define LOG_TO_STRING_INFO(message) google::NullStream()
+#endif
+
+#if GOOGLE_STRIP_LOG <= 1
+#define COMPACT_GOOGLE_LOG_WARNING google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_WARNING)
+#define LOG_TO_STRING_WARNING(message) google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_WARNING, message)
+#else
+#define COMPACT_GOOGLE_LOG_WARNING google::NullStream()
+#define LOG_TO_STRING_WARNING(message) google::NullStream()
+#endif
+
+#if GOOGLE_STRIP_LOG <= 2
+#define COMPACT_GOOGLE_LOG_ERROR google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_ERROR)
+#define LOG_TO_STRING_ERROR(message) google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_ERROR, message)
+#else
+#define COMPACT_GOOGLE_LOG_ERROR google::NullStream()
+#define LOG_TO_STRING_ERROR(message) google::NullStream()
+#endif
+
+#if GOOGLE_STRIP_LOG <= 3
+#define COMPACT_GOOGLE_LOG_FATAL google::LogMessageFatal( \
+      __FILE__, __LINE__)
+#define LOG_TO_STRING_FATAL(message) google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_FATAL, message)
+#else
+#define COMPACT_GOOGLE_LOG_FATAL google::NullStreamFatal()
+#define LOG_TO_STRING_FATAL(message) google::NullStreamFatal()
+#endif
+
+#if defined(NDEBUG) && !defined(DCHECK_ALWAYS_ON)
+#define DCHECK_IS_ON() 0
+#else
+#define DCHECK_IS_ON() 1
+#endif
+
+// For DFATAL, we want to use LogMessage (as opposed to
+// LogMessageFatal), to be consistent with the original behavior.
+#if !DCHECK_IS_ON()
+#define COMPACT_GOOGLE_LOG_DFATAL COMPACT_GOOGLE_LOG_ERROR
+#elif GOOGLE_STRIP_LOG <= 3
+#define COMPACT_GOOGLE_LOG_DFATAL google::LogMessage( \
+      __FILE__, __LINE__, google::GLOG_FATAL)
+#else
+#define COMPACT_GOOGLE_LOG_DFATAL google::NullStreamFatal()
+#endif
+
+#define GOOGLE_LOG_INFO(counter) google::LogMessage(__FILE__, __LINE__, google::GLOG_INFO, counter, &google::LogMessage::SendToLog)
+#define SYSLOG_INFO(counter) \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_INFO, counter, \
+  &google::LogMessage::SendToSyslogAndLog)
+#define GOOGLE_LOG_WARNING(counter)  \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_WARNING, counter, \
+  &google::LogMessage::SendToLog)
+#define SYSLOG_WARNING(counter)  \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_WARNING, counter, \
+  &google::LogMessage::SendToSyslogAndLog)
+#define GOOGLE_LOG_ERROR(counter)  \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, counter, \
+  &google::LogMessage::SendToLog)
+#define SYSLOG_ERROR(counter)  \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, counter, \
+  &google::LogMessage::SendToSyslogAndLog)
+#define GOOGLE_LOG_FATAL(counter) \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_FATAL, counter, \
+  &google::LogMessage::SendToLog)
+#define SYSLOG_FATAL(counter) \
+  google::LogMessage(__FILE__, __LINE__, google::GLOG_FATAL, counter, \
+  &google::LogMessage::SendToSyslogAndLog)
+#define GOOGLE_LOG_DFATAL(counter) \
+  google::LogMessage(__FILE__, __LINE__, google::DFATAL_LEVEL, counter, \
+  &google::LogMessage::SendToLog)
+#define SYSLOG_DFATAL(counter) \
+  google::LogMessage(__FILE__, __LINE__, google::DFATAL_LEVEL, counter, \
+  &google::LogMessage::SendToSyslogAndLog)
+
+#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__) || defined(__CYGWIN__) || defined(__CYGWIN32__)
+// A very useful logging macro to log windows errors:
+#define LOG_SYSRESULT(result) \
+  if (FAILED(HRESULT_FROM_WIN32(result))) { \
+    LPSTR message = NULL; \
+    LPSTR msg = reinterpret_cast<LPSTR>(&message); \
+    DWORD message_length = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | \
+                         FORMAT_MESSAGE_FROM_SYSTEM, \
+                         0, result, 0, msg, 100, NULL); \
+    if (message_length > 0) { \
+      google::LogMessage(__FILE__, __LINE__, google::GLOG_ERROR, 0, \
+          &google::LogMessage::SendToLog).stream() \
+          << reinterpret_cast<const char*>(message); \
+      LocalFree(message); \
+    } \
+  }
+#endif
+
+// We use the preprocessor's merging operator, "##", so that, e.g.,
+// LOG(INFO) becomes the token GOOGLE_LOG_INFO.  There's some funny
+// subtle difference between ostream member streaming functions (e.g.,
+// ostream::operator<<(int) and ostream non-member streaming functions
+// (e.g., ::operator<<(ostream&, string&): it turns out that it's
+// impossible to stream something like a string directly to an unnamed
+// ostream. We employ a neat hack by calling the stream() member
+// function of LogMessage which seems to avoid the problem.
+#define LOG(severity) COMPACT_GOOGLE_LOG_ ## severity.stream()
+#define SYSLOG(severity) SYSLOG_ ## severity(0).stream()
+
+namespace google {
+
+// They need the definitions of integer types.
+#include "glog/log_severity.h"
+#include "glog/vlog_is_on.h"
+
+// Initialize google's logging library. You will see the program name
+// specified by argv0 in log outputs.
+GOOGLE_GLOG_DLL_DECL void InitGoogleLogging(const char* argv0);
+
+#ifdef GLOG_CUSTOM_PREFIX_SUPPORT
+GOOGLE_GLOG_DLL_DECL void InitGoogleLogging(const char* argv0,
+                                            CustomPrefixCallback prefix_callback,
+                                            void* prefix_callback_data = NULL);
+#endif
+
+// Shutdown google's logging library.
+GOOGLE_GLOG_DLL_DECL void ShutdownGoogleLogging();
+
+// Install a function which will be called after LOG(FATAL).
+GOOGLE_GLOG_DLL_DECL void InstallFailureFunction(void (*fail_func)());
+
+// Enable/Disable old log cleaner.
+GOOGLE_GLOG_DLL_DECL void EnableLogCleaner(int overdue_days);
+GOOGLE_GLOG_DLL_DECL void DisableLogCleaner();
+GOOGLE_GLOG_DLL_DECL void SetApplicationFingerprint(const std::string& fingerprint);
+
+class LogSink;  // defined below
+
+// If a non-NULL sink pointer is given, we push this message to that sink.
+// For LOG_TO_SINK we then do normal LOG(severity) logging as well.
+// This is useful for capturing messages and passing/storing them
+// somewhere more specific than the global log of the process.
+// Argument types:
+//   LogSink* sink;
+//   LogSeverity severity;
+// The cast is to disambiguate NULL arguments.
+#define LOG_TO_SINK(sink, severity) \
+  google::LogMessage(                                    \
+      __FILE__, __LINE__,                                               \
+      google::GLOG_ ## severity,                         \
+      static_cast<google::LogSink*>(sink), true).stream()
+#define LOG_TO_SINK_BUT_NOT_TO_LOGFILE(sink, severity)                  \
+  google::LogMessage(                                    \
+      __FILE__, __LINE__,                                               \
+      google::GLOG_ ## severity,                         \
+      static_cast<google::LogSink*>(sink), false).stream()
+
+// If a non-NULL string pointer is given, we write this message to that string.
+// We then do normal LOG(severity) logging as well.
+// This is useful for capturing messages and storing them somewhere more
+// specific than the global log of the process.
+// Argument types:
+//   string* message;
+//   LogSeverity severity;
+// The cast is to disambiguate NULL arguments.
+// NOTE: LOG(severity) expands to LogMessage().stream() for the specified
+// severity.
+#define LOG_TO_STRING(severity, message) \
+  LOG_TO_STRING_##severity(static_cast<std::string*>(message)).stream()
+
+// If a non-NULL pointer is given, we push the message onto the end
+// of a vector of strings; otherwise, we report it with LOG(severity).
+// This is handy for capturing messages and perhaps passing them back
+// to the caller, rather than reporting them immediately.
+// Argument types:
+//   LogSeverity severity;
+//   vector<string> *outvec;
+// The cast is to disambiguate NULL arguments.
+#define LOG_STRING(severity, outvec) \
+  LOG_TO_STRING_##severity(static_cast<std::vector<std::string>*>(outvec)).stream()
+
+#define LOG_IF(severity, condition) \
+  static_cast<void>(0),             \
+  !(condition) ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+#define SYSLOG_IF(severity, condition) \
+  static_cast<void>(0),                \
+  !(condition) ? (void) 0 : google::LogMessageVoidify() & SYSLOG(severity)
+
+#define LOG_ASSERT(condition)  \
+  LOG_IF(FATAL, !(condition)) << "Assert failed: " #condition
+#define SYSLOG_ASSERT(condition) \
+  SYSLOG_IF(FATAL, !(condition)) << "Assert failed: " #condition
+
+// CHECK dies with a fatal error if condition is not true.  It is *not*
+// controlled by DCHECK_IS_ON(), so the check will be executed regardless of
+// compilation mode.  Therefore, it is safe to do things like:
+//    CHECK(fp->Write(x) == 4)
+#define CHECK(condition)  \
+      LOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN(!(condition))) \
+             << "Check failed: " #condition " "
+
+// A container for a string pointer which can be evaluated to a bool -
+// true iff the pointer is NULL.
+struct CheckOpString {
+  CheckOpString(std::string* str) : str_(str) { }
+  // No destructor: if str_ is non-NULL, we're about to LOG(FATAL),
+  // so there's no point in cleaning up str_.
+  operator bool() const {
+    return GOOGLE_PREDICT_BRANCH_NOT_TAKEN(str_ != NULL);
+  }
+  std::string* str_;
+};
+
+// Function is overloaded for integral types to allow static const
+// integrals declared in classes and not defined to be used as arguments to
+// CHECK* macros. It's not encouraged though.
+template <class T>
+inline const T&       GetReferenceableValue(const T&           t) { return t; }
+inline char           GetReferenceableValue(char               t) { return t; }
+inline unsigned char  GetReferenceableValue(unsigned char      t) { return t; }
+inline signed char    GetReferenceableValue(signed char        t) { return t; }
+inline short          GetReferenceableValue(short              t) { return t; }
+inline unsigned short GetReferenceableValue(unsigned short     t) { return t; }
+inline int            GetReferenceableValue(int                t) { return t; }
+inline unsigned int   GetReferenceableValue(unsigned int       t) { return t; }
+inline long           GetReferenceableValue(long               t) { return t; }
+inline unsigned long  GetReferenceableValue(unsigned long      t) { return t; }
+inline long long      GetReferenceableValue(long long          t) { return t; }
+inline unsigned long long GetReferenceableValue(unsigned long long t) {
+  return t;
+}
+
+// This is a dummy class to define the following operator.
+struct DummyClassToDefineOperator {};
+
+}
+
+// Define global operator<< to declare using ::operator<<.
+// This declaration will allow use to use CHECK macros for user
+// defined classes which have operator<< (e.g., stl_logging.h).
+inline std::ostream& operator<<(
+    std::ostream& out, const google::DummyClassToDefineOperator&) {
+  return out;
+}
+
+namespace google {
+
+// This formats a value for a failing CHECK_XX statement.  Ordinarily,
+// it uses the definition for operator<<, with a few special cases below.
+template <typename T>
+inline void MakeCheckOpValueString(std::ostream* os, const T& v) {
+  (*os) << v;
+}
+
+// Overrides for char types provide readable values for unprintable
+// characters.
+template <> GOOGLE_GLOG_DLL_DECL
+void MakeCheckOpValueString(std::ostream* os, const char& v);
+template <> GOOGLE_GLOG_DLL_DECL
+void MakeCheckOpValueString(std::ostream* os, const signed char& v);
+template <> GOOGLE_GLOG_DLL_DECL
+void MakeCheckOpValueString(std::ostream* os, const unsigned char& v);
+
+// This is required because nullptr is only present in c++ 11 and later.
+#if 1
+// Provide printable value for nullptr_t
+template <> GOOGLE_GLOG_DLL_DECL
+void MakeCheckOpValueString(std::ostream* os, const std::nullptr_t& v);
+#endif
+
+// Build the error message string. Specify no inlining for code size.
+template <typename T1, typename T2>
+std::string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext)
+    __attribute__((noinline));
+
+namespace base {
+namespace internal {
+
+// If "s" is less than base_logging::INFO, returns base_logging::INFO.
+// If "s" is greater than base_logging::FATAL, returns
+// base_logging::ERROR.  Otherwise, returns "s".
+LogSeverity NormalizeSeverity(LogSeverity s);
+
+}  // namespace internal
+
+// A helper class for formatting "expr (V1 vs. V2)" in a CHECK_XX
+// statement.  See MakeCheckOpString for sample usage.  Other
+// approaches were considered: use of a template method (e.g.,
+// base::BuildCheckOpString(exprtext, base::Print<T1>, &v1,
+// base::Print<T2>, &v2), however this approach has complications
+// related to volatile arguments and function-pointer arguments).
+class GOOGLE_GLOG_DLL_DECL CheckOpMessageBuilder {
+ public:
+  // Inserts "exprtext" and " (" to the stream.
+  explicit CheckOpMessageBuilder(const char *exprtext);
+  // Deletes "stream_".
+  ~CheckOpMessageBuilder();
+  // For inserting the first variable.
+  std::ostream* ForVar1() { return stream_; }
+  // For inserting the second variable (adds an intermediate " vs. ").
+  std::ostream* ForVar2();
+  // Get the result (inserts the closing ")").
+  std::string* NewString();
+
+ private:
+  std::ostringstream *stream_;
+};
+
+}  // namespace base
+
+template <typename T1, typename T2>
+std::string* MakeCheckOpString(const T1& v1, const T2& v2, const char* exprtext) {
+  base::CheckOpMessageBuilder comb(exprtext);
+  MakeCheckOpValueString(comb.ForVar1(), v1);
+  MakeCheckOpValueString(comb.ForVar2(), v2);
+  return comb.NewString();
+}
+
+// Helper functions for CHECK_OP macro.
+// The (int, int) specialization works around the issue that the compiler
+// will not instantiate the template version of the function on values of
+// unnamed enum type - see comment below.
+#define DEFINE_CHECK_OP_IMPL(name, op) \
+  template <typename T1, typename T2> \
+  inline std::string* name##Impl(const T1& v1, const T2& v2,    \
+                            const char* exprtext) { \
+    if (GOOGLE_PREDICT_TRUE(v1 op v2)) return NULL; \
+    else return MakeCheckOpString(v1, v2, exprtext); \
+  } \
+  inline std::string* name##Impl(int v1, int v2, const char* exprtext) { \
+    return name##Impl<int, int>(v1, v2, exprtext); \
+  }
+
+// We use the full name Check_EQ, Check_NE, etc. in case the file including
+// base/logging.h provides its own #defines for the simpler names EQ, NE, etc.
+// This happens if, for example, those are used as token names in a
+// yacc grammar.
+DEFINE_CHECK_OP_IMPL(Check_EQ, ==)  // Compilation error with CHECK_EQ(NULL, x)?
+DEFINE_CHECK_OP_IMPL(Check_NE, !=)  // Use CHECK(x == NULL) instead.
+DEFINE_CHECK_OP_IMPL(Check_LE, <=)
+DEFINE_CHECK_OP_IMPL(Check_LT, < )
+DEFINE_CHECK_OP_IMPL(Check_GE, >=)
+DEFINE_CHECK_OP_IMPL(Check_GT, > )
+#undef DEFINE_CHECK_OP_IMPL
+
+// Helper macro for binary operators.
+// Don't use this macro directly in your code, use CHECK_EQ et al below.
+
+#if defined(STATIC_ANALYSIS)
+// Only for static analysis tool to know that it is equivalent to assert
+#define CHECK_OP_LOG(name, op, val1, val2, log) CHECK((val1) op (val2))
+#elif DCHECK_IS_ON()
+// In debug mode, avoid constructing CheckOpStrings if possible,
+// to reduce the overhead of CHECK statments by 2x.
+// Real DCHECK-heavy tests have seen 1.5x speedups.
+
+// The meaning of "string" might be different between now and
+// when this macro gets invoked (e.g., if someone is experimenting
+// with other string implementations that get defined after this
+// file is included).  Save the current meaning now and use it
+// in the macro.
+typedef std::string _Check_string;
+#define CHECK_OP_LOG(name, op, val1, val2, log)                         \
+  while (google::_Check_string* _result =                \
+         google::Check##name##Impl(                      \
+             google::GetReferenceableValue(val1),        \
+             google::GetReferenceableValue(val2),        \
+             #val1 " " #op " " #val2))                                  \
+    log(__FILE__, __LINE__,                                             \
+        google::CheckOpString(_result)).stream()
+#else
+// In optimized mode, use CheckOpString to hint to compiler that
+// the while condition is unlikely.
+#define CHECK_OP_LOG(name, op, val1, val2, log)                         \
+  while (google::CheckOpString _result =                 \
+         google::Check##name##Impl(                      \
+             google::GetReferenceableValue(val1),        \
+             google::GetReferenceableValue(val2),        \
+             #val1 " " #op " " #val2))                                  \
+    log(__FILE__, __LINE__, _result).stream()
+#endif  // STATIC_ANALYSIS, DCHECK_IS_ON()
+
+#if GOOGLE_STRIP_LOG <= 3
+#define CHECK_OP(name, op, val1, val2) \
+  CHECK_OP_LOG(name, op, val1, val2, google::LogMessageFatal)
+#else
+#define CHECK_OP(name, op, val1, val2) \
+  CHECK_OP_LOG(name, op, val1, val2, google::NullStreamFatal)
+#endif // STRIP_LOG <= 3
+
+// Equality/Inequality checks - compare two values, and log a FATAL message
+// including the two values when the result is not as expected.  The values
+// must have operator<<(ostream, ...) defined.
+//
+// You may append to the error message like so:
+//   CHECK_NE(1, 2) << ": The world must be ending!";
+//
+// We are very careful to ensure that each argument is evaluated exactly
+// once, and that anything which is legal to pass as a function argument is
+// legal here.  In particular, the arguments may be temporary expressions
+// which will end up being destroyed at the end of the apparent statement,
+// for example:
+//   CHECK_EQ(string("abc")[1], 'b');
+//
+// WARNING: These don't compile correctly if one of the arguments is a pointer
+// and the other is NULL. To work around this, simply static_cast NULL to the
+// type of the desired pointer.
+
+#define CHECK_EQ(val1, val2) CHECK_OP(_EQ, ==, val1, val2)
+#define CHECK_NE(val1, val2) CHECK_OP(_NE, !=, val1, val2)
+#define CHECK_LE(val1, val2) CHECK_OP(_LE, <=, val1, val2)
+#define CHECK_LT(val1, val2) CHECK_OP(_LT, < , val1, val2)
+#define CHECK_GE(val1, val2) CHECK_OP(_GE, >=, val1, val2)
+#define CHECK_GT(val1, val2) CHECK_OP(_GT, > , val1, val2)
+
+// Check that the input is non NULL.  This very useful in constructor
+// initializer lists.
+
+#define CHECK_NOTNULL(val) \
+  google::CheckNotNull(__FILE__, __LINE__, "'" #val "' Must be non NULL", (val))
+
+// Helper functions for string comparisons.
+// To avoid bloat, the definitions are in logging.cc.
+#define DECLARE_CHECK_STROP_IMPL(func, expected) \
+  GOOGLE_GLOG_DLL_DECL std::string* Check##func##expected##Impl( \
+      const char* s1, const char* s2, const char* names);
+DECLARE_CHECK_STROP_IMPL(strcmp, true)
+DECLARE_CHECK_STROP_IMPL(strcmp, false)
+DECLARE_CHECK_STROP_IMPL(strcasecmp, true)
+DECLARE_CHECK_STROP_IMPL(strcasecmp, false)
+#undef DECLARE_CHECK_STROP_IMPL
+
+// Helper macro for string comparisons.
+// Don't use this macro directly in your code, use CHECK_STREQ et al below.
+#define CHECK_STROP(func, op, expected, s1, s2) \
+  while (google::CheckOpString _result = \
+         google::Check##func##expected##Impl((s1), (s2), \
+                                     #s1 " " #op " " #s2)) \
+    LOG(FATAL) << *_result.str_
+
+
+// String (char*) equality/inequality checks.
+// CASE versions are case-insensitive.
+//
+// Note that "s1" and "s2" may be temporary strings which are destroyed
+// by the compiler at the end of the current "full expression"
+// (e.g. CHECK_STREQ(Foo().c_str(), Bar().c_str())).
+
+#define CHECK_STREQ(s1, s2) CHECK_STROP(strcmp, ==, true, s1, s2)
+#define CHECK_STRNE(s1, s2) CHECK_STROP(strcmp, !=, false, s1, s2)
+#define CHECK_STRCASEEQ(s1, s2) CHECK_STROP(strcasecmp, ==, true, s1, s2)
+#define CHECK_STRCASENE(s1, s2) CHECK_STROP(strcasecmp, !=, false, s1, s2)
+
+#define CHECK_INDEX(I,A) CHECK(I < (sizeof(A)/sizeof(A[0])))
+#define CHECK_BOUND(B,A) CHECK(B <= (sizeof(A)/sizeof(A[0])))
+
+#define CHECK_DOUBLE_EQ(val1, val2)              \
+  do {                                           \
+    CHECK_LE((val1), (val2)+0.000000000000001L); \
+    CHECK_GE((val1), (val2)-0.000000000000001L); \
+  } while (0)
+
+#define CHECK_NEAR(val1, val2, margin)           \
+  do {                                           \
+    CHECK_LE((val1), (val2)+(margin));           \
+    CHECK_GE((val1), (val2)-(margin));           \
+  } while (0)
+
+// perror()..googly style!
+//
+// PLOG() and PLOG_IF() and PCHECK() behave exactly like their LOG* and
+// CHECK equivalents with the addition that they postpend a description
+// of the current state of errno to their output lines.
+
+#define PLOG(severity) GOOGLE_PLOG(severity, 0).stream()
+
+#define GOOGLE_PLOG(severity, counter)  \
+  google::ErrnoLogMessage( \
+      __FILE__, __LINE__, google::GLOG_ ## severity, counter, \
+      &google::LogMessage::SendToLog)
+
+#define PLOG_IF(severity, condition) \
+  static_cast<void>(0),              \
+  !(condition) ? (void) 0 : google::LogMessageVoidify() & PLOG(severity)
+
+// A CHECK() macro that postpends errno if the condition is false. E.g.
+//
+// if (poll(fds, nfds, timeout) == -1) { PCHECK(errno == EINTR); ... }
+#define PCHECK(condition)  \
+      PLOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN(!(condition))) \
+              << "Check failed: " #condition " "
+
+// A CHECK() macro that lets you assert the success of a function that
+// returns -1 and sets errno in case of an error. E.g.
+//
+// CHECK_ERR(mkdir(path, 0700));
+//
+// or
+//
+// int fd = open(filename, flags); CHECK_ERR(fd) << ": open " << filename;
+#define CHECK_ERR(invocation)                                          \
+PLOG_IF(FATAL, GOOGLE_PREDICT_BRANCH_NOT_TAKEN((invocation) == -1))    \
+        << #invocation
+
+// Use macro expansion to create, for each use of LOG_EVERY_N(), static
+// variables with the __LINE__ expansion as part of the variable name.
+#define LOG_EVERY_N_VARNAME(base, line) LOG_EVERY_N_VARNAME_CONCAT(base, line)
+#define LOG_EVERY_N_VARNAME_CONCAT(base, line) base ## line
+
+#define LOG_OCCURRENCES LOG_EVERY_N_VARNAME(occurrences_, __LINE__)
+#define LOG_OCCURRENCES_MOD_N LOG_EVERY_N_VARNAME(occurrences_mod_n_, __LINE__)
+
+
+#if defined(__has_feature)
+#define _GLOG_HAS_FEATURE(...) __has_feature(__VA_ARGS__)
+#else
+#define _GLOG_HAS_FEATURE(...) 0
+#endif
+
+#if _GLOG_HAS_FEATURE(thread_sanitizer) || __SANITIZE_THREAD__
+#define _GLOG_SANITIZE_THREAD 1
+#endif
+
+#if defined(_GLOG_SANITIZE_THREAD)
+#define _GLOG_IFDEF_THREAD_SANITIZER(X) X
+#else
+#define _GLOG_IFDEF_THREAD_SANITIZER(X)
+#endif
+
+#if defined(_GLOG_SANITIZE_THREAD)
+} // namespace google
+
+// We need to identify the static variables as "benign" races
+// to avoid noisy reports from TSAN.
+extern "C" void AnnotateBenignRaceSized(
+  const char *file,
+  int line,
+  const volatile void *mem,
+  long size,
+  const char *description);
+
+namespace google {
+#endif
+
+#ifdef HAVE_CXX11_ATOMIC
+#define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
+  static std::atomic<int> LOG_OCCURRENCES(0), LOG_OCCURRENCES_MOD_N(0); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES_MOD_N, sizeof(int), "")); \
+  ++LOG_OCCURRENCES; \
+  if (++LOG_OCCURRENCES_MOD_N > n) LOG_OCCURRENCES_MOD_N -= n; \
+  if (LOG_OCCURRENCES_MOD_N == 1) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
+  static std::atomic<int> LOG_OCCURRENCES(0), LOG_OCCURRENCES_MOD_N(0); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES_MOD_N, sizeof(int), "")); \
+  ++LOG_OCCURRENCES; \
+  if (condition && \
+      ((LOG_OCCURRENCES_MOD_N=(LOG_OCCURRENCES_MOD_N + 1) % n) == (1 % n))) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+                 &what_to_do).stream()
+
+#define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
+  static std::atomic<int> LOG_OCCURRENCES(0), LOG_OCCURRENCES_MOD_N(0); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES_MOD_N, sizeof(int), "")); \
+  ++LOG_OCCURRENCES; \
+  if (++LOG_OCCURRENCES_MOD_N > n) LOG_OCCURRENCES_MOD_N -= n; \
+  if (LOG_OCCURRENCES_MOD_N == 1) \
+    google::ErrnoLogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
+  static std::atomic<int> LOG_OCCURRENCES(0); \
+  _GLOG_IFDEF_THREAD_SANITIZER(AnnotateBenignRaceSized(__FILE__, __LINE__, &LOG_OCCURRENCES, sizeof(int), "")); \
+  if (LOG_OCCURRENCES <= n) \
+    ++LOG_OCCURRENCES; \
+  if (LOG_OCCURRENCES <= n) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#elif defined(OS_WINDOWS)
+
+#define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+  InterlockedIncrement(&LOG_OCCURRENCES); \
+  if (InterlockedIncrement(&LOG_OCCURRENCES_MOD_N) > n) \
+    InterlockedExchangeSubtract(&LOG_OCCURRENCES_MOD_N, n); \
+  if (LOG_OCCURRENCES_MOD_N == 1) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+  InterlockedIncrement(&LOG_OCCURRENCES); \
+  if (condition && \
+      (InterlockedIncrement(&LOG_OCCURRENCES_MOD_N) || true) && \
+      ((LOG_OCCURRENCES_MOD_N >= n && InterlockedExchangeAdd(&LOG_OCCURRENCES_MOD_N, n)) || true) && \
+      LOG_OCCURRENCES_MOD_N == (1 % n)) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+                 &what_to_do).stream()
+
+#define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+  InterlockedIncrement(&LOG_OCCURRENCES); \
+  if (InterlockedIncrement(&LOG_OCCURRENCES_MOD_N) > n) \
+    InterlockedExchangeSubtract(&LOG_OCCURRENCES_MOD_N, n); \
+  if (LOG_OCCURRENCES_MOD_N == 1) \
+    google::ErrnoLogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0; \
+  if (LOG_OCCURRENCES <= n) \
+    InterlockedIncrement(&LOG_OCCURRENCES); \
+  if (LOG_OCCURRENCES <= n) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#else
+
+#define SOME_KIND_OF_LOG_EVERY_N(severity, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+  __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+  if (__sync_add_and_fetch(&LOG_OCCURRENCES_MOD_N, 1) > n) \
+    __sync_sub_and_fetch(&LOG_OCCURRENCES_MOD_N, n); \
+  if (LOG_OCCURRENCES_MOD_N == 1) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#define SOME_KIND_OF_LOG_IF_EVERY_N(severity, condition, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+  __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+  if (condition && \
+      (__sync_add_and_fetch(&LOG_OCCURRENCES_MOD_N, 1) || true) && \
+      ((LOG_OCCURRENCES_MOD_N >= n && __sync_sub_and_fetch(&LOG_OCCURRENCES_MOD_N, n)) || true) && \
+      LOG_OCCURRENCES_MOD_N == (1 % n)) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+                 &what_to_do).stream()
+
+#define SOME_KIND_OF_PLOG_EVERY_N(severity, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0, LOG_OCCURRENCES_MOD_N = 0; \
+  __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+  if (__sync_add_and_fetch(&LOG_OCCURRENCES_MOD_N, 1) > n) \
+    __sync_sub_and_fetch(&LOG_OCCURRENCES_MOD_N, n); \
+  if (LOG_OCCURRENCES_MOD_N == 1) \
+    google::ErrnoLogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+
+#define SOME_KIND_OF_LOG_FIRST_N(severity, n, what_to_do) \
+  static int LOG_OCCURRENCES = 0; \
+  if (LOG_OCCURRENCES <= n) \
+    __sync_add_and_fetch(&LOG_OCCURRENCES, 1); \
+  if (LOG_OCCURRENCES <= n) \
+    google::LogMessage( \
+        __FILE__, __LINE__, google::GLOG_ ## severity, LOG_OCCURRENCES, \
+        &what_to_do).stream()
+#endif
+
+namespace glog_internal_namespace_ {
+template <bool>
+struct CompileAssert {
+};
+struct CrashReason;
+
+// Returns true if FailureSignalHandler is installed.
+// Needs to be exported since it's used by the signalhandler_unittest.
+GOOGLE_GLOG_DLL_DECL bool IsFailureSignalHandlerInstalled();
+}  // namespace glog_internal_namespace_
+
+#define LOG_EVERY_N(severity, n)                                        \
+  SOME_KIND_OF_LOG_EVERY_N(severity, (n), google::LogMessage::SendToLog)
+
+#define SYSLOG_EVERY_N(severity, n) \
+  SOME_KIND_OF_LOG_EVERY_N(severity, (n), google::LogMessage::SendToSyslogAndLog)
+
+#define PLOG_EVERY_N(severity, n) \
+  SOME_KIND_OF_PLOG_EVERY_N(severity, (n), google::LogMessage::SendToLog)
+
+#define LOG_FIRST_N(severity, n) \
+  SOME_KIND_OF_LOG_FIRST_N(severity, (n), google::LogMessage::SendToLog)
+
+#define LOG_IF_EVERY_N(severity, condition, n) \
+  SOME_KIND_OF_LOG_IF_EVERY_N(severity, (condition), (n), google::LogMessage::SendToLog)
+
+// We want the special COUNTER value available for LOG_EVERY_X()'ed messages
+enum PRIVATE_Counter {COUNTER};
+
+#ifdef GLOG_NO_ABBREVIATED_SEVERITIES
+// wingdi.h defines ERROR to be 0. When we call LOG(ERROR), it gets
+// substituted with 0, and it expands to COMPACT_GOOGLE_LOG_0. To allow us
+// to keep using this syntax, we define this macro to do the same thing
+// as COMPACT_GOOGLE_LOG_ERROR.
+#define COMPACT_GOOGLE_LOG_0 COMPACT_GOOGLE_LOG_ERROR
+#define SYSLOG_0 SYSLOG_ERROR
+#define LOG_TO_STRING_0 LOG_TO_STRING_ERROR
+// Needed for LOG_IS_ON(ERROR).
+const LogSeverity GLOG_0 = GLOG_ERROR;
+#else
+// Users may include windows.h after logging.h without
+// GLOG_NO_ABBREVIATED_SEVERITIES nor WIN32_LEAN_AND_MEAN.
+// For this case, we cannot detect if ERROR is defined before users
+// actually use ERROR. Let's make an undefined symbol to warn users.
+# define GLOG_ERROR_MSG ERROR_macro_is_defined_Define_GLOG_NO_ABBREVIATED_SEVERITIES_before_including_logging_h_See_the_document_for_detail
+# define COMPACT_GOOGLE_LOG_0 GLOG_ERROR_MSG
+# define SYSLOG_0 GLOG_ERROR_MSG
+# define LOG_TO_STRING_0 GLOG_ERROR_MSG
+# define GLOG_0 GLOG_ERROR_MSG
+#endif
+
+// Plus some debug-logging macros that get compiled to nothing for production
+
+#if DCHECK_IS_ON()
+
+#define DLOG(severity) LOG(severity)
+#define DVLOG(verboselevel) VLOG(verboselevel)
+#define DLOG_IF(severity, condition) LOG_IF(severity, condition)
+#define DLOG_EVERY_N(severity, n) LOG_EVERY_N(severity, n)
+#define DLOG_IF_EVERY_N(severity, condition, n) \
+  LOG_IF_EVERY_N(severity, condition, n)
+#define DLOG_ASSERT(condition) LOG_ASSERT(condition)
+
+// debug-only checking.  executed if DCHECK_IS_ON().
+#define DCHECK(condition) CHECK(condition)
+#define DCHECK_EQ(val1, val2) CHECK_EQ(val1, val2)
+#define DCHECK_NE(val1, val2) CHECK_NE(val1, val2)
+#define DCHECK_LE(val1, val2) CHECK_LE(val1, val2)
+#define DCHECK_LT(val1, val2) CHECK_LT(val1, val2)
+#define DCHECK_GE(val1, val2) CHECK_GE(val1, val2)
+#define DCHECK_GT(val1, val2) CHECK_GT(val1, val2)
+#define DCHECK_NOTNULL(val) CHECK_NOTNULL(val)
+#define DCHECK_STREQ(str1, str2) CHECK_STREQ(str1, str2)
+#define DCHECK_STRCASEEQ(str1, str2) CHECK_STRCASEEQ(str1, str2)
+#define DCHECK_STRNE(str1, str2) CHECK_STRNE(str1, str2)
+#define DCHECK_STRCASENE(str1, str2) CHECK_STRCASENE(str1, str2)
+
+#else  // !DCHECK_IS_ON()
+
+#define DLOG(severity)  \
+  static_cast<void>(0), \
+  true ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+
+#define DVLOG(verboselevel)             \
+  static_cast<void>(0),                 \
+  (true || !VLOG_IS_ON(verboselevel)) ? \
+      (void) 0 : google::LogMessageVoidify() & LOG(INFO)
+
+#define DLOG_IF(severity, condition) \
+  static_cast<void>(0),              \
+  (true || !(condition)) ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+
+#define DLOG_EVERY_N(severity, n) \
+  static_cast<void>(0),           \
+  true ? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+
+#define DLOG_IF_EVERY_N(severity, condition, n) \
+  static_cast<void>(0),                         \
+  (true || !(condition))? (void) 0 : google::LogMessageVoidify() & LOG(severity)
+
+#define DLOG_ASSERT(condition) \
+  static_cast<void>(0),        \
+  true ? (void) 0 : LOG_ASSERT(condition)
+
+// MSVC warning C4127: conditional expression is constant
+#define DCHECK(condition) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK(condition)
+
+#define DCHECK_EQ(val1, val2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_EQ(val1, val2)
+
+#define DCHECK_NE(val1, val2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_NE(val1, val2)
+
+#define DCHECK_LE(val1, val2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_LE(val1, val2)
+
+#define DCHECK_LT(val1, val2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_LT(val1, val2)
+
+#define DCHECK_GE(val1, val2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_GE(val1, val2)
+
+#define DCHECK_GT(val1, val2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_GT(val1, val2)
+
+// You may see warnings in release mode if you don't use the return
+// value of DCHECK_NOTNULL. Please just use DCHECK for such cases.
+#define DCHECK_NOTNULL(val) (val)
+
+#define DCHECK_STREQ(str1, str2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_STREQ(str1, str2)
+
+#define DCHECK_STRCASEEQ(str1, str2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_STRCASEEQ(str1, str2)
+
+#define DCHECK_STRNE(str1, str2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_STRNE(str1, str2)
+
+#define DCHECK_STRCASENE(str1, str2) \
+  GLOG_MSVC_PUSH_DISABLE_WARNING(4127) \
+  while (false) \
+    GLOG_MSVC_POP_WARNING() CHECK_STRCASENE(str1, str2)
+
+#endif  // DCHECK_IS_ON()
+
+// Log only in verbose mode.
+
+#define VLOG(verboselevel) LOG_IF(INFO, VLOG_IS_ON(verboselevel))
+
+#define VLOG_IF(verboselevel, condition) \
+  LOG_IF(INFO, (condition) && VLOG_IS_ON(verboselevel))
+
+#define VLOG_EVERY_N(verboselevel, n) \
+  LOG_IF_EVERY_N(INFO, VLOG_IS_ON(verboselevel), n)
+
+#define VLOG_IF_EVERY_N(verboselevel, condition, n) \
+  LOG_IF_EVERY_N(INFO, (condition) && VLOG_IS_ON(verboselevel), n)
+
+namespace base_logging {
+
+// LogMessage::LogStream is a std::ostream backed by this streambuf.
+// This class ignores overflow and leaves two bytes at the end of the
+// buffer to allow for a '\n' and '\0'.
+class GOOGLE_GLOG_DLL_DECL LogStreamBuf : public std::streambuf {
+ public:
+  // REQUIREMENTS: "len" must be >= 2 to account for the '\n' and '\0'.
+  LogStreamBuf(char *buf, int len) {
+    setp(buf, buf + len - 2);
+  }
+
+  // This effectively ignores overflow.
+  int_type overflow(int_type ch) {
+    return ch;
+  }
+
+  // Legacy public ostrstream method.
+  size_t pcount() const { return pptr() - pbase(); }
+  char* pbase() const { return std::streambuf::pbase(); }
+};
+
+}  // namespace base_logging
+
+//
+// This class more or less represents a particular log message.  You
+// create an instance of LogMessage and then stream stuff to it.
+// When you finish streaming to it, ~LogMessage is called and the
+// full message gets streamed to the appropriate destination.
+//
+// You shouldn't actually use LogMessage's constructor to log things,
+// though.  You should use the LOG() macro (and variants thereof)
+// above.
+class GOOGLE_GLOG_DLL_DECL LogMessage {
+public:
+  enum {
+    // Passing kNoLogPrefix for the line number disables the
+    // log-message prefix. Useful for using the LogMessage
+    // infrastructure as a printing utility. See also the --log_prefix
+    // flag for controlling the log-message prefix on an
+    // application-wide basis.
+    kNoLogPrefix = -1
+  };
+
+  // LogStream inherit from non-DLL-exported class (std::ostrstream)
+  // and VC++ produces a warning for this situation.
+  // However, MSDN says "C4275 can be ignored in Microsoft Visual C++
+  // 2005 if you are deriving from a type in the Standard C++ Library"
+  // http://msdn.microsoft.com/en-us/library/3tdb471s(VS.80).aspx
+  // Let's just ignore the warning.
+GLOG_MSVC_PUSH_DISABLE_WARNING(4275)
+  class GOOGLE_GLOG_DLL_DECL LogStream : public std::ostream {
+GLOG_MSVC_POP_WARNING()
+  public:
+    LogStream(char *buf, int len, uint64 ctr)
+        : std::ostream(NULL),
+          streambuf_(buf, len),
+          ctr_(ctr),
+          self_(this) {
+      rdbuf(&streambuf_);
+    }
+
+    uint64 ctr() const { return ctr_; }
+    void set_ctr(uint64 ctr) { ctr_ = ctr; }
+    LogStream* self() const { return self_; }
+
+    // Legacy std::streambuf methods.
+    size_t pcount() const { return streambuf_.pcount(); }
+    char* pbase() const { return streambuf_.pbase(); }
+    char* str() const { return pbase(); }
+
+  private:
+    LogStream(const LogStream&);
+    LogStream& operator=(const LogStream&);
+    base_logging::LogStreamBuf streambuf_;
+    uint64 ctr_;  // Counter hack (for the LOG_EVERY_X() macro)
+    LogStream *self_;  // Consistency check hack
+  };
+
+public:
+  // icc 8 requires this typedef to avoid an internal compiler error.
+  typedef void (LogMessage::*SendMethod)();
+
+  LogMessage(const char* file, int line, LogSeverity severity, uint64 ctr,
+             SendMethod send_method);
+
+  // Two special constructors that generate reduced amounts of code at
+  // LOG call sites for common cases.
+
+  // Used for LOG(INFO): Implied are:
+  // severity = INFO, ctr = 0, send_method = &LogMessage::SendToLog.
+  //
+  // Using this constructor instead of the more complex constructor above
+  // saves 19 bytes per call site.
+  LogMessage(const char* file, int line);
+
+  // Used for LOG(severity) where severity != INFO.  Implied
+  // are: ctr = 0, send_method = &LogMessage::SendToLog
+  //
+  // Using this constructor instead of the more complex constructor above
+  // saves 17 bytes per call site.
+  LogMessage(const char* file, int line, LogSeverity severity);
+
+  // Constructor to log this message to a specified sink (if not NULL).
+  // Implied are: ctr = 0, send_method = &LogMessage::SendToSinkAndLog if
+  // also_send_to_log is true, send_method = &LogMessage::SendToSink otherwise.
+  LogMessage(const char* file, int line, LogSeverity severity, LogSink* sink,
+             bool also_send_to_log);
+
+  // Constructor where we also give a vector<string> pointer
+  // for storing the messages (if the pointer is not NULL).
+  // Implied are: ctr = 0, send_method = &LogMessage::SaveOrSendToLog.
+  LogMessage(const char* file, int line, LogSeverity severity,
+             std::vector<std::string>* outvec);
+
+  // Constructor where we also give a string pointer for storing the
+  // message (if the pointer is not NULL).  Implied are: ctr = 0,
+  // send_method = &LogMessage::WriteToStringAndLog.
+  LogMessage(const char* file, int line, LogSeverity severity,
+             std::string* message);
+
+  // A special constructor used for check failures
+  LogMessage(const char* file, int line, const CheckOpString& result);
+
+  ~LogMessage();
+
+  // Flush a buffered message to the sink set in the constructor.  Always
+  // called by the destructor, it may also be called from elsewhere if
+  // needed.  Only the first call is actioned; any later ones are ignored.
+  void Flush();
+
+  // An arbitrary limit on the length of a single log message.  This
+  // is so that streaming can be done more efficiently.
+  static const size_t kMaxLogMessageLen;
+
+  // Theses should not be called directly outside of logging.*,
+  // only passed as SendMethod arguments to other LogMessage methods:
+  void SendToLog();  // Actually dispatch to the logs
+  void SendToSyslogAndLog();  // Actually dispatch to syslog and the logs
+
+  // Call abort() or similar to perform LOG(FATAL) crash.
+  static void __attribute__((noreturn)) Fail();
+
+  std::ostream& stream();
+
+  int preserved_errno() const;
+
+  // Must be called without the log_mutex held.  (L < log_mutex)
+  static int64 num_messages(int severity);
+
+  struct LogMessageData;
+
+private:
+  // Fully internal SendMethod cases:
+  void SendToSinkAndLog();  // Send to sink if provided and dispatch to the logs
+  void SendToSink();  // Send to sink if provided, do nothing otherwise.
+
+  // Write to string if provided and dispatch to the logs.
+  void WriteToStringAndLog();
+
+  void SaveOrSendToLog();  // Save to stringvec if provided, else to logs
+
+  void Init(const char* file, int line, LogSeverity severity,
+            void (LogMessage::*send_method)());
+
+  // Used to fill in crash information during LOG(FATAL) failures.
+  void RecordCrashReason(glog_internal_namespace_::CrashReason* reason);
+
+  // Counts of messages sent at each priority:
+  static int64 num_messages_[NUM_SEVERITIES];  // under log_mutex
+
+  // We keep the data in a separate struct so that each instance of
+  // LogMessage uses less stack space.
+  LogMessageData* allocated_;
+  LogMessageData* data_;
+
+  friend class LogDestination;
+
+  LogMessage(const LogMessage&);
+  void operator=(const LogMessage&);
+};
+
+// This class happens to be thread-hostile because all instances share
+// a single data buffer, but since it can only be created just before
+// the process dies, we don't worry so much.
+class GOOGLE_GLOG_DLL_DECL LogMessageFatal : public LogMessage {
+ public:
+  LogMessageFatal(const char* file, int line);
+  LogMessageFatal(const char* file, int line, const CheckOpString& result);
+  __attribute__((noreturn)) ~LogMessageFatal();
+};
+
+// A non-macro interface to the log facility; (useful
+// when the logging level is not a compile-time constant).
+inline void LogAtLevel(int const severity, std::string const &msg) {
+  LogMessage(__FILE__, __LINE__, severity).stream() << msg;
+}
+
+// A macro alternative of LogAtLevel. New code may want to use this
+// version since there are two advantages: 1. this version outputs the
+// file name and the line number where this macro is put like other
+// LOG macros, 2. this macro can be used as C++ stream.
+#define LOG_AT_LEVEL(severity) google::LogMessage(__FILE__, __LINE__, severity).stream()
+
+// Check if it's compiled in C++11 mode.
+//
+// GXX_EXPERIMENTAL_CXX0X is defined by gcc and clang up to at least
+// gcc-4.7 and clang-3.1 (2011-12-13).  __cplusplus was defined to 1
+// in gcc before 4.7 (Crosstool 16) and clang before 3.1, but is
+// defined according to the language version in effect thereafter.
+// Microsoft Visual Studio 14 (2015) sets __cplusplus==199711 despite
+// reasonably good C++11 support, so we set LANG_CXX for it and
+// newer versions (_MSC_VER >= 1900).
+#if (defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L || \
+     (defined(_MSC_VER) && _MSC_VER >= 1900)) && !defined(__UCLIBCXX_MAJOR__)
+// Helper for CHECK_NOTNULL().
+//
+// In C++11, all cases can be handled by a single function. Since the value
+// category of the argument is preserved (also for rvalue references),
+// member initializer lists like the one below will compile correctly:
+//
+//   Foo()
+//     : x_(CHECK_NOTNULL(MethodReturningUniquePtr())) {}
+template <typename T>
+T CheckNotNull(const char* file, int line, const char* names, T&& t) {
+ if (t == nullptr) {
+   LogMessageFatal(file, line, new std::string(names));
+ }
+ return std::forward<T>(t);
+}
+
+#else
+
+// A small helper for CHECK_NOTNULL().
+template <typename T>
+T* CheckNotNull(const char *file, int line, const char *names, T* t) {
+  if (t == NULL) {
+    LogMessageFatal(file, line, new std::string(names));
+  }
+  return t;
+}
+#endif
+
+// Allow folks to put a counter in the LOG_EVERY_X()'ed messages. This
+// only works if ostream is a LogStream. If the ostream is not a
+// LogStream you'll get an assert saying as much at runtime.
+GOOGLE_GLOG_DLL_DECL std::ostream& operator<<(std::ostream &os,
+                                              const PRIVATE_Counter&);
+
+
+// Derived class for PLOG*() above.
+class GOOGLE_GLOG_DLL_DECL ErrnoLogMessage : public LogMessage {
+ public:
+
+  ErrnoLogMessage(const char* file, int line, LogSeverity severity, uint64 ctr,
+                  void (LogMessage::*send_method)());
+
+  // Postpends ": strerror(errno) [errno]".
+  ~ErrnoLogMessage();
+
+ private:
+  ErrnoLogMessage(const ErrnoLogMessage&);
+  void operator=(const ErrnoLogMessage&);
+};
+
+
+// This class is used to explicitly ignore values in the conditional
+// logging macros.  This avoids compiler warnings like "value computed
+// is not used" and "statement has no effect".
+
+class GOOGLE_GLOG_DLL_DECL LogMessageVoidify {
+ public:
+  LogMessageVoidify() { }
+  // This has to be an operator with a precedence lower than << but
+  // higher than ?:
+  void operator&(std::ostream&) { }
+};
+
+
+// Flushes all log files that contains messages that are at least of
+// the specified severity level.  Thread-safe.
+GOOGLE_GLOG_DLL_DECL void FlushLogFiles(LogSeverity min_severity);
+
+// Flushes all log files that contains messages that are at least of
+// the specified severity level. Thread-hostile because it ignores
+// locking -- used for catastrophic failures.
+GOOGLE_GLOG_DLL_DECL void FlushLogFilesUnsafe(LogSeverity min_severity);
+
+//
+// Set the destination to which a particular severity level of log
+// messages is sent.  If base_filename is "", it means "don't log this
+// severity".  Thread-safe.
+//
+GOOGLE_GLOG_DLL_DECL void SetLogDestination(LogSeverity severity,
+                                            const char* base_filename);
+
+//
+// Set the basename of the symlink to the latest log file at a given
+// severity.  If symlink_basename is empty, do not make a symlink.  If
+// you don't call this function, the symlink basename is the
+// invocation name of the program.  Thread-safe.
+//
+GOOGLE_GLOG_DLL_DECL void SetLogSymlink(LogSeverity severity,
+                                        const char* symlink_basename);
+
+//
+// Used to send logs to some other kind of destination
+// Users should subclass LogSink and override send to do whatever they want.
+// Implementations must be thread-safe because a shared instance will
+// be called from whichever thread ran the LOG(XXX) line.
+class GOOGLE_GLOG_DLL_DECL LogSink {
+ public:
+  virtual ~LogSink();
+
+  // Sink's logging logic (message_len is such as to exclude '\n' at the end).
+  // This method can't use LOG() or CHECK() as logging system mutex(s) are held
+  // during this call.
+  virtual void send(LogSeverity severity, const char* full_filename,
+                    const char* base_filename, int line,
+                    const struct ::tm* tm_time,
+                    const char* message, size_t message_len, int32 /*usecs*/) {
+    send(severity, full_filename, base_filename, line,
+         tm_time, message, message_len);
+  }
+  // This send() signature is obsolete.
+  // New implementations should define this in terms of
+  // the above send() method.
+  virtual void send(LogSeverity severity, const char* full_filename,
+                    const char* base_filename, int line,
+                    const struct ::tm* tm_time,
+                    const char* message, size_t message_len) = 0;
+
+  // Redefine this to implement waiting for
+  // the sink's logging logic to complete.
+  // It will be called after each send() returns,
+  // but before that LogMessage exits or crashes.
+  // By default this function does nothing.
+  // Using this function one can implement complex logic for send()
+  // that itself involves logging; and do all this w/o causing deadlocks and
+  // inconsistent rearrangement of log messages.
+  // E.g. if a LogSink has thread-specific actions, the send() method
+  // can simply add the message to a queue and wake up another thread that
+  // handles real logging while itself making some LOG() calls;
+  // WaitTillSent() can be implemented to wait for that logic to complete.
+  // See our unittest for an example.
+  virtual void WaitTillSent();
+
+  // Returns the normal text output of the log message.
+  // Can be useful to implement send().
+  static std::string ToString(LogSeverity severity, const char* file, int line,
+                              const struct ::tm* tm_time,
+                              const char* message, size_t message_len,
+                              int32 usecs);
+
+  // Obsolete
+  static std::string ToString(LogSeverity severity, const char* file, int line,
+                              const struct ::tm* tm_time,
+                              const char* message, size_t message_len) {
+    return ToString(severity, file, line, tm_time, message, message_len, 0);
+  }
+};
+
+// Add or remove a LogSink as a consumer of logging data.  Thread-safe.
+GOOGLE_GLOG_DLL_DECL void AddLogSink(LogSink *destination);
+GOOGLE_GLOG_DLL_DECL void RemoveLogSink(LogSink *destination);
+
+//
+// Specify an "extension" added to the filename specified via
+// SetLogDestination.  This applies to all severity levels.  It's
+// often used to append the port we're listening on to the logfile
+// name.  Thread-safe.
+//
+GOOGLE_GLOG_DLL_DECL void SetLogFilenameExtension(
+    const char* filename_extension);
+
+//
+// Make it so that all log messages of at least a particular severity
+// are logged to stderr (in addition to logging to the usual log
+// file(s)).  Thread-safe.
+//
+GOOGLE_GLOG_DLL_DECL void SetStderrLogging(LogSeverity min_severity);
+
+//
+// Make it so that all log messages go only to stderr.  Thread-safe.
+//
+GOOGLE_GLOG_DLL_DECL void LogToStderr();
+
+//
+// Make it so that all log messages of at least a particular severity are
+// logged via email to a list of addresses (in addition to logging to the
+// usual log file(s)).  The list of addresses is just a string containing
+// the email addresses to send to (separated by spaces, say).  Thread-safe.
+//
+GOOGLE_GLOG_DLL_DECL void SetEmailLogging(LogSeverity min_severity,
+                                          const char* addresses);
+
+// A simple function that sends email. dest is a commma-separated
+// list of addressess.  Thread-safe.
+GOOGLE_GLOG_DLL_DECL bool SendEmail(const char *dest,
+                                    const char *subject, const char *body);
+
+GOOGLE_GLOG_DLL_DECL const std::vector<std::string>& GetLoggingDirectories();
+
+// For tests only:  Clear the internal [cached] list of logging directories to
+// force a refresh the next time GetLoggingDirectories is called.
+// Thread-hostile.
+void TestOnly_ClearLoggingDirectoriesList();
+
+// Returns a set of existing temporary directories, which will be a
+// subset of the directories returned by GetLogginDirectories().
+// Thread-safe.
+GOOGLE_GLOG_DLL_DECL void GetExistingTempDirectories(
+    std::vector<std::string>* list);
+
+// Print any fatal message again -- useful to call from signal handler
+// so that the last thing in the output is the fatal message.
+// Thread-hostile, but a race is unlikely.
+GOOGLE_GLOG_DLL_DECL void ReprintFatalMessage();
+
+// Truncate a log file that may be the append-only output of multiple
+// processes and hence can't simply be renamed/reopened (typically a
+// stdout/stderr).  If the file "path" is > "limit" bytes, copy the
+// last "keep" bytes to offset 0 and truncate the rest. Since we could
+// be racing with other writers, this approach has the potential to
+// lose very small amounts of data. For security, only follow symlinks
+// if the path is /proc/self/fd/*
+GOOGLE_GLOG_DLL_DECL void TruncateLogFile(const char *path,
+                                          int64 limit, int64 keep);
+
+// Truncate stdout and stderr if they are over the value specified by
+// --max_log_size; keep the final 1MB.  This function has the same
+// race condition as TruncateLogFile.
+GOOGLE_GLOG_DLL_DECL void TruncateStdoutStderr();
+
+// Return the string representation of the provided LogSeverity level.
+// Thread-safe.
+GOOGLE_GLOG_DLL_DECL const char* GetLogSeverityName(LogSeverity severity);
+
+// ---------------------------------------------------------------------
+// Implementation details that are not useful to most clients
+// ---------------------------------------------------------------------
+
+// A Logger is the interface used by logging modules to emit entries
+// to a log.  A typical implementation will dump formatted data to a
+// sequence of files.  We also provide interfaces that will forward
+// the data to another thread so that the invoker never blocks.
+// Implementations should be thread-safe since the logging system
+// will write to them from multiple threads.
+
+namespace base {
+
+class GOOGLE_GLOG_DLL_DECL Logger {
+ public:
+  virtual ~Logger();
+
+  // Writes "message[0,message_len-1]" corresponding to an event that
+  // occurred at "timestamp".  If "force_flush" is true, the log file
+  // is flushed immediately.
+  //
+  // The input message has already been formatted as deemed
+  // appropriate by the higher level logging facility.  For example,
+  // textual log messages already contain timestamps, and the
+  // file:linenumber header.
+  virtual void Write(bool force_flush,
+                     time_t timestamp,
+                     const char* message,
+                     int message_len) = 0;
+
+  // Flush any buffered messages
+  virtual void Flush() = 0;
+
+  // Get the current LOG file size.
+  // The returned value is approximate since some
+  // logged data may not have been flushed to disk yet.
+  virtual uint32 LogSize() = 0;
+};
+
+// Get the logger for the specified severity level.  The logger
+// remains the property of the logging module and should not be
+// deleted by the caller.  Thread-safe.
+extern GOOGLE_GLOG_DLL_DECL Logger* GetLogger(LogSeverity level);
+
+// Set the logger for the specified severity level.  The logger
+// becomes the property of the logging module and should not
+// be deleted by the caller.  Thread-safe.
+extern GOOGLE_GLOG_DLL_DECL void SetLogger(LogSeverity level, Logger* logger);
+
+}
+
+// glibc has traditionally implemented two incompatible versions of
+// strerror_r(). There is a poorly defined convention for picking the
+// version that we want, but it is not clear whether it even works with
+// all versions of glibc.
+// So, instead, we provide this wrapper that automatically detects the
+// version that is in use, and then implements POSIX semantics.
+// N.B. In addition to what POSIX says, we also guarantee that "buf" will
+// be set to an empty string, if this function failed. This means, in most
+// cases, you do not need to check the error code and you can directly
+// use the value of "buf". It will never have an undefined value.
+// DEPRECATED: Use StrError(int) instead.
+GOOGLE_GLOG_DLL_DECL int posix_strerror_r(int err, char *buf, size_t len);
+
+// A thread-safe replacement for strerror(). Returns a string describing the
+// given POSIX error code.
+GOOGLE_GLOG_DLL_DECL std::string StrError(int err);
+
+// A class for which we define operator<<, which does nothing.
+class GOOGLE_GLOG_DLL_DECL NullStream : public LogMessage::LogStream {
+ public:
+  // Initialize the LogStream so the messages can be written somewhere
+  // (they'll never be actually displayed). This will be needed if a
+  // NullStream& is implicitly converted to LogStream&, in which case
+  // the overloaded NullStream::operator<< will not be invoked.
+  NullStream() : LogMessage::LogStream(message_buffer_, 1, 0) { }
+  NullStream(const char* /*file*/, int /*line*/,
+             const CheckOpString& /*result*/) :
+      LogMessage::LogStream(message_buffer_, 1, 0) { }
+  NullStream &stream() { return *this; }
+ private:
+  // A very short buffer for messages (which we discard anyway). This
+  // will be needed if NullStream& converted to LogStream& (e.g. as a
+  // result of a conditional expression).
+  char message_buffer_[2];
+};
+
+// Do nothing. This operator is inline, allowing the message to be
+// compiled away. The message will not be compiled away if we do
+// something like (flag ? LOG(INFO) : LOG(ERROR)) << message; when
+// SKIP_LOG=WARNING. In those cases, NullStream will be implicitly
+// converted to LogStream and the message will be computed and then
+// quietly discarded.
+template<class T>
+inline NullStream& operator<<(NullStream &str, const T &) { return str; }
+
+// Similar to NullStream, but aborts the program (without stack
+// trace), like LogMessageFatal.
+class GOOGLE_GLOG_DLL_DECL NullStreamFatal : public NullStream {
+ public:
+  NullStreamFatal() { }
+  NullStreamFatal(const char* file, int line, const CheckOpString& result) :
+      NullStream(file, line, result) { }
+  __attribute__((noreturn)) ~NullStreamFatal() throw () { _exit(1); }
+};
+
+// Install a signal handler that will dump signal information and a stack
+// trace when the program crashes on certain signals.  We'll install the
+// signal handler for the following signals.
+//
+// SIGSEGV, SIGILL, SIGFPE, SIGABRT, SIGBUS, and SIGTERM.
+//
+// By default, the signal handler will write the failure dump to the
+// standard error.  You can customize the destination by installing your
+// own writer function by InstallFailureWriter() below.
+//
+// Note on threading:
+//
+// The function should be called before threads are created, if you want
+// to use the failure signal handler for all threads.  The stack trace
+// will be shown only for the thread that receives the signal.  In other
+// words, stack traces of other threads won't be shown.
+GOOGLE_GLOG_DLL_DECL void InstallFailureSignalHandler();
+
+// Installs a function that is used for writing the failure dump.  "data"
+// is the pointer to the beginning of a message to be written, and "size"
+// is the size of the message.  You should not expect the data is
+// terminated with '\0'.
+GOOGLE_GLOG_DLL_DECL void InstallFailureWriter(
+    void (*writer)(const char* data, int size));
+
+}
+
+#ifdef GLOG_GFLAGS_DLL_DECLARE_FLAG_WAS_DEFINED
+#undef GLOG_GFLAGS_DLL_DECLARE_FLAG_WAS_DEFINED
+#pragma pop_macro("GFLAGS_DLL_DECLARE_FLAG")
+#endif // defined(GLOG_GFLAGS_DLL_DECLARE_FLAG_WAS_DEFINED)
+
+#endif // _LOGGING_H_
diff --git a/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/raw_logging.h b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/raw_logging.h
new file mode 100644
index 000000000..b43f5a42e
--- /dev/null
+++ b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/raw_logging.h
@@ -0,0 +1,180 @@
+// Copyright (c) 2006, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Author: Maxim Lifantsev
+//
+// Thread-safe logging routines that do not allocate any memory or
+// acquire any locks, and can therefore be used by low-level memory
+// allocation and synchronization code.
+
+#ifndef BASE_RAW_LOGGING_H_
+#define BASE_RAW_LOGGING_H_
+
+#include <ctime>
+
+namespace google {
+
+#include "glog/log_severity.h"
+#include "glog/vlog_is_on.h"
+
+// Annoying stuff for windows -- makes sure clients can import these functions
+#ifndef GOOGLE_GLOG_DLL_DECL
+# if defined(_WIN32) && !defined(__CYGWIN__)
+#   define GOOGLE_GLOG_DLL_DECL  __declspec(dllimport)
+# else
+#   define GOOGLE_GLOG_DLL_DECL
+# endif
+#endif
+
+// This is similar to LOG(severity) << format... and VLOG(level) << format..,
+// but
+// * it is to be used ONLY by low-level modules that can't use normal LOG()
+// * it is desiged to be a low-level logger that does not allocate any
+//   memory and does not need any locks, hence:
+// * it logs straight and ONLY to STDERR w/o buffering
+// * it uses an explicit format and arguments list
+// * it will silently chop off really long message strings
+// Usage example:
+//   RAW_LOG(ERROR, "Failed foo with %i: %s", status, error);
+//   RAW_VLOG(3, "status is %i", status);
+// These will print an almost standard log lines like this to stderr only:
+//   E20200821 211317 file.cc:123] RAW: Failed foo with 22: bad_file
+//   I20200821 211317 file.cc:142] RAW: status is 20
+#define RAW_LOG(severity, ...) \
+  do { \
+    switch (google::GLOG_ ## severity) {  \
+      case 0: \
+        RAW_LOG_INFO(__VA_ARGS__); \
+        break; \
+      case 1: \
+        RAW_LOG_WARNING(__VA_ARGS__); \
+        break; \
+      case 2: \
+        RAW_LOG_ERROR(__VA_ARGS__); \
+        break; \
+      case 3: \
+        RAW_LOG_FATAL(__VA_ARGS__); \
+        break; \
+      default: \
+        break; \
+    } \
+  } while (0)
+
+// The following STRIP_LOG testing is performed in the header file so that it's
+// possible to completely compile out the logging code and the log messages.
+#if STRIP_LOG == 0
+#define RAW_VLOG(verboselevel, ...) \
+  do { \
+    if (VLOG_IS_ON(verboselevel)) { \
+      RAW_LOG_INFO(__VA_ARGS__); \
+    } \
+  } while (0)
+#else
+#define RAW_VLOG(verboselevel, ...) RawLogStub__(0, __VA_ARGS__)
+#endif // STRIP_LOG == 0
+
+#if STRIP_LOG == 0
+#define RAW_LOG_INFO(...) google::RawLog__(google::GLOG_INFO, \
+                                   __FILE__, __LINE__, __VA_ARGS__)
+#else
+#define RAW_LOG_INFO(...) google::RawLogStub__(0, __VA_ARGS__)
+#endif // STRIP_LOG == 0
+
+#if STRIP_LOG <= 1
+#define RAW_LOG_WARNING(...) google::RawLog__(google::GLOG_WARNING,   \
+                                      __FILE__, __LINE__, __VA_ARGS__)
+#else
+#define RAW_LOG_WARNING(...) google::RawLogStub__(0, __VA_ARGS__)
+#endif // STRIP_LOG <= 1
+
+#if STRIP_LOG <= 2
+#define RAW_LOG_ERROR(...) google::RawLog__(google::GLOG_ERROR,       \
+                                    __FILE__, __LINE__, __VA_ARGS__)
+#else
+#define RAW_LOG_ERROR(...) google::RawLogStub__(0, __VA_ARGS__)
+#endif // STRIP_LOG <= 2
+
+#if STRIP_LOG <= 3
+#define RAW_LOG_FATAL(...) google::RawLog__(google::GLOG_FATAL,       \
+                                    __FILE__, __LINE__, __VA_ARGS__)
+#else
+#define RAW_LOG_FATAL(...) \
+  do { \
+    google::RawLogStub__(0, __VA_ARGS__);        \
+    exit(1); \
+  } while (0)
+#endif // STRIP_LOG <= 3
+
+// Similar to CHECK(condition) << message,
+// but for low-level modules: we use only RAW_LOG that does not allocate memory.
+// We do not want to provide args list here to encourage this usage:
+//   if (!cond)  RAW_LOG(FATAL, "foo ...", hard_to_compute_args);
+// so that the args are not computed when not needed.
+#define RAW_CHECK(condition, message)                                   \
+  do {                                                                  \
+    if (!(condition)) {                                                 \
+      RAW_LOG(FATAL, "Check %s failed: %s", #condition, message);       \
+    }                                                                   \
+  } while (0)
+
+// Debug versions of RAW_LOG and RAW_CHECK
+#ifndef NDEBUG
+
+#define RAW_DLOG(severity, ...) RAW_LOG(severity, __VA_ARGS__)
+#define RAW_DCHECK(condition, message) RAW_CHECK(condition, message)
+
+#else  // NDEBUG
+
+#define RAW_DLOG(severity, ...)                                 \
+  while (false)                                                 \
+    RAW_LOG(severity, __VA_ARGS__)
+#define RAW_DCHECK(condition, message) \
+  while (false) \
+    RAW_CHECK(condition, message)
+
+#endif  // NDEBUG
+
+// Stub log function used to work around for unused variable warnings when
+// building with STRIP_LOG > 0.
+static inline void RawLogStub__(int /* ignored */, ...) {
+}
+
+// Helper function to implement RAW_LOG and RAW_VLOG
+// Logs format... at "severity" level, reporting it
+// as called from file:line.
+// This does not allocate memory or acquire locks.
+GOOGLE_GLOG_DLL_DECL void RawLog__(LogSeverity severity,
+                                   const char* file,
+                                   int line,
+                                   const char* format, ...)
+   __attribute__((__format__(__printf__, 4, 5)));
+
+}
+
+#endif  // BASE_RAW_LOGGING_H_
diff --git a/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/stl_logging.h b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/stl_logging.h
new file mode 100644
index 000000000..40a15aa45
--- /dev/null
+++ b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/stl_logging.h
@@ -0,0 +1,220 @@
+// Copyright (c) 2003, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Stream output operators for STL containers; to be used for logging *only*.
+// Inclusion of this file lets you do:
+//
+// list<string> x;
+// LOG(INFO) << "data: " << x;
+// vector<int> v1, v2;
+// CHECK_EQ(v1, v2);
+//
+// If you want to use this header file with hash maps or slist, you
+// need to define macros before including this file:
+//
+// - GLOG_STL_LOGGING_FOR_UNORDERED     - <unordered_map> and <unordered_set>
+// - GLOG_STL_LOGGING_FOR_TR1_UNORDERED - <tr1/unordered_(map|set)>
+// - GLOG_STL_LOGGING_FOR_EXT_HASH      - <ext/hash_(map|set)>
+// - GLOG_STL_LOGGING_FOR_EXT_SLIST     - <ext/slist>
+//
+
+#ifndef UTIL_GTL_STL_LOGGING_INL_H_
+#define UTIL_GTL_STL_LOGGING_INL_H_
+
+#if !1
+# error We do not support stl_logging for this compiler
+#endif
+
+#include <deque>
+#include <list>
+#include <map>
+#include <ostream>
+#include <set>
+#include <utility>
+#include <vector>
+
+#ifdef GLOG_STL_LOGGING_FOR_UNORDERED
+# include <unordered_map>
+# include <unordered_set>
+#endif
+
+#ifdef GLOG_STL_LOGGING_FOR_TR1_UNORDERED
+# include <tr1/unordered_map>
+# include <tr1/unordered_set>
+#endif
+
+#ifdef GLOG_STL_LOGGING_FOR_EXT_HASH
+# include <ext/hash_set>
+# include <ext/hash_map>
+#endif
+#ifdef GLOG_STL_LOGGING_FOR_EXT_SLIST
+# include <ext/slist>
+#endif
+
+// Forward declare these two, and define them after all the container streams
+// operators so that we can recurse from pair -> container -> container -> pair
+// properly.
+template<class First, class Second>
+std::ostream& operator<<(std::ostream& out, const std::pair<First, Second>& p);
+
+namespace google {
+
+template<class Iter>
+void PrintSequence(std::ostream& out, Iter begin, Iter end);
+
+}
+
+#define OUTPUT_TWO_ARG_CONTAINER(Sequence) \
+template<class T1, class T2> \
+inline std::ostream& operator<<(std::ostream& out, \
+                                const Sequence<T1, T2>& seq) { \
+  google::PrintSequence(out, seq.begin(), seq.end()); \
+  return out; \
+}
+
+OUTPUT_TWO_ARG_CONTAINER(std::vector)
+OUTPUT_TWO_ARG_CONTAINER(std::deque)
+OUTPUT_TWO_ARG_CONTAINER(std::list)
+#ifdef GLOG_STL_LOGGING_FOR_EXT_SLIST
+OUTPUT_TWO_ARG_CONTAINER(__gnu_cxx::slist)
+#endif
+
+#undef OUTPUT_TWO_ARG_CONTAINER
+
+#define OUTPUT_THREE_ARG_CONTAINER(Sequence) \
+template<class T1, class T2, class T3> \
+inline std::ostream& operator<<(std::ostream& out, \
+                                const Sequence<T1, T2, T3>& seq) { \
+  google::PrintSequence(out, seq.begin(), seq.end()); \
+  return out; \
+}
+
+OUTPUT_THREE_ARG_CONTAINER(std::set)
+OUTPUT_THREE_ARG_CONTAINER(std::multiset)
+
+#undef OUTPUT_THREE_ARG_CONTAINER
+
+#define OUTPUT_FOUR_ARG_CONTAINER(Sequence) \
+template<class T1, class T2, class T3, class T4> \
+inline std::ostream& operator<<(std::ostream& out, \
+                                const Sequence<T1, T2, T3, T4>& seq) { \
+  google::PrintSequence(out, seq.begin(), seq.end()); \
+  return out; \
+}
+
+OUTPUT_FOUR_ARG_CONTAINER(std::map)
+OUTPUT_FOUR_ARG_CONTAINER(std::multimap)
+#ifdef GLOG_STL_LOGGING_FOR_UNORDERED
+OUTPUT_FOUR_ARG_CONTAINER(std::unordered_set)
+OUTPUT_FOUR_ARG_CONTAINER(std::unordered_multiset)
+#endif
+#ifdef GLOG_STL_LOGGING_FOR_TR1_UNORDERED
+OUTPUT_FOUR_ARG_CONTAINER(std::tr1::unordered_set)
+OUTPUT_FOUR_ARG_CONTAINER(std::tr1::unordered_multiset)
+#endif
+#ifdef GLOG_STL_LOGGING_FOR_EXT_HASH
+OUTPUT_FOUR_ARG_CONTAINER(__gnu_cxx::hash_set)
+OUTPUT_FOUR_ARG_CONTAINER(__gnu_cxx::hash_multiset)
+#endif
+
+#undef OUTPUT_FOUR_ARG_CONTAINER
+
+#define OUTPUT_FIVE_ARG_CONTAINER(Sequence) \
+template<class T1, class T2, class T3, class T4, class T5> \
+inline std::ostream& operator<<(std::ostream& out, \
+                                const Sequence<T1, T2, T3, T4, T5>& seq) { \
+  google::PrintSequence(out, seq.begin(), seq.end()); \
+  return out; \
+}
+
+#ifdef GLOG_STL_LOGGING_FOR_UNORDERED
+OUTPUT_FIVE_ARG_CONTAINER(std::unordered_map)
+OUTPUT_FIVE_ARG_CONTAINER(std::unordered_multimap)
+#endif
+#ifdef GLOG_STL_LOGGING_FOR_TR1_UNORDERED
+OUTPUT_FIVE_ARG_CONTAINER(std::tr1::unordered_map)
+OUTPUT_FIVE_ARG_CONTAINER(std::tr1::unordered_multimap)
+#endif
+#ifdef GLOG_STL_LOGGING_FOR_EXT_HASH
+OUTPUT_FIVE_ARG_CONTAINER(__gnu_cxx::hash_map)
+OUTPUT_FIVE_ARG_CONTAINER(__gnu_cxx::hash_multimap)
+#endif
+
+#undef OUTPUT_FIVE_ARG_CONTAINER
+
+template<class First, class Second>
+inline std::ostream& operator<<(std::ostream& out,
+                                const std::pair<First, Second>& p) {
+  out << '(' << p.first << ", " << p.second << ')';
+  return out;
+}
+
+namespace google {
+
+template<class Iter>
+inline void PrintSequence(std::ostream& out, Iter begin, Iter end) {
+  // Output at most 100 elements -- appropriate if used for logging.
+  for (int i = 0; begin != end && i < 100; ++i, ++begin) {
+    if (i > 0) out << ' ';
+    out << *begin;
+  }
+  if (begin != end) {
+    out << " ...";
+  }
+}
+
+}
+
+// Note that this is technically undefined behavior! We are adding things into
+// the std namespace for a reason though -- we are providing new operations on
+// types which are themselves defined with this namespace. Without this, these
+// operator overloads cannot be found via ADL. If these definitions are not
+// found via ADL, they must be #included before they're used, which requires
+// this header to be included before apparently independent other headers.
+//
+// For example, base/logging.h defines various template functions to implement
+// CHECK_EQ(x, y) and stream x and y into the log in the event the check fails.
+// It does so via the function template MakeCheckOpValueString:
+//   template<class T>
+//   void MakeCheckOpValueString(strstream* ss, const T& v) {
+//     (*ss) << v;
+//   }
+// Because 'glog/logging.h' is included before 'glog/stl_logging.h',
+// subsequent CHECK_EQ(v1, v2) for vector<...> typed variable v1 and v2 can only
+// find these operator definitions via ADL.
+//
+// Even this solution has problems -- it may pull unintended operators into the
+// namespace as well, allowing them to also be found via ADL, and creating code
+// that only works with a particular order of includes. Long term, we need to
+// move all of the *definitions* into namespace std, bet we need to ensure no
+// one references them first. This lets us take that step. We cannot define them
+// in both because that would create ambiguous overloads when both are found.
+namespace std { using ::operator<<; }
+
+#endif  // UTIL_GTL_STL_LOGGING_INL_H_
diff --git a/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/vlog_is_on.h b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/vlog_is_on.h
new file mode 100644
index 000000000..0601d7a8c
--- /dev/null
+++ b/libraries/cmake/source/glog/generated/linux/ppc64le/public/glog/vlog_is_on.h
@@ -0,0 +1,122 @@
+// Copyright (c) 1999, 2007, Google Inc.
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions are
+// met:
+//
+//     * Redistributions of source code must retain the above copyright
+// notice, this list of conditions and the following disclaimer.
+//     * Redistributions in binary form must reproduce the above
+// copyright notice, this list of conditions and the following disclaimer
+// in the documentation and/or other materials provided with the
+// distribution.
+//     * Neither the name of Google Inc. nor the names of its
+// contributors may be used to endorse or promote products derived from
+// this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+// Author: Ray Sidney and many others
+//
+// Defines the VLOG_IS_ON macro that controls the variable-verbosity
+// conditional logging.
+//
+// It's used by VLOG and VLOG_IF in logging.h
+// and by RAW_VLOG in raw_logging.h to trigger the logging.
+//
+// It can also be used directly e.g. like this:
+//   if (VLOG_IS_ON(2)) {
+//     // do some logging preparation and logging
+//     // that can't be accomplished e.g. via just VLOG(2) << ...;
+//   }
+//
+// The truth value that VLOG_IS_ON(level) returns is determined by
+// the three verbosity level flags:
+//   --v=<n>  Gives the default maximal active V-logging level;
+//            0 is the default.
+//            Normally positive values are used for V-logging levels.
+//   --vmodule=<str>  Gives the per-module maximal V-logging levels to override
+//                    the value given by --v.
+//                    E.g. "my_module=2,foo*=3" would change the logging level
+//                    for all code in source files "my_module.*" and "foo*.*"
+//                    ("-inl" suffixes are also disregarded for this matching).
+//
+// SetVLOGLevel helper function is provided to do limited dynamic control over
+// V-logging by overriding the per-module settings given via --vmodule flag.
+//
+// CAVEAT: --vmodule functionality is not available in non gcc compilers.
+//
+
+#ifndef BASE_VLOG_IS_ON_H_
+#define BASE_VLOG_IS_ON_H_
+
+#include "glog/log_severity.h"
+
+// Annoying stuff for windows -- makes sure clients can import these functions
+#ifndef GOOGLE_GLOG_DLL_DECL
+# if defined(_WIN32) && !defined(__CYGWIN__)
+#   define GOOGLE_GLOG_DLL_DECL  __declspec(dllimport)
+# else
+#   define GOOGLE_GLOG_DLL_DECL
+# endif
+#endif
+
+#if defined(__GNUC__)
+// We emit an anonymous static int* variable at every VLOG_IS_ON(n) site.
+// (Normally) the first time every VLOG_IS_ON(n) site is hit,
+// we determine what variable will dynamically control logging at this site:
+// it's either FLAGS_v or an appropriate internal variable
+// matching the current source file that represents results of
+// parsing of --vmodule flag and/or SetVLOGLevel calls.
+#define VLOG_IS_ON(verboselevel)                                \
+  __extension__  \
+  ({ static google::int32* vlocal__ = NULL;           \
+     google::int32 verbose_level__ = (verboselevel);                    \
+     (vlocal__ == NULL ? google::InitVLOG3__(&vlocal__, &FLAGS_v, \
+                        __FILE__, verbose_level__) : *vlocal__ >= verbose_level__); \
+  })
+#else
+// GNU extensions not available, so we do not support --vmodule.
+// Dynamic value of FLAGS_v always controls the logging level.
+#define VLOG_IS_ON(verboselevel) (FLAGS_v >= (verboselevel))
+#endif
+
+// Set VLOG(_IS_ON) level for module_pattern to log_level.
+// This lets us dynamically control what is normally set by the --vmodule flag.
+// Returns the level that previously applied to module_pattern.
+// NOTE: To change the log level for VLOG(_IS_ON) sites
+//	 that have already executed after/during InitGoogleLogging,
+//	 one needs to supply the exact --vmodule pattern that applied to them.
+//       (If no --vmodule pattern applied to them
+//       the value of FLAGS_v will continue to control them.)
+extern GOOGLE_GLOG_DLL_DECL int SetVLOGLevel(const char* module_pattern,
+                                             int log_level);
+
+// Various declarations needed for VLOG_IS_ON above: =========================
+
+// Helper routine which determines the logging info for a particalur VLOG site.
+//   site_flag     is the address of the site-local pointer to the controlling
+//                 verbosity level
+//   site_default  is the default to use for *site_flag
+//   fname         is the current source file name
+//   verbose_level is the argument to VLOG_IS_ON
+// We will return the return value for VLOG_IS_ON
+// and if possible set *site_flag appropriately.
+extern GOOGLE_GLOG_DLL_DECL bool InitVLOG3__(
+    google::int32** site_flag,
+    google::int32* site_default,
+    const char* fname,
+    google::int32 verbose_level);
+
+#endif  // BASE_VLOG_IS_ON_H_
diff --git a/libraries/cmake/source/libarchive/CMakeLists.txt b/libraries/cmake/source/libarchive/CMakeLists.txt
index 178f0f8c3..5e99baf24 100644
--- a/libraries/cmake/source/libarchive/CMakeLists.txt
+++ b/libraries/cmake/source/libarchive/CMakeLists.txt
@@ -174,6 +174,7 @@ function(libarchiveMain)
 
   target_link_libraries(thirdparty_libarchive PRIVATE
     thirdparty_c_settings
+    thirdparty_openssl
   )
 
   # Add Zlib support
diff --git a/libraries/cmake/source/libarchive/config/linux/ppc64le/config.h b/libraries/cmake/source/libarchive/config/linux/ppc64le/config.h
new file mode 100644
index 000000000..764b5c053
--- /dev/null
+++ b/libraries/cmake/source/libarchive/config/linux/ppc64le/config.h
@@ -0,0 +1,1408 @@
+/* config.h.  Generated from build/cmake/config.h.in by cmake configure */
+#define __LIBARCHIVE_CONFIG_H_INCLUDED 1
+
+/*
+ * Ensure we have C99-style int64_t, etc, all defined.
+ */
+
+/* First, we need to know if the system has already defined them. */
+#define HAVE_INT16_T
+#define HAVE_INT32_T
+#define HAVE_INT64_T
+#define HAVE_INTMAX_T
+
+#define HAVE_UINT8_T
+#define HAVE_UINT16_T
+#define HAVE_UINT32_T
+#define HAVE_UINT64_T
+#define HAVE_UINTMAX_T
+
+/* We might have the types we want under other spellings. */
+/* #undef HAVE___INT64 */
+/* #undef HAVE_U_INT64_T */
+/* #undef HAVE_UNSIGNED___INT64 */
+
+/* The sizes of various standard integer types. */
+#define SIZEOF_SHORT 2
+#define SIZEOF_INT 4
+#define SIZEOF_LONG 8
+#define SIZEOF_LONG_LONG 8
+#define SIZEOF_UNSIGNED_SHORT 2
+#define SIZEOF_UNSIGNED 4
+#define SIZEOF_UNSIGNED_LONG 8
+#define SIZEOF_UNSIGNED_LONG_LONG 8
+
+/*
+ * If we lack int64_t, define it to the first of __int64, int, long, and long long
+ * that exists and is the right size.
+ */
+#if !defined(HAVE_INT64_T) && defined(HAVE___INT64)
+typedef __int64 int64_t;
+#define HAVE_INT64_T
+#endif
+
+#if !defined(HAVE_INT64_T) && SIZEOF_INT == 8
+typedef int int64_t;
+#define HAVE_INT64_T
+#endif
+
+#if !defined(HAVE_INT64_T) && SIZEOF_LONG == 8
+typedef long int64_t;
+#define HAVE_INT64_T
+#endif
+
+#if !defined(HAVE_INT64_T) && SIZEOF_LONG_LONG == 8
+typedef long long int64_t;
+#define HAVE_INT64_T
+#endif
+
+#if !defined(HAVE_INT64_T)
+#error No 64-bit integer type was found.
+#endif
+
+/*
+ * Similarly for int32_t
+ */
+#if !defined(HAVE_INT32_T) && SIZEOF_INT == 4
+typedef int int32_t;
+#define HAVE_INT32_T
+#endif
+
+#if !defined(HAVE_INT32_T) && SIZEOF_LONG == 4
+typedef long int32_t;
+#define HAVE_INT32_T
+#endif
+
+#if !defined(HAVE_INT32_T)
+#error No 32-bit integer type was found.
+#endif
+
+/*
+ * Similarly for int16_t
+ */
+#if !defined(HAVE_INT16_T) && SIZEOF_INT == 2
+typedef int int16_t;
+#define HAVE_INT16_T
+#endif
+
+#if !defined(HAVE_INT16_T) && SIZEOF_SHORT == 2
+typedef short int16_t;
+#define HAVE_INT16_T
+#endif
+
+#if !defined(HAVE_INT16_T)
+#error No 16-bit integer type was found.
+#endif
+
+/*
+ * Similarly for uint64_t
+ */
+#if !defined(HAVE_UINT64_T) && defined(HAVE_UNSIGNED___INT64)
+typedef unsigned __int64 uint64_t;
+#define HAVE_UINT64_T
+#endif
+
+#if !defined(HAVE_UINT64_T) && SIZEOF_UNSIGNED == 8
+typedef unsigned uint64_t;
+#define HAVE_UINT64_T
+#endif
+
+#if !defined(HAVE_UINT64_T) && SIZEOF_UNSIGNED_LONG == 8
+typedef unsigned long uint64_t;
+#define HAVE_UINT64_T
+#endif
+
+#if !defined(HAVE_UINT64_T) && SIZEOF_UNSIGNED_LONG_LONG == 8
+typedef unsigned long long uint64_t;
+#define HAVE_UINT64_T
+#endif
+
+#if !defined(HAVE_UINT64_T)
+#error No 64-bit unsigned integer type was found.
+#endif
+
+
+/*
+ * Similarly for uint32_t
+ */
+#if !defined(HAVE_UINT32_T) && SIZEOF_UNSIGNED == 4
+typedef unsigned uint32_t;
+#define HAVE_UINT32_T
+#endif
+
+#if !defined(HAVE_UINT32_T) && SIZEOF_UNSIGNED_LONG == 4
+typedef unsigned long uint32_t;
+#define HAVE_UINT32_T
+#endif
+
+#if !defined(HAVE_UINT32_T)
+#error No 32-bit unsigned integer type was found.
+#endif
+
+/*
+ * Similarly for uint16_t
+ */
+#if !defined(HAVE_UINT16_T) && SIZEOF_UNSIGNED == 2
+typedef unsigned uint16_t;
+#define HAVE_UINT16_T
+#endif
+
+#if !defined(HAVE_UINT16_T) && SIZEOF_UNSIGNED_SHORT == 2
+typedef unsigned short uint16_t;
+#define HAVE_UINT16_T
+#endif
+
+#if !defined(HAVE_UINT16_T)
+#error No 16-bit unsigned integer type was found.
+#endif
+
+/*
+ * Similarly for uint8_t
+ */
+#if !defined(HAVE_UINT8_T)
+typedef unsigned char uint8_t;
+#define HAVE_UINT8_T
+#endif
+
+#if !defined(HAVE_UINT8_T)
+#error No 8-bit unsigned integer type was found.
+#endif
+
+/* Define intmax_t and uintmax_t if they are not already defined. */
+#if !defined(HAVE_INTMAX_T)
+typedef int64_t intmax_t;
+#endif
+
+#if !defined(HAVE_UINTMAX_T)
+typedef uint64_t uintmax_t;
+#endif
+
+/* Define ZLIB_WINAPI if zlib was built on Visual Studio. */
+/* #undef ZLIB_WINAPI */
+
+/* Darwin ACL support */
+/* #undef ARCHIVE_ACL_DARWIN */
+
+/* FreeBSD ACL support */
+/* #undef ARCHIVE_ACL_FREEBSD */
+
+/* FreeBSD NFSv4 ACL support */
+/* #undef ARCHIVE_ACL_FREEBSD_NFS4 */
+
+/* Linux POSIX.1e ACL support via libacl */
+/* #undef ARCHIVE_ACL_LIBACL */
+
+/* Linux NFSv4 ACL support via librichacl */
+/* #undef ARCHIVE_ACL_LIBRICHACL */
+
+/* Solaris ACL support */
+/* #undef ARCHIVE_ACL_SUNOS */
+
+/* Solaris NFSv4 ACL support */
+/* #undef ARCHIVE_ACL_SUNOS_NFS4 */
+
+/* MD5 via ARCHIVE_CRYPTO_MD5_LIBC supported. */
+/* #undef ARCHIVE_CRYPTO_MD5_LIBC */
+
+/* MD5 via ARCHIVE_CRYPTO_MD5_LIBSYSTEM supported. */
+/* #undef ARCHIVE_CRYPTO_MD5_LIBSYSTEM */
+
+/* MD5 via ARCHIVE_CRYPTO_MD5_MBEDTLS supported. */
+/* #undef ARCHIVE_CRYPTO_MD5_MBEDTLS */
+
+/* MD5 via ARCHIVE_CRYPTO_MD5_NETTLE supported. */
+/* #undef ARCHIVE_CRYPTO_MD5_NETTLE */
+
+/* MD5 via ARCHIVE_CRYPTO_MD5_OPENSSL supported. */
+#define ARCHIVE_CRYPTO_MD5_OPENSSL 1
+
+/* MD5 via ARCHIVE_CRYPTO_MD5_WIN supported. */
+/* #undef ARCHIVE_CRYPTO_MD5_WIN */
+
+/* RMD160 via ARCHIVE_CRYPTO_RMD160_LIBC supported. */
+/* #undef ARCHIVE_CRYPTO_RMD160_LIBC */
+
+/* RMD160 via ARCHIVE_CRYPTO_RMD160_NETTLE supported. */
+/* #undef ARCHIVE_CRYPTO_RMD160_NETTLE */
+
+/* RMD160 via ARCHIVE_CRYPTO_RMD160_MBEDTLS supported. */
+/* #undef ARCHIVE_CRYPTO_RMD160_MBEDTLS */
+
+/* RMD160 via ARCHIVE_CRYPTO_RMD160_OPENSSL supported. */
+#define ARCHIVE_CRYPTO_RMD160_OPENSSL 1
+
+/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBC supported. */
+/* #undef ARCHIVE_CRYPTO_SHA1_LIBC */
+
+/* SHA1 via ARCHIVE_CRYPTO_SHA1_LIBSYSTEM supported. */
+/* #undef ARCHIVE_CRYPTO_SHA1_LIBSYSTEM */
+
+/* SHA1 via ARCHIVE_CRYPTO_SHA1_MBEDTLS supported. */
+/* #undef ARCHIVE_CRYPTO_SHA1_MBEDTLS */
+
+/* SHA1 via ARCHIVE_CRYPTO_SHA1_NETTLE supported. */
+/* #undef ARCHIVE_CRYPTO_SHA1_NETTLE */
+
+/* SHA1 via ARCHIVE_CRYPTO_SHA1_OPENSSL supported. */
+#define ARCHIVE_CRYPTO_SHA1_OPENSSL 1
+
+/* SHA1 via ARCHIVE_CRYPTO_SHA1_WIN supported. */
+/* #undef ARCHIVE_CRYPTO_SHA1_WIN */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_LIBC */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC2 supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_LIBC2 */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBC3 supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_LIBC3 */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_LIBSYSTEM supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_LIBSYSTEM */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_MBEDTLS supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_MBEDTLS */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_NETTLE supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_NETTLE */
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_OPENSSL supported. */
+#define ARCHIVE_CRYPTO_SHA256_OPENSSL 1
+
+/* SHA256 via ARCHIVE_CRYPTO_SHA256_WIN supported. */
+/* #undef ARCHIVE_CRYPTO_SHA256_WIN */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_LIBC */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC2 supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_LIBC2 */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBC3 supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_LIBC3 */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_LIBSYSTEM supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_LIBSYSTEM */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_MBEDTLS supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_MBEDTLS */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_NETTLE supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_NETTLE */
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_OPENSSL supported. */
+#define ARCHIVE_CRYPTO_SHA384_OPENSSL 1
+
+/* SHA384 via ARCHIVE_CRYPTO_SHA384_WIN supported. */
+/* #undef ARCHIVE_CRYPTO_SHA384_WIN */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_LIBC */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC2 supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_LIBC2 */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBC3 supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_LIBC3 */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_LIBSYSTEM supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_LIBSYSTEM */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_MBEDTLS supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_MBEDTLS */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_NETTLE supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_NETTLE */
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_OPENSSL supported. */
+#define ARCHIVE_CRYPTO_SHA512_OPENSSL 1
+
+/* SHA512 via ARCHIVE_CRYPTO_SHA512_WIN supported. */
+/* #undef ARCHIVE_CRYPTO_SHA512_WIN */
+
+/* AIX xattr support */
+/* #undef ARCHIVE_XATTR_AIX */
+
+/* Darwin xattr support */
+/* #undef ARCHIVE_XATTR_DARWIN */
+
+/* FreeBSD xattr support */
+/* #undef ARCHIVE_XATTR_FREEBSD */
+
+/* Linux xattr support */
+#define ARCHIVE_XATTR_LINUX 1
+
+/* Version number of bsdcpio */
+#define BSDCPIO_VERSION_STRING "3.7.9"
+
+/* Version number of bsdtar */
+#define BSDTAR_VERSION_STRING "3.7.9"
+
+/* Version number of bsdcat */
+#define BSDCAT_VERSION_STRING "3.7.9"
+
+/* Version number of bsdunzip */
+#define BSDUNZIP_VERSION_STRING "3.7.9"
+
+/* Define to 1 if you have the `acl_create_entry' function. */
+/* #undef HAVE_ACL_CREATE_ENTRY */
+
+/* Define to 1 if you have the `acl_get_fd_np' function. */
+/* #undef HAVE_ACL_GET_FD_NP */
+
+/* Define to 1 if you have the `acl_get_link' function. */
+/* #undef HAVE_ACL_GET_LINK */
+
+/* Define to 1 if you have the `acl_get_link_np' function. */
+/* #undef HAVE_ACL_GET_LINK_NP */
+
+/* Define to 1 if you have the `acl_get_perm' function. */
+/* #undef HAVE_ACL_GET_PERM */
+
+/* Define to 1 if you have the `acl_get_perm_np' function. */
+/* #undef HAVE_ACL_GET_PERM_NP */
+
+/* Define to 1 if you have the `acl_init' function. */
+/* #undef HAVE_ACL_INIT */
+
+/* Define to 1 if you have the <acl/libacl.h> header file. */
+/* #undef HAVE_ACL_LIBACL_H */
+
+/* Define to 1 if the system has the type `acl_permset_t'. */
+/* #undef HAVE_ACL_PERMSET_T */
+
+/* Define to 1 if you have the `acl_set_fd' function. */
+/* #undef HAVE_ACL_SET_FD */
+
+/* Define to 1 if you have the `acl_set_fd_np' function. */
+/* #undef HAVE_ACL_SET_FD_NP */
+
+/* Define to 1 if you have the `acl_set_file' function. */
+/* #undef HAVE_ACL_SET_FILE */
+
+/* Define to 1 if you have the `arc4random_buf' function. */
+/* #undef HAVE_ARC4RANDOM_BUF */
+
+/* Define to 1 if you have the <attr/xattr.h> header file. */
+/* #undef HAVE_ATTR_XATTR_H */
+
+/* Define to 1 if you have the <bcrypt.h> header file. */
+/* #undef HAVE_BCRYPT_H */
+
+/* Define to 1 if you have the <bsdxml.h> header file. */
+/* #undef HAVE_BSDXML_H */
+
+/* Define to 1 if you have the <bzlib.h> header file. */
+/* #undef HAVE_BZLIB_H */
+
+/* Define to 1 if you have the `chflags' function. */
+/* #undef HAVE_CHFLAGS */
+
+/* Define to 1 if you have the `chown' function. */
+#define HAVE_CHOWN 1
+
+/* Define to 1 if you have the `chroot' function. */
+#define HAVE_CHROOT 1
+
+/* Define to 1 if you have the <copyfile.h> header file. */
+/* #undef HAVE_COPYFILE_H */
+
+/* Define to 1 if you have the `ctime_r' function. */
+#define HAVE_CTIME_R 1
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#define HAVE_CTYPE_H 1
+
+/* Define to 1 if you have the `cygwin_conv_path' function. */
+/* #undef HAVE_CYGWIN_CONV_PATH */
+
+/* Define to 1 if you have the declaration of `ACE_GETACL', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_ACE_GETACL */
+
+/* Define to 1 if you have the declaration of `ACE_GETACLCNT', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_ACE_GETACLCNT */
+
+/* Define to 1 if you have the declaration of `ACE_SETACL', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_ACE_SETACL */
+
+/* Define to 1 if you have the declaration of `ACL_SYNCHRONIZE', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_ACL_SYNCHRONIZE */
+
+/* Define to 1 if you have the declaration of `ACL_TYPE_EXTENDED', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_ACL_TYPE_EXTENDED */
+
+/* Define to 1 if you have the declaration of `ACL_TYPE_NFS4', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_ACL_TYPE_NFS4 */
+
+/* Define to 1 if you have the declaration of `ACL_USER', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_ACL_USER */
+
+/* Define to 1 if you have the declaration of `INT32_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_INT32_MAX 1
+
+/* Define to 1 if you have the declaration of `INT32_MIN', and to 0 if you
+   don't. */
+#define HAVE_DECL_INT32_MIN 1
+
+/* Define to 1 if you have the declaration of `INT64_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_INT64_MAX 1
+
+/* Define to 1 if you have the declaration of `INT64_MIN', and to 0 if you
+   don't. */
+#define HAVE_DECL_INT64_MIN 1
+
+/* Define to 1 if you have the declaration of `INTMAX_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_INTMAX_MAX 1
+
+/* Define to 1 if you have the declaration of `INTMAX_MIN', and to 0 if you
+   don't. */
+#define HAVE_DECL_INTMAX_MIN 1
+
+/* Define to 1 if you have the declaration of `SETACL', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_SETACL */
+
+/* Define to 1 if you have the declaration of `SIZE_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_SIZE_MAX 1
+
+/* Define to 1 if you have the declaration of `SSIZE_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_SSIZE_MAX 1
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the declaration of `UINT32_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_UINT32_MAX 1
+
+/* Define to 1 if you have the declaration of `UINT64_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_UINT64_MAX 1
+
+/* Define to 1 if you have the declaration of `UINTMAX_MAX', and to 0 if you
+   don't. */
+#define HAVE_DECL_UINTMAX_MAX 1
+
+/* Define to 1 if you have the declaration of `XATTR_NOFOLLOW', and to 0 if
+   you don't. */
+/* #undef HAVE_DECL_XATTR_NOFOLLOW */
+
+/* Define to 1 if you have the <direct.h> header file. */
+/* #undef HAVE_DIRECT_H */
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the `dirfd' function. */
+#define HAVE_DIRFD 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+/* #undef HAVE_DOPRNT */
+
+/* Define to 1 if nl_langinfo supports D_MD_ORDER */
+/* #undef HAVE_D_MD_ORDER */
+
+/* A possible errno value for invalid file format errors */
+/* #undef HAVE_EFTYPE */
+
+/* A possible errno value for invalid file format errors */
+#define HAVE_EILSEQ 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the <expat.h> header file. */
+/* #undef HAVE_EXPAT_H */
+
+/* Define to 1 if you have the <ext2fs/ext2_fs.h> header file. */
+/* #undef HAVE_EXT2FS_EXT2_FS_H */
+
+/* Define to 1 if you have the `extattr_get_file' function. */
+/* #undef HAVE_EXTATTR_GET_FILE */
+
+/* Define to 1 if you have the `extattr_list_file' function. */
+/* #undef HAVE_EXTATTR_LIST_FILE */
+
+/* Define to 1 if you have the `extattr_set_fd' function. */
+/* #undef HAVE_EXTATTR_SET_FD */
+
+/* Define to 1 if you have the `extattr_set_file' function. */
+/* #undef HAVE_EXTATTR_SET_FILE */
+
+/* Define to 1 if EXTATTR_NAMESPACE_USER is defined in sys/extattr.h. */
+/* #undef HAVE_DECL_EXTATTR_NAMESPACE_USER */
+
+/* Define to 1 if you have the declaration of `GETACL', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_GETACL */
+
+/* Define to 1 if you have the declaration of `GETACLCNT', and to 0 if you
+   don't. */
+/* #undef HAVE_DECL_GETACLCNT */
+
+/* Define to 1 if you have the `fchdir' function. */
+#define HAVE_FCHDIR 1
+
+/* Define to 1 if you have the `fchflags' function. */
+/* #undef HAVE_FCHFLAGS */
+
+/* Define to 1 if you have the `fchmod' function. */
+#define HAVE_FCHMOD 1
+
+/* Define to 1 if you have the `fchown' function. */
+#define HAVE_FCHOWN 1
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fdopendir' function. */
+#define HAVE_FDOPENDIR 1
+
+/* Define to 1 if you have the `fgetea' function. */
+/* #undef HAVE_FGETEA */
+
+/* Define to 1 if you have the `fgetxattr' function. */
+#define HAVE_FGETXATTR 1
+
+/* Define to 1 if you have the `flistea' function. */
+/* #undef HAVE_FLISTEA */
+
+/* Define to 1 if you have the `flistxattr' function. */
+#define HAVE_FLISTXATTR 1
+
+/* Define to 1 if you have the `fnmatch' function. */
+#define HAVE_FNMATCH 1
+
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#define HAVE_FNMATCH_H 1
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `fsetea' function. */
+/* #undef HAVE_FSETEA */
+
+/* Define to 1 if you have the `fsetxattr' function. */
+#define HAVE_FSETXATTR 1
+
+/* Define to 1 if you have the `fstat' function. */
+#define HAVE_FSTAT 1
+
+/* Define to 1 if you have the `fstatat' function. */
+#define HAVE_FSTATAT 1
+
+/* Define to 1 if you have the `fstatfs' function. */
+#define HAVE_FSTATFS 1
+
+/* Define to 1 if you have the `fstatvfs' function. */
+#define HAVE_FSTATVFS 1
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define to 1 if you have the `futimens' function. */
+#define HAVE_FUTIMENS 1
+
+/* Define to 1 if you have the `futimes' function. */
+#define HAVE_FUTIMES 1
+
+/* Define to 1 if you have the `futimesat' function. */
+#define HAVE_FUTIMESAT 1
+
+/* Define to 1 if you have the `getea' function. */
+/* #undef HAVE_GETEA */
+
+/* Define to 1 if you have the `geteuid' function. */
+#define HAVE_GETEUID 1
+
+/* Define to 1 if you have the `getgrgid_r' function. */
+#define HAVE_GETGRGID_R 1
+
+/* Define to 1 if you have the `getgrnam_r' function. */
+#define HAVE_GETGRNAM_R 1
+
+/* Define to 1 if you have the `getline' function. */
+#define HAVE_GETLINE 1
+
+/* Define to 1 if you have the `getpid' function. */
+#define HAVE_GETPID 1
+
+/* Define to 1 if you have the `getpwnam_r' function. */
+#define HAVE_GETPWNAM_R 1
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+#define HAVE_GETPWUID_R 1
+
+/* Define to 1 if you have the `getvfsbyname' function. */
+/* #undef HAVE_GETVFSBYNAME */
+
+/* Define to 1 if you have the `getxattr' function. */
+#define HAVE_GETXATTR 1
+
+/* Define to 1 if you have the `gmtime_r' function. */
+#define HAVE_GMTIME_R 1
+
+/* Define to 1 if you have the <grp.h> header file. */
+#define HAVE_GRP_H 1
+
+/* Define to 1 if you have the `iconv' function. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <iconv.h> header file. */
+#define HAVE_ICONV_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <io.h> header file. */
+/* #undef HAVE_IO_H */
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define to 1 if you have the `lchflags' function. */
+/* #undef HAVE_LCHFLAGS */
+
+/* Define to 1 if you have the `lchmod' function. */
+#define HAVE_LCHMOD 1
+
+/* Define to 1 if you have the `lchown' function. */
+#define HAVE_LCHOWN 1
+
+/* Define to 1 if you have the `lgetea' function. */
+/* #undef HAVE_LGETEA */
+
+/* Define to 1 if you have the `lgetxattr' function. */
+#define HAVE_LGETXATTR 1
+
+/* Define to 1 if you have the `acl' library (-lacl). */
+/* #undef HAVE_LIBACL */
+
+/* Define to 1 if you have the `attr' library (-lattr). */
+/* #undef HAVE_LIBATTR */
+
+/* Define to 1 if you have the `bsdxml' library (-lbsdxml). */
+/* #undef HAVE_LIBBSDXML */
+
+/* Define to 1 if you have the `bz2' library (-lbz2). */
+/* #undef HAVE_LIBBZ2 */
+
+/* Define to 1 if you have the `b2' library (-lb2). */
+/* #undef HAVE_LIBB2 */
+
+/* Define to 1 if you have the <blake2.h> header file. */
+/* #undef HAVE_BLAKE2_H */
+
+/* Define to 1 if you have the `charset' library (-lcharset). */
+/* #undef HAVE_LIBCHARSET */
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+#define HAVE_LIBCRYPTO 1
+
+/* Define to 1 if you have the `expat' library (-lexpat). */
+/* #undef HAVE_LIBEXPAT */
+
+/* Define to 1 if you have the `gcc' library (-lgcc). */
+/* #undef HAVE_LIBGCC */
+
+/* Define to 1 if you have the `lz4' library (-llz4). */
+/* #undef HAVE_LIBLZ4 */
+
+/* Define to 1 if you have the `lzma' library (-llzma). */
+/* #undef HAVE_LIBLZMA */
+
+/* Define to 1 if you have the `lzo2' library (-llzo2). */
+/* #undef HAVE_LIBLZO2 */
+
+/* Define to 1 if you have the `mbedcrypto' library (-lmbedcrypto). */
+/* #undef HAVE_LIBMBEDCRYPTO */
+
+/* Define to 1 if you have the `nettle' library (-lnettle). */
+/* #undef HAVE_LIBNETTLE */
+
+/* Define to 1 if you have the `pcre' library (-lpcre). */
+/* #undef HAVE_LIBPCRE */
+
+/* Define to 1 if you have the `pcreposix' library (-lpcreposix). */
+/* #undef HAVE_LIBPCREPOSIX */
+
+/* Define to 1 if you have the `pcre2-8' library (-lpcre2-8). */
+/* #undef HAVE_LIBPCRE2 */
+
+/* Define to 1 if you have the `pcreposix' library (-lpcre2posix). */
+/* #undef HAVE_LIBPCRE2POSIX */
+
+/* Define to 1 if you have the `xml2' library (-lxml2). */
+/* #undef HAVE_LIBXML2 */
+
+/* Define to 1 if you have the <libxml/xmlreader.h> header file. */
+/* #undef HAVE_LIBXML_XMLREADER_H */
+
+/* Define to 1 if you have the <libxml/xmlwriter.h> header file. */
+/* #undef HAVE_LIBXML_XMLWRITER_H */
+
+/* Define to 1 if you have the `z' library (-lz). */
+/* #undef HAVE_LIBZ */
+
+/* Define to 1 if you have the `zstd' library (-lzstd). */
+/* #undef HAVE_LIBZSTD */
+
+/* Define to 1 if you have the ZSTD_compressStream function. */
+/* #undef HAVE_ZSTD_compressStream */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the `link' function. */
+#define HAVE_LINK 1
+
+/* Define to 1 if you have the `linkat' function. */
+#define HAVE_LINKAT 1
+
+/* Define to 1 if you have the <linux/fiemap.h> header file. */
+#define HAVE_LINUX_FIEMAP_H 1
+
+/* Define to 1 if you have the <linux/fs.h> header file. */
+#define HAVE_LINUX_FS_H 1
+
+/* Define to 1 if you have the <linux/magic.h> header file. */
+#define HAVE_LINUX_MAGIC_H 1
+
+/* Define to 1 if you have the <linux/types.h> header file. */
+#define HAVE_LINUX_TYPES_H 1
+
+/* Define to 1 if you have the `listea' function. */
+/* #undef HAVE_LISTEA */
+
+/* Define to 1 if you have the `listxattr' function. */
+#define HAVE_LISTXATTR 1
+
+/* Define to 1 if you have the `llistea' function. */
+/* #undef HAVE_LLISTEA */
+
+/* Define to 1 if you have the `llistxattr' function. */
+#define HAVE_LLISTXATTR 1
+
+/* Define to 1 if you have the <localcharset.h> header file. */
+/* #undef HAVE_LOCALCHARSET_H */
+
+/* Define to 1 if you have the `locale_charset' function. */
+/* #undef HAVE_LOCALE_CHARSET */
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the `localtime_r' function. */
+#define HAVE_LOCALTIME_R 1
+
+/* Define to 1 if the system has the type `long long int'. */
+/* #undef HAVE_LONG_LONG_INT */
+
+/* Define to 1 if you have the `lsetea' function. */
+/* #undef HAVE_LSETEA */
+
+/* Define to 1 if you have the `lsetxattr' function. */
+#define HAVE_LSETXATTR 1
+
+/* Define to 1 if you have the `lstat' function. */
+#define HAVE_LSTAT 1
+
+/* Define to 1 if `lstat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */
+
+/* Define to 1 if you have the `lutimes' function. */
+#define HAVE_LUTIMES 1
+
+/* Define to 1 if you have the <lz4hc.h> header file. */
+/* #undef HAVE_LZ4HC_H */
+
+/* Define to 1 if you have the <lz4.h> header file. */
+/* #undef HAVE_LZ4_H */
+
+/* Define to 1 if you have the <lzma.h> header file. */
+/* #undef HAVE_LZMA_H */
+
+/* Define to 1 if you have a working `lzma_stream_encoder_mt' function. */
+/* #undef HAVE_LZMA_STREAM_ENCODER_MT */
+
+/* Define to 1 if you have the <lzo/lzo1x.h> header file. */
+/* #undef HAVE_LZO_LZO1X_H */
+
+/* Define to 1 if you have the <lzo/lzoconf.h> header file. */
+/* #undef HAVE_LZO_LZOCONF_H */
+
+/* Define to 1 if you have the <mbedtls/aes.h> header file. */
+/* #undef HAVE_MBEDTLS_AES_H */
+
+/* Define to 1 if you have the <mbedtls/md.h> header file. */
+/* #undef HAVE_MBEDTLS_MD_H */
+
+/* Define to 1 if you have the <mbedtls/pkcs5.h> header file. */
+/* #undef HAVE_MBEDTLS_PKCS5_H */
+
+/* Define to 1 if you have the `mbrtowc' function. */
+#define HAVE_MBRTOWC 1
+
+/* Define to 1 if you have the <membership.h> header file. */
+/* #undef HAVE_MEMBERSHIP_H */
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkdir' function. */
+#define HAVE_MKDIR 1
+
+/* Define to 1 if you have the `mkfifo' function. */
+#define HAVE_MKFIFO 1
+
+/* Define to 1 if you have the `mknod' function. */
+#define HAVE_MKNOD 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the <nettle/aes.h> header file. */
+/* #undef HAVE_NETTLE_AES_H */
+
+/* Define to 1 if you have the <nettle/hmac.h> header file. */
+/* #undef HAVE_NETTLE_HMAC_H */
+
+/* Define to 1 if you have the <nettle/md5.h> header file. */
+/* #undef HAVE_NETTLE_MD5_H */
+
+/* Define to 1 if you have the <nettle/pbkdf2.h> header file. */
+/* #undef HAVE_NETTLE_PBKDF2_H */
+
+/* Define to 1 if you have the <nettle/ripemd160.h> header file. */
+/* #undef HAVE_NETTLE_RIPEMD160_H */
+
+/* Define to 1 if you have the <nettle/sha.h> header file. */
+/* #undef HAVE_NETTLE_SHA_H */
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#define HAVE_NL_LANGINFO 1
+
+/* Define to 1 if you have the `openat' function. */
+#define HAVE_OPENAT 1
+
+/* Define to 1 if you have the <openssl/evp.h> header file. */
+#define HAVE_OPENSSL_EVP_H 1
+
+/* Define to 1 if you have the <paths.h> header file. */
+#define HAVE_PATHS_H 1
+
+/* Define to 1 if you have the <pcreposix.h> header file. */
+/* #undef HAVE_PCREPOSIX_H */
+
+/* Define to 1 if you have the <pcre2posix.h> header file. */
+/* #undef HAVE_PCRE2POSIX_H */
+
+/* Define to 1 if you have the `pipe' function. */
+#define HAVE_PIPE 1
+
+/* Define to 1 if you have the `PKCS5_PBKDF2_HMAC_SHA1' function. */
+#define HAVE_PKCS5_PBKDF2_HMAC_SHA1 1
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the `posix_spawnp' function. */
+#define HAVE_POSIX_SPAWNP 1
+
+/* Define to 1 if you have the <process.h> header file. */
+/* #undef HAVE_PROCESS_H */
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#define HAVE_PWD_H 1
+
+/* Define to 1 if you have the `readdir_r' function. */
+#define HAVE_READDIR_R 1
+
+/* Define to 1 if you have the `readlink' function. */
+#define HAVE_READLINK 1
+
+/* Define to 1 if you have the `readlinkat' function. */
+#define HAVE_READLINKAT 1
+
+/* Define to 1 if you have the `readpassphrase' function. */
+/* #undef HAVE_READPASSPHRASE */
+
+/* Define to 1 if you have the <readpassphrase.h> header file. */
+/* #undef HAVE_READPASSPHRASE_H */
+
+/* Define to 1 if you have the <regex.h> header file. */
+#define HAVE_REGEX_H 1
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if you have the `setlocale' function. */
+#define HAVE_SETLOCALE 1
+
+/* Define to 1 if you have the `sigaction' function. */
+#define HAVE_SIGACTION 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <spawn.h> header file. */
+#define HAVE_SPAWN_H 1
+
+/* Define to 1 if you have the `statfs' function. */
+#define HAVE_STATFS 1
+
+/* Define to 1 if you have the `statvfs' function. */
+#define HAVE_STATVFS 1
+
+/* Define to 1 if `stat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+/* #undef HAVE_STAT_EMPTY_STRING_BUG */
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#define HAVE_STDARG_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strchr' function. */
+#define HAVE_STRCHR 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if you have the `strdup' function. */
+#define HAVE_STRDUP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the `strftime' function. */
+#define HAVE_STRFTIME 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strrchr' function. */
+#define HAVE_STRRCHR 1
+
+/* Define to 1 if the system has the type `struct statfs'. */
+/* #undef HAVE_STRUCT_STATFS */
+
+/* Define to 1 if `f_iosize' is a member of `struct statfs'. */
+/* #undef HAVE_STRUCT_STATFS_F_IOSIZE */
+
+/* Define to 1 if `f_namemax' is a member of `struct statfs'. */
+/* #undef HAVE_STRUCT_STATFS_F_NAMEMAX */
+
+/* Define to 1 if `f_iosize' is a member of `struct statvfs'. */
+/* #undef HAVE_STRUCT_STATVFS_F_IOSIZE */
+
+/* Define to 1 if `st_birthtime' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIME */
+
+/* Define to 1 if `st_birthtimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_BIRTHTIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_blksize' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_BLKSIZE 1
+
+/* Define to 1 if `st_flags' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_FLAGS */
+
+/* Define to 1 if `st_mtimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_MTIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_MTIME_N */
+
+/* Define to 1 if `st_mtime_usec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_MTIME_USEC */
+
+/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+
+/* Define to 1 if `st_umtime' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_UMTIME */
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_GMTOFF 1
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+/* #undef HAVE_STRUCT_TM___TM_GMTOFF */
+
+/* Define to 1 if you have `struct vfsconf'. */
+/* #undef HAVE_STRUCT_VFSCONF */
+
+/* Define to 1 if you have `struct xvfsconf'. */
+/* #undef HAVE_STRUCT_XVFSCONF */
+
+/* Define to 1 if you have the `symlink' function. */
+#define HAVE_SYMLINK 1
+
+/* Define to 1 if you have the `sysconf' function. */
+#define HAVE_SYSCONF 1
+
+/* Define to 1 if you have the <sys/acl.h> header file. */
+/* #undef HAVE_SYS_ACL_H */
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+#define HAVE_SYS_CDEFS_H 1
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/ea.h> header file. */
+/* #undef HAVE_SYS_EA_H */
+
+/* Define to 1 if you have the <sys/extattr.h> header file. */
+/* #undef HAVE_SYS_EXTATTR_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mkdev.h> header file. */
+/* #undef HAVE_SYS_MKDEV_H */
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+/* #undef HAVE_SYS_MOUNT_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#define HAVE_SYS_POLL_H 1
+
+/* Define to 1 if you have the <sys/richacl.h> header file. */
+/* #undef HAVE_SYS_RICHACL_H */
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/statfs.h> header file. */
+#define HAVE_SYS_STATFS_H 1
+
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+#define HAVE_SYS_STATVFS_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+
+/* Define to 1 if you have the <sys/sysmacros.h> header file. */
+#define HAVE_SYS_SYSMACROS_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/utime.h> header file. */
+/* #undef HAVE_SYS_UTIME_H */
+
+/* Define to 1 if you have the <sys/utsname.h> header file. */
+#define HAVE_SYS_UTSNAME_H 1
+
+/* Define to 1 if you have the <sys/vfs.h> header file. */
+#define HAVE_SYS_VFS_H 1
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#define HAVE_SYS_WAIT_H 1
+
+/* Define to 1 if you have the <sys/xattr.h> header file. */
+#define HAVE_SYS_XATTR_H 1
+
+/* Define to 1 if you have the `tcgetattr' function. */
+#define HAVE_TCGETATTR 1
+
+/* Define to 1 if you have the `tcsetattr' function. */
+#define HAVE_TCSETATTR 1
+
+/* Define to 1 if you have the `timegm' function. */
+#define HAVE_TIMEGM 1
+
+/* Define to 1 if you have the <time.h> header file. */
+#define HAVE_TIME_H 1
+
+/* Define to 1 if you have the `tzset' function. */
+#define HAVE_TZSET 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unlinkat' function. */
+#define HAVE_UNLINKAT 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define HAVE_UNSETENV 1
+
+/* Define to 1 if the system has the type `unsigned long long'. */
+/* #undef HAVE_UNSIGNED_LONG_LONG */
+
+/* Define to 1 if the system has the type `unsigned long long int'. */
+/* #undef HAVE_UNSIGNED_LONG_LONG_INT */
+
+/* Define to 1 if you have the `utime' function. */
+#define HAVE_UTIME 1
+
+/* Define to 1 if you have the `utimensat' function. */
+#define HAVE_UTIMENSAT 1
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+#define HAVE_UTIME_H 1
+
+/* Define to 1 if you have the `vfork' function. */
+#define HAVE_VFORK 1
+
+/* Define to 1 if you have the `vprintf' function. */
+#define HAVE_VPRINTF 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if the system has the type `wchar_t'. */
+#define HAVE_WCHAR_T 1
+
+/* Define to 1 if you have the `wcrtomb' function. */
+#define HAVE_WCRTOMB 1
+
+/* Define to 1 if you have the `wcscmp' function. */
+#define HAVE_WCSCMP 1
+
+/* Define to 1 if you have the `wcscpy' function. */
+#define HAVE_WCSCPY 1
+
+/* Define to 1 if you have the `wcslen' function. */
+#define HAVE_WCSLEN 1
+
+/* Define to 1 if you have the `wctomb' function. */
+#define HAVE_WCTOMB 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if you have the <wincrypt.h> header file. */
+/* #undef HAVE_WINCRYPT_H */
+
+/* Define to 1 if you have the <windows.h> header file. */
+/* #undef HAVE_WINDOWS_H */
+
+/* Define to 1 if you have the <winioctl.h> header file. */
+/* #undef HAVE_WINIOCTL_H */
+
+/* Define to 1 if you have _CrtSetReportMode in <crtdbg.h>  */
+/* #undef HAVE__CrtSetReportMode */
+
+/* Define to 1 if you have the `wmemcmp' function. */
+#define HAVE_WMEMCMP 1
+
+/* Define to 1 if you have the `wmemcpy' function. */
+#define HAVE_WMEMCPY 1
+
+/* Define to 1 if you have the `wmemmove' function. */
+#define HAVE_WMEMMOVE 1
+
+/* Define to 1 if you have a working EXT2_IOC_GETFLAGS */
+/* #undef HAVE_WORKING_EXT2_IOC_GETFLAGS */
+
+/* Define to 1 if you have a working FS_IOC_GETFLAGS */
+#define HAVE_WORKING_FS_IOC_GETFLAGS 1
+
+/* Define to 1 if you have the <zlib.h> header file. */
+/* #undef HAVE_ZLIB_H */
+
+/* Define to 1 if you have the <zstd.h> header file. */
+/* #undef HAVE_ZSTD_H */
+
+/* Define to 1 if you have the `ctime_s' function. */
+/* #undef HAVE_CTIME_S */
+
+/* Define to 1 if you have the `_fseeki64' function. */
+/* #undef HAVE__FSEEKI64 */
+
+/* Define to 1 if you have the `_get_timezone' function. */
+/* #undef HAVE__GET_TIMEZONE */
+
+/* Define to 1 if you have the `gmtime_s' function. */
+/* #undef HAVE_GMTIME_S */
+
+/* Define to 1 if you have the `localtime_s' function. */
+/* #undef HAVE_LOCALTIME_S */
+
+/* Define to 1 if you have the `_mkgmtime' function. */
+/* #undef HAVE__MKGMTIME */
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST 
+
+/* Version number of libarchive as a single integer */
+#define LIBARCHIVE_VERSION_NUMBER "3007009"
+
+/* Version number of libarchive */
+#define LIBARCHIVE_VERSION_STRING "3.7.9"
+
+/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
+   slash. */
+/* #undef LSTAT_FOLLOWS_SLASHED_SYMLINK */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
+   */
+/* #undef MAJOR_IN_MKDEV */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in
+   <sysmacros.h>. */
+#define MAJOR_IN_SYSMACROS 1
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+/* #undef NO_MINUS_C_MINUS_O */
+
+/* The size of `wchar_t', as computed by sizeof. */
+#define SIZEOF_WCHAR_T 4
+
+/* Define to 1 if strerror_r returns char *. */
+/* #undef STRERROR_R_CHAR_P */
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+/* #undef TIME_WITH_SYS_TIME */
+
+/*
+ * Some platform requires a macro to use extension functions.
+ */
+#define SAFE_TO_DEFINE_EXTENSIONS 1
+#ifdef SAFE_TO_DEFINE_EXTENSIONS
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+#endif /* SAFE_TO_DEFINE_EXTENSIONS */
+
+/* Version number of package */
+#define VERSION "3.7.9"
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to control Windows SDK version */
+#ifndef NTDDI_VERSION
+/* #undef NTDDI_VERSION */
+#endif // NTDDI_VERSION
+
+#ifndef _WIN32_WINNT
+/* #undef _WIN32_WINNT */
+#endif // _WIN32_WINNT
+
+#ifndef WINVER
+/* #undef WINVER */
+#endif // WINVER
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define to `unsigned long' if <sys/types.h> does not define. */
+/* #undef id_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `long long' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef ssize_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef intptr_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef uintptr_t */
diff --git a/libraries/cmake/source/libaudit/config/ppc64le/config.h b/libraries/cmake/source/libaudit/config/ppc64le/config.h
new file mode 100644
index 000000000..638306e90
--- /dev/null
+++ b/libraries/cmake/source/libaudit/config/ppc64le/config.h
@@ -0,0 +1,179 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Define to 1 to use the syscall interface for clock_gettime */
+/* #undef HAVE_CLOCK_SYSCALL */
+
+/* Define to 1 if you have the declaration of `AUDIT_FEATURE_VERSION', and to
+   0 if you don't. */
+#define HAVE_DECL_AUDIT_FEATURE_VERSION 1
+
+/* Define to 1 if you have the declaration of
+   `AUDIT_VERSION_BACKLOG_WAIT_TIME', and to 0 if you don't. */
+#define HAVE_DECL_AUDIT_VERSION_BACKLOG_WAIT_TIME 1
+
+/* Define to 1 if you have the declaration of `MS_DIRSYNC', and to 0 if you
+   don't. */
+#define HAVE_DECL_MS_DIRSYNC 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `epoll_ctl' function. */
+#define HAVE_EPOLL_CTL 1
+
+/* Define to 1 if you have the `eventfd' function. */
+#define HAVE_EVENTFD 1
+
+/* Define to 1 if the floor function is available */
+#define HAVE_FLOOR 1
+
+/* Define to 1 if you have the `inotify_init' function. */
+#define HAVE_INOTIFY_INIT 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `kqueue' function. */
+/* #undef HAVE_KQUEUE */
+
+/* libcap-ng support */
+/* #undef HAVE_LIBCAP_NG */
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+/* #undef HAVE_LIBRT */
+
+/* Define if tcp_wrappers support is enabled */
+/* #undef HAVE_LIBWRAP */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `nanosleep' function. */
+#define HAVE_NANOSLEEP 1
+
+/* Define to 1 if you have the `poll' function. */
+#define HAVE_POLL 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the `port_create' function. */
+/* #undef HAVE_PORT_CREATE */
+
+/* Define to 1 if you have the <port.h> header file. */
+/* #undef HAVE_PORT_H */
+
+/* Define to 1 if you have the `select' function. */
+#define HAVE_SELECT 1
+
+/* Define to 1 if you have the `signalfd' function. */
+#define HAVE_SIGNALFD 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/epoll.h> header file. */
+#define HAVE_SYS_EPOLL_H 1
+
+/* Define to 1 if you have the <sys/eventfd.h> header file. */
+#define HAVE_SYS_EVENTFD_H 1
+
+/* Define to 1 if you have the <sys/event.h> header file. */
+/* #undef HAVE_SYS_EVENT_H */
+
+/* Define to 1 if you have the <sys/inotify.h> header file. */
+#define HAVE_SYS_INOTIFY_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/signalfd.h> header file. */
+#define HAVE_SYS_SIGNALFD_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "audit"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "audit"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "audit 2.4.3"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "audit"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.4.3"
+
+/* The size of `unsigned int', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_INT 4
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if you want to use GSSAPI */
+/* #undef USE_GSSAPI */
+
+/* Define if you want to use the auditd network listener. */
+#define USE_LISTENER 1
+
+/* Version number of package */
+#define VERSION "2.4.3"
+
+/* Define if you want to enable Aarch64 processor support. */
+/* #undef WITH_AARCH64 */
+
+/* Define if you want to enable Alpha processor support. */
+/* #undef WITH_ALPHA */
+
+/* Define if you want to enable AppArmor events. */
+/* #undef WITH_APPARMOR */
+
+/* Define if you want to enable Arm eabi processor support. */
+/* #undef WITH_ARM */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
diff --git a/libraries/cmake/source/libdpkg/config/ppc64le/config.h b/libraries/cmake/source/libdpkg/config/ppc64le/config.h
new file mode 100644
index 000000000..1cc51f880
--- /dev/null
+++ b/libraries/cmake/source/libdpkg/config/ppc64le/config.h
@@ -0,0 +1,464 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Set this to the canonical dpkg architecture name. */
+#define ARCHITECTURE "ppc64el"
+
+/* Set this to the canonical dpkg CPU name. */
+#define ARCHITECTURE_CPU "ppc64el"
+
+/* Set this to the canonical dpkg system name. */
+#define ARCHITECTURE_OS "linux"
+
+/* Define to 1 if dselect is compiled. */
+#define BUILD_DSELECT 1
+
+/* Define to 1 if start-stop-daemon is compiled. */
+#define BUILD_START_STOP_DAEMON 1
+
+/* Define to 1 if update-alternatives is compiled. */
+#define BUILD_UPDATE_ALTERNATIVES 1
+
+/* default dpkg-deb build compressor */
+#define DPKG_DEB_DEFAULT_COMPRESSOR COMPRESSOR_TYPE_XZ
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#define ENABLE_NLS 1
+
+/* Define to 1 if you have the `alphasort' function. */
+#define HAVE_ALPHASORT 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define HAVE_ASPRINTF 1
+
+/* Define to 1 if the compiler supports C99. */
+#define HAVE_C99 1
+
+/* Define to 1 if the 'snprintf' family is C99 conformant */
+#define HAVE_C99_SNPRINTF 1
+
+/* Define to 1 if you have the Mac OS X function
+   CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if you have the <curses.h> header file. */
+#define HAVE_CURSES_H 1
+
+/* Define to 1 if the compiler supports C++11. */
+#define HAVE_CXX11 1
+
+/* Define to 1 if you have the <cxxabi.h> header file. */
+#define HAVE_CXXABI_H 1
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the declaration of `sys_errlist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_ERRLIST 1
+
+/* Define to 1 if you have the declaration of `sys_nerr', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_NERR 1
+
+/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_SIGLIST 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <error.h> header file. */
+#define HAVE_ERROR_H 1
+
+/* Define to 1 if you have the <err.h> header file. */
+#define HAVE_ERR_H 1
+
+/* Define to 1 if you have the `fallocate' function. */
+#define HAVE_FALLOCATE 1
+
+/* Define to 1 if the 'fsync' function works on directories */
+#define HAVE_FSYNC_DIR 1
+
+/* Define to 1 if 'F_ALLOCSP64' is declared in <fcntl.h> */
+/* #undef HAVE_F_ALLOCSP64 */
+
+/* Define to 1 if 'F_PREALLOCATE' is declared in <fcntl.h> */
+/* #undef HAVE_F_PREALLOCATE */
+
+/* Define to 1 if you have the `getdtablesize' function. */
+#define HAVE_GETDTABLESIZE 1
+
+/* Define to 1 if you have the `getexecname' function. */
+/* #undef HAVE_GETEXECNAME */
+
+/* Define to 1 if you have the `getopt' function. */
+#define HAVE_GETOPT 1
+
+/* Define to 1 if you have the `getopt_long' function. */
+#define HAVE_GETOPT_LONG 1
+
+/* Define to 1 if you have the `getprocs64' function. */
+/* #undef HAVE_GETPROCS64 */
+
+/* Define to 1 if you have the `getprogname' function. */
+/* #undef HAVE_GETPROGNAME */
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define if you have the iconv() function and it works. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `isascii' function. */
+#define HAVE_ISASCII 1
+
+/* Define to 1 if you have the <kvm.h> header file. */
+/* #undef HAVE_KVM_H */
+
+/* Define to 1 if you have the `lchown' function. */
+#define HAVE_LCHOWN 1
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#define HAVE_LIBINTL_H 1
+
+/* Define to 1 if you have the `selinux' library (-lselinux). */
+/* #undef HAVE_LIBSELINUX */
+
+/* Define to 1 if you have the <linux/fiemap.h> header file. */
+#define HAVE_LINUX_FIEMAP_H 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if you have the `lutimes' function. */
+#define HAVE_LUTIMES 1
+
+/* xz multithreaded compression support */
+/* #undef HAVE_LZMA_MT_ENCODER */
+
+/* Define to 1 if 'makedev' is declared in <sys/types.h> */
+/* #undef HAVE_MAKEDEV */
+
+/* Define to 1 if you have the <md5.h> header file. */
+/* #undef HAVE_MD5_H */
+
+/* Define to 1 if you have the `memcpy' function. */
+#define HAVE_MEMCPY 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mmap' function. */
+/* #undef HAVE_MMAP */
+
+/* Define to 1 if you have the <ncursesw/ncurses.h> header file. */
+/* #undef HAVE_NCURSESW_NCURSES_H */
+
+/* Define to 1 if you have the <ncursesw/term.h> header file. */
+/* #undef HAVE_NCURSESW_TERM_H */
+
+/* Define to 1 if you have the <ncurses.h> header file. */
+#define HAVE_NCURSES_H 1
+
+/* Define to 1 if you have the <ncurses/ncurses.h> header file. */
+/* #undef HAVE_NCURSES_NCURSES_H */
+
+/* Define to 1 if you have the <ncurses/term.h> header file. */
+/* #undef HAVE_NCURSES_TERM_H */
+
+/* Define to 1 if you have the `obstack_free' function. */
+#define HAVE_OBSTACK_FREE 1
+
+/* Define to 1 if 'offsetof' is declared in <stddef.h> */
+#define HAVE_OFFSETOF 1
+
+/* Define to 1 if 'O_NOFOLLOW' is declared in <fcntl.h> */
+#define HAVE_O_NOFOLLOW 1
+
+/* Define to 1 if you have the `posix_fadvise' function. */
+#define HAVE_POSIX_FADVISE 1
+
+/* Define to 1 if you have the `posix_fallocate' function. */
+#define HAVE_POSIX_FALLOCATE 1
+
+/* Define to 1 if you have program_invocation_short_name */
+#define HAVE_PROGRAM_INVOCATION_SHORT_NAME 1
+
+/* Define to 1 if 'P_tmpdir' is declared in <stdio.h> */
+#define HAVE_P_TMPDIR 1
+
+/* Define to 1 if you have the `scandir' function. */
+#define HAVE_SCANDIR 1
+
+/* Define to 1 if you have the `setsid' function. */
+#define HAVE_SETSID 1
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#define HAVE_STDDEF_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strchrnul' function. */
+#define HAVE_STRCHRNUL 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if you have the `strsignal' function. */
+#define HAVE_STRSIGNAL 1
+
+/* Define to 1 if you have the `strtoimax' function. */
+#define HAVE_STRTOIMAX 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/procfs.h> header file. */
+#define HAVE_SYS_PROCFS_H 1
+
+/* Define to 1 if you have the <sys/proc.h> header file. */
+/* #undef HAVE_SYS_PROC_H */
+
+/* Define to 1 if you have the <sys/pstat.h> header file. */
+/* #undef HAVE_SYS_PSTAT_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/syscall.h> header file. */
+#define HAVE_SYS_SYSCALL_H 1
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+/* #undef HAVE_SYS_SYSCTL_H */
+
+/* Define to 1 if you have the <sys/sysmacros.h> header file. */
+#define HAVE_SYS_SYSMACROS_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/user.h> header file. */
+#define HAVE_SYS_USER_H 1
+
+/* Define to 1 if you have the <term.h> header file. */
+#define HAVE_TERM_H 1
+
+/* Define to 1 if 'TIOCNOTTY' is declared in <sys/ioctl.h> */
+#define HAVE_TIOCNOTTY 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define HAVE_UNSETENV 1
+
+/* Define to 1 if you have the `uselocale' function. */
+#define HAVE_USELOCALE 1
+
+/* Define to 1 if the 'va_copy' macro exists */
+#define HAVE_VA_COPY 1
+
+/* Define to 1 if 'WCOREDUMP' is declared in <sys/wait.h> */
+#define HAVE_WCOREDUMP 1
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define to 1 if you have the `__cxa_pure_virtual' function. */
+/* #undef HAVE___CXA_PURE_VIRTUAL */
+
+/* Define to 1 if you have __progname */
+#define HAVE___PROGNAME 1
+
+/* Acknowledge the volatility of the API. */
+#define LIBDPKG_VOLATILE_API 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "dpkg"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "debian-dpkg@lists.debian.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "dpkg"
+
+/* Define the project release information, version and architecture */
+#define PACKAGE_RELEASE PACKAGE_VERSION " (" ARCHITECTURE ")"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "dpkg 1.21.7"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "dpkg"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "https://wiki.debian.org/Teams/Dpkg"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.21.7"
+
+/* GNU patch program */
+#define PATCH "patch"
+
+/* The size of `unsigned int', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_INT 4
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* GNU tar program */
+#define TAR "gtar"
+
+/* Use disk size pre-allocation */
+/* #undef USE_DISK_PREALLOCATE */
+
+/* Define to the zlib implementation to use */
+#define USE_LIBZ_IMPL USE_LIBZ_IMPL_ZLIB
+
+/* Define none as 0 for the zlib implementation enum */
+#define USE_LIBZ_IMPL_NONE 0
+
+/* Define zlib as 1 for the zlib implementation enum */
+#define USE_LIBZ_IMPL_ZLIB 1
+
+/* Define zlib-ng as 2 for the zlib implementation enum */
+#define USE_LIBZ_IMPL_ZLIB_NG 2
+
+/* Use unreliable mmap support */
+/* #undef USE_MMAP */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "1.21.7"
+
+/* Define to yes to use zlib-ng gzFile IO support */
+/* #undef WITH_GZFILEOP */
+
+/* Define to 1 to use bz2 library rather than console tool */
+/* #undef WITH_LIBBZ2 */
+
+/* Define to 1 to use lzma library rather than console tool */
+/* #undef WITH_LIBLZMA */
+
+/* Define to 1 to compile in SELinux support */
+/* #undef WITH_LIBSELINUX */
+
+/* Define to 1 to use z library rather than console tool */
+#define WITH_LIBZ 1
+
+/* Define to 1 to use z-ng library rather than console tool */
+/* #undef WITH_LIBZ_NG */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to 'int' if <malloc.h> does not define. */
+/* #undef ptrdiff_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+/* #undef volatile */
diff --git a/libraries/cmake/source/libgcrypt/CMakeLists.txt b/libraries/cmake/source/libgcrypt/CMakeLists.txt
index d4d84c604..283a5f87a 100644
--- a/libraries/cmake/source/libgcrypt/CMakeLists.txt
+++ b/libraries/cmake/source/libgcrypt/CMakeLists.txt
@@ -124,6 +124,13 @@ function(libgcryptMain)
     target_sources(thirdparty_libgcrypt PRIVATE
       "${library_root}/src/hwf-arm.c"
       "${library_root}/cipher/rijndael-armv8-ce.c")
+  elseif(TARGET_PROCESSOR STREQUAL "ppc64le")
+    target_sources(thirdparty_libgcrypt PRIVATE
+      "${generated_root}/mpi/mpih-add1.c"
+      "${generated_root}/mpi/mpih-sub1.c"
+      "${generated_root}/mpi/mpih-mul1.c"
+      "${generated_root}/mpi/mpih-mul2.c"
+      "${generated_root}/mpi/mpih-mul3.c")
   else()
     target_sources(thirdparty_libgcrypt PRIVATE
       "${library_root}/cipher/crc-intel-pclmul.c"
diff --git a/libraries/cmake/source/libgcrypt/config/ppc64le/config.h b/libraries/cmake/source/libgcrypt/config/ppc64le/config.h
new file mode 100644
index 000000000..f543d682f
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/config/ppc64le/config.h
@@ -0,0 +1,674 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+
+#ifndef _GCRYPT_CONFIG_H_INCLUDED
+#define _GCRYPT_CONFIG_H_INCLUDED
+
+/* Enable gpg-error's strerror macro for W32CE.  */
+#define GPG_ERR_ENABLE_ERRNO_MACROS 1
+
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* GIT commit id revision used to build this package */
+#define BUILD_REVISION "80fd8615"
+
+/* The time this package was configured for a build */
+#define BUILD_TIMESTAMP "<none>"
+
+/* configure did not test for endianness */
+/* #undef DISABLED_ENDIAN_CHECK */
+
+/* Define if you don't want the default EGD socket name. For details see
+   cipher/rndegd.c */
+#define EGD_SOCKET_NAME ""
+
+/* Enable support for Intel AES-NI instructions. */
+/* #undef ENABLE_AESNI_SUPPORT */
+
+/* Enable support for ARMv8 Crypto Extension instructions. */
+/* #undef ENABLE_ARM_CRYPTO_SUPPORT */
+
+/* Enable support for Intel AVX2 instructions. */
+/* #undef ENABLE_AVX2_SUPPORT */
+
+/* Enable support for Intel AVX instructions. */
+/* #undef ENABLE_AVX_SUPPORT */
+
+/* Enable support for Intel DRNG (RDRAND instruction). */
+/* #undef ENABLE_DRNG_SUPPORT */
+
+/* Define to support an HMAC based integrity check */
+/* #undef ENABLE_HMAC_BINARY_CHECK */
+
+/* Enable support for the jitter entropy collector. */
+/* #undef ENABLE_JENT_SUPPORT */
+
+/* Enable support for ARM NEON instructions. */
+/* #undef ENABLE_NEON_SUPPORT */
+
+/* Enable support for the PadLock engine. */
+/* #undef ENABLE_PADLOCK_SUPPORT */
+
+/* Enable support for Intel PCLMUL instructions. */
+/* #undef ENABLE_PCLMUL_SUPPORT */
+
+/* Enable support for Intel SSE4.1 instructions. */
+/* #undef ENABLE_SSE41_SUPPORT */
+
+/* Define to use the GNU C visibility attribute. */
+#define GCRY_USE_VISIBILITY 1
+
+/* The default error source for libgcrypt. */
+#define GPG_ERR_SOURCE_DEFAULT GPG_ERR_SOURCE_GCRYPT
+
+/* Defined if ARM architecture is v6 or newer */
+/* #undef HAVE_ARM_ARCH_V6 */
+
+/* Define to 1 if you have the `atexit' function. */
+#define HAVE_ATEXIT 1
+
+/* Defined if the mlock() call does not work */
+/* #undef HAVE_BROKEN_MLOCK */
+
+/* Defined if compiler has '__builtin_bswap32' intrinsic */
+#define HAVE_BUILTIN_BSWAP32 1
+
+/* Defined if compiler has '__builtin_bswap64' intrinsic */
+#define HAVE_BUILTIN_BSWAP64 1
+
+/* Defined if compiler has '__builtin_ctz' intrinsic */
+#define HAVE_BUILTIN_CTZ 1
+
+/* Defined if a `byte' is typedef'd */
+/* #undef HAVE_BYTE_TYPEDEF */
+
+/* Define to 1 if you have the `clock' function. */
+#define HAVE_CLOCK 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Defined if underlying assembler is compatible with ARMv8/Aarch64 assembly
+   implementations */
+/* #undef HAVE_COMPATIBLE_GCC_AARCH64_PLATFORM_AS */
+
+/* Defined if underlying assembler is compatible with amd64 assembly
+   implementations */
+/* #undef HAVE_COMPATIBLE_GCC_AMD64_PLATFORM_AS */
+
+/* Defined if underlying assembler is compatible with ARM assembly
+   implementations */
+/* #undef HAVE_COMPATIBLE_GCC_ARM_PLATFORM_AS */
+
+/* Defined if underlying assembler is compatible with WIN64 assembly
+   implementations */
+/* #undef HAVE_COMPATIBLE_GCC_WIN64_PLATFORM_AS */
+
+/* Defined for Alpha platforms */
+/* #undef HAVE_CPU_ARCH_ALPHA */
+
+/* Defined for ARM AArch64 platforms */
+/* #undef HAVE_CPU_ARCH_ARM */
+
+/* Defined for M68k platforms */
+/* #undef HAVE_CPU_ARCH_M68K */
+
+/* Defined for MIPS platforms */
+/* #undef HAVE_CPU_ARCH_MIPS */
+
+/* Defined for PPC platforms */
+#define HAVE_CPU_ARCH_PPC 1
+
+/* Defined for SPARC platforms */
+/* #undef HAVE_CPU_ARCH_SPARC */
+
+/* Defined for the x86 platforms */
+/* #undef HAVE_CPU_ARCH_X86 */
+
+/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_SIGLIST 0
+
+/* defined if the system supports a random device */
+#define HAVE_DEV_RANDOM 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+/* #undef HAVE_DOPRNT */
+
+/* defined if we run on some of the PCDOS like systems (DOS, Windoze. OS/2)
+   with special properties like no file modes */
+/* #undef HAVE_DOSISH_SYSTEM */
+
+/* defined if we must run on a stupid file system */
+/* #undef HAVE_DRIVE_LETTERS */
+
+/* Define to 1 if you have the `fcntl' function. */
+#define HAVE_FCNTL 1
+
+/* Define to 1 if you have the `flockfile' function. */
+#define HAVE_FLOCKFILE 1
+
+/* Define to 1 if you have the `ftruncate' function. */
+#define HAVE_FTRUNCATE 1
+
+/* Define if inline asm memory barrier is supported */
+#define HAVE_GCC_ASM_VOLATILE_MEMORY 1
+
+/* Defined if a GCC style "__attribute__ ((aligned (n))" is supported */
+#define HAVE_GCC_ATTRIBUTE_ALIGNED 1
+
+/* Defined if a GCC style "__attribute__ ((may_alias))" is supported */
+#define HAVE_GCC_ATTRIBUTE_MAY_ALIAS 1
+
+/* Defined if compiler supports "__attribute__ ((ms_abi))" function attribute
+   */
+/* #undef HAVE_GCC_ATTRIBUTE_MS_ABI */
+
+/* Defined if a GCC style "__attribute__ ((packed))" is supported */
+#define HAVE_GCC_ATTRIBUTE_PACKED 1
+
+/* Defined if compiler supports "__attribute__ ((sysv_abi))" function
+   attribute */
+/* #undef HAVE_GCC_ATTRIBUTE_SYSV_ABI */
+
+/* Defined if default calling convention is 'ms_abi' */
+/* #undef HAVE_GCC_DEFAULT_ABI_IS_MS_ABI */
+
+/* Defined if default calling convention is 'sysv_abi' */
+/* #undef HAVE_GCC_DEFAULT_ABI_IS_SYSV_ABI */
+
+/* Defined if inline assembler supports AArch32 Crypto Extension instructions
+   */
+/* #undef HAVE_GCC_INLINE_ASM_AARCH32_CRYPTO */
+
+/* Defined if inline assembler supports AArch64 Crypto Extension instructions
+   */
+/* #undef HAVE_GCC_INLINE_ASM_AARCH64_CRYPTO */
+
+/* Defined if inline assembler supports AArch64 NEON instructions */
+/* #undef HAVE_GCC_INLINE_ASM_AARCH64_NEON */
+
+/* Defined if inline assembler supports AVX instructions */
+/* #undef HAVE_GCC_INLINE_ASM_AVX */
+
+/* Defined if inline assembler supports AVX2 instructions */
+/* #undef HAVE_GCC_INLINE_ASM_AVX2 */
+
+/* Defined if inline assembler supports BMI2 instructions */
+/* #undef HAVE_GCC_INLINE_ASM_BMI2 */
+
+/* Defined if inline assembler supports NEON instructions */
+/* #undef HAVE_GCC_INLINE_ASM_NEON */
+
+/* Defined if inline assembler supports PCLMUL instructions */
+/* #undef HAVE_GCC_INLINE_ASM_PCLMUL */
+
+/* Defined if inline assembler supports SSE4.1 instructions */
+/* #undef HAVE_GCC_INLINE_ASM_SSE41 */
+
+/* Defined if inline assembler supports SSSE3 instructions */
+/* #undef HAVE_GCC_INLINE_ASM_SSSE3 */
+
+/* Define to 1 if you have the `gethrtime' function. */
+/* #undef HAVE_GETHRTIME */
+
+/* Define to 1 if you have the `getpagesize' function. */
+#define HAVE_GETPAGESIZE 1
+
+/* Define to 1 if you have the `getpid' function. */
+#define HAVE_GETPID 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Defined if underlying assembler is compatible with Intel syntax assembly
+   implementations */
+/* #undef HAVE_INTEL_SYNTAX_PLATFORM_AS */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `rt' library (-lrt). */
+/* #undef HAVE_LIBRT */
+
+/* Define to 1 if you have the `memmove' function. */
+#define HAVE_MEMMOVE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Defined if the system supports an mlock() call */
+#define HAVE_MLOCK 1
+
+/* Define to 1 if you have the `mmap' function. */
+#define HAVE_MMAP 1
+
+/* Defined if the GNU Pth is available */
+/* #undef HAVE_PTH */
+
+/* Define if we have pthread. */
+#define HAVE_PTHREAD 1 
+
+/* Define to 1 if you have the `raise' function. */
+#define HAVE_RAISE 1
+
+/* Define to 1 if you have the `rand' function. */
+#define HAVE_RAND 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#define HAVE_STRCASECMP 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the `stricmp' function. */
+/* #undef HAVE_STRICMP */
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strtoul' function. */
+#define HAVE_STRTOUL 1
+
+/* Define to 1 if you have the `syscall' function. */
+#define HAVE_SYSCALL 1
+
+/* Define to 1 if you have the `sysconf' function. */
+#define HAVE_SYSCONF 1
+
+/* Define to 1 if you have the `syslog' function. */
+#define HAVE_SYSLOG 1
+
+/* Define to 1 if you have the <sys/capability.h> header file. */
+/* #undef HAVE_SYS_CAPABILITY_H */
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+/* #undef HAVE_SYS_MMAN_H */
+
+/* Define to 1 if you have the <sys/msg.h> header file. */
+#define HAVE_SYS_MSG_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Defined if a `u16' is typedef'd */
+/* #undef HAVE_U16_TYPEDEF */
+
+/* Defined if a `u32' is typedef'd */
+/* #undef HAVE_U32_TYPEDEF */
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Defined if a `ulong' is typedef'd */
+#define HAVE_ULONG_TYPEDEF 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Defined if a `ushort' is typedef'd */
+#define HAVE_USHORT_TYPEDEF 1
+
+/* Defined if variable length arrays are supported */
+#define HAVE_VLA 1
+
+/* Define to 1 if you have the `vprintf' function. */
+#define HAVE_VPRINTF 1
+
+/* Defined if we run on WindowsCE */
+/* #undef HAVE_W32CE_SYSTEM */
+
+/* Defined if we run on a W32 API based system */
+/* #undef HAVE_W32_SYSTEM */
+
+/* Define to 1 if you have the `wait4' function. */
+#define HAVE_WAIT4 1
+
+/* Define to 1 if you have the `waitpid' function. */
+#define HAVE_WAITPID 1
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+/* #undef HAVE_WINSOCK2_H */
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+/* #undef HAVE_WS2TCPIP_H */
+
+/* Defined if this is not a regular release */
+/* #undef IS_DEVELOPMENT_VERSION */
+
+/* List of available cipher algorithms */
+#define LIBGCRYPT_CIPHERS "arcfour:blowfish:cast5:des:aes:twofish:serpent:rfc2268:seed:camellia:idea:salsa20:gost28147:chacha20"
+
+/* List of available digest algorithms */
+#define LIBGCRYPT_DIGESTS "crc:gostr3411-94::md4:md5:rmd160:sha1:sha256:sha512:sha3:tiger:whirlpool:stribog:blake2"
+
+/* List of available KDF algorithms */
+#define LIBGCRYPT_KDFS "s2k:pkdf2:scrypt"
+
+/* List of available public key cipher algorithms */
+#define LIBGCRYPT_PUBKEY_CIPHERS "dsa:elgamal:rsa:ecc"
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Define to use the (obsolete) malloc guarding feature */
+/* #undef M_GUARD */
+
+/* defined to the name of the strong random device */
+#define NAME_OF_DEV_RANDOM "/dev/random"
+
+/* defined to the name of the weaker random device */
+#define NAME_OF_DEV_URANDOM "/dev/urandom"
+
+/* Name of this package */
+#define PACKAGE "libgcrypt"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "http://bugs.gnupg.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libgcrypt"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libgcrypt 1.8.1"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libgcrypt"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.8.1"
+
+/* A human readable text with the name of the OS */
+#define PRINTABLE_OS_NAME "GNU/Linux"
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#define RETSIGTYPE void
+
+/* The size of `uint64_t', as computed by sizeof. */
+#define SIZEOF_UINT64_T 8
+
+/* The size of `unsigned int', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_INT 4
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 8
+
+/* The size of `unsigned long long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG_LONG 8
+
+/* The size of `unsigned short', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_SHORT 2
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Defined if this module should be included */
+#define USE_AES 1
+
+/* Defined if this module should be included */
+#define USE_ARCFOUR 1
+
+/* Defined if this module should be included */
+#define USE_BLAKE2 1
+
+/* Defined if this module should be included */
+#define USE_BLOWFISH 1
+
+/* Defined if this module should be included */
+#define USE_CAMELLIA 1
+
+/* define if capabilities should be used */
+/* #undef USE_CAPABILITIES */
+
+/* Defined if this module should be included */
+#define USE_CAST5 1
+
+/* Defined if this module should be included */
+#define USE_CHACHA20 1
+
+/* Defined if this module should be included */
+#define USE_CRC 1
+
+/* Defined if this module should be included */
+#define USE_DES 1
+
+/* Defined if this module should be included */
+#define USE_DSA 1
+
+/* Defined if this module should be included */
+#define USE_ECC 1
+
+/* Defined if this module should be included */
+#define USE_ELGAMAL 1
+
+/* Defined if the GNU Portable Thread Library should be used */
+/* #undef USE_GNU_PTH */
+
+/* Defined if this module should be included */
+#define USE_GOST28147 1
+
+/* Defined if this module should be included */
+#define USE_GOST_R_3411_12 1
+
+/* Defined if this module should be included */
+#define USE_GOST_R_3411_94 1
+
+/* Defined if this module should be included */
+#define USE_IDEA 1
+
+/* Defined if this module should be included */
+/* #undef USE_MD2 */
+
+/* Defined if this module should be included */
+#define USE_MD4 1
+
+/* Defined if this module should be included */
+#define USE_MD5 1
+
+/* set this to limit filenames to the 8.3 format */
+/* #undef USE_ONLY_8DOT3 */
+
+/* Define to support the experimental random daemon */
+/* #undef USE_RANDOM_DAEMON */
+
+/* Defined if this module should be included */
+#define USE_RFC2268 1
+
+/* Defined if this module should be included */
+#define USE_RMD160 1
+
+/* Defined if the EGD based RNG should be used. */
+/* #undef USE_RNDEGD */
+
+/* Defined if the /dev/random RNG should be used. */
+#define USE_RNDLINUX 1
+
+/* Defined if the default Unix RNG should be used. */
+/* #undef USE_RNDUNIX */
+
+/* Defined if the Windows specific RNG should be used. */
+/* #undef USE_RNDW32 */
+
+/* Defined if the WindowsCE specific RNG should be used. */
+/* #undef USE_RNDW32CE */
+
+/* Defined if this module should be included */
+#define USE_RSA 1
+
+/* Defined if this module should be included */
+#define USE_SALSA20 1
+
+/* Defined if this module should be included */
+#define USE_SCRYPT 1
+
+/* Defined if this module should be included */
+#define USE_SEED 1
+
+/* Defined if this module should be included */
+#define USE_SERPENT 1
+
+/* Defined if this module should be included */
+#define USE_SHA1 1
+
+/* Defined if this module should be included */
+#define USE_SHA256 1
+
+/* Defined if this module should be included */
+#define USE_SHA3 1
+
+/* Defined if this module should be included */
+#define USE_SHA512 1
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Defined if this module should be included */
+#define USE_TIGER 1
+
+/* Defined if this module should be included */
+#define USE_TWOFISH 1
+
+/* Defined if this module should be included */
+#define USE_WHIRLPOOL 1
+
+/* Version of this package */
+#define VERSION "1.8.1"
+
+/* Defined if compiled symbols have a leading underscore */
+/* #undef WITH_SYMBOL_UNDERSCORE */
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Expose all libc features (__DARWIN_C_FULL). */
+/* #undef _DARWIN_C_SOURCE */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* To allow the use of Libgcrypt in multithreaded programs we have to use
+    special features from the library. */
+#ifndef _REENTRANT
+# define _REENTRANT 1
+#endif
+
+
+/* Define to supported assembler block keyword, if plain 'asm' was not
+   supported */
+/* #undef asm */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+/* #undef inline */
+#endif
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* type to use in place of socklen_t if not defined */
+/* #undef socklen_t */
+
+/* Define to the type of an unsigned integer type wide enough to hold a
+   pointer, if such a type exists, and if the system does not define it. */
+/* #undef uintptr_t */
+
+
+#define _GCRYPT_IN_LIBGCRYPT 1
+
+/* If the configure check for endianness has been disabled, get it from
+   OS macros.  This is intended for making fat binary builds on OS X.  */
+#ifdef DISABLED_ENDIAN_CHECK
+# if defined(__BIG_ENDIAN__)
+#  define WORDS_BIGENDIAN 1
+# elif defined(__LITTLE_ENDIAN__)
+/* #  undef WORDS_BIGENDIAN */
+# else
+#  error "No endianness found"
+# endif
+#endif /*DISABLED_ENDIAN_CHECK*/
+
+/* We basically use the original Camellia source.  Make sure the symbols
+   properly prefixed.  */
+#define CAMELLIA_EXT_SYM_PREFIX _gcry_
+
+#endif /*_GCRYPT_CONFIG_H_INCLUDED*/
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/cipher/gost-sb.h b/libraries/cmake/source/libgcrypt/generated/ppc64le/cipher/gost-sb.h
new file mode 100644
index 000000000..5a87fc95a
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/cipher/gost-sb.h
@@ -0,0 +1,2127 @@
+static const u32 sbox_test_3411[4*256] =
+  {
+    /* 0 */
+    0x00072000, 0x00075000, 0x00074800, 0x00071000,
+    0x00076800, 0x00074000, 0x00070000, 0x00077000,
+    0x00073000, 0x00075800, 0x00070800, 0x00076000,
+    0x00073800, 0x00077800, 0x00072800, 0x00071800,
+    0x0005a000, 0x0005d000, 0x0005c800, 0x00059000,
+    0x0005e800, 0x0005c000, 0x00058000, 0x0005f000,
+    0x0005b000, 0x0005d800, 0x00058800, 0x0005e000,
+    0x0005b800, 0x0005f800, 0x0005a800, 0x00059800,
+    0x00022000, 0x00025000, 0x00024800, 0x00021000,
+    0x00026800, 0x00024000, 0x00020000, 0x00027000,
+    0x00023000, 0x00025800, 0x00020800, 0x00026000,
+    0x00023800, 0x00027800, 0x00022800, 0x00021800,
+    0x00062000, 0x00065000, 0x00064800, 0x00061000,
+    0x00066800, 0x00064000, 0x00060000, 0x00067000,
+    0x00063000, 0x00065800, 0x00060800, 0x00066000,
+    0x00063800, 0x00067800, 0x00062800, 0x00061800,
+    0x00032000, 0x00035000, 0x00034800, 0x00031000,
+    0x00036800, 0x00034000, 0x00030000, 0x00037000,
+    0x00033000, 0x00035800, 0x00030800, 0x00036000,
+    0x00033800, 0x00037800, 0x00032800, 0x00031800,
+    0x0006a000, 0x0006d000, 0x0006c800, 0x00069000,
+    0x0006e800, 0x0006c000, 0x00068000, 0x0006f000,
+    0x0006b000, 0x0006d800, 0x00068800, 0x0006e000,
+    0x0006b800, 0x0006f800, 0x0006a800, 0x00069800,
+    0x0007a000, 0x0007d000, 0x0007c800, 0x00079000,
+    0x0007e800, 0x0007c000, 0x00078000, 0x0007f000,
+    0x0007b000, 0x0007d800, 0x00078800, 0x0007e000,
+    0x0007b800, 0x0007f800, 0x0007a800, 0x00079800,
+    0x00052000, 0x00055000, 0x00054800, 0x00051000,
+    0x00056800, 0x00054000, 0x00050000, 0x00057000,
+    0x00053000, 0x00055800, 0x00050800, 0x00056000,
+    0x00053800, 0x00057800, 0x00052800, 0x00051800,
+    0x00012000, 0x00015000, 0x00014800, 0x00011000,
+    0x00016800, 0x00014000, 0x00010000, 0x00017000,
+    0x00013000, 0x00015800, 0x00010800, 0x00016000,
+    0x00013800, 0x00017800, 0x00012800, 0x00011800,
+    0x0001a000, 0x0001d000, 0x0001c800, 0x00019000,
+    0x0001e800, 0x0001c000, 0x00018000, 0x0001f000,
+    0x0001b000, 0x0001d800, 0x00018800, 0x0001e000,
+    0x0001b800, 0x0001f800, 0x0001a800, 0x00019800,
+    0x00042000, 0x00045000, 0x00044800, 0x00041000,
+    0x00046800, 0x00044000, 0x00040000, 0x00047000,
+    0x00043000, 0x00045800, 0x00040800, 0x00046000,
+    0x00043800, 0x00047800, 0x00042800, 0x00041800,
+    0x0000a000, 0x0000d000, 0x0000c800, 0x00009000,
+    0x0000e800, 0x0000c000, 0x00008000, 0x0000f000,
+    0x0000b000, 0x0000d800, 0x00008800, 0x0000e000,
+    0x0000b800, 0x0000f800, 0x0000a800, 0x00009800,
+    0x00002000, 0x00005000, 0x00004800, 0x00001000,
+    0x00006800, 0x00004000, 0x00000000, 0x00007000,
+    0x00003000, 0x00005800, 0x00000800, 0x00006000,
+    0x00003800, 0x00007800, 0x00002800, 0x00001800,
+    0x0003a000, 0x0003d000, 0x0003c800, 0x00039000,
+    0x0003e800, 0x0003c000, 0x00038000, 0x0003f000,
+    0x0003b000, 0x0003d800, 0x00038800, 0x0003e000,
+    0x0003b800, 0x0003f800, 0x0003a800, 0x00039800,
+    0x0002a000, 0x0002d000, 0x0002c800, 0x00029000,
+    0x0002e800, 0x0002c000, 0x00028000, 0x0002f000,
+    0x0002b000, 0x0002d800, 0x00028800, 0x0002e000,
+    0x0002b800, 0x0002f800, 0x0002a800, 0x00029800,
+    0x0004a000, 0x0004d000, 0x0004c800, 0x00049000,
+    0x0004e800, 0x0004c000, 0x00048000, 0x0004f000,
+    0x0004b000, 0x0004d800, 0x00048800, 0x0004e000,
+    0x0004b800, 0x0004f800, 0x0004a800, 0x00049800,
+    /* 1 */
+    0x03a80000, 0x03c00000, 0x03880000, 0x03e80000,
+    0x03d00000, 0x03980000, 0x03a00000, 0x03900000,
+    0x03f00000, 0x03f80000, 0x03e00000, 0x03b80000,
+    0x03b00000, 0x03800000, 0x03c80000, 0x03d80000,
+    0x06a80000, 0x06c00000, 0x06880000, 0x06e80000,
+    0x06d00000, 0x06980000, 0x06a00000, 0x06900000,
+    0x06f00000, 0x06f80000, 0x06e00000, 0x06b80000,
+    0x06b00000, 0x06800000, 0x06c80000, 0x06d80000,
+    0x05280000, 0x05400000, 0x05080000, 0x05680000,
+    0x05500000, 0x05180000, 0x05200000, 0x05100000,
+    0x05700000, 0x05780000, 0x05600000, 0x05380000,
+    0x05300000, 0x05000000, 0x05480000, 0x05580000,
+    0x00a80000, 0x00c00000, 0x00880000, 0x00e80000,
+    0x00d00000, 0x00980000, 0x00a00000, 0x00900000,
+    0x00f00000, 0x00f80000, 0x00e00000, 0x00b80000,
+    0x00b00000, 0x00800000, 0x00c80000, 0x00d80000,
+    0x00280000, 0x00400000, 0x00080000, 0x00680000,
+    0x00500000, 0x00180000, 0x00200000, 0x00100000,
+    0x00700000, 0x00780000, 0x00600000, 0x00380000,
+    0x00300000, 0x00000000, 0x00480000, 0x00580000,
+    0x04280000, 0x04400000, 0x04080000, 0x04680000,
+    0x04500000, 0x04180000, 0x04200000, 0x04100000,
+    0x04700000, 0x04780000, 0x04600000, 0x04380000,
+    0x04300000, 0x04000000, 0x04480000, 0x04580000,
+    0x04a80000, 0x04c00000, 0x04880000, 0x04e80000,
+    0x04d00000, 0x04980000, 0x04a00000, 0x04900000,
+    0x04f00000, 0x04f80000, 0x04e00000, 0x04b80000,
+    0x04b00000, 0x04800000, 0x04c80000, 0x04d80000,
+    0x07a80000, 0x07c00000, 0x07880000, 0x07e80000,
+    0x07d00000, 0x07980000, 0x07a00000, 0x07900000,
+    0x07f00000, 0x07f80000, 0x07e00000, 0x07b80000,
+    0x07b00000, 0x07800000, 0x07c80000, 0x07d80000,
+    0x07280000, 0x07400000, 0x07080000, 0x07680000,
+    0x07500000, 0x07180000, 0x07200000, 0x07100000,
+    0x07700000, 0x07780000, 0x07600000, 0x07380000,
+    0x07300000, 0x07000000, 0x07480000, 0x07580000,
+    0x02280000, 0x02400000, 0x02080000, 0x02680000,
+    0x02500000, 0x02180000, 0x02200000, 0x02100000,
+    0x02700000, 0x02780000, 0x02600000, 0x02380000,
+    0x02300000, 0x02000000, 0x02480000, 0x02580000,
+    0x03280000, 0x03400000, 0x03080000, 0x03680000,
+    0x03500000, 0x03180000, 0x03200000, 0x03100000,
+    0x03700000, 0x03780000, 0x03600000, 0x03380000,
+    0x03300000, 0x03000000, 0x03480000, 0x03580000,
+    0x06280000, 0x06400000, 0x06080000, 0x06680000,
+    0x06500000, 0x06180000, 0x06200000, 0x06100000,
+    0x06700000, 0x06780000, 0x06600000, 0x06380000,
+    0x06300000, 0x06000000, 0x06480000, 0x06580000,
+    0x05a80000, 0x05c00000, 0x05880000, 0x05e80000,
+    0x05d00000, 0x05980000, 0x05a00000, 0x05900000,
+    0x05f00000, 0x05f80000, 0x05e00000, 0x05b80000,
+    0x05b00000, 0x05800000, 0x05c80000, 0x05d80000,
+    0x01280000, 0x01400000, 0x01080000, 0x01680000,
+    0x01500000, 0x01180000, 0x01200000, 0x01100000,
+    0x01700000, 0x01780000, 0x01600000, 0x01380000,
+    0x01300000, 0x01000000, 0x01480000, 0x01580000,
+    0x02a80000, 0x02c00000, 0x02880000, 0x02e80000,
+    0x02d00000, 0x02980000, 0x02a00000, 0x02900000,
+    0x02f00000, 0x02f80000, 0x02e00000, 0x02b80000,
+    0x02b00000, 0x02800000, 0x02c80000, 0x02d80000,
+    0x01a80000, 0x01c00000, 0x01880000, 0x01e80000,
+    0x01d00000, 0x01980000, 0x01a00000, 0x01900000,
+    0x01f00000, 0x01f80000, 0x01e00000, 0x01b80000,
+    0x01b00000, 0x01800000, 0x01c80000, 0x01d80000,
+    /* 2 */
+    0x30000002, 0x60000002, 0x38000002, 0x08000002,
+    0x28000002, 0x78000002, 0x68000002, 0x40000002,
+    0x20000002, 0x50000002, 0x48000002, 0x70000002,
+    0x00000002, 0x18000002, 0x58000002, 0x10000002,
+    0xb0000005, 0xe0000005, 0xb8000005, 0x88000005,
+    0xa8000005, 0xf8000005, 0xe8000005, 0xc0000005,
+    0xa0000005, 0xd0000005, 0xc8000005, 0xf0000005,
+    0x80000005, 0x98000005, 0xd8000005, 0x90000005,
+    0x30000005, 0x60000005, 0x38000005, 0x08000005,
+    0x28000005, 0x78000005, 0x68000005, 0x40000005,
+    0x20000005, 0x50000005, 0x48000005, 0x70000005,
+    0x00000005, 0x18000005, 0x58000005, 0x10000005,
+    0x30000000, 0x60000000, 0x38000000, 0x08000000,
+    0x28000000, 0x78000000, 0x68000000, 0x40000000,
+    0x20000000, 0x50000000, 0x48000000, 0x70000000,
+    0x00000000, 0x18000000, 0x58000000, 0x10000000,
+    0xb0000003, 0xe0000003, 0xb8000003, 0x88000003,
+    0xa8000003, 0xf8000003, 0xe8000003, 0xc0000003,
+    0xa0000003, 0xd0000003, 0xc8000003, 0xf0000003,
+    0x80000003, 0x98000003, 0xd8000003, 0x90000003,
+    0x30000001, 0x60000001, 0x38000001, 0x08000001,
+    0x28000001, 0x78000001, 0x68000001, 0x40000001,
+    0x20000001, 0x50000001, 0x48000001, 0x70000001,
+    0x00000001, 0x18000001, 0x58000001, 0x10000001,
+    0xb0000000, 0xe0000000, 0xb8000000, 0x88000000,
+    0xa8000000, 0xf8000000, 0xe8000000, 0xc0000000,
+    0xa0000000, 0xd0000000, 0xc8000000, 0xf0000000,
+    0x80000000, 0x98000000, 0xd8000000, 0x90000000,
+    0xb0000006, 0xe0000006, 0xb8000006, 0x88000006,
+    0xa8000006, 0xf8000006, 0xe8000006, 0xc0000006,
+    0xa0000006, 0xd0000006, 0xc8000006, 0xf0000006,
+    0x80000006, 0x98000006, 0xd8000006, 0x90000006,
+    0xb0000001, 0xe0000001, 0xb8000001, 0x88000001,
+    0xa8000001, 0xf8000001, 0xe8000001, 0xc0000001,
+    0xa0000001, 0xd0000001, 0xc8000001, 0xf0000001,
+    0x80000001, 0x98000001, 0xd8000001, 0x90000001,
+    0x30000003, 0x60000003, 0x38000003, 0x08000003,
+    0x28000003, 0x78000003, 0x68000003, 0x40000003,
+    0x20000003, 0x50000003, 0x48000003, 0x70000003,
+    0x00000003, 0x18000003, 0x58000003, 0x10000003,
+    0x30000004, 0x60000004, 0x38000004, 0x08000004,
+    0x28000004, 0x78000004, 0x68000004, 0x40000004,
+    0x20000004, 0x50000004, 0x48000004, 0x70000004,
+    0x00000004, 0x18000004, 0x58000004, 0x10000004,
+    0xb0000002, 0xe0000002, 0xb8000002, 0x88000002,
+    0xa8000002, 0xf8000002, 0xe8000002, 0xc0000002,
+    0xa0000002, 0xd0000002, 0xc8000002, 0xf0000002,
+    0x80000002, 0x98000002, 0xd8000002, 0x90000002,
+    0xb0000004, 0xe0000004, 0xb8000004, 0x88000004,
+    0xa8000004, 0xf8000004, 0xe8000004, 0xc0000004,
+    0xa0000004, 0xd0000004, 0xc8000004, 0xf0000004,
+    0x80000004, 0x98000004, 0xd8000004, 0x90000004,
+    0x30000006, 0x60000006, 0x38000006, 0x08000006,
+    0x28000006, 0x78000006, 0x68000006, 0x40000006,
+    0x20000006, 0x50000006, 0x48000006, 0x70000006,
+    0x00000006, 0x18000006, 0x58000006, 0x10000006,
+    0xb0000007, 0xe0000007, 0xb8000007, 0x88000007,
+    0xa8000007, 0xf8000007, 0xe8000007, 0xc0000007,
+    0xa0000007, 0xd0000007, 0xc8000007, 0xf0000007,
+    0x80000007, 0x98000007, 0xd8000007, 0x90000007,
+    0x30000007, 0x60000007, 0x38000007, 0x08000007,
+    0x28000007, 0x78000007, 0x68000007, 0x40000007,
+    0x20000007, 0x50000007, 0x48000007, 0x70000007,
+    0x00000007, 0x18000007, 0x58000007, 0x10000007,
+    /* 3 */
+    0x000000e8, 0x000000d8, 0x000000a0, 0x00000088,
+    0x00000098, 0x000000f8, 0x000000a8, 0x000000c8,
+    0x00000080, 0x000000d0, 0x000000f0, 0x000000b8,
+    0x000000b0, 0x000000c0, 0x00000090, 0x000000e0,
+    0x000007e8, 0x000007d8, 0x000007a0, 0x00000788,
+    0x00000798, 0x000007f8, 0x000007a8, 0x000007c8,
+    0x00000780, 0x000007d0, 0x000007f0, 0x000007b8,
+    0x000007b0, 0x000007c0, 0x00000790, 0x000007e0,
+    0x000006e8, 0x000006d8, 0x000006a0, 0x00000688,
+    0x00000698, 0x000006f8, 0x000006a8, 0x000006c8,
+    0x00000680, 0x000006d0, 0x000006f0, 0x000006b8,
+    0x000006b0, 0x000006c0, 0x00000690, 0x000006e0,
+    0x00000068, 0x00000058, 0x00000020, 0x00000008,
+    0x00000018, 0x00000078, 0x00000028, 0x00000048,
+    0x00000000, 0x00000050, 0x00000070, 0x00000038,
+    0x00000030, 0x00000040, 0x00000010, 0x00000060,
+    0x000002e8, 0x000002d8, 0x000002a0, 0x00000288,
+    0x00000298, 0x000002f8, 0x000002a8, 0x000002c8,
+    0x00000280, 0x000002d0, 0x000002f0, 0x000002b8,
+    0x000002b0, 0x000002c0, 0x00000290, 0x000002e0,
+    0x000003e8, 0x000003d8, 0x000003a0, 0x00000388,
+    0x00000398, 0x000003f8, 0x000003a8, 0x000003c8,
+    0x00000380, 0x000003d0, 0x000003f0, 0x000003b8,
+    0x000003b0, 0x000003c0, 0x00000390, 0x000003e0,
+    0x00000568, 0x00000558, 0x00000520, 0x00000508,
+    0x00000518, 0x00000578, 0x00000528, 0x00000548,
+    0x00000500, 0x00000550, 0x00000570, 0x00000538,
+    0x00000530, 0x00000540, 0x00000510, 0x00000560,
+    0x00000268, 0x00000258, 0x00000220, 0x00000208,
+    0x00000218, 0x00000278, 0x00000228, 0x00000248,
+    0x00000200, 0x00000250, 0x00000270, 0x00000238,
+    0x00000230, 0x00000240, 0x00000210, 0x00000260,
+    0x000004e8, 0x000004d8, 0x000004a0, 0x00000488,
+    0x00000498, 0x000004f8, 0x000004a8, 0x000004c8,
+    0x00000480, 0x000004d0, 0x000004f0, 0x000004b8,
+    0x000004b0, 0x000004c0, 0x00000490, 0x000004e0,
+    0x00000168, 0x00000158, 0x00000120, 0x00000108,
+    0x00000118, 0x00000178, 0x00000128, 0x00000148,
+    0x00000100, 0x00000150, 0x00000170, 0x00000138,
+    0x00000130, 0x00000140, 0x00000110, 0x00000160,
+    0x000001e8, 0x000001d8, 0x000001a0, 0x00000188,
+    0x00000198, 0x000001f8, 0x000001a8, 0x000001c8,
+    0x00000180, 0x000001d0, 0x000001f0, 0x000001b8,
+    0x000001b0, 0x000001c0, 0x00000190, 0x000001e0,
+    0x00000768, 0x00000758, 0x00000720, 0x00000708,
+    0x00000718, 0x00000778, 0x00000728, 0x00000748,
+    0x00000700, 0x00000750, 0x00000770, 0x00000738,
+    0x00000730, 0x00000740, 0x00000710, 0x00000760,
+    0x00000368, 0x00000358, 0x00000320, 0x00000308,
+    0x00000318, 0x00000378, 0x00000328, 0x00000348,
+    0x00000300, 0x00000350, 0x00000370, 0x00000338,
+    0x00000330, 0x00000340, 0x00000310, 0x00000360,
+    0x000005e8, 0x000005d8, 0x000005a0, 0x00000588,
+    0x00000598, 0x000005f8, 0x000005a8, 0x000005c8,
+    0x00000580, 0x000005d0, 0x000005f0, 0x000005b8,
+    0x000005b0, 0x000005c0, 0x00000590, 0x000005e0,
+    0x00000468, 0x00000458, 0x00000420, 0x00000408,
+    0x00000418, 0x00000478, 0x00000428, 0x00000448,
+    0x00000400, 0x00000450, 0x00000470, 0x00000438,
+    0x00000430, 0x00000440, 0x00000410, 0x00000460,
+    0x00000668, 0x00000658, 0x00000620, 0x00000608,
+    0x00000618, 0x00000678, 0x00000628, 0x00000648,
+    0x00000600, 0x00000650, 0x00000670, 0x00000638,
+    0x00000630, 0x00000640, 0x00000610, 0x00000660,
+  };
+
+static const u32 sbox_CryptoPro_3411[4*256] =
+  {
+    /* 0 */
+    0x0002d000, 0x0002a000, 0x0002a800, 0x0002b000,
+    0x0002c000, 0x00028800, 0x00029800, 0x0002b800,
+    0x0002e800, 0x0002e000, 0x0002f000, 0x00028000,
+    0x0002c800, 0x00029000, 0x0002d800, 0x0002f800,
+    0x0007d000, 0x0007a000, 0x0007a800, 0x0007b000,
+    0x0007c000, 0x00078800, 0x00079800, 0x0007b800,
+    0x0007e800, 0x0007e000, 0x0007f000, 0x00078000,
+    0x0007c800, 0x00079000, 0x0007d800, 0x0007f800,
+    0x00025000, 0x00022000, 0x00022800, 0x00023000,
+    0x00024000, 0x00020800, 0x00021800, 0x00023800,
+    0x00026800, 0x00026000, 0x00027000, 0x00020000,
+    0x00024800, 0x00021000, 0x00025800, 0x00027800,
+    0x00005000, 0x00002000, 0x00002800, 0x00003000,
+    0x00004000, 0x00000800, 0x00001800, 0x00003800,
+    0x00006800, 0x00006000, 0x00007000, 0x00000000,
+    0x00004800, 0x00001000, 0x00005800, 0x00007800,
+    0x00015000, 0x00012000, 0x00012800, 0x00013000,
+    0x00014000, 0x00010800, 0x00011800, 0x00013800,
+    0x00016800, 0x00016000, 0x00017000, 0x00010000,
+    0x00014800, 0x00011000, 0x00015800, 0x00017800,
+    0x0006d000, 0x0006a000, 0x0006a800, 0x0006b000,
+    0x0006c000, 0x00068800, 0x00069800, 0x0006b800,
+    0x0006e800, 0x0006e000, 0x0006f000, 0x00068000,
+    0x0006c800, 0x00069000, 0x0006d800, 0x0006f800,
+    0x0005d000, 0x0005a000, 0x0005a800, 0x0005b000,
+    0x0005c000, 0x00058800, 0x00059800, 0x0005b800,
+    0x0005e800, 0x0005e000, 0x0005f000, 0x00058000,
+    0x0005c800, 0x00059000, 0x0005d800, 0x0005f800,
+    0x0004d000, 0x0004a000, 0x0004a800, 0x0004b000,
+    0x0004c000, 0x00048800, 0x00049800, 0x0004b800,
+    0x0004e800, 0x0004e000, 0x0004f000, 0x00048000,
+    0x0004c800, 0x00049000, 0x0004d800, 0x0004f800,
+    0x0000d000, 0x0000a000, 0x0000a800, 0x0000b000,
+    0x0000c000, 0x00008800, 0x00009800, 0x0000b800,
+    0x0000e800, 0x0000e000, 0x0000f000, 0x00008000,
+    0x0000c800, 0x00009000, 0x0000d800, 0x0000f800,
+    0x0003d000, 0x0003a000, 0x0003a800, 0x0003b000,
+    0x0003c000, 0x00038800, 0x00039800, 0x0003b800,
+    0x0003e800, 0x0003e000, 0x0003f000, 0x00038000,
+    0x0003c800, 0x00039000, 0x0003d800, 0x0003f800,
+    0x00035000, 0x00032000, 0x00032800, 0x00033000,
+    0x00034000, 0x00030800, 0x00031800, 0x00033800,
+    0x00036800, 0x00036000, 0x00037000, 0x00030000,
+    0x00034800, 0x00031000, 0x00035800, 0x00037800,
+    0x0001d000, 0x0001a000, 0x0001a800, 0x0001b000,
+    0x0001c000, 0x00018800, 0x00019800, 0x0001b800,
+    0x0001e800, 0x0001e000, 0x0001f000, 0x00018000,
+    0x0001c800, 0x00019000, 0x0001d800, 0x0001f800,
+    0x00065000, 0x00062000, 0x00062800, 0x00063000,
+    0x00064000, 0x00060800, 0x00061800, 0x00063800,
+    0x00066800, 0x00066000, 0x00067000, 0x00060000,
+    0x00064800, 0x00061000, 0x00065800, 0x00067800,
+    0x00075000, 0x00072000, 0x00072800, 0x00073000,
+    0x00074000, 0x00070800, 0x00071800, 0x00073800,
+    0x00076800, 0x00076000, 0x00077000, 0x00070000,
+    0x00074800, 0x00071000, 0x00075800, 0x00077800,
+    0x00055000, 0x00052000, 0x00052800, 0x00053000,
+    0x00054000, 0x00050800, 0x00051800, 0x00053800,
+    0x00056800, 0x00056000, 0x00057000, 0x00050000,
+    0x00054800, 0x00051000, 0x00055800, 0x00057800,
+    0x00045000, 0x00042000, 0x00042800, 0x00043000,
+    0x00044000, 0x00040800, 0x00041800, 0x00043800,
+    0x00046800, 0x00046000, 0x00047000, 0x00040000,
+    0x00044800, 0x00041000, 0x00045800, 0x00047800,
+    /* 1 */
+    0x02380000, 0x02780000, 0x02600000, 0x02700000,
+    0x02480000, 0x02200000, 0x02080000, 0x02000000,
+    0x02180000, 0x02580000, 0x02280000, 0x02100000,
+    0x02300000, 0x02500000, 0x02400000, 0x02680000,
+    0x05380000, 0x05780000, 0x05600000, 0x05700000,
+    0x05480000, 0x05200000, 0x05080000, 0x05000000,
+    0x05180000, 0x05580000, 0x05280000, 0x05100000,
+    0x05300000, 0x05500000, 0x05400000, 0x05680000,
+    0x03b80000, 0x03f80000, 0x03e00000, 0x03f00000,
+    0x03c80000, 0x03a00000, 0x03880000, 0x03800000,
+    0x03980000, 0x03d80000, 0x03a80000, 0x03900000,
+    0x03b00000, 0x03d00000, 0x03c00000, 0x03e80000,
+    0x06380000, 0x06780000, 0x06600000, 0x06700000,
+    0x06480000, 0x06200000, 0x06080000, 0x06000000,
+    0x06180000, 0x06580000, 0x06280000, 0x06100000,
+    0x06300000, 0x06500000, 0x06400000, 0x06680000,
+    0x00380000, 0x00780000, 0x00600000, 0x00700000,
+    0x00480000, 0x00200000, 0x00080000, 0x00000000,
+    0x00180000, 0x00580000, 0x00280000, 0x00100000,
+    0x00300000, 0x00500000, 0x00400000, 0x00680000,
+    0x07b80000, 0x07f80000, 0x07e00000, 0x07f00000,
+    0x07c80000, 0x07a00000, 0x07880000, 0x07800000,
+    0x07980000, 0x07d80000, 0x07a80000, 0x07900000,
+    0x07b00000, 0x07d00000, 0x07c00000, 0x07e80000,
+    0x01380000, 0x01780000, 0x01600000, 0x01700000,
+    0x01480000, 0x01200000, 0x01080000, 0x01000000,
+    0x01180000, 0x01580000, 0x01280000, 0x01100000,
+    0x01300000, 0x01500000, 0x01400000, 0x01680000,
+    0x04380000, 0x04780000, 0x04600000, 0x04700000,
+    0x04480000, 0x04200000, 0x04080000, 0x04000000,
+    0x04180000, 0x04580000, 0x04280000, 0x04100000,
+    0x04300000, 0x04500000, 0x04400000, 0x04680000,
+    0x07380000, 0x07780000, 0x07600000, 0x07700000,
+    0x07480000, 0x07200000, 0x07080000, 0x07000000,
+    0x07180000, 0x07580000, 0x07280000, 0x07100000,
+    0x07300000, 0x07500000, 0x07400000, 0x07680000,
+    0x00b80000, 0x00f80000, 0x00e00000, 0x00f00000,
+    0x00c80000, 0x00a00000, 0x00880000, 0x00800000,
+    0x00980000, 0x00d80000, 0x00a80000, 0x00900000,
+    0x00b00000, 0x00d00000, 0x00c00000, 0x00e80000,
+    0x03380000, 0x03780000, 0x03600000, 0x03700000,
+    0x03480000, 0x03200000, 0x03080000, 0x03000000,
+    0x03180000, 0x03580000, 0x03280000, 0x03100000,
+    0x03300000, 0x03500000, 0x03400000, 0x03680000,
+    0x02b80000, 0x02f80000, 0x02e00000, 0x02f00000,
+    0x02c80000, 0x02a00000, 0x02880000, 0x02800000,
+    0x02980000, 0x02d80000, 0x02a80000, 0x02900000,
+    0x02b00000, 0x02d00000, 0x02c00000, 0x02e80000,
+    0x06b80000, 0x06f80000, 0x06e00000, 0x06f00000,
+    0x06c80000, 0x06a00000, 0x06880000, 0x06800000,
+    0x06980000, 0x06d80000, 0x06a80000, 0x06900000,
+    0x06b00000, 0x06d00000, 0x06c00000, 0x06e80000,
+    0x05b80000, 0x05f80000, 0x05e00000, 0x05f00000,
+    0x05c80000, 0x05a00000, 0x05880000, 0x05800000,
+    0x05980000, 0x05d80000, 0x05a80000, 0x05900000,
+    0x05b00000, 0x05d00000, 0x05c00000, 0x05e80000,
+    0x04b80000, 0x04f80000, 0x04e00000, 0x04f00000,
+    0x04c80000, 0x04a00000, 0x04880000, 0x04800000,
+    0x04980000, 0x04d80000, 0x04a80000, 0x04900000,
+    0x04b00000, 0x04d00000, 0x04c00000, 0x04e80000,
+    0x01b80000, 0x01f80000, 0x01e00000, 0x01f00000,
+    0x01c80000, 0x01a00000, 0x01880000, 0x01800000,
+    0x01980000, 0x01d80000, 0x01a80000, 0x01900000,
+    0x01b00000, 0x01d00000, 0x01c00000, 0x01e80000,
+    /* 2 */
+    0xb8000003, 0xb0000003, 0xa0000003, 0xd8000003,
+    0xc8000003, 0xe0000003, 0x90000003, 0xd0000003,
+    0x88000003, 0xc0000003, 0x80000003, 0xf0000003,
+    0xf8000003, 0xe8000003, 0x98000003, 0xa8000003,
+    0x38000003, 0x30000003, 0x20000003, 0x58000003,
+    0x48000003, 0x60000003, 0x10000003, 0x50000003,
+    0x08000003, 0x40000003, 0x00000003, 0x70000003,
+    0x78000003, 0x68000003, 0x18000003, 0x28000003,
+    0x38000001, 0x30000001, 0x20000001, 0x58000001,
+    0x48000001, 0x60000001, 0x10000001, 0x50000001,
+    0x08000001, 0x40000001, 0x00000001, 0x70000001,
+    0x78000001, 0x68000001, 0x18000001, 0x28000001,
+    0x38000002, 0x30000002, 0x20000002, 0x58000002,
+    0x48000002, 0x60000002, 0x10000002, 0x50000002,
+    0x08000002, 0x40000002, 0x00000002, 0x70000002,
+    0x78000002, 0x68000002, 0x18000002, 0x28000002,
+    0xb8000006, 0xb0000006, 0xa0000006, 0xd8000006,
+    0xc8000006, 0xe0000006, 0x90000006, 0xd0000006,
+    0x88000006, 0xc0000006, 0x80000006, 0xf0000006,
+    0xf8000006, 0xe8000006, 0x98000006, 0xa8000006,
+    0xb8000004, 0xb0000004, 0xa0000004, 0xd8000004,
+    0xc8000004, 0xe0000004, 0x90000004, 0xd0000004,
+    0x88000004, 0xc0000004, 0x80000004, 0xf0000004,
+    0xf8000004, 0xe8000004, 0x98000004, 0xa8000004,
+    0xb8000007, 0xb0000007, 0xa0000007, 0xd8000007,
+    0xc8000007, 0xe0000007, 0x90000007, 0xd0000007,
+    0x88000007, 0xc0000007, 0x80000007, 0xf0000007,
+    0xf8000007, 0xe8000007, 0x98000007, 0xa8000007,
+    0x38000000, 0x30000000, 0x20000000, 0x58000000,
+    0x48000000, 0x60000000, 0x10000000, 0x50000000,
+    0x08000000, 0x40000000, 0x00000000, 0x70000000,
+    0x78000000, 0x68000000, 0x18000000, 0x28000000,
+    0x38000005, 0x30000005, 0x20000005, 0x58000005,
+    0x48000005, 0x60000005, 0x10000005, 0x50000005,
+    0x08000005, 0x40000005, 0x00000005, 0x70000005,
+    0x78000005, 0x68000005, 0x18000005, 0x28000005,
+    0xb8000000, 0xb0000000, 0xa0000000, 0xd8000000,
+    0xc8000000, 0xe0000000, 0x90000000, 0xd0000000,
+    0x88000000, 0xc0000000, 0x80000000, 0xf0000000,
+    0xf8000000, 0xe8000000, 0x98000000, 0xa8000000,
+    0xb8000002, 0xb0000002, 0xa0000002, 0xd8000002,
+    0xc8000002, 0xe0000002, 0x90000002, 0xd0000002,
+    0x88000002, 0xc0000002, 0x80000002, 0xf0000002,
+    0xf8000002, 0xe8000002, 0x98000002, 0xa8000002,
+    0xb8000005, 0xb0000005, 0xa0000005, 0xd8000005,
+    0xc8000005, 0xe0000005, 0x90000005, 0xd0000005,
+    0x88000005, 0xc0000005, 0x80000005, 0xf0000005,
+    0xf8000005, 0xe8000005, 0x98000005, 0xa8000005,
+    0x38000004, 0x30000004, 0x20000004, 0x58000004,
+    0x48000004, 0x60000004, 0x10000004, 0x50000004,
+    0x08000004, 0x40000004, 0x00000004, 0x70000004,
+    0x78000004, 0x68000004, 0x18000004, 0x28000004,
+    0x38000007, 0x30000007, 0x20000007, 0x58000007,
+    0x48000007, 0x60000007, 0x10000007, 0x50000007,
+    0x08000007, 0x40000007, 0x00000007, 0x70000007,
+    0x78000007, 0x68000007, 0x18000007, 0x28000007,
+    0x38000006, 0x30000006, 0x20000006, 0x58000006,
+    0x48000006, 0x60000006, 0x10000006, 0x50000006,
+    0x08000006, 0x40000006, 0x00000006, 0x70000006,
+    0x78000006, 0x68000006, 0x18000006, 0x28000006,
+    0xb8000001, 0xb0000001, 0xa0000001, 0xd8000001,
+    0xc8000001, 0xe0000001, 0x90000001, 0xd0000001,
+    0x88000001, 0xc0000001, 0x80000001, 0xf0000001,
+    0xf8000001, 0xe8000001, 0x98000001, 0xa8000001,
+    /* 3 */
+    0x000000e8, 0x000000f0, 0x000000a0, 0x00000088,
+    0x000000b8, 0x00000080, 0x000000a8, 0x000000d0,
+    0x00000098, 0x000000e0, 0x000000c0, 0x000000f8,
+    0x000000b0, 0x00000090, 0x000000c8, 0x000000d8,
+    0x000001e8, 0x000001f0, 0x000001a0, 0x00000188,
+    0x000001b8, 0x00000180, 0x000001a8, 0x000001d0,
+    0x00000198, 0x000001e0, 0x000001c0, 0x000001f8,
+    0x000001b0, 0x00000190, 0x000001c8, 0x000001d8,
+    0x00000568, 0x00000570, 0x00000520, 0x00000508,
+    0x00000538, 0x00000500, 0x00000528, 0x00000550,
+    0x00000518, 0x00000560, 0x00000540, 0x00000578,
+    0x00000530, 0x00000510, 0x00000548, 0x00000558,
+    0x000004e8, 0x000004f0, 0x000004a0, 0x00000488,
+    0x000004b8, 0x00000480, 0x000004a8, 0x000004d0,
+    0x00000498, 0x000004e0, 0x000004c0, 0x000004f8,
+    0x000004b0, 0x00000490, 0x000004c8, 0x000004d8,
+    0x000002e8, 0x000002f0, 0x000002a0, 0x00000288,
+    0x000002b8, 0x00000280, 0x000002a8, 0x000002d0,
+    0x00000298, 0x000002e0, 0x000002c0, 0x000002f8,
+    0x000002b0, 0x00000290, 0x000002c8, 0x000002d8,
+    0x000005e8, 0x000005f0, 0x000005a0, 0x00000588,
+    0x000005b8, 0x00000580, 0x000005a8, 0x000005d0,
+    0x00000598, 0x000005e0, 0x000005c0, 0x000005f8,
+    0x000005b0, 0x00000590, 0x000005c8, 0x000005d8,
+    0x00000268, 0x00000270, 0x00000220, 0x00000208,
+    0x00000238, 0x00000200, 0x00000228, 0x00000250,
+    0x00000218, 0x00000260, 0x00000240, 0x00000278,
+    0x00000230, 0x00000210, 0x00000248, 0x00000258,
+    0x000007e8, 0x000007f0, 0x000007a0, 0x00000788,
+    0x000007b8, 0x00000780, 0x000007a8, 0x000007d0,
+    0x00000798, 0x000007e0, 0x000007c0, 0x000007f8,
+    0x000007b0, 0x00000790, 0x000007c8, 0x000007d8,
+    0x00000468, 0x00000470, 0x00000420, 0x00000408,
+    0x00000438, 0x00000400, 0x00000428, 0x00000450,
+    0x00000418, 0x00000460, 0x00000440, 0x00000478,
+    0x00000430, 0x00000410, 0x00000448, 0x00000458,
+    0x00000368, 0x00000370, 0x00000320, 0x00000308,
+    0x00000338, 0x00000300, 0x00000328, 0x00000350,
+    0x00000318, 0x00000360, 0x00000340, 0x00000378,
+    0x00000330, 0x00000310, 0x00000348, 0x00000358,
+    0x000003e8, 0x000003f0, 0x000003a0, 0x00000388,
+    0x000003b8, 0x00000380, 0x000003a8, 0x000003d0,
+    0x00000398, 0x000003e0, 0x000003c0, 0x000003f8,
+    0x000003b0, 0x00000390, 0x000003c8, 0x000003d8,
+    0x00000768, 0x00000770, 0x00000720, 0x00000708,
+    0x00000738, 0x00000700, 0x00000728, 0x00000750,
+    0x00000718, 0x00000760, 0x00000740, 0x00000778,
+    0x00000730, 0x00000710, 0x00000748, 0x00000758,
+    0x000006e8, 0x000006f0, 0x000006a0, 0x00000688,
+    0x000006b8, 0x00000680, 0x000006a8, 0x000006d0,
+    0x00000698, 0x000006e0, 0x000006c0, 0x000006f8,
+    0x000006b0, 0x00000690, 0x000006c8, 0x000006d8,
+    0x00000068, 0x00000070, 0x00000020, 0x00000008,
+    0x00000038, 0x00000000, 0x00000028, 0x00000050,
+    0x00000018, 0x00000060, 0x00000040, 0x00000078,
+    0x00000030, 0x00000010, 0x00000048, 0x00000058,
+    0x00000168, 0x00000170, 0x00000120, 0x00000108,
+    0x00000138, 0x00000100, 0x00000128, 0x00000150,
+    0x00000118, 0x00000160, 0x00000140, 0x00000178,
+    0x00000130, 0x00000110, 0x00000148, 0x00000158,
+    0x00000668, 0x00000670, 0x00000620, 0x00000608,
+    0x00000638, 0x00000600, 0x00000628, 0x00000650,
+    0x00000618, 0x00000660, 0x00000640, 0x00000678,
+    0x00000630, 0x00000610, 0x00000648, 0x00000658,
+  };
+
+static const u32 sbox_Test_89[4*256] =
+  {
+    /* 0 */
+    0x00062000, 0x00061000, 0x00067800, 0x00062800,
+    0x00064800, 0x00060800, 0x00060000, 0x00064000,
+    0x00067000, 0x00061800, 0x00065800, 0x00066000,
+    0x00066800, 0x00063800, 0x00065000, 0x00063000,
+    0x0004a000, 0x00049000, 0x0004f800, 0x0004a800,
+    0x0004c800, 0x00048800, 0x00048000, 0x0004c000,
+    0x0004f000, 0x00049800, 0x0004d800, 0x0004e000,
+    0x0004e800, 0x0004b800, 0x0004d000, 0x0004b000,
+    0x0007a000, 0x00079000, 0x0007f800, 0x0007a800,
+    0x0007c800, 0x00078800, 0x00078000, 0x0007c000,
+    0x0007f000, 0x00079800, 0x0007d800, 0x0007e000,
+    0x0007e800, 0x0007b800, 0x0007d000, 0x0007b000,
+    0x00072000, 0x00071000, 0x00077800, 0x00072800,
+    0x00074800, 0x00070800, 0x00070000, 0x00074000,
+    0x00077000, 0x00071800, 0x00075800, 0x00076000,
+    0x00076800, 0x00073800, 0x00075000, 0x00073000,
+    0x00042000, 0x00041000, 0x00047800, 0x00042800,
+    0x00044800, 0x00040800, 0x00040000, 0x00044000,
+    0x00047000, 0x00041800, 0x00045800, 0x00046000,
+    0x00046800, 0x00043800, 0x00045000, 0x00043000,
+    0x0000a000, 0x00009000, 0x0000f800, 0x0000a800,
+    0x0000c800, 0x00008800, 0x00008000, 0x0000c000,
+    0x0000f000, 0x00009800, 0x0000d800, 0x0000e000,
+    0x0000e800, 0x0000b800, 0x0000d000, 0x0000b000,
+    0x0001a000, 0x00019000, 0x0001f800, 0x0001a800,
+    0x0001c800, 0x00018800, 0x00018000, 0x0001c000,
+    0x0001f000, 0x00019800, 0x0001d800, 0x0001e000,
+    0x0001e800, 0x0001b800, 0x0001d000, 0x0001b000,
+    0x00052000, 0x00051000, 0x00057800, 0x00052800,
+    0x00054800, 0x00050800, 0x00050000, 0x00054000,
+    0x00057000, 0x00051800, 0x00055800, 0x00056000,
+    0x00056800, 0x00053800, 0x00055000, 0x00053000,
+    0x00012000, 0x00011000, 0x00017800, 0x00012800,
+    0x00014800, 0x00010800, 0x00010000, 0x00014000,
+    0x00017000, 0x00011800, 0x00015800, 0x00016000,
+    0x00016800, 0x00013800, 0x00015000, 0x00013000,
+    0x0003a000, 0x00039000, 0x0003f800, 0x0003a800,
+    0x0003c800, 0x00038800, 0x00038000, 0x0003c000,
+    0x0003f000, 0x00039800, 0x0003d800, 0x0003e000,
+    0x0003e800, 0x0003b800, 0x0003d000, 0x0003b000,
+    0x00022000, 0x00021000, 0x00027800, 0x00022800,
+    0x00024800, 0x00020800, 0x00020000, 0x00024000,
+    0x00027000, 0x00021800, 0x00025800, 0x00026000,
+    0x00026800, 0x00023800, 0x00025000, 0x00023000,
+    0x0006a000, 0x00069000, 0x0006f800, 0x0006a800,
+    0x0006c800, 0x00068800, 0x00068000, 0x0006c000,
+    0x0006f000, 0x00069800, 0x0006d800, 0x0006e000,
+    0x0006e800, 0x0006b800, 0x0006d000, 0x0006b000,
+    0x00032000, 0x00031000, 0x00037800, 0x00032800,
+    0x00034800, 0x00030800, 0x00030000, 0x00034000,
+    0x00037000, 0x00031800, 0x00035800, 0x00036000,
+    0x00036800, 0x00033800, 0x00035000, 0x00033000,
+    0x00002000, 0x00001000, 0x00007800, 0x00002800,
+    0x00004800, 0x00000800, 0x00000000, 0x00004000,
+    0x00007000, 0x00001800, 0x00005800, 0x00006000,
+    0x00006800, 0x00003800, 0x00005000, 0x00003000,
+    0x0005a000, 0x00059000, 0x0005f800, 0x0005a800,
+    0x0005c800, 0x00058800, 0x00058000, 0x0005c000,
+    0x0005f000, 0x00059800, 0x0005d800, 0x0005e000,
+    0x0005e800, 0x0005b800, 0x0005d000, 0x0005b000,
+    0x0002a000, 0x00029000, 0x0002f800, 0x0002a800,
+    0x0002c800, 0x00028800, 0x00028000, 0x0002c000,
+    0x0002f000, 0x00029800, 0x0002d800, 0x0002e000,
+    0x0002e800, 0x0002b800, 0x0002d000, 0x0002b000,
+    /* 1 */
+    0x07680000, 0x07400000, 0x07700000, 0x07600000,
+    0x07380000, 0x07180000, 0x07480000, 0x07500000,
+    0x07080000, 0x07280000, 0x07100000, 0x07200000,
+    0x07300000, 0x07780000, 0x07000000, 0x07580000,
+    0x04e80000, 0x04c00000, 0x04f00000, 0x04e00000,
+    0x04b80000, 0x04980000, 0x04c80000, 0x04d00000,
+    0x04880000, 0x04a80000, 0x04900000, 0x04a00000,
+    0x04b00000, 0x04f80000, 0x04800000, 0x04d80000,
+    0x05e80000, 0x05c00000, 0x05f00000, 0x05e00000,
+    0x05b80000, 0x05980000, 0x05c80000, 0x05d00000,
+    0x05880000, 0x05a80000, 0x05900000, 0x05a00000,
+    0x05b00000, 0x05f80000, 0x05800000, 0x05d80000,
+    0x01680000, 0x01400000, 0x01700000, 0x01600000,
+    0x01380000, 0x01180000, 0x01480000, 0x01500000,
+    0x01080000, 0x01280000, 0x01100000, 0x01200000,
+    0x01300000, 0x01780000, 0x01000000, 0x01580000,
+    0x02e80000, 0x02c00000, 0x02f00000, 0x02e00000,
+    0x02b80000, 0x02980000, 0x02c80000, 0x02d00000,
+    0x02880000, 0x02a80000, 0x02900000, 0x02a00000,
+    0x02b00000, 0x02f80000, 0x02800000, 0x02d80000,
+    0x07e80000, 0x07c00000, 0x07f00000, 0x07e00000,
+    0x07b80000, 0x07980000, 0x07c80000, 0x07d00000,
+    0x07880000, 0x07a80000, 0x07900000, 0x07a00000,
+    0x07b00000, 0x07f80000, 0x07800000, 0x07d80000,
+    0x03e80000, 0x03c00000, 0x03f00000, 0x03e00000,
+    0x03b80000, 0x03980000, 0x03c80000, 0x03d00000,
+    0x03880000, 0x03a80000, 0x03900000, 0x03a00000,
+    0x03b00000, 0x03f80000, 0x03800000, 0x03d80000,
+    0x00e80000, 0x00c00000, 0x00f00000, 0x00e00000,
+    0x00b80000, 0x00980000, 0x00c80000, 0x00d00000,
+    0x00880000, 0x00a80000, 0x00900000, 0x00a00000,
+    0x00b00000, 0x00f80000, 0x00800000, 0x00d80000,
+    0x00680000, 0x00400000, 0x00700000, 0x00600000,
+    0x00380000, 0x00180000, 0x00480000, 0x00500000,
+    0x00080000, 0x00280000, 0x00100000, 0x00200000,
+    0x00300000, 0x00780000, 0x00000000, 0x00580000,
+    0x06e80000, 0x06c00000, 0x06f00000, 0x06e00000,
+    0x06b80000, 0x06980000, 0x06c80000, 0x06d00000,
+    0x06880000, 0x06a80000, 0x06900000, 0x06a00000,
+    0x06b00000, 0x06f80000, 0x06800000, 0x06d80000,
+    0x06680000, 0x06400000, 0x06700000, 0x06600000,
+    0x06380000, 0x06180000, 0x06480000, 0x06500000,
+    0x06080000, 0x06280000, 0x06100000, 0x06200000,
+    0x06300000, 0x06780000, 0x06000000, 0x06580000,
+    0x03680000, 0x03400000, 0x03700000, 0x03600000,
+    0x03380000, 0x03180000, 0x03480000, 0x03500000,
+    0x03080000, 0x03280000, 0x03100000, 0x03200000,
+    0x03300000, 0x03780000, 0x03000000, 0x03580000,
+    0x05680000, 0x05400000, 0x05700000, 0x05600000,
+    0x05380000, 0x05180000, 0x05480000, 0x05500000,
+    0x05080000, 0x05280000, 0x05100000, 0x05200000,
+    0x05300000, 0x05780000, 0x05000000, 0x05580000,
+    0x02680000, 0x02400000, 0x02700000, 0x02600000,
+    0x02380000, 0x02180000, 0x02480000, 0x02500000,
+    0x02080000, 0x02280000, 0x02100000, 0x02200000,
+    0x02300000, 0x02780000, 0x02000000, 0x02580000,
+    0x01e80000, 0x01c00000, 0x01f00000, 0x01e00000,
+    0x01b80000, 0x01980000, 0x01c80000, 0x01d00000,
+    0x01880000, 0x01a80000, 0x01900000, 0x01a00000,
+    0x01b00000, 0x01f80000, 0x01800000, 0x01d80000,
+    0x04680000, 0x04400000, 0x04700000, 0x04600000,
+    0x04380000, 0x04180000, 0x04480000, 0x04500000,
+    0x04080000, 0x04280000, 0x04100000, 0x04200000,
+    0x04300000, 0x04780000, 0x04000000, 0x04580000,
+    /* 2 */
+    0x18000004, 0x70000004, 0x28000004, 0x48000004,
+    0x30000004, 0x40000004, 0x00000004, 0x68000004,
+    0x50000004, 0x58000004, 0x38000004, 0x60000004,
+    0x10000004, 0x08000004, 0x78000004, 0x20000004,
+    0x98000007, 0xf0000007, 0xa8000007, 0xc8000007,
+    0xb0000007, 0xc0000007, 0x80000007, 0xe8000007,
+    0xd0000007, 0xd8000007, 0xb8000007, 0xe0000007,
+    0x90000007, 0x88000007, 0xf8000007, 0xa0000007,
+    0x18000003, 0x70000003, 0x28000003, 0x48000003,
+    0x30000003, 0x40000003, 0x00000003, 0x68000003,
+    0x50000003, 0x58000003, 0x38000003, 0x60000003,
+    0x10000003, 0x08000003, 0x78000003, 0x20000003,
+    0x98000005, 0xf0000005, 0xa8000005, 0xc8000005,
+    0xb0000005, 0xc0000005, 0x80000005, 0xe8000005,
+    0xd0000005, 0xd8000005, 0xb8000005, 0xe0000005,
+    0x90000005, 0x88000005, 0xf8000005, 0xa0000005,
+    0x98000000, 0xf0000000, 0xa8000000, 0xc8000000,
+    0xb0000000, 0xc0000000, 0x80000000, 0xe8000000,
+    0xd0000000, 0xd8000000, 0xb8000000, 0xe0000000,
+    0x90000000, 0x88000000, 0xf8000000, 0xa0000000,
+    0x98000004, 0xf0000004, 0xa8000004, 0xc8000004,
+    0xb0000004, 0xc0000004, 0x80000004, 0xe8000004,
+    0xd0000004, 0xd8000004, 0xb8000004, 0xe0000004,
+    0x90000004, 0x88000004, 0xf8000004, 0xa0000004,
+    0x18000006, 0x70000006, 0x28000006, 0x48000006,
+    0x30000006, 0x40000006, 0x00000006, 0x68000006,
+    0x50000006, 0x58000006, 0x38000006, 0x60000006,
+    0x10000006, 0x08000006, 0x78000006, 0x20000006,
+    0x98000002, 0xf0000002, 0xa8000002, 0xc8000002,
+    0xb0000002, 0xc0000002, 0x80000002, 0xe8000002,
+    0xd0000002, 0xd8000002, 0xb8000002, 0xe0000002,
+    0x90000002, 0x88000002, 0xf8000002, 0xa0000002,
+    0x98000006, 0xf0000006, 0xa8000006, 0xc8000006,
+    0xb0000006, 0xc0000006, 0x80000006, 0xe8000006,
+    0xd0000006, 0xd8000006, 0xb8000006, 0xe0000006,
+    0x90000006, 0x88000006, 0xf8000006, 0xa0000006,
+    0x98000001, 0xf0000001, 0xa8000001, 0xc8000001,
+    0xb0000001, 0xc0000001, 0x80000001, 0xe8000001,
+    0xd0000001, 0xd8000001, 0xb8000001, 0xe0000001,
+    0x90000001, 0x88000001, 0xf8000001, 0xa0000001,
+    0x98000003, 0xf0000003, 0xa8000003, 0xc8000003,
+    0xb0000003, 0xc0000003, 0x80000003, 0xe8000003,
+    0xd0000003, 0xd8000003, 0xb8000003, 0xe0000003,
+    0x90000003, 0x88000003, 0xf8000003, 0xa0000003,
+    0x18000005, 0x70000005, 0x28000005, 0x48000005,
+    0x30000005, 0x40000005, 0x00000005, 0x68000005,
+    0x50000005, 0x58000005, 0x38000005, 0x60000005,
+    0x10000005, 0x08000005, 0x78000005, 0x20000005,
+    0x18000000, 0x70000000, 0x28000000, 0x48000000,
+    0x30000000, 0x40000000, 0x00000000, 0x68000000,
+    0x50000000, 0x58000000, 0x38000000, 0x60000000,
+    0x10000000, 0x08000000, 0x78000000, 0x20000000,
+    0x18000007, 0x70000007, 0x28000007, 0x48000007,
+    0x30000007, 0x40000007, 0x00000007, 0x68000007,
+    0x50000007, 0x58000007, 0x38000007, 0x60000007,
+    0x10000007, 0x08000007, 0x78000007, 0x20000007,
+    0x18000001, 0x70000001, 0x28000001, 0x48000001,
+    0x30000001, 0x40000001, 0x00000001, 0x68000001,
+    0x50000001, 0x58000001, 0x38000001, 0x60000001,
+    0x10000001, 0x08000001, 0x78000001, 0x20000001,
+    0x18000002, 0x70000002, 0x28000002, 0x48000002,
+    0x30000002, 0x40000002, 0x00000002, 0x68000002,
+    0x50000002, 0x58000002, 0x38000002, 0x60000002,
+    0x10000002, 0x08000002, 0x78000002, 0x20000002,
+    /* 3 */
+    0x00000648, 0x00000658, 0x00000660, 0x00000600,
+    0x00000618, 0x00000630, 0x00000638, 0x00000628,
+    0x00000620, 0x00000640, 0x00000670, 0x00000678,
+    0x00000608, 0x00000650, 0x00000610, 0x00000668,
+    0x00000348, 0x00000358, 0x00000360, 0x00000300,
+    0x00000318, 0x00000330, 0x00000338, 0x00000328,
+    0x00000320, 0x00000340, 0x00000370, 0x00000378,
+    0x00000308, 0x00000350, 0x00000310, 0x00000368,
+    0x000002c8, 0x000002d8, 0x000002e0, 0x00000280,
+    0x00000298, 0x000002b0, 0x000002b8, 0x000002a8,
+    0x000002a0, 0x000002c0, 0x000002f0, 0x000002f8,
+    0x00000288, 0x000002d0, 0x00000290, 0x000002e8,
+    0x00000148, 0x00000158, 0x00000160, 0x00000100,
+    0x00000118, 0x00000130, 0x00000138, 0x00000128,
+    0x00000120, 0x00000140, 0x00000170, 0x00000178,
+    0x00000108, 0x00000150, 0x00000110, 0x00000168,
+    0x000005c8, 0x000005d8, 0x000005e0, 0x00000580,
+    0x00000598, 0x000005b0, 0x000005b8, 0x000005a8,
+    0x000005a0, 0x000005c0, 0x000005f0, 0x000005f8,
+    0x00000588, 0x000005d0, 0x00000590, 0x000005e8,
+    0x00000048, 0x00000058, 0x00000060, 0x00000000,
+    0x00000018, 0x00000030, 0x00000038, 0x00000028,
+    0x00000020, 0x00000040, 0x00000070, 0x00000078,
+    0x00000008, 0x00000050, 0x00000010, 0x00000068,
+    0x000004c8, 0x000004d8, 0x000004e0, 0x00000480,
+    0x00000498, 0x000004b0, 0x000004b8, 0x000004a8,
+    0x000004a0, 0x000004c0, 0x000004f0, 0x000004f8,
+    0x00000488, 0x000004d0, 0x00000490, 0x000004e8,
+    0x000006c8, 0x000006d8, 0x000006e0, 0x00000680,
+    0x00000698, 0x000006b0, 0x000006b8, 0x000006a8,
+    0x000006a0, 0x000006c0, 0x000006f0, 0x000006f8,
+    0x00000688, 0x000006d0, 0x00000690, 0x000006e8,
+    0x000001c8, 0x000001d8, 0x000001e0, 0x00000180,
+    0x00000198, 0x000001b0, 0x000001b8, 0x000001a8,
+    0x000001a0, 0x000001c0, 0x000001f0, 0x000001f8,
+    0x00000188, 0x000001d0, 0x00000190, 0x000001e8,
+    0x00000748, 0x00000758, 0x00000760, 0x00000700,
+    0x00000718, 0x00000730, 0x00000738, 0x00000728,
+    0x00000720, 0x00000740, 0x00000770, 0x00000778,
+    0x00000708, 0x00000750, 0x00000710, 0x00000768,
+    0x000003c8, 0x000003d8, 0x000003e0, 0x00000380,
+    0x00000398, 0x000003b0, 0x000003b8, 0x000003a8,
+    0x000003a0, 0x000003c0, 0x000003f0, 0x000003f8,
+    0x00000388, 0x000003d0, 0x00000390, 0x000003e8,
+    0x00000548, 0x00000558, 0x00000560, 0x00000500,
+    0x00000518, 0x00000530, 0x00000538, 0x00000528,
+    0x00000520, 0x00000540, 0x00000570, 0x00000578,
+    0x00000508, 0x00000550, 0x00000510, 0x00000568,
+    0x000007c8, 0x000007d8, 0x000007e0, 0x00000780,
+    0x00000798, 0x000007b0, 0x000007b8, 0x000007a8,
+    0x000007a0, 0x000007c0, 0x000007f0, 0x000007f8,
+    0x00000788, 0x000007d0, 0x00000790, 0x000007e8,
+    0x00000248, 0x00000258, 0x00000260, 0x00000200,
+    0x00000218, 0x00000230, 0x00000238, 0x00000228,
+    0x00000220, 0x00000240, 0x00000270, 0x00000278,
+    0x00000208, 0x00000250, 0x00000210, 0x00000268,
+    0x000000c8, 0x000000d8, 0x000000e0, 0x00000080,
+    0x00000098, 0x000000b0, 0x000000b8, 0x000000a8,
+    0x000000a0, 0x000000c0, 0x000000f0, 0x000000f8,
+    0x00000088, 0x000000d0, 0x00000090, 0x000000e8,
+    0x00000448, 0x00000458, 0x00000460, 0x00000400,
+    0x00000418, 0x00000430, 0x00000438, 0x00000428,
+    0x00000420, 0x00000440, 0x00000470, 0x00000478,
+    0x00000408, 0x00000450, 0x00000410, 0x00000468,
+  };
+
+static const u32 sbox_CryptoPro_A[4*256] =
+  {
+    /* 0 */
+    0x0001c800, 0x0001b000, 0x00019800, 0x00019000,
+    0x0001c000, 0x0001d800, 0x00018800, 0x0001b800,
+    0x0001d000, 0x0001a000, 0x0001f000, 0x0001f800,
+    0x0001e000, 0x00018000, 0x0001e800, 0x0001a800,
+    0x0003c800, 0x0003b000, 0x00039800, 0x00039000,
+    0x0003c000, 0x0003d800, 0x00038800, 0x0003b800,
+    0x0003d000, 0x0003a000, 0x0003f000, 0x0003f800,
+    0x0003e000, 0x00038000, 0x0003e800, 0x0003a800,
+    0x00074800, 0x00073000, 0x00071800, 0x00071000,
+    0x00074000, 0x00075800, 0x00070800, 0x00073800,
+    0x00075000, 0x00072000, 0x00077000, 0x00077800,
+    0x00076000, 0x00070000, 0x00076800, 0x00072800,
+    0x0004c800, 0x0004b000, 0x00049800, 0x00049000,
+    0x0004c000, 0x0004d800, 0x00048800, 0x0004b800,
+    0x0004d000, 0x0004a000, 0x0004f000, 0x0004f800,
+    0x0004e000, 0x00048000, 0x0004e800, 0x0004a800,
+    0x00044800, 0x00043000, 0x00041800, 0x00041000,
+    0x00044000, 0x00045800, 0x00040800, 0x00043800,
+    0x00045000, 0x00042000, 0x00047000, 0x00047800,
+    0x00046000, 0x00040000, 0x00046800, 0x00042800,
+    0x00054800, 0x00053000, 0x00051800, 0x00051000,
+    0x00054000, 0x00055800, 0x00050800, 0x00053800,
+    0x00055000, 0x00052000, 0x00057000, 0x00057800,
+    0x00056000, 0x00050000, 0x00056800, 0x00052800,
+    0x0007c800, 0x0007b000, 0x00079800, 0x00079000,
+    0x0007c000, 0x0007d800, 0x00078800, 0x0007b800,
+    0x0007d000, 0x0007a000, 0x0007f000, 0x0007f800,
+    0x0007e000, 0x00078000, 0x0007e800, 0x0007a800,
+    0x00004800, 0x00003000, 0x00001800, 0x00001000,
+    0x00004000, 0x00005800, 0x00000800, 0x00003800,
+    0x00005000, 0x00002000, 0x00007000, 0x00007800,
+    0x00006000, 0x00000000, 0x00006800, 0x00002800,
+    0x0002c800, 0x0002b000, 0x00029800, 0x00029000,
+    0x0002c000, 0x0002d800, 0x00028800, 0x0002b800,
+    0x0002d000, 0x0002a000, 0x0002f000, 0x0002f800,
+    0x0002e000, 0x00028000, 0x0002e800, 0x0002a800,
+    0x00014800, 0x00013000, 0x00011800, 0x00011000,
+    0x00014000, 0x00015800, 0x00010800, 0x00013800,
+    0x00015000, 0x00012000, 0x00017000, 0x00017800,
+    0x00016000, 0x00010000, 0x00016800, 0x00012800,
+    0x00034800, 0x00033000, 0x00031800, 0x00031000,
+    0x00034000, 0x00035800, 0x00030800, 0x00033800,
+    0x00035000, 0x00032000, 0x00037000, 0x00037800,
+    0x00036000, 0x00030000, 0x00036800, 0x00032800,
+    0x00064800, 0x00063000, 0x00061800, 0x00061000,
+    0x00064000, 0x00065800, 0x00060800, 0x00063800,
+    0x00065000, 0x00062000, 0x00067000, 0x00067800,
+    0x00066000, 0x00060000, 0x00066800, 0x00062800,
+    0x0005c800, 0x0005b000, 0x00059800, 0x00059000,
+    0x0005c000, 0x0005d800, 0x00058800, 0x0005b800,
+    0x0005d000, 0x0005a000, 0x0005f000, 0x0005f800,
+    0x0005e000, 0x00058000, 0x0005e800, 0x0005a800,
+    0x00024800, 0x00023000, 0x00021800, 0x00021000,
+    0x00024000, 0x00025800, 0x00020800, 0x00023800,
+    0x00025000, 0x00022000, 0x00027000, 0x00027800,
+    0x00026000, 0x00020000, 0x00026800, 0x00022800,
+    0x0006c800, 0x0006b000, 0x00069800, 0x00069000,
+    0x0006c000, 0x0006d800, 0x00068800, 0x0006b800,
+    0x0006d000, 0x0006a000, 0x0006f000, 0x0006f800,
+    0x0006e000, 0x00068000, 0x0006e800, 0x0006a800,
+    0x0000c800, 0x0000b000, 0x00009800, 0x00009000,
+    0x0000c000, 0x0000d800, 0x00008800, 0x0000b800,
+    0x0000d000, 0x0000a000, 0x0000f000, 0x0000f800,
+    0x0000e000, 0x00008000, 0x0000e800, 0x0000a800,
+    /* 1 */
+    0x07700000, 0x07200000, 0x07300000, 0x07100000,
+    0x07580000, 0x07180000, 0x07680000, 0x07400000,
+    0x07600000, 0x07780000, 0x07280000, 0x07500000,
+    0x07000000, 0x07380000, 0x07080000, 0x07480000,
+    0x03f00000, 0x03a00000, 0x03b00000, 0x03900000,
+    0x03d80000, 0x03980000, 0x03e80000, 0x03c00000,
+    0x03e00000, 0x03f80000, 0x03a80000, 0x03d00000,
+    0x03800000, 0x03b80000, 0x03880000, 0x03c80000,
+    0x05700000, 0x05200000, 0x05300000, 0x05100000,
+    0x05580000, 0x05180000, 0x05680000, 0x05400000,
+    0x05600000, 0x05780000, 0x05280000, 0x05500000,
+    0x05000000, 0x05380000, 0x05080000, 0x05480000,
+    0x06700000, 0x06200000, 0x06300000, 0x06100000,
+    0x06580000, 0x06180000, 0x06680000, 0x06400000,
+    0x06600000, 0x06780000, 0x06280000, 0x06500000,
+    0x06000000, 0x06380000, 0x06080000, 0x06480000,
+    0x06f00000, 0x06a00000, 0x06b00000, 0x06900000,
+    0x06d80000, 0x06980000, 0x06e80000, 0x06c00000,
+    0x06e00000, 0x06f80000, 0x06a80000, 0x06d00000,
+    0x06800000, 0x06b80000, 0x06880000, 0x06c80000,
+    0x00f00000, 0x00a00000, 0x00b00000, 0x00900000,
+    0x00d80000, 0x00980000, 0x00e80000, 0x00c00000,
+    0x00e00000, 0x00f80000, 0x00a80000, 0x00d00000,
+    0x00800000, 0x00b80000, 0x00880000, 0x00c80000,
+    0x01f00000, 0x01a00000, 0x01b00000, 0x01900000,
+    0x01d80000, 0x01980000, 0x01e80000, 0x01c00000,
+    0x01e00000, 0x01f80000, 0x01a80000, 0x01d00000,
+    0x01800000, 0x01b80000, 0x01880000, 0x01c80000,
+    0x04f00000, 0x04a00000, 0x04b00000, 0x04900000,
+    0x04d80000, 0x04980000, 0x04e80000, 0x04c00000,
+    0x04e00000, 0x04f80000, 0x04a80000, 0x04d00000,
+    0x04800000, 0x04b80000, 0x04880000, 0x04c80000,
+    0x00700000, 0x00200000, 0x00300000, 0x00100000,
+    0x00580000, 0x00180000, 0x00680000, 0x00400000,
+    0x00600000, 0x00780000, 0x00280000, 0x00500000,
+    0x00000000, 0x00380000, 0x00080000, 0x00480000,
+    0x01700000, 0x01200000, 0x01300000, 0x01100000,
+    0x01580000, 0x01180000, 0x01680000, 0x01400000,
+    0x01600000, 0x01780000, 0x01280000, 0x01500000,
+    0x01000000, 0x01380000, 0x01080000, 0x01480000,
+    0x05f00000, 0x05a00000, 0x05b00000, 0x05900000,
+    0x05d80000, 0x05980000, 0x05e80000, 0x05c00000,
+    0x05e00000, 0x05f80000, 0x05a80000, 0x05d00000,
+    0x05800000, 0x05b80000, 0x05880000, 0x05c80000,
+    0x02700000, 0x02200000, 0x02300000, 0x02100000,
+    0x02580000, 0x02180000, 0x02680000, 0x02400000,
+    0x02600000, 0x02780000, 0x02280000, 0x02500000,
+    0x02000000, 0x02380000, 0x02080000, 0x02480000,
+    0x07f00000, 0x07a00000, 0x07b00000, 0x07900000,
+    0x07d80000, 0x07980000, 0x07e80000, 0x07c00000,
+    0x07e00000, 0x07f80000, 0x07a80000, 0x07d00000,
+    0x07800000, 0x07b80000, 0x07880000, 0x07c80000,
+    0x04700000, 0x04200000, 0x04300000, 0x04100000,
+    0x04580000, 0x04180000, 0x04680000, 0x04400000,
+    0x04600000, 0x04780000, 0x04280000, 0x04500000,
+    0x04000000, 0x04380000, 0x04080000, 0x04480000,
+    0x02f00000, 0x02a00000, 0x02b00000, 0x02900000,
+    0x02d80000, 0x02980000, 0x02e80000, 0x02c00000,
+    0x02e00000, 0x02f80000, 0x02a80000, 0x02d00000,
+    0x02800000, 0x02b80000, 0x02880000, 0x02c80000,
+    0x03700000, 0x03200000, 0x03300000, 0x03100000,
+    0x03580000, 0x03180000, 0x03680000, 0x03400000,
+    0x03600000, 0x03780000, 0x03280000, 0x03500000,
+    0x03000000, 0x03380000, 0x03080000, 0x03480000,
+    /* 2 */
+    0xd8000001, 0xa8000001, 0x88000001, 0xc8000001,
+    0xc0000001, 0xe8000001, 0xf8000001, 0x80000001,
+    0xf0000001, 0xa0000001, 0x90000001, 0x98000001,
+    0xe0000001, 0xb8000001, 0xd0000001, 0xb0000001,
+    0x58000005, 0x28000005, 0x08000005, 0x48000005,
+    0x40000005, 0x68000005, 0x78000005, 0x00000005,
+    0x70000005, 0x20000005, 0x10000005, 0x18000005,
+    0x60000005, 0x38000005, 0x50000005, 0x30000005,
+    0xd8000006, 0xa8000006, 0x88000006, 0xc8000006,
+    0xc0000006, 0xe8000006, 0xf8000006, 0x80000006,
+    0xf0000006, 0xa0000006, 0x90000006, 0x98000006,
+    0xe0000006, 0xb8000006, 0xd0000006, 0xb0000006,
+    0x58000006, 0x28000006, 0x08000006, 0x48000006,
+    0x40000006, 0x68000006, 0x78000006, 0x00000006,
+    0x70000006, 0x20000006, 0x10000006, 0x18000006,
+    0x60000006, 0x38000006, 0x50000006, 0x30000006,
+    0xd8000000, 0xa8000000, 0x88000000, 0xc8000000,
+    0xc0000000, 0xe8000000, 0xf8000000, 0x80000000,
+    0xf0000000, 0xa0000000, 0x90000000, 0x98000000,
+    0xe0000000, 0xb8000000, 0xd0000000, 0xb0000000,
+    0x58000001, 0x28000001, 0x08000001, 0x48000001,
+    0x40000001, 0x68000001, 0x78000001, 0x00000001,
+    0x70000001, 0x20000001, 0x10000001, 0x18000001,
+    0x60000001, 0x38000001, 0x50000001, 0x30000001,
+    0x58000000, 0x28000000, 0x08000000, 0x48000000,
+    0x40000000, 0x68000000, 0x78000000, 0x00000000,
+    0x70000000, 0x20000000, 0x10000000, 0x18000000,
+    0x60000000, 0x38000000, 0x50000000, 0x30000000,
+    0xd8000005, 0xa8000005, 0x88000005, 0xc8000005,
+    0xc0000005, 0xe8000005, 0xf8000005, 0x80000005,
+    0xf0000005, 0xa0000005, 0x90000005, 0x98000005,
+    0xe0000005, 0xb8000005, 0xd0000005, 0xb0000005,
+    0xd8000003, 0xa8000003, 0x88000003, 0xc8000003,
+    0xc0000003, 0xe8000003, 0xf8000003, 0x80000003,
+    0xf0000003, 0xa0000003, 0x90000003, 0x98000003,
+    0xe0000003, 0xb8000003, 0xd0000003, 0xb0000003,
+    0xd8000002, 0xa8000002, 0x88000002, 0xc8000002,
+    0xc0000002, 0xe8000002, 0xf8000002, 0x80000002,
+    0xf0000002, 0xa0000002, 0x90000002, 0x98000002,
+    0xe0000002, 0xb8000002, 0xd0000002, 0xb0000002,
+    0xd8000004, 0xa8000004, 0x88000004, 0xc8000004,
+    0xc0000004, 0xe8000004, 0xf8000004, 0x80000004,
+    0xf0000004, 0xa0000004, 0x90000004, 0x98000004,
+    0xe0000004, 0xb8000004, 0xd0000004, 0xb0000004,
+    0x58000002, 0x28000002, 0x08000002, 0x48000002,
+    0x40000002, 0x68000002, 0x78000002, 0x00000002,
+    0x70000002, 0x20000002, 0x10000002, 0x18000002,
+    0x60000002, 0x38000002, 0x50000002, 0x30000002,
+    0x58000004, 0x28000004, 0x08000004, 0x48000004,
+    0x40000004, 0x68000004, 0x78000004, 0x00000004,
+    0x70000004, 0x20000004, 0x10000004, 0x18000004,
+    0x60000004, 0x38000004, 0x50000004, 0x30000004,
+    0xd8000007, 0xa8000007, 0x88000007, 0xc8000007,
+    0xc0000007, 0xe8000007, 0xf8000007, 0x80000007,
+    0xf0000007, 0xa0000007, 0x90000007, 0x98000007,
+    0xe0000007, 0xb8000007, 0xd0000007, 0xb0000007,
+    0x58000007, 0x28000007, 0x08000007, 0x48000007,
+    0x40000007, 0x68000007, 0x78000007, 0x00000007,
+    0x70000007, 0x20000007, 0x10000007, 0x18000007,
+    0x60000007, 0x38000007, 0x50000007, 0x30000007,
+    0x58000003, 0x28000003, 0x08000003, 0x48000003,
+    0x40000003, 0x68000003, 0x78000003, 0x00000003,
+    0x70000003, 0x20000003, 0x10000003, 0x18000003,
+    0x60000003, 0x38000003, 0x50000003, 0x30000003,
+    /* 3 */
+    0x00000588, 0x000005e8, 0x00000590, 0x000005c8,
+    0x000005b8, 0x000005d0, 0x000005b0, 0x00000580,
+    0x000005c0, 0x000005e0, 0x000005a0, 0x000005a8,
+    0x000005f8, 0x00000598, 0x000005d8, 0x000005f0,
+    0x00000508, 0x00000568, 0x00000510, 0x00000548,
+    0x00000538, 0x00000550, 0x00000530, 0x00000500,
+    0x00000540, 0x00000560, 0x00000520, 0x00000528,
+    0x00000578, 0x00000518, 0x00000558, 0x00000570,
+    0x00000788, 0x000007e8, 0x00000790, 0x000007c8,
+    0x000007b8, 0x000007d0, 0x000007b0, 0x00000780,
+    0x000007c0, 0x000007e0, 0x000007a0, 0x000007a8,
+    0x000007f8, 0x00000798, 0x000007d8, 0x000007f0,
+    0x00000288, 0x000002e8, 0x00000290, 0x000002c8,
+    0x000002b8, 0x000002d0, 0x000002b0, 0x00000280,
+    0x000002c0, 0x000002e0, 0x000002a0, 0x000002a8,
+    0x000002f8, 0x00000298, 0x000002d8, 0x000002f0,
+    0x00000008, 0x00000068, 0x00000010, 0x00000048,
+    0x00000038, 0x00000050, 0x00000030, 0x00000000,
+    0x00000040, 0x00000060, 0x00000020, 0x00000028,
+    0x00000078, 0x00000018, 0x00000058, 0x00000070,
+    0x00000608, 0x00000668, 0x00000610, 0x00000648,
+    0x00000638, 0x00000650, 0x00000630, 0x00000600,
+    0x00000640, 0x00000660, 0x00000620, 0x00000628,
+    0x00000678, 0x00000618, 0x00000658, 0x00000670,
+    0x00000708, 0x00000768, 0x00000710, 0x00000748,
+    0x00000738, 0x00000750, 0x00000730, 0x00000700,
+    0x00000740, 0x00000760, 0x00000720, 0x00000728,
+    0x00000778, 0x00000718, 0x00000758, 0x00000770,
+    0x00000408, 0x00000468, 0x00000410, 0x00000448,
+    0x00000438, 0x00000450, 0x00000430, 0x00000400,
+    0x00000440, 0x00000460, 0x00000420, 0x00000428,
+    0x00000478, 0x00000418, 0x00000458, 0x00000470,
+    0x00000308, 0x00000368, 0x00000310, 0x00000348,
+    0x00000338, 0x00000350, 0x00000330, 0x00000300,
+    0x00000340, 0x00000360, 0x00000320, 0x00000328,
+    0x00000378, 0x00000318, 0x00000358, 0x00000370,
+    0x00000108, 0x00000168, 0x00000110, 0x00000148,
+    0x00000138, 0x00000150, 0x00000130, 0x00000100,
+    0x00000140, 0x00000160, 0x00000120, 0x00000128,
+    0x00000178, 0x00000118, 0x00000158, 0x00000170,
+    0x00000188, 0x000001e8, 0x00000190, 0x000001c8,
+    0x000001b8, 0x000001d0, 0x000001b0, 0x00000180,
+    0x000001c0, 0x000001e0, 0x000001a0, 0x000001a8,
+    0x000001f8, 0x00000198, 0x000001d8, 0x000001f0,
+    0x00000488, 0x000004e8, 0x00000490, 0x000004c8,
+    0x000004b8, 0x000004d0, 0x000004b0, 0x00000480,
+    0x000004c0, 0x000004e0, 0x000004a0, 0x000004a8,
+    0x000004f8, 0x00000498, 0x000004d8, 0x000004f0,
+    0x00000088, 0x000000e8, 0x00000090, 0x000000c8,
+    0x000000b8, 0x000000d0, 0x000000b0, 0x00000080,
+    0x000000c0, 0x000000e0, 0x000000a0, 0x000000a8,
+    0x000000f8, 0x00000098, 0x000000d8, 0x000000f0,
+    0x00000388, 0x000003e8, 0x00000390, 0x000003c8,
+    0x000003b8, 0x000003d0, 0x000003b0, 0x00000380,
+    0x000003c0, 0x000003e0, 0x000003a0, 0x000003a8,
+    0x000003f8, 0x00000398, 0x000003d8, 0x000003f0,
+    0x00000688, 0x000006e8, 0x00000690, 0x000006c8,
+    0x000006b8, 0x000006d0, 0x000006b0, 0x00000680,
+    0x000006c0, 0x000006e0, 0x000006a0, 0x000006a8,
+    0x000006f8, 0x00000698, 0x000006d8, 0x000006f0,
+    0x00000208, 0x00000268, 0x00000210, 0x00000248,
+    0x00000238, 0x00000250, 0x00000230, 0x00000200,
+    0x00000240, 0x00000260, 0x00000220, 0x00000228,
+    0x00000278, 0x00000218, 0x00000258, 0x00000270,
+  };
+
+static const u32 sbox_CryptoPro_B[4*256] =
+  {
+    /* 0 */
+    0x00004000, 0x00002000, 0x00005800, 0x00000800,
+    0x00001800, 0x00002800, 0x00000000, 0x00004800,
+    0x00001000, 0x00007000, 0x00005000, 0x00006000,
+    0x00006800, 0x00003000, 0x00003800, 0x00007800,
+    0x0000c000, 0x0000a000, 0x0000d800, 0x00008800,
+    0x00009800, 0x0000a800, 0x00008000, 0x0000c800,
+    0x00009000, 0x0000f000, 0x0000d000, 0x0000e000,
+    0x0000e800, 0x0000b000, 0x0000b800, 0x0000f800,
+    0x00014000, 0x00012000, 0x00015800, 0x00010800,
+    0x00011800, 0x00012800, 0x00010000, 0x00014800,
+    0x00011000, 0x00017000, 0x00015000, 0x00016000,
+    0x00016800, 0x00013000, 0x00013800, 0x00017800,
+    0x00054000, 0x00052000, 0x00055800, 0x00050800,
+    0x00051800, 0x00052800, 0x00050000, 0x00054800,
+    0x00051000, 0x00057000, 0x00055000, 0x00056000,
+    0x00056800, 0x00053000, 0x00053800, 0x00057800,
+    0x00024000, 0x00022000, 0x00025800, 0x00020800,
+    0x00021800, 0x00022800, 0x00020000, 0x00024800,
+    0x00021000, 0x00027000, 0x00025000, 0x00026000,
+    0x00026800, 0x00023000, 0x00023800, 0x00027800,
+    0x0006c000, 0x0006a000, 0x0006d800, 0x00068800,
+    0x00069800, 0x0006a800, 0x00068000, 0x0006c800,
+    0x00069000, 0x0006f000, 0x0006d000, 0x0006e000,
+    0x0006e800, 0x0006b000, 0x0006b800, 0x0006f800,
+    0x0002c000, 0x0002a000, 0x0002d800, 0x00028800,
+    0x00029800, 0x0002a800, 0x00028000, 0x0002c800,
+    0x00029000, 0x0002f000, 0x0002d000, 0x0002e000,
+    0x0002e800, 0x0002b000, 0x0002b800, 0x0002f800,
+    0x00064000, 0x00062000, 0x00065800, 0x00060800,
+    0x00061800, 0x00062800, 0x00060000, 0x00064800,
+    0x00061000, 0x00067000, 0x00065000, 0x00066000,
+    0x00066800, 0x00063000, 0x00063800, 0x00067800,
+    0x0004c000, 0x0004a000, 0x0004d800, 0x00048800,
+    0x00049800, 0x0004a800, 0x00048000, 0x0004c800,
+    0x00049000, 0x0004f000, 0x0004d000, 0x0004e000,
+    0x0004e800, 0x0004b000, 0x0004b800, 0x0004f800,
+    0x0003c000, 0x0003a000, 0x0003d800, 0x00038800,
+    0x00039800, 0x0003a800, 0x00038000, 0x0003c800,
+    0x00039000, 0x0003f000, 0x0003d000, 0x0003e000,
+    0x0003e800, 0x0003b000, 0x0003b800, 0x0003f800,
+    0x0001c000, 0x0001a000, 0x0001d800, 0x00018800,
+    0x00019800, 0x0001a800, 0x00018000, 0x0001c800,
+    0x00019000, 0x0001f000, 0x0001d000, 0x0001e000,
+    0x0001e800, 0x0001b000, 0x0001b800, 0x0001f800,
+    0x0007c000, 0x0007a000, 0x0007d800, 0x00078800,
+    0x00079800, 0x0007a800, 0x00078000, 0x0007c800,
+    0x00079000, 0x0007f000, 0x0007d000, 0x0007e000,
+    0x0007e800, 0x0007b000, 0x0007b800, 0x0007f800,
+    0x0005c000, 0x0005a000, 0x0005d800, 0x00058800,
+    0x00059800, 0x0005a800, 0x00058000, 0x0005c800,
+    0x00059000, 0x0005f000, 0x0005d000, 0x0005e000,
+    0x0005e800, 0x0005b000, 0x0005b800, 0x0005f800,
+    0x00044000, 0x00042000, 0x00045800, 0x00040800,
+    0x00041800, 0x00042800, 0x00040000, 0x00044800,
+    0x00041000, 0x00047000, 0x00045000, 0x00046000,
+    0x00046800, 0x00043000, 0x00043800, 0x00047800,
+    0x00034000, 0x00032000, 0x00035800, 0x00030800,
+    0x00031800, 0x00032800, 0x00030000, 0x00034800,
+    0x00031000, 0x00037000, 0x00035000, 0x00036000,
+    0x00036800, 0x00033000, 0x00033800, 0x00037800,
+    0x00074000, 0x00072000, 0x00075800, 0x00070800,
+    0x00071800, 0x00072800, 0x00070000, 0x00074800,
+    0x00071000, 0x00077000, 0x00075000, 0x00076000,
+    0x00076800, 0x00073000, 0x00073800, 0x00077800,
+    /* 1 */
+    0x03f00000, 0x03e00000, 0x03800000, 0x03d00000,
+    0x03c80000, 0x03900000, 0x03e80000, 0x03d80000,
+    0x03b80000, 0x03a80000, 0x03c00000, 0x03f80000,
+    0x03980000, 0x03b00000, 0x03880000, 0x03a00000,
+    0x02f00000, 0x02e00000, 0x02800000, 0x02d00000,
+    0x02c80000, 0x02900000, 0x02e80000, 0x02d80000,
+    0x02b80000, 0x02a80000, 0x02c00000, 0x02f80000,
+    0x02980000, 0x02b00000, 0x02880000, 0x02a00000,
+    0x00700000, 0x00600000, 0x00000000, 0x00500000,
+    0x00480000, 0x00100000, 0x00680000, 0x00580000,
+    0x00380000, 0x00280000, 0x00400000, 0x00780000,
+    0x00180000, 0x00300000, 0x00080000, 0x00200000,
+    0x06f00000, 0x06e00000, 0x06800000, 0x06d00000,
+    0x06c80000, 0x06900000, 0x06e80000, 0x06d80000,
+    0x06b80000, 0x06a80000, 0x06c00000, 0x06f80000,
+    0x06980000, 0x06b00000, 0x06880000, 0x06a00000,
+    0x05f00000, 0x05e00000, 0x05800000, 0x05d00000,
+    0x05c80000, 0x05900000, 0x05e80000, 0x05d80000,
+    0x05b80000, 0x05a80000, 0x05c00000, 0x05f80000,
+    0x05980000, 0x05b00000, 0x05880000, 0x05a00000,
+    0x03700000, 0x03600000, 0x03000000, 0x03500000,
+    0x03480000, 0x03100000, 0x03680000, 0x03580000,
+    0x03380000, 0x03280000, 0x03400000, 0x03780000,
+    0x03180000, 0x03300000, 0x03080000, 0x03200000,
+    0x00f00000, 0x00e00000, 0x00800000, 0x00d00000,
+    0x00c80000, 0x00900000, 0x00e80000, 0x00d80000,
+    0x00b80000, 0x00a80000, 0x00c00000, 0x00f80000,
+    0x00980000, 0x00b00000, 0x00880000, 0x00a00000,
+    0x01700000, 0x01600000, 0x01000000, 0x01500000,
+    0x01480000, 0x01100000, 0x01680000, 0x01580000,
+    0x01380000, 0x01280000, 0x01400000, 0x01780000,
+    0x01180000, 0x01300000, 0x01080000, 0x01200000,
+    0x01f00000, 0x01e00000, 0x01800000, 0x01d00000,
+    0x01c80000, 0x01900000, 0x01e80000, 0x01d80000,
+    0x01b80000, 0x01a80000, 0x01c00000, 0x01f80000,
+    0x01980000, 0x01b00000, 0x01880000, 0x01a00000,
+    0x05700000, 0x05600000, 0x05000000, 0x05500000,
+    0x05480000, 0x05100000, 0x05680000, 0x05580000,
+    0x05380000, 0x05280000, 0x05400000, 0x05780000,
+    0x05180000, 0x05300000, 0x05080000, 0x05200000,
+    0x06700000, 0x06600000, 0x06000000, 0x06500000,
+    0x06480000, 0x06100000, 0x06680000, 0x06580000,
+    0x06380000, 0x06280000, 0x06400000, 0x06780000,
+    0x06180000, 0x06300000, 0x06080000, 0x06200000,
+    0x07f00000, 0x07e00000, 0x07800000, 0x07d00000,
+    0x07c80000, 0x07900000, 0x07e80000, 0x07d80000,
+    0x07b80000, 0x07a80000, 0x07c00000, 0x07f80000,
+    0x07980000, 0x07b00000, 0x07880000, 0x07a00000,
+    0x02700000, 0x02600000, 0x02000000, 0x02500000,
+    0x02480000, 0x02100000, 0x02680000, 0x02580000,
+    0x02380000, 0x02280000, 0x02400000, 0x02780000,
+    0x02180000, 0x02300000, 0x02080000, 0x02200000,
+    0x07700000, 0x07600000, 0x07000000, 0x07500000,
+    0x07480000, 0x07100000, 0x07680000, 0x07580000,
+    0x07380000, 0x07280000, 0x07400000, 0x07780000,
+    0x07180000, 0x07300000, 0x07080000, 0x07200000,
+    0x04f00000, 0x04e00000, 0x04800000, 0x04d00000,
+    0x04c80000, 0x04900000, 0x04e80000, 0x04d80000,
+    0x04b80000, 0x04a80000, 0x04c00000, 0x04f80000,
+    0x04980000, 0x04b00000, 0x04880000, 0x04a00000,
+    0x04700000, 0x04600000, 0x04000000, 0x04500000,
+    0x04480000, 0x04100000, 0x04680000, 0x04580000,
+    0x04380000, 0x04280000, 0x04400000, 0x04780000,
+    0x04180000, 0x04300000, 0x04080000, 0x04200000,
+    /* 2 */
+    0x10000004, 0x38000004, 0x60000004, 0x78000004,
+    0x48000004, 0x28000004, 0x50000004, 0x58000004,
+    0x08000004, 0x20000004, 0x00000004, 0x68000004,
+    0x30000004, 0x40000004, 0x70000004, 0x18000004,
+    0x90000001, 0xb8000001, 0xe0000001, 0xf8000001,
+    0xc8000001, 0xa8000001, 0xd0000001, 0xd8000001,
+    0x88000001, 0xa0000001, 0x80000001, 0xe8000001,
+    0xb0000001, 0xc0000001, 0xf0000001, 0x98000001,
+    0x10000001, 0x38000001, 0x60000001, 0x78000001,
+    0x48000001, 0x28000001, 0x50000001, 0x58000001,
+    0x08000001, 0x20000001, 0x00000001, 0x68000001,
+    0x30000001, 0x40000001, 0x70000001, 0x18000001,
+    0x10000003, 0x38000003, 0x60000003, 0x78000003,
+    0x48000003, 0x28000003, 0x50000003, 0x58000003,
+    0x08000003, 0x20000003, 0x00000003, 0x68000003,
+    0x30000003, 0x40000003, 0x70000003, 0x18000003,
+    0x10000002, 0x38000002, 0x60000002, 0x78000002,
+    0x48000002, 0x28000002, 0x50000002, 0x58000002,
+    0x08000002, 0x20000002, 0x00000002, 0x68000002,
+    0x30000002, 0x40000002, 0x70000002, 0x18000002,
+    0x90000006, 0xb8000006, 0xe0000006, 0xf8000006,
+    0xc8000006, 0xa8000006, 0xd0000006, 0xd8000006,
+    0x88000006, 0xa0000006, 0x80000006, 0xe8000006,
+    0xb0000006, 0xc0000006, 0xf0000006, 0x98000006,
+    0x10000007, 0x38000007, 0x60000007, 0x78000007,
+    0x48000007, 0x28000007, 0x50000007, 0x58000007,
+    0x08000007, 0x20000007, 0x00000007, 0x68000007,
+    0x30000007, 0x40000007, 0x70000007, 0x18000007,
+    0x90000005, 0xb8000005, 0xe0000005, 0xf8000005,
+    0xc8000005, 0xa8000005, 0xd0000005, 0xd8000005,
+    0x88000005, 0xa0000005, 0x80000005, 0xe8000005,
+    0xb0000005, 0xc0000005, 0xf0000005, 0x98000005,
+    0x10000006, 0x38000006, 0x60000006, 0x78000006,
+    0x48000006, 0x28000006, 0x50000006, 0x58000006,
+    0x08000006, 0x20000006, 0x00000006, 0x68000006,
+    0x30000006, 0x40000006, 0x70000006, 0x18000006,
+    0x90000000, 0xb8000000, 0xe0000000, 0xf8000000,
+    0xc8000000, 0xa8000000, 0xd0000000, 0xd8000000,
+    0x88000000, 0xa0000000, 0x80000000, 0xe8000000,
+    0xb0000000, 0xc0000000, 0xf0000000, 0x98000000,
+    0x90000003, 0xb8000003, 0xe0000003, 0xf8000003,
+    0xc8000003, 0xa8000003, 0xd0000003, 0xd8000003,
+    0x88000003, 0xa0000003, 0x80000003, 0xe8000003,
+    0xb0000003, 0xc0000003, 0xf0000003, 0x98000003,
+    0x90000007, 0xb8000007, 0xe0000007, 0xf8000007,
+    0xc8000007, 0xa8000007, 0xd0000007, 0xd8000007,
+    0x88000007, 0xa0000007, 0x80000007, 0xe8000007,
+    0xb0000007, 0xc0000007, 0xf0000007, 0x98000007,
+    0x10000005, 0x38000005, 0x60000005, 0x78000005,
+    0x48000005, 0x28000005, 0x50000005, 0x58000005,
+    0x08000005, 0x20000005, 0x00000005, 0x68000005,
+    0x30000005, 0x40000005, 0x70000005, 0x18000005,
+    0x10000000, 0x38000000, 0x60000000, 0x78000000,
+    0x48000000, 0x28000000, 0x50000000, 0x58000000,
+    0x08000000, 0x20000000, 0x00000000, 0x68000000,
+    0x30000000, 0x40000000, 0x70000000, 0x18000000,
+    0x90000004, 0xb8000004, 0xe0000004, 0xf8000004,
+    0xc8000004, 0xa8000004, 0xd0000004, 0xd8000004,
+    0x88000004, 0xa0000004, 0x80000004, 0xe8000004,
+    0xb0000004, 0xc0000004, 0xf0000004, 0x98000004,
+    0x90000002, 0xb8000002, 0xe0000002, 0xf8000002,
+    0xc8000002, 0xa8000002, 0xd0000002, 0xd8000002,
+    0x88000002, 0xa0000002, 0x80000002, 0xe8000002,
+    0xb0000002, 0xc0000002, 0xf0000002, 0x98000002,
+    /* 3 */
+    0x00000028, 0x00000010, 0x00000050, 0x00000058,
+    0x00000048, 0x00000008, 0x00000060, 0x00000018,
+    0x00000038, 0x00000020, 0x00000068, 0x00000000,
+    0x00000030, 0x00000078, 0x00000040, 0x00000070,
+    0x00000228, 0x00000210, 0x00000250, 0x00000258,
+    0x00000248, 0x00000208, 0x00000260, 0x00000218,
+    0x00000238, 0x00000220, 0x00000268, 0x00000200,
+    0x00000230, 0x00000278, 0x00000240, 0x00000270,
+    0x000005a8, 0x00000590, 0x000005d0, 0x000005d8,
+    0x000005c8, 0x00000588, 0x000005e0, 0x00000598,
+    0x000005b8, 0x000005a0, 0x000005e8, 0x00000580,
+    0x000005b0, 0x000005f8, 0x000005c0, 0x000005f0,
+    0x00000728, 0x00000710, 0x00000750, 0x00000758,
+    0x00000748, 0x00000708, 0x00000760, 0x00000718,
+    0x00000738, 0x00000720, 0x00000768, 0x00000700,
+    0x00000730, 0x00000778, 0x00000740, 0x00000770,
+    0x00000428, 0x00000410, 0x00000450, 0x00000458,
+    0x00000448, 0x00000408, 0x00000460, 0x00000418,
+    0x00000438, 0x00000420, 0x00000468, 0x00000400,
+    0x00000430, 0x00000478, 0x00000440, 0x00000470,
+    0x000001a8, 0x00000190, 0x000001d0, 0x000001d8,
+    0x000001c8, 0x00000188, 0x000001e0, 0x00000198,
+    0x000001b8, 0x000001a0, 0x000001e8, 0x00000180,
+    0x000001b0, 0x000001f8, 0x000001c0, 0x000001f0,
+    0x000003a8, 0x00000390, 0x000003d0, 0x000003d8,
+    0x000003c8, 0x00000388, 0x000003e0, 0x00000398,
+    0x000003b8, 0x000003a0, 0x000003e8, 0x00000380,
+    0x000003b0, 0x000003f8, 0x000003c0, 0x000003f0,
+    0x000000a8, 0x00000090, 0x000000d0, 0x000000d8,
+    0x000000c8, 0x00000088, 0x000000e0, 0x00000098,
+    0x000000b8, 0x000000a0, 0x000000e8, 0x00000080,
+    0x000000b0, 0x000000f8, 0x000000c0, 0x000000f0,
+    0x00000528, 0x00000510, 0x00000550, 0x00000558,
+    0x00000548, 0x00000508, 0x00000560, 0x00000518,
+    0x00000538, 0x00000520, 0x00000568, 0x00000500,
+    0x00000530, 0x00000578, 0x00000540, 0x00000570,
+    0x00000128, 0x00000110, 0x00000150, 0x00000158,
+    0x00000148, 0x00000108, 0x00000160, 0x00000118,
+    0x00000138, 0x00000120, 0x00000168, 0x00000100,
+    0x00000130, 0x00000178, 0x00000140, 0x00000170,
+    0x000004a8, 0x00000490, 0x000004d0, 0x000004d8,
+    0x000004c8, 0x00000488, 0x000004e0, 0x00000498,
+    0x000004b8, 0x000004a0, 0x000004e8, 0x00000480,
+    0x000004b0, 0x000004f8, 0x000004c0, 0x000004f0,
+    0x00000328, 0x00000310, 0x00000350, 0x00000358,
+    0x00000348, 0x00000308, 0x00000360, 0x00000318,
+    0x00000338, 0x00000320, 0x00000368, 0x00000300,
+    0x00000330, 0x00000378, 0x00000340, 0x00000370,
+    0x000007a8, 0x00000790, 0x000007d0, 0x000007d8,
+    0x000007c8, 0x00000788, 0x000007e0, 0x00000798,
+    0x000007b8, 0x000007a0, 0x000007e8, 0x00000780,
+    0x000007b0, 0x000007f8, 0x000007c0, 0x000007f0,
+    0x000006a8, 0x00000690, 0x000006d0, 0x000006d8,
+    0x000006c8, 0x00000688, 0x000006e0, 0x00000698,
+    0x000006b8, 0x000006a0, 0x000006e8, 0x00000680,
+    0x000006b0, 0x000006f8, 0x000006c0, 0x000006f0,
+    0x000002a8, 0x00000290, 0x000002d0, 0x000002d8,
+    0x000002c8, 0x00000288, 0x000002e0, 0x00000298,
+    0x000002b8, 0x000002a0, 0x000002e8, 0x00000280,
+    0x000002b0, 0x000002f8, 0x000002c0, 0x000002f0,
+    0x00000628, 0x00000610, 0x00000650, 0x00000658,
+    0x00000648, 0x00000608, 0x00000660, 0x00000618,
+    0x00000638, 0x00000620, 0x00000668, 0x00000600,
+    0x00000630, 0x00000678, 0x00000640, 0x00000670,
+  };
+
+static const u32 sbox_CryptoPro_C[4*256] =
+  {
+    /* 0 */
+    0x00000800, 0x00005800, 0x00006000, 0x00001000,
+    0x00004800, 0x00006800, 0x00000000, 0x00007800,
+    0x00002000, 0x00002800, 0x00004000, 0x00007000,
+    0x00005000, 0x00003800, 0x00003000, 0x00001800,
+    0x00008800, 0x0000d800, 0x0000e000, 0x00009000,
+    0x0000c800, 0x0000e800, 0x00008000, 0x0000f800,
+    0x0000a000, 0x0000a800, 0x0000c000, 0x0000f000,
+    0x0000d000, 0x0000b800, 0x0000b000, 0x00009800,
+    0x00038800, 0x0003d800, 0x0003e000, 0x00039000,
+    0x0003c800, 0x0003e800, 0x00038000, 0x0003f800,
+    0x0003a000, 0x0003a800, 0x0003c000, 0x0003f000,
+    0x0003d000, 0x0003b800, 0x0003b000, 0x00039800,
+    0x00068800, 0x0006d800, 0x0006e000, 0x00069000,
+    0x0006c800, 0x0006e800, 0x00068000, 0x0006f800,
+    0x0006a000, 0x0006a800, 0x0006c000, 0x0006f000,
+    0x0006d000, 0x0006b800, 0x0006b000, 0x00069800,
+    0x00058800, 0x0005d800, 0x0005e000, 0x00059000,
+    0x0005c800, 0x0005e800, 0x00058000, 0x0005f800,
+    0x0005a000, 0x0005a800, 0x0005c000, 0x0005f000,
+    0x0005d000, 0x0005b800, 0x0005b000, 0x00059800,
+    0x00020800, 0x00025800, 0x00026000, 0x00021000,
+    0x00024800, 0x00026800, 0x00020000, 0x00027800,
+    0x00022000, 0x00022800, 0x00024000, 0x00027000,
+    0x00025000, 0x00023800, 0x00023000, 0x00021800,
+    0x00028800, 0x0002d800, 0x0002e000, 0x00029000,
+    0x0002c800, 0x0002e800, 0x00028000, 0x0002f800,
+    0x0002a000, 0x0002a800, 0x0002c000, 0x0002f000,
+    0x0002d000, 0x0002b800, 0x0002b000, 0x00029800,
+    0x00010800, 0x00015800, 0x00016000, 0x00011000,
+    0x00014800, 0x00016800, 0x00010000, 0x00017800,
+    0x00012000, 0x00012800, 0x00014000, 0x00017000,
+    0x00015000, 0x00013800, 0x00013000, 0x00011800,
+    0x00040800, 0x00045800, 0x00046000, 0x00041000,
+    0x00044800, 0x00046800, 0x00040000, 0x00047800,
+    0x00042000, 0x00042800, 0x00044000, 0x00047000,
+    0x00045000, 0x00043800, 0x00043000, 0x00041800,
+    0x00070800, 0x00075800, 0x00076000, 0x00071000,
+    0x00074800, 0x00076800, 0x00070000, 0x00077800,
+    0x00072000, 0x00072800, 0x00074000, 0x00077000,
+    0x00075000, 0x00073800, 0x00073000, 0x00071800,
+    0x00078800, 0x0007d800, 0x0007e000, 0x00079000,
+    0x0007c800, 0x0007e800, 0x00078000, 0x0007f800,
+    0x0007a000, 0x0007a800, 0x0007c000, 0x0007f000,
+    0x0007d000, 0x0007b800, 0x0007b000, 0x00079800,
+    0x00060800, 0x00065800, 0x00066000, 0x00061000,
+    0x00064800, 0x00066800, 0x00060000, 0x00067800,
+    0x00062000, 0x00062800, 0x00064000, 0x00067000,
+    0x00065000, 0x00063800, 0x00063000, 0x00061800,
+    0x00048800, 0x0004d800, 0x0004e000, 0x00049000,
+    0x0004c800, 0x0004e800, 0x00048000, 0x0004f800,
+    0x0004a000, 0x0004a800, 0x0004c000, 0x0004f000,
+    0x0004d000, 0x0004b800, 0x0004b000, 0x00049800,
+    0x00050800, 0x00055800, 0x00056000, 0x00051000,
+    0x00054800, 0x00056800, 0x00050000, 0x00057800,
+    0x00052000, 0x00052800, 0x00054000, 0x00057000,
+    0x00055000, 0x00053800, 0x00053000, 0x00051800,
+    0x00030800, 0x00035800, 0x00036000, 0x00031000,
+    0x00034800, 0x00036800, 0x00030000, 0x00037800,
+    0x00032000, 0x00032800, 0x00034000, 0x00037000,
+    0x00035000, 0x00033800, 0x00033000, 0x00031800,
+    0x00018800, 0x0001d800, 0x0001e000, 0x00019000,
+    0x0001c800, 0x0001e800, 0x00018000, 0x0001f800,
+    0x0001a000, 0x0001a800, 0x0001c000, 0x0001f000,
+    0x0001d000, 0x0001b800, 0x0001b000, 0x00019800,
+    /* 1 */
+    0x01c00000, 0x01900000, 0x01a80000, 0x01800000,
+    0x01a00000, 0x01c80000, 0x01f80000, 0x01d00000,
+    0x01980000, 0x01b80000, 0x01e00000, 0x01e80000,
+    0x01b00000, 0x01f00000, 0x01880000, 0x01d80000,
+    0x03400000, 0x03100000, 0x03280000, 0x03000000,
+    0x03200000, 0x03480000, 0x03780000, 0x03500000,
+    0x03180000, 0x03380000, 0x03600000, 0x03680000,
+    0x03300000, 0x03700000, 0x03080000, 0x03580000,
+    0x00400000, 0x00100000, 0x00280000, 0x00000000,
+    0x00200000, 0x00480000, 0x00780000, 0x00500000,
+    0x00180000, 0x00380000, 0x00600000, 0x00680000,
+    0x00300000, 0x00700000, 0x00080000, 0x00580000,
+    0x00c00000, 0x00900000, 0x00a80000, 0x00800000,
+    0x00a00000, 0x00c80000, 0x00f80000, 0x00d00000,
+    0x00980000, 0x00b80000, 0x00e00000, 0x00e80000,
+    0x00b00000, 0x00f00000, 0x00880000, 0x00d80000,
+    0x02c00000, 0x02900000, 0x02a80000, 0x02800000,
+    0x02a00000, 0x02c80000, 0x02f80000, 0x02d00000,
+    0x02980000, 0x02b80000, 0x02e00000, 0x02e80000,
+    0x02b00000, 0x02f00000, 0x02880000, 0x02d80000,
+    0x06c00000, 0x06900000, 0x06a80000, 0x06800000,
+    0x06a00000, 0x06c80000, 0x06f80000, 0x06d00000,
+    0x06980000, 0x06b80000, 0x06e00000, 0x06e80000,
+    0x06b00000, 0x06f00000, 0x06880000, 0x06d80000,
+    0x05400000, 0x05100000, 0x05280000, 0x05000000,
+    0x05200000, 0x05480000, 0x05780000, 0x05500000,
+    0x05180000, 0x05380000, 0x05600000, 0x05680000,
+    0x05300000, 0x05700000, 0x05080000, 0x05580000,
+    0x04400000, 0x04100000, 0x04280000, 0x04000000,
+    0x04200000, 0x04480000, 0x04780000, 0x04500000,
+    0x04180000, 0x04380000, 0x04600000, 0x04680000,
+    0x04300000, 0x04700000, 0x04080000, 0x04580000,
+    0x05c00000, 0x05900000, 0x05a80000, 0x05800000,
+    0x05a00000, 0x05c80000, 0x05f80000, 0x05d00000,
+    0x05980000, 0x05b80000, 0x05e00000, 0x05e80000,
+    0x05b00000, 0x05f00000, 0x05880000, 0x05d80000,
+    0x01400000, 0x01100000, 0x01280000, 0x01000000,
+    0x01200000, 0x01480000, 0x01780000, 0x01500000,
+    0x01180000, 0x01380000, 0x01600000, 0x01680000,
+    0x01300000, 0x01700000, 0x01080000, 0x01580000,
+    0x04c00000, 0x04900000, 0x04a80000, 0x04800000,
+    0x04a00000, 0x04c80000, 0x04f80000, 0x04d00000,
+    0x04980000, 0x04b80000, 0x04e00000, 0x04e80000,
+    0x04b00000, 0x04f00000, 0x04880000, 0x04d80000,
+    0x03c00000, 0x03900000, 0x03a80000, 0x03800000,
+    0x03a00000, 0x03c80000, 0x03f80000, 0x03d00000,
+    0x03980000, 0x03b80000, 0x03e00000, 0x03e80000,
+    0x03b00000, 0x03f00000, 0x03880000, 0x03d80000,
+    0x07400000, 0x07100000, 0x07280000, 0x07000000,
+    0x07200000, 0x07480000, 0x07780000, 0x07500000,
+    0x07180000, 0x07380000, 0x07600000, 0x07680000,
+    0x07300000, 0x07700000, 0x07080000, 0x07580000,
+    0x07c00000, 0x07900000, 0x07a80000, 0x07800000,
+    0x07a00000, 0x07c80000, 0x07f80000, 0x07d00000,
+    0x07980000, 0x07b80000, 0x07e00000, 0x07e80000,
+    0x07b00000, 0x07f00000, 0x07880000, 0x07d80000,
+    0x06400000, 0x06100000, 0x06280000, 0x06000000,
+    0x06200000, 0x06480000, 0x06780000, 0x06500000,
+    0x06180000, 0x06380000, 0x06600000, 0x06680000,
+    0x06300000, 0x06700000, 0x06080000, 0x06580000,
+    0x02400000, 0x02100000, 0x02280000, 0x02000000,
+    0x02200000, 0x02480000, 0x02780000, 0x02500000,
+    0x02180000, 0x02380000, 0x02600000, 0x02680000,
+    0x02300000, 0x02700000, 0x02080000, 0x02580000,
+    /* 2 */
+    0x40000006, 0x68000006, 0x58000006, 0x00000006,
+    0x20000006, 0x28000006, 0x08000006, 0x10000006,
+    0x48000006, 0x18000006, 0x60000006, 0x70000006,
+    0x30000006, 0x78000006, 0x50000006, 0x38000006,
+    0xc0000004, 0xe8000004, 0xd8000004, 0x80000004,
+    0xa0000004, 0xa8000004, 0x88000004, 0x90000004,
+    0xc8000004, 0x98000004, 0xe0000004, 0xf0000004,
+    0xb0000004, 0xf8000004, 0xd0000004, 0xb8000004,
+    0xc0000005, 0xe8000005, 0xd8000005, 0x80000005,
+    0xa0000005, 0xa8000005, 0x88000005, 0x90000005,
+    0xc8000005, 0x98000005, 0xe0000005, 0xf0000005,
+    0xb0000005, 0xf8000005, 0xd0000005, 0xb8000005,
+    0xc0000000, 0xe8000000, 0xd8000000, 0x80000000,
+    0xa0000000, 0xa8000000, 0x88000000, 0x90000000,
+    0xc8000000, 0x98000000, 0xe0000000, 0xf0000000,
+    0xb0000000, 0xf8000000, 0xd0000000, 0xb8000000,
+    0x40000004, 0x68000004, 0x58000004, 0x00000004,
+    0x20000004, 0x28000004, 0x08000004, 0x10000004,
+    0x48000004, 0x18000004, 0x60000004, 0x70000004,
+    0x30000004, 0x78000004, 0x50000004, 0x38000004,
+    0x40000007, 0x68000007, 0x58000007, 0x00000007,
+    0x20000007, 0x28000007, 0x08000007, 0x10000007,
+    0x48000007, 0x18000007, 0x60000007, 0x70000007,
+    0x30000007, 0x78000007, 0x50000007, 0x38000007,
+    0x40000001, 0x68000001, 0x58000001, 0x00000001,
+    0x20000001, 0x28000001, 0x08000001, 0x10000001,
+    0x48000001, 0x18000001, 0x60000001, 0x70000001,
+    0x30000001, 0x78000001, 0x50000001, 0x38000001,
+    0x40000002, 0x68000002, 0x58000002, 0x00000002,
+    0x20000002, 0x28000002, 0x08000002, 0x10000002,
+    0x48000002, 0x18000002, 0x60000002, 0x70000002,
+    0x30000002, 0x78000002, 0x50000002, 0x38000002,
+    0xc0000003, 0xe8000003, 0xd8000003, 0x80000003,
+    0xa0000003, 0xa8000003, 0x88000003, 0x90000003,
+    0xc8000003, 0x98000003, 0xe0000003, 0xf0000003,
+    0xb0000003, 0xf8000003, 0xd0000003, 0xb8000003,
+    0xc0000001, 0xe8000001, 0xd8000001, 0x80000001,
+    0xa0000001, 0xa8000001, 0x88000001, 0x90000001,
+    0xc8000001, 0x98000001, 0xe0000001, 0xf0000001,
+    0xb0000001, 0xf8000001, 0xd0000001, 0xb8000001,
+    0x40000003, 0x68000003, 0x58000003, 0x00000003,
+    0x20000003, 0x28000003, 0x08000003, 0x10000003,
+    0x48000003, 0x18000003, 0x60000003, 0x70000003,
+    0x30000003, 0x78000003, 0x50000003, 0x38000003,
+    0xc0000002, 0xe8000002, 0xd8000002, 0x80000002,
+    0xa0000002, 0xa8000002, 0x88000002, 0x90000002,
+    0xc8000002, 0x98000002, 0xe0000002, 0xf0000002,
+    0xb0000002, 0xf8000002, 0xd0000002, 0xb8000002,
+    0x40000005, 0x68000005, 0x58000005, 0x00000005,
+    0x20000005, 0x28000005, 0x08000005, 0x10000005,
+    0x48000005, 0x18000005, 0x60000005, 0x70000005,
+    0x30000005, 0x78000005, 0x50000005, 0x38000005,
+    0x40000000, 0x68000000, 0x58000000, 0x00000000,
+    0x20000000, 0x28000000, 0x08000000, 0x10000000,
+    0x48000000, 0x18000000, 0x60000000, 0x70000000,
+    0x30000000, 0x78000000, 0x50000000, 0x38000000,
+    0xc0000007, 0xe8000007, 0xd8000007, 0x80000007,
+    0xa0000007, 0xa8000007, 0x88000007, 0x90000007,
+    0xc8000007, 0x98000007, 0xe0000007, 0xf0000007,
+    0xb0000007, 0xf8000007, 0xd0000007, 0xb8000007,
+    0xc0000006, 0xe8000006, 0xd8000006, 0x80000006,
+    0xa0000006, 0xa8000006, 0x88000006, 0x90000006,
+    0xc8000006, 0x98000006, 0xe0000006, 0xf0000006,
+    0xb0000006, 0xf8000006, 0xd0000006, 0xb8000006,
+    /* 3 */
+    0x000003d0, 0x000003c8, 0x000003b0, 0x000003c0,
+    0x000003e8, 0x000003f0, 0x00000390, 0x00000380,
+    0x000003f8, 0x00000398, 0x000003a8, 0x000003d8,
+    0x000003a0, 0x00000388, 0x000003e0, 0x000003b8,
+    0x00000250, 0x00000248, 0x00000230, 0x00000240,
+    0x00000268, 0x00000270, 0x00000210, 0x00000200,
+    0x00000278, 0x00000218, 0x00000228, 0x00000258,
+    0x00000220, 0x00000208, 0x00000260, 0x00000238,
+    0x00000050, 0x00000048, 0x00000030, 0x00000040,
+    0x00000068, 0x00000070, 0x00000010, 0x00000000,
+    0x00000078, 0x00000018, 0x00000028, 0x00000058,
+    0x00000020, 0x00000008, 0x00000060, 0x00000038,
+    0x000002d0, 0x000002c8, 0x000002b0, 0x000002c0,
+    0x000002e8, 0x000002f0, 0x00000290, 0x00000280,
+    0x000002f8, 0x00000298, 0x000002a8, 0x000002d8,
+    0x000002a0, 0x00000288, 0x000002e0, 0x000002b8,
+    0x00000550, 0x00000548, 0x00000530, 0x00000540,
+    0x00000568, 0x00000570, 0x00000510, 0x00000500,
+    0x00000578, 0x00000518, 0x00000528, 0x00000558,
+    0x00000520, 0x00000508, 0x00000560, 0x00000538,
+    0x00000150, 0x00000148, 0x00000130, 0x00000140,
+    0x00000168, 0x00000170, 0x00000110, 0x00000100,
+    0x00000178, 0x00000118, 0x00000128, 0x00000158,
+    0x00000120, 0x00000108, 0x00000160, 0x00000138,
+    0x000007d0, 0x000007c8, 0x000007b0, 0x000007c0,
+    0x000007e8, 0x000007f0, 0x00000790, 0x00000780,
+    0x000007f8, 0x00000798, 0x000007a8, 0x000007d8,
+    0x000007a0, 0x00000788, 0x000007e0, 0x000007b8,
+    0x00000750, 0x00000748, 0x00000730, 0x00000740,
+    0x00000768, 0x00000770, 0x00000710, 0x00000700,
+    0x00000778, 0x00000718, 0x00000728, 0x00000758,
+    0x00000720, 0x00000708, 0x00000760, 0x00000738,
+    0x00000650, 0x00000648, 0x00000630, 0x00000640,
+    0x00000668, 0x00000670, 0x00000610, 0x00000600,
+    0x00000678, 0x00000618, 0x00000628, 0x00000658,
+    0x00000620, 0x00000608, 0x00000660, 0x00000638,
+    0x00000350, 0x00000348, 0x00000330, 0x00000340,
+    0x00000368, 0x00000370, 0x00000310, 0x00000300,
+    0x00000378, 0x00000318, 0x00000328, 0x00000358,
+    0x00000320, 0x00000308, 0x00000360, 0x00000338,
+    0x000000d0, 0x000000c8, 0x000000b0, 0x000000c0,
+    0x000000e8, 0x000000f0, 0x00000090, 0x00000080,
+    0x000000f8, 0x00000098, 0x000000a8, 0x000000d8,
+    0x000000a0, 0x00000088, 0x000000e0, 0x000000b8,
+    0x000005d0, 0x000005c8, 0x000005b0, 0x000005c0,
+    0x000005e8, 0x000005f0, 0x00000590, 0x00000580,
+    0x000005f8, 0x00000598, 0x000005a8, 0x000005d8,
+    0x000005a0, 0x00000588, 0x000005e0, 0x000005b8,
+    0x000006d0, 0x000006c8, 0x000006b0, 0x000006c0,
+    0x000006e8, 0x000006f0, 0x00000690, 0x00000680,
+    0x000006f8, 0x00000698, 0x000006a8, 0x000006d8,
+    0x000006a0, 0x00000688, 0x000006e0, 0x000006b8,
+    0x000004d0, 0x000004c8, 0x000004b0, 0x000004c0,
+    0x000004e8, 0x000004f0, 0x00000490, 0x00000480,
+    0x000004f8, 0x00000498, 0x000004a8, 0x000004d8,
+    0x000004a0, 0x00000488, 0x000004e0, 0x000004b8,
+    0x000001d0, 0x000001c8, 0x000001b0, 0x000001c0,
+    0x000001e8, 0x000001f0, 0x00000190, 0x00000180,
+    0x000001f8, 0x00000198, 0x000001a8, 0x000001d8,
+    0x000001a0, 0x00000188, 0x000001e0, 0x000001b8,
+    0x00000450, 0x00000448, 0x00000430, 0x00000440,
+    0x00000468, 0x00000470, 0x00000410, 0x00000400,
+    0x00000478, 0x00000418, 0x00000428, 0x00000458,
+    0x00000420, 0x00000408, 0x00000460, 0x00000438,
+  };
+
+static const u32 sbox_CryptoPro_D[4*256] =
+  {
+    /* 0 */
+    0x0005f800, 0x0005e000, 0x00059000, 0x0005d000,
+    0x0005b000, 0x0005a000, 0x0005a800, 0x00058000,
+    0x0005b800, 0x0005c800, 0x0005f000, 0x0005e800,
+    0x00058800, 0x0005d800, 0x0005c000, 0x00059800,
+    0x00037800, 0x00036000, 0x00031000, 0x00035000,
+    0x00033000, 0x00032000, 0x00032800, 0x00030000,
+    0x00033800, 0x00034800, 0x00037000, 0x00036800,
+    0x00030800, 0x00035800, 0x00034000, 0x00031800,
+    0x0001f800, 0x0001e000, 0x00019000, 0x0001d000,
+    0x0001b000, 0x0001a000, 0x0001a800, 0x00018000,
+    0x0001b800, 0x0001c800, 0x0001f000, 0x0001e800,
+    0x00018800, 0x0001d800, 0x0001c000, 0x00019800,
+    0x00027800, 0x00026000, 0x00021000, 0x00025000,
+    0x00023000, 0x00022000, 0x00022800, 0x00020000,
+    0x00023800, 0x00024800, 0x00027000, 0x00026800,
+    0x00020800, 0x00025800, 0x00024000, 0x00021800,
+    0x00067800, 0x00066000, 0x00061000, 0x00065000,
+    0x00063000, 0x00062000, 0x00062800, 0x00060000,
+    0x00063800, 0x00064800, 0x00067000, 0x00066800,
+    0x00060800, 0x00065800, 0x00064000, 0x00061800,
+    0x0007f800, 0x0007e000, 0x00079000, 0x0007d000,
+    0x0007b000, 0x0007a000, 0x0007a800, 0x00078000,
+    0x0007b800, 0x0007c800, 0x0007f000, 0x0007e800,
+    0x00078800, 0x0007d800, 0x0007c000, 0x00079800,
+    0x00077800, 0x00076000, 0x00071000, 0x00075000,
+    0x00073000, 0x00072000, 0x00072800, 0x00070000,
+    0x00073800, 0x00074800, 0x00077000, 0x00076800,
+    0x00070800, 0x00075800, 0x00074000, 0x00071800,
+    0x00017800, 0x00016000, 0x00011000, 0x00015000,
+    0x00013000, 0x00012000, 0x00012800, 0x00010000,
+    0x00013800, 0x00014800, 0x00017000, 0x00016800,
+    0x00010800, 0x00015800, 0x00014000, 0x00011800,
+    0x0003f800, 0x0003e000, 0x00039000, 0x0003d000,
+    0x0003b000, 0x0003a000, 0x0003a800, 0x00038000,
+    0x0003b800, 0x0003c800, 0x0003f000, 0x0003e800,
+    0x00038800, 0x0003d800, 0x0003c000, 0x00039800,
+    0x0006f800, 0x0006e000, 0x00069000, 0x0006d000,
+    0x0006b000, 0x0006a000, 0x0006a800, 0x00068000,
+    0x0006b800, 0x0006c800, 0x0006f000, 0x0006e800,
+    0x00068800, 0x0006d800, 0x0006c000, 0x00069800,
+    0x00047800, 0x00046000, 0x00041000, 0x00045000,
+    0x00043000, 0x00042000, 0x00042800, 0x00040000,
+    0x00043800, 0x00044800, 0x00047000, 0x00046800,
+    0x00040800, 0x00045800, 0x00044000, 0x00041800,
+    0x00007800, 0x00006000, 0x00001000, 0x00005000,
+    0x00003000, 0x00002000, 0x00002800, 0x00000000,
+    0x00003800, 0x00004800, 0x00007000, 0x00006800,
+    0x00000800, 0x00005800, 0x00004000, 0x00001800,
+    0x0002f800, 0x0002e000, 0x00029000, 0x0002d000,
+    0x0002b000, 0x0002a000, 0x0002a800, 0x00028000,
+    0x0002b800, 0x0002c800, 0x0002f000, 0x0002e800,
+    0x00028800, 0x0002d800, 0x0002c000, 0x00029800,
+    0x00057800, 0x00056000, 0x00051000, 0x00055000,
+    0x00053000, 0x00052000, 0x00052800, 0x00050000,
+    0x00053800, 0x00054800, 0x00057000, 0x00056800,
+    0x00050800, 0x00055800, 0x00054000, 0x00051800,
+    0x0004f800, 0x0004e000, 0x00049000, 0x0004d000,
+    0x0004b000, 0x0004a000, 0x0004a800, 0x00048000,
+    0x0004b800, 0x0004c800, 0x0004f000, 0x0004e800,
+    0x00048800, 0x0004d800, 0x0004c000, 0x00049800,
+    0x0000f800, 0x0000e000, 0x00009000, 0x0000d000,
+    0x0000b000, 0x0000a000, 0x0000a800, 0x00008000,
+    0x0000b800, 0x0000c800, 0x0000f000, 0x0000e800,
+    0x00008800, 0x0000d800, 0x0000c000, 0x00009800,
+    /* 1 */
+    0x00880000, 0x00e00000, 0x00d80000, 0x00800000,
+    0x00f80000, 0x00f00000, 0x00b00000, 0x00a80000,
+    0x00d00000, 0x00e80000, 0x00a00000, 0x00c00000,
+    0x00c80000, 0x00980000, 0x00b80000, 0x00900000,
+    0x02880000, 0x02e00000, 0x02d80000, 0x02800000,
+    0x02f80000, 0x02f00000, 0x02b00000, 0x02a80000,
+    0x02d00000, 0x02e80000, 0x02a00000, 0x02c00000,
+    0x02c80000, 0x02980000, 0x02b80000, 0x02900000,
+    0x07080000, 0x07600000, 0x07580000, 0x07000000,
+    0x07780000, 0x07700000, 0x07300000, 0x07280000,
+    0x07500000, 0x07680000, 0x07200000, 0x07400000,
+    0x07480000, 0x07180000, 0x07380000, 0x07100000,
+    0x06080000, 0x06600000, 0x06580000, 0x06000000,
+    0x06780000, 0x06700000, 0x06300000, 0x06280000,
+    0x06500000, 0x06680000, 0x06200000, 0x06400000,
+    0x06480000, 0x06180000, 0x06380000, 0x06100000,
+    0x05080000, 0x05600000, 0x05580000, 0x05000000,
+    0x05780000, 0x05700000, 0x05300000, 0x05280000,
+    0x05500000, 0x05680000, 0x05200000, 0x05400000,
+    0x05480000, 0x05180000, 0x05380000, 0x05100000,
+    0x03880000, 0x03e00000, 0x03d80000, 0x03800000,
+    0x03f80000, 0x03f00000, 0x03b00000, 0x03a80000,
+    0x03d00000, 0x03e80000, 0x03a00000, 0x03c00000,
+    0x03c80000, 0x03980000, 0x03b80000, 0x03900000,
+    0x00080000, 0x00600000, 0x00580000, 0x00000000,
+    0x00780000, 0x00700000, 0x00300000, 0x00280000,
+    0x00500000, 0x00680000, 0x00200000, 0x00400000,
+    0x00480000, 0x00180000, 0x00380000, 0x00100000,
+    0x06880000, 0x06e00000, 0x06d80000, 0x06800000,
+    0x06f80000, 0x06f00000, 0x06b00000, 0x06a80000,
+    0x06d00000, 0x06e80000, 0x06a00000, 0x06c00000,
+    0x06c80000, 0x06980000, 0x06b80000, 0x06900000,
+    0x03080000, 0x03600000, 0x03580000, 0x03000000,
+    0x03780000, 0x03700000, 0x03300000, 0x03280000,
+    0x03500000, 0x03680000, 0x03200000, 0x03400000,
+    0x03480000, 0x03180000, 0x03380000, 0x03100000,
+    0x01080000, 0x01600000, 0x01580000, 0x01000000,
+    0x01780000, 0x01700000, 0x01300000, 0x01280000,
+    0x01500000, 0x01680000, 0x01200000, 0x01400000,
+    0x01480000, 0x01180000, 0x01380000, 0x01100000,
+    0x05880000, 0x05e00000, 0x05d80000, 0x05800000,
+    0x05f80000, 0x05f00000, 0x05b00000, 0x05a80000,
+    0x05d00000, 0x05e80000, 0x05a00000, 0x05c00000,
+    0x05c80000, 0x05980000, 0x05b80000, 0x05900000,
+    0x02080000, 0x02600000, 0x02580000, 0x02000000,
+    0x02780000, 0x02700000, 0x02300000, 0x02280000,
+    0x02500000, 0x02680000, 0x02200000, 0x02400000,
+    0x02480000, 0x02180000, 0x02380000, 0x02100000,
+    0x04880000, 0x04e00000, 0x04d80000, 0x04800000,
+    0x04f80000, 0x04f00000, 0x04b00000, 0x04a80000,
+    0x04d00000, 0x04e80000, 0x04a00000, 0x04c00000,
+    0x04c80000, 0x04980000, 0x04b80000, 0x04900000,
+    0x01880000, 0x01e00000, 0x01d80000, 0x01800000,
+    0x01f80000, 0x01f00000, 0x01b00000, 0x01a80000,
+    0x01d00000, 0x01e80000, 0x01a00000, 0x01c00000,
+    0x01c80000, 0x01980000, 0x01b80000, 0x01900000,
+    0x07880000, 0x07e00000, 0x07d80000, 0x07800000,
+    0x07f80000, 0x07f00000, 0x07b00000, 0x07a80000,
+    0x07d00000, 0x07e80000, 0x07a00000, 0x07c00000,
+    0x07c80000, 0x07980000, 0x07b80000, 0x07900000,
+    0x04080000, 0x04600000, 0x04580000, 0x04000000,
+    0x04780000, 0x04700000, 0x04300000, 0x04280000,
+    0x04500000, 0x04680000, 0x04200000, 0x04400000,
+    0x04480000, 0x04180000, 0x04380000, 0x04100000,
+    /* 2 */
+    0x00000004, 0x60000004, 0x40000004, 0x48000004,
+    0x68000004, 0x10000004, 0x50000004, 0x58000004,
+    0x38000004, 0x18000004, 0x30000004, 0x28000004,
+    0x20000004, 0x70000004, 0x78000004, 0x08000004,
+    0x00000000, 0x60000000, 0x40000000, 0x48000000,
+    0x68000000, 0x10000000, 0x50000000, 0x58000000,
+    0x38000000, 0x18000000, 0x30000000, 0x28000000,
+    0x20000000, 0x70000000, 0x78000000, 0x08000000,
+    0x80000007, 0xe0000007, 0xc0000007, 0xc8000007,
+    0xe8000007, 0x90000007, 0xd0000007, 0xd8000007,
+    0xb8000007, 0x98000007, 0xb0000007, 0xa8000007,
+    0xa0000007, 0xf0000007, 0xf8000007, 0x88000007,
+    0x80000001, 0xe0000001, 0xc0000001, 0xc8000001,
+    0xe8000001, 0x90000001, 0xd0000001, 0xd8000001,
+    0xb8000001, 0x98000001, 0xb0000001, 0xa8000001,
+    0xa0000001, 0xf0000001, 0xf8000001, 0x88000001,
+    0x00000001, 0x60000001, 0x40000001, 0x48000001,
+    0x68000001, 0x10000001, 0x50000001, 0x58000001,
+    0x38000001, 0x18000001, 0x30000001, 0x28000001,
+    0x20000001, 0x70000001, 0x78000001, 0x08000001,
+    0x80000002, 0xe0000002, 0xc0000002, 0xc8000002,
+    0xe8000002, 0x90000002, 0xd0000002, 0xd8000002,
+    0xb8000002, 0x98000002, 0xb0000002, 0xa8000002,
+    0xa0000002, 0xf0000002, 0xf8000002, 0x88000002,
+    0x00000007, 0x60000007, 0x40000007, 0x48000007,
+    0x68000007, 0x10000007, 0x50000007, 0x58000007,
+    0x38000007, 0x18000007, 0x30000007, 0x28000007,
+    0x20000007, 0x70000007, 0x78000007, 0x08000007,
+    0x80000005, 0xe0000005, 0xc0000005, 0xc8000005,
+    0xe8000005, 0x90000005, 0xd0000005, 0xd8000005,
+    0xb8000005, 0x98000005, 0xb0000005, 0xa8000005,
+    0xa0000005, 0xf0000005, 0xf8000005, 0x88000005,
+    0x80000000, 0xe0000000, 0xc0000000, 0xc8000000,
+    0xe8000000, 0x90000000, 0xd0000000, 0xd8000000,
+    0xb8000000, 0x98000000, 0xb0000000, 0xa8000000,
+    0xa0000000, 0xf0000000, 0xf8000000, 0x88000000,
+    0x00000005, 0x60000005, 0x40000005, 0x48000005,
+    0x68000005, 0x10000005, 0x50000005, 0x58000005,
+    0x38000005, 0x18000005, 0x30000005, 0x28000005,
+    0x20000005, 0x70000005, 0x78000005, 0x08000005,
+    0x00000002, 0x60000002, 0x40000002, 0x48000002,
+    0x68000002, 0x10000002, 0x50000002, 0x58000002,
+    0x38000002, 0x18000002, 0x30000002, 0x28000002,
+    0x20000002, 0x70000002, 0x78000002, 0x08000002,
+    0x80000003, 0xe0000003, 0xc0000003, 0xc8000003,
+    0xe8000003, 0x90000003, 0xd0000003, 0xd8000003,
+    0xb8000003, 0x98000003, 0xb0000003, 0xa8000003,
+    0xa0000003, 0xf0000003, 0xf8000003, 0x88000003,
+    0x00000006, 0x60000006, 0x40000006, 0x48000006,
+    0x68000006, 0x10000006, 0x50000006, 0x58000006,
+    0x38000006, 0x18000006, 0x30000006, 0x28000006,
+    0x20000006, 0x70000006, 0x78000006, 0x08000006,
+    0x80000004, 0xe0000004, 0xc0000004, 0xc8000004,
+    0xe8000004, 0x90000004, 0xd0000004, 0xd8000004,
+    0xb8000004, 0x98000004, 0xb0000004, 0xa8000004,
+    0xa0000004, 0xf0000004, 0xf8000004, 0x88000004,
+    0x80000006, 0xe0000006, 0xc0000006, 0xc8000006,
+    0xe8000006, 0x90000006, 0xd0000006, 0xd8000006,
+    0xb8000006, 0x98000006, 0xb0000006, 0xa8000006,
+    0xa0000006, 0xf0000006, 0xf8000006, 0x88000006,
+    0x00000003, 0x60000003, 0x40000003, 0x48000003,
+    0x68000003, 0x10000003, 0x50000003, 0x58000003,
+    0x38000003, 0x18000003, 0x30000003, 0x28000003,
+    0x20000003, 0x70000003, 0x78000003, 0x08000003,
+    /* 3 */
+    0x00000098, 0x00000080, 0x000000b0, 0x000000f8,
+    0x00000088, 0x000000f0, 0x000000c8, 0x00000090,
+    0x000000e8, 0x000000c0, 0x000000e0, 0x000000a0,
+    0x000000d8, 0x000000d0, 0x000000a8, 0x000000b8,
+    0x00000518, 0x00000500, 0x00000530, 0x00000578,
+    0x00000508, 0x00000570, 0x00000548, 0x00000510,
+    0x00000568, 0x00000540, 0x00000560, 0x00000520,
+    0x00000558, 0x00000550, 0x00000528, 0x00000538,
+    0x00000318, 0x00000300, 0x00000330, 0x00000378,
+    0x00000308, 0x00000370, 0x00000348, 0x00000310,
+    0x00000368, 0x00000340, 0x00000360, 0x00000320,
+    0x00000358, 0x00000350, 0x00000328, 0x00000338,
+    0x00000418, 0x00000400, 0x00000430, 0x00000478,
+    0x00000408, 0x00000470, 0x00000448, 0x00000410,
+    0x00000468, 0x00000440, 0x00000460, 0x00000420,
+    0x00000458, 0x00000450, 0x00000428, 0x00000438,
+    0x00000798, 0x00000780, 0x000007b0, 0x000007f8,
+    0x00000788, 0x000007f0, 0x000007c8, 0x00000790,
+    0x000007e8, 0x000007c0, 0x000007e0, 0x000007a0,
+    0x000007d8, 0x000007d0, 0x000007a8, 0x000007b8,
+    0x00000598, 0x00000580, 0x000005b0, 0x000005f8,
+    0x00000588, 0x000005f0, 0x000005c8, 0x00000590,
+    0x000005e8, 0x000005c0, 0x000005e0, 0x000005a0,
+    0x000005d8, 0x000005d0, 0x000005a8, 0x000005b8,
+    0x00000018, 0x00000000, 0x00000030, 0x00000078,
+    0x00000008, 0x00000070, 0x00000048, 0x00000010,
+    0x00000068, 0x00000040, 0x00000060, 0x00000020,
+    0x00000058, 0x00000050, 0x00000028, 0x00000038,
+    0x00000218, 0x00000200, 0x00000230, 0x00000278,
+    0x00000208, 0x00000270, 0x00000248, 0x00000210,
+    0x00000268, 0x00000240, 0x00000260, 0x00000220,
+    0x00000258, 0x00000250, 0x00000228, 0x00000238,
+    0x00000618, 0x00000600, 0x00000630, 0x00000678,
+    0x00000608, 0x00000670, 0x00000648, 0x00000610,
+    0x00000668, 0x00000640, 0x00000660, 0x00000620,
+    0x00000658, 0x00000650, 0x00000628, 0x00000638,
+    0x00000198, 0x00000180, 0x000001b0, 0x000001f8,
+    0x00000188, 0x000001f0, 0x000001c8, 0x00000190,
+    0x000001e8, 0x000001c0, 0x000001e0, 0x000001a0,
+    0x000001d8, 0x000001d0, 0x000001a8, 0x000001b8,
+    0x00000298, 0x00000280, 0x000002b0, 0x000002f8,
+    0x00000288, 0x000002f0, 0x000002c8, 0x00000290,
+    0x000002e8, 0x000002c0, 0x000002e0, 0x000002a0,
+    0x000002d8, 0x000002d0, 0x000002a8, 0x000002b8,
+    0x00000498, 0x00000480, 0x000004b0, 0x000004f8,
+    0x00000488, 0x000004f0, 0x000004c8, 0x00000490,
+    0x000004e8, 0x000004c0, 0x000004e0, 0x000004a0,
+    0x000004d8, 0x000004d0, 0x000004a8, 0x000004b8,
+    0x00000398, 0x00000380, 0x000003b0, 0x000003f8,
+    0x00000388, 0x000003f0, 0x000003c8, 0x00000390,
+    0x000003e8, 0x000003c0, 0x000003e0, 0x000003a0,
+    0x000003d8, 0x000003d0, 0x000003a8, 0x000003b8,
+    0x00000698, 0x00000680, 0x000006b0, 0x000006f8,
+    0x00000688, 0x000006f0, 0x000006c8, 0x00000690,
+    0x000006e8, 0x000006c0, 0x000006e0, 0x000006a0,
+    0x000006d8, 0x000006d0, 0x000006a8, 0x000006b8,
+    0x00000118, 0x00000100, 0x00000130, 0x00000178,
+    0x00000108, 0x00000170, 0x00000148, 0x00000110,
+    0x00000168, 0x00000140, 0x00000160, 0x00000120,
+    0x00000158, 0x00000150, 0x00000128, 0x00000138,
+    0x00000718, 0x00000700, 0x00000730, 0x00000778,
+    0x00000708, 0x00000770, 0x00000748, 0x00000710,
+    0x00000768, 0x00000740, 0x00000760, 0x00000720,
+    0x00000758, 0x00000750, 0x00000728, 0x00000738,
+  };
+
+static const u32 sbox_TC26_Z[4*256] =
+  {
+    /* 0 */
+    0x00036000, 0x00032000, 0x00033000, 0x00031000,
+    0x00035000, 0x00032800, 0x00035800, 0x00034800,
+    0x00037000, 0x00034000, 0x00036800, 0x00033800,
+    0x00030000, 0x00031800, 0x00037800, 0x00030800,
+    0x00046000, 0x00042000, 0x00043000, 0x00041000,
+    0x00045000, 0x00042800, 0x00045800, 0x00044800,
+    0x00047000, 0x00044000, 0x00046800, 0x00043800,
+    0x00040000, 0x00041800, 0x00047800, 0x00040800,
+    0x00016000, 0x00012000, 0x00013000, 0x00011000,
+    0x00015000, 0x00012800, 0x00015800, 0x00014800,
+    0x00017000, 0x00014000, 0x00016800, 0x00013800,
+    0x00010000, 0x00011800, 0x00017800, 0x00010800,
+    0x0001e000, 0x0001a000, 0x0001b000, 0x00019000,
+    0x0001d000, 0x0001a800, 0x0001d800, 0x0001c800,
+    0x0001f000, 0x0001c000, 0x0001e800, 0x0001b800,
+    0x00018000, 0x00019800, 0x0001f800, 0x00018800,
+    0x0004e000, 0x0004a000, 0x0004b000, 0x00049000,
+    0x0004d000, 0x0004a800, 0x0004d800, 0x0004c800,
+    0x0004f000, 0x0004c000, 0x0004e800, 0x0004b800,
+    0x00048000, 0x00049800, 0x0004f800, 0x00048800,
+    0x00056000, 0x00052000, 0x00053000, 0x00051000,
+    0x00055000, 0x00052800, 0x00055800, 0x00054800,
+    0x00057000, 0x00054000, 0x00056800, 0x00053800,
+    0x00050000, 0x00051800, 0x00057800, 0x00050800,
+    0x0002e000, 0x0002a000, 0x0002b000, 0x00029000,
+    0x0002d000, 0x0002a800, 0x0002d800, 0x0002c800,
+    0x0002f000, 0x0002c000, 0x0002e800, 0x0002b800,
+    0x00028000, 0x00029800, 0x0002f800, 0x00028800,
+    0x00066000, 0x00062000, 0x00063000, 0x00061000,
+    0x00065000, 0x00062800, 0x00065800, 0x00064800,
+    0x00067000, 0x00064000, 0x00066800, 0x00063800,
+    0x00060000, 0x00061800, 0x00067800, 0x00060800,
+    0x0000e000, 0x0000a000, 0x0000b000, 0x00009000,
+    0x0000d000, 0x0000a800, 0x0000d800, 0x0000c800,
+    0x0000f000, 0x0000c000, 0x0000e800, 0x0000b800,
+    0x00008000, 0x00009800, 0x0000f800, 0x00008800,
+    0x00076000, 0x00072000, 0x00073000, 0x00071000,
+    0x00075000, 0x00072800, 0x00075800, 0x00074800,
+    0x00077000, 0x00074000, 0x00076800, 0x00073800,
+    0x00070000, 0x00071800, 0x00077800, 0x00070800,
+    0x00026000, 0x00022000, 0x00023000, 0x00021000,
+    0x00025000, 0x00022800, 0x00025800, 0x00024800,
+    0x00027000, 0x00024000, 0x00026800, 0x00023800,
+    0x00020000, 0x00021800, 0x00027800, 0x00020800,
+    0x0003e000, 0x0003a000, 0x0003b000, 0x00039000,
+    0x0003d000, 0x0003a800, 0x0003d800, 0x0003c800,
+    0x0003f000, 0x0003c000, 0x0003e800, 0x0003b800,
+    0x00038000, 0x00039800, 0x0003f800, 0x00038800,
+    0x0005e000, 0x0005a000, 0x0005b000, 0x00059000,
+    0x0005d000, 0x0005a800, 0x0005d800, 0x0005c800,
+    0x0005f000, 0x0005c000, 0x0005e800, 0x0005b800,
+    0x00058000, 0x00059800, 0x0005f800, 0x00058800,
+    0x0006e000, 0x0006a000, 0x0006b000, 0x00069000,
+    0x0006d000, 0x0006a800, 0x0006d800, 0x0006c800,
+    0x0006f000, 0x0006c000, 0x0006e800, 0x0006b800,
+    0x00068000, 0x00069800, 0x0006f800, 0x00068800,
+    0x00006000, 0x00002000, 0x00003000, 0x00001000,
+    0x00005000, 0x00002800, 0x00005800, 0x00004800,
+    0x00007000, 0x00004000, 0x00006800, 0x00003800,
+    0x00000000, 0x00001800, 0x00007800, 0x00000800,
+    0x0007e000, 0x0007a000, 0x0007b000, 0x00079000,
+    0x0007d000, 0x0007a800, 0x0007d800, 0x0007c800,
+    0x0007f000, 0x0007c000, 0x0007e800, 0x0007b800,
+    0x00078000, 0x00079800, 0x0007f800, 0x00078800,
+    /* 1 */
+    0x06580000, 0x06180000, 0x06280000, 0x06400000,
+    0x06100000, 0x06780000, 0x06500000, 0x06680000,
+    0x06700000, 0x06080000, 0x06380000, 0x06200000,
+    0x06600000, 0x06480000, 0x06300000, 0x06000000,
+    0x04580000, 0x04180000, 0x04280000, 0x04400000,
+    0x04100000, 0x04780000, 0x04500000, 0x04680000,
+    0x04700000, 0x04080000, 0x04380000, 0x04200000,
+    0x04600000, 0x04480000, 0x04300000, 0x04000000,
+    0x01580000, 0x01180000, 0x01280000, 0x01400000,
+    0x01100000, 0x01780000, 0x01500000, 0x01680000,
+    0x01700000, 0x01080000, 0x01380000, 0x01200000,
+    0x01600000, 0x01480000, 0x01300000, 0x01000000,
+    0x00d80000, 0x00980000, 0x00a80000, 0x00c00000,
+    0x00900000, 0x00f80000, 0x00d00000, 0x00e80000,
+    0x00f00000, 0x00880000, 0x00b80000, 0x00a00000,
+    0x00e00000, 0x00c80000, 0x00b00000, 0x00800000,
+    0x06d80000, 0x06980000, 0x06a80000, 0x06c00000,
+    0x06900000, 0x06f80000, 0x06d00000, 0x06e80000,
+    0x06f00000, 0x06880000, 0x06b80000, 0x06a00000,
+    0x06e00000, 0x06c80000, 0x06b00000, 0x06800000,
+    0x02580000, 0x02180000, 0x02280000, 0x02400000,
+    0x02100000, 0x02780000, 0x02500000, 0x02680000,
+    0x02700000, 0x02080000, 0x02380000, 0x02200000,
+    0x02600000, 0x02480000, 0x02300000, 0x02000000,
+    0x07d80000, 0x07980000, 0x07a80000, 0x07c00000,
+    0x07900000, 0x07f80000, 0x07d00000, 0x07e80000,
+    0x07f00000, 0x07880000, 0x07b80000, 0x07a00000,
+    0x07e00000, 0x07c80000, 0x07b00000, 0x07800000,
+    0x03580000, 0x03180000, 0x03280000, 0x03400000,
+    0x03100000, 0x03780000, 0x03500000, 0x03680000,
+    0x03700000, 0x03080000, 0x03380000, 0x03200000,
+    0x03600000, 0x03480000, 0x03300000, 0x03000000,
+    0x03d80000, 0x03980000, 0x03a80000, 0x03c00000,
+    0x03900000, 0x03f80000, 0x03d00000, 0x03e80000,
+    0x03f00000, 0x03880000, 0x03b80000, 0x03a00000,
+    0x03e00000, 0x03c80000, 0x03b00000, 0x03800000,
+    0x00580000, 0x00180000, 0x00280000, 0x00400000,
+    0x00100000, 0x00780000, 0x00500000, 0x00680000,
+    0x00700000, 0x00080000, 0x00380000, 0x00200000,
+    0x00600000, 0x00480000, 0x00300000, 0x00000000,
+    0x05580000, 0x05180000, 0x05280000, 0x05400000,
+    0x05100000, 0x05780000, 0x05500000, 0x05680000,
+    0x05700000, 0x05080000, 0x05380000, 0x05200000,
+    0x05600000, 0x05480000, 0x05300000, 0x05000000,
+    0x02d80000, 0x02980000, 0x02a80000, 0x02c00000,
+    0x02900000, 0x02f80000, 0x02d00000, 0x02e80000,
+    0x02f00000, 0x02880000, 0x02b80000, 0x02a00000,
+    0x02e00000, 0x02c80000, 0x02b00000, 0x02800000,
+    0x01d80000, 0x01980000, 0x01a80000, 0x01c00000,
+    0x01900000, 0x01f80000, 0x01d00000, 0x01e80000,
+    0x01f00000, 0x01880000, 0x01b80000, 0x01a00000,
+    0x01e00000, 0x01c80000, 0x01b00000, 0x01800000,
+    0x07580000, 0x07180000, 0x07280000, 0x07400000,
+    0x07100000, 0x07780000, 0x07500000, 0x07680000,
+    0x07700000, 0x07080000, 0x07380000, 0x07200000,
+    0x07600000, 0x07480000, 0x07300000, 0x07000000,
+    0x04d80000, 0x04980000, 0x04a80000, 0x04c00000,
+    0x04900000, 0x04f80000, 0x04d00000, 0x04e80000,
+    0x04f00000, 0x04880000, 0x04b80000, 0x04a00000,
+    0x04e00000, 0x04c80000, 0x04b00000, 0x04800000,
+    0x05d80000, 0x05980000, 0x05a80000, 0x05c00000,
+    0x05900000, 0x05f80000, 0x05d00000, 0x05e80000,
+    0x05f00000, 0x05880000, 0x05b80000, 0x05a00000,
+    0x05e00000, 0x05c80000, 0x05b00000, 0x05800000,
+    /* 2 */
+    0xb8000002, 0xf8000002, 0xa8000002, 0xd0000002,
+    0xc0000002, 0x88000002, 0xb0000002, 0xe8000002,
+    0x80000002, 0xc8000002, 0x98000002, 0xf0000002,
+    0xd8000002, 0xa0000002, 0x90000002, 0xe0000002,
+    0xb8000006, 0xf8000006, 0xa8000006, 0xd0000006,
+    0xc0000006, 0x88000006, 0xb0000006, 0xe8000006,
+    0x80000006, 0xc8000006, 0x98000006, 0xf0000006,
+    0xd8000006, 0xa0000006, 0x90000006, 0xe0000006,
+    0xb8000007, 0xf8000007, 0xa8000007, 0xd0000007,
+    0xc0000007, 0x88000007, 0xb0000007, 0xe8000007,
+    0x80000007, 0xc8000007, 0x98000007, 0xf0000007,
+    0xd8000007, 0xa0000007, 0x90000007, 0xe0000007,
+    0x38000003, 0x78000003, 0x28000003, 0x50000003,
+    0x40000003, 0x08000003, 0x30000003, 0x68000003,
+    0x00000003, 0x48000003, 0x18000003, 0x70000003,
+    0x58000003, 0x20000003, 0x10000003, 0x60000003,
+    0xb8000004, 0xf8000004, 0xa8000004, 0xd0000004,
+    0xc0000004, 0x88000004, 0xb0000004, 0xe8000004,
+    0x80000004, 0xc8000004, 0x98000004, 0xf0000004,
+    0xd8000004, 0xa0000004, 0x90000004, 0xe0000004,
+    0x38000001, 0x78000001, 0x28000001, 0x50000001,
+    0x40000001, 0x08000001, 0x30000001, 0x68000001,
+    0x00000001, 0x48000001, 0x18000001, 0x70000001,
+    0x58000001, 0x20000001, 0x10000001, 0x60000001,
+    0x38000006, 0x78000006, 0x28000006, 0x50000006,
+    0x40000006, 0x08000006, 0x30000006, 0x68000006,
+    0x00000006, 0x48000006, 0x18000006, 0x70000006,
+    0x58000006, 0x20000006, 0x10000006, 0x60000006,
+    0x38000005, 0x78000005, 0x28000005, 0x50000005,
+    0x40000005, 0x08000005, 0x30000005, 0x68000005,
+    0x00000005, 0x48000005, 0x18000005, 0x70000005,
+    0x58000005, 0x20000005, 0x10000005, 0x60000005,
+    0xb8000005, 0xf8000005, 0xa8000005, 0xd0000005,
+    0xc0000005, 0x88000005, 0xb0000005, 0xe8000005,
+    0x80000005, 0xc8000005, 0x98000005, 0xf0000005,
+    0xd8000005, 0xa0000005, 0x90000005, 0xe0000005,
+    0xb8000003, 0xf8000003, 0xa8000003, 0xd0000003,
+    0xc0000003, 0x88000003, 0xb0000003, 0xe8000003,
+    0x80000003, 0xc8000003, 0x98000003, 0xf0000003,
+    0xd8000003, 0xa0000003, 0x90000003, 0xe0000003,
+    0x38000004, 0x78000004, 0x28000004, 0x50000004,
+    0x40000004, 0x08000004, 0x30000004, 0x68000004,
+    0x00000004, 0x48000004, 0x18000004, 0x70000004,
+    0x58000004, 0x20000004, 0x10000004, 0x60000004,
+    0xb8000000, 0xf8000000, 0xa8000000, 0xd0000000,
+    0xc0000000, 0x88000000, 0xb0000000, 0xe8000000,
+    0x80000000, 0xc8000000, 0x98000000, 0xf0000000,
+    0xd8000000, 0xa0000000, 0x90000000, 0xe0000000,
+    0x38000002, 0x78000002, 0x28000002, 0x50000002,
+    0x40000002, 0x08000002, 0x30000002, 0x68000002,
+    0x00000002, 0x48000002, 0x18000002, 0x70000002,
+    0x58000002, 0x20000002, 0x10000002, 0x60000002,
+    0xb8000001, 0xf8000001, 0xa8000001, 0xd0000001,
+    0xc0000001, 0x88000001, 0xb0000001, 0xe8000001,
+    0x80000001, 0xc8000001, 0x98000001, 0xf0000001,
+    0xd8000001, 0xa0000001, 0x90000001, 0xe0000001,
+    0x38000007, 0x78000007, 0x28000007, 0x50000007,
+    0x40000007, 0x08000007, 0x30000007, 0x68000007,
+    0x00000007, 0x48000007, 0x18000007, 0x70000007,
+    0x58000007, 0x20000007, 0x10000007, 0x60000007,
+    0x38000000, 0x78000000, 0x28000000, 0x50000000,
+    0x40000000, 0x08000000, 0x30000000, 0x68000000,
+    0x00000000, 0x48000000, 0x18000000, 0x70000000,
+    0x58000000, 0x20000000, 0x10000000, 0x60000000,
+    /* 3 */
+    0x000000c0, 0x000000f0, 0x00000090, 0x000000a8,
+    0x000000b0, 0x000000c8, 0x00000088, 0x000000e0,
+    0x000000f8, 0x000000a0, 0x000000d8, 0x00000080,
+    0x000000e8, 0x000000d0, 0x00000098, 0x000000b8,
+    0x000003c0, 0x000003f0, 0x00000390, 0x000003a8,
+    0x000003b0, 0x000003c8, 0x00000388, 0x000003e0,
+    0x000003f8, 0x000003a0, 0x000003d8, 0x00000380,
+    0x000003e8, 0x000003d0, 0x00000398, 0x000003b8,
+    0x00000740, 0x00000770, 0x00000710, 0x00000728,
+    0x00000730, 0x00000748, 0x00000708, 0x00000760,
+    0x00000778, 0x00000720, 0x00000758, 0x00000700,
+    0x00000768, 0x00000750, 0x00000718, 0x00000738,
+    0x000006c0, 0x000006f0, 0x00000690, 0x000006a8,
+    0x000006b0, 0x000006c8, 0x00000688, 0x000006e0,
+    0x000006f8, 0x000006a0, 0x000006d8, 0x00000680,
+    0x000006e8, 0x000006d0, 0x00000698, 0x000006b8,
+    0x00000040, 0x00000070, 0x00000010, 0x00000028,
+    0x00000030, 0x00000048, 0x00000008, 0x00000060,
+    0x00000078, 0x00000020, 0x00000058, 0x00000000,
+    0x00000068, 0x00000050, 0x00000018, 0x00000038,
+    0x000002c0, 0x000002f0, 0x00000290, 0x000002a8,
+    0x000002b0, 0x000002c8, 0x00000288, 0x000002e0,
+    0x000002f8, 0x000002a0, 0x000002d8, 0x00000280,
+    0x000002e8, 0x000002d0, 0x00000298, 0x000002b8,
+    0x00000440, 0x00000470, 0x00000410, 0x00000428,
+    0x00000430, 0x00000448, 0x00000408, 0x00000460,
+    0x00000478, 0x00000420, 0x00000458, 0x00000400,
+    0x00000468, 0x00000450, 0x00000418, 0x00000438,
+    0x000001c0, 0x000001f0, 0x00000190, 0x000001a8,
+    0x000001b0, 0x000001c8, 0x00000188, 0x000001e0,
+    0x000001f8, 0x000001a0, 0x000001d8, 0x00000180,
+    0x000001e8, 0x000001d0, 0x00000198, 0x000001b8,
+    0x00000240, 0x00000270, 0x00000210, 0x00000228,
+    0x00000230, 0x00000248, 0x00000208, 0x00000260,
+    0x00000278, 0x00000220, 0x00000258, 0x00000200,
+    0x00000268, 0x00000250, 0x00000218, 0x00000238,
+    0x000007c0, 0x000007f0, 0x00000790, 0x000007a8,
+    0x000007b0, 0x000007c8, 0x00000788, 0x000007e0,
+    0x000007f8, 0x000007a0, 0x000007d8, 0x00000780,
+    0x000007e8, 0x000007d0, 0x00000798, 0x000007b8,
+    0x00000540, 0x00000570, 0x00000510, 0x00000528,
+    0x00000530, 0x00000548, 0x00000508, 0x00000560,
+    0x00000578, 0x00000520, 0x00000558, 0x00000500,
+    0x00000568, 0x00000550, 0x00000518, 0x00000538,
+    0x00000340, 0x00000370, 0x00000310, 0x00000328,
+    0x00000330, 0x00000348, 0x00000308, 0x00000360,
+    0x00000378, 0x00000320, 0x00000358, 0x00000300,
+    0x00000368, 0x00000350, 0x00000318, 0x00000338,
+    0x000004c0, 0x000004f0, 0x00000490, 0x000004a8,
+    0x000004b0, 0x000004c8, 0x00000488, 0x000004e0,
+    0x000004f8, 0x000004a0, 0x000004d8, 0x00000480,
+    0x000004e8, 0x000004d0, 0x00000498, 0x000004b8,
+    0x00000640, 0x00000670, 0x00000610, 0x00000628,
+    0x00000630, 0x00000648, 0x00000608, 0x00000660,
+    0x00000678, 0x00000620, 0x00000658, 0x00000600,
+    0x00000668, 0x00000650, 0x00000618, 0x00000638,
+    0x000005c0, 0x000005f0, 0x00000590, 0x000005a8,
+    0x000005b0, 0x000005c8, 0x00000588, 0x000005e0,
+    0x000005f8, 0x000005a0, 0x000005d8, 0x00000580,
+    0x000005e8, 0x000005d0, 0x00000598, 0x000005b8,
+    0x00000140, 0x00000170, 0x00000110, 0x00000128,
+    0x00000130, 0x00000148, 0x00000108, 0x00000160,
+    0x00000178, 0x00000120, 0x00000158, 0x00000100,
+    0x00000168, 0x00000150, 0x00000118, 0x00000138,
+  };
+
+static struct
+{
+  const char *oid;
+  const u32 *sbox;
+} gost_oid_map[] = {
+  { "1.2.643.2.2.30.0", sbox_test_3411 },
+  { "1.2.643.2.2.30.1", sbox_CryptoPro_3411 },
+  { "1.2.643.2.2.31.0", sbox_Test_89 },
+  { "1.2.643.2.2.31.1", sbox_CryptoPro_A },
+  { "1.2.643.2.2.31.2", sbox_CryptoPro_B },
+  { "1.2.643.2.2.31.3", sbox_CryptoPro_C },
+  { "1.2.643.2.2.31.4", sbox_CryptoPro_D },
+  { "1.2.643.7.1.2.5.1.1", sbox_TC26_Z },
+  { NULL, NULL }
+};
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mod-source-info.h b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mod-source-info.h
new file mode 100644
index 000000000..ae17ce1cd
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mod-source-info.h
@@ -0,0 +1,11 @@
+/* Created by config.links - do not edit */
+/* Host: powerpc64le-unknown-linux-gnu */
+static char mod_source_info[] =
+  ":generic/mpih-add1.c"
+  ":generic/mpih-sub1.c"
+  ":generic/mpih-mul1.c"
+  ":generic/mpih-mul2.c"
+  ":generic/mpih-mul3.c"
+  ":generic/mpih-lshift.c"
+  ":generic/mpih-rshift.c"
+  ;
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpi-asm-defs.h b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpi-asm-defs.h
new file mode 100644
index 000000000..e607806e1
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpi-asm-defs.h
@@ -0,0 +1,8 @@
+/* This file defines some basic constants for the MPI machinery.
+ * AMD64 compiled for the x32 ABI is special and thus we can't use the
+ * standard values for this ABI.  */
+#if __GNUC__ >= 3 && defined(__x86_64__) && defined(__ILP32__)
+#define BYTES_PER_MPI_LIMB 8
+#else
+#define BYTES_PER_MPI_LIMB  (SIZEOF_UNSIGNED_LONG)
+#endif
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-add1.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-add1.c
new file mode 100644
index 000000000..4a84df64d
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-add1.c
@@ -0,0 +1,65 @@
+/* mpihelp-add_1.c  -  MPI helper functions
+ * Copyright (C) 1994, 1996, 1997, 1998, 
+ *               2000, 2002 Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+#include "longlong.h"
+
+mpi_limb_t
+_gcry_mpih_add_n (mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
+                  mpi_ptr_t s2_ptr, mpi_size_t size)
+{
+  mpi_limb_t x, y, cy;
+  mpi_size_t j;
+
+  /* The loop counter and index J goes from -SIZE to -1.  This way
+     the loop becomes faster.  */
+  j = -size;
+
+  /* Offset the base pointers to compensate for the negative indices. */
+  s1_ptr -= j;
+  s2_ptr -= j;
+  res_ptr -= j;
+
+  cy = 0;
+  do 
+    {
+      y = s2_ptr[j];
+      x = s1_ptr[j];
+      y += cy;		  /* add previous carry to one addend */
+      cy = y < cy;	  /* get out carry from that addition */
+      y += x; 		  /* add other addend */
+      cy += y < x;	  /* get out carry from that add, combine */
+      res_ptr[j] = y;
+    } 
+  while ( ++j );
+
+  return cy;
+}
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-lshift.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-lshift.c
new file mode 100644
index 000000000..f48c12cd0
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-lshift.c
@@ -0,0 +1,68 @@
+/* mpi-lshift.c  - MPI helper functions
+ * Copyright (C) 1994, 1996, 1998, 2001, 2002 Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+
+/* Shift U (pointed to by UP and USIZE digits long) CNT bits to the left
+ * and store the USIZE least significant digits of the result at WP.
+ * Return the bits shifted out from the most significant digit.
+ *
+ * Argument constraints:
+ * 1. 0 < CNT < BITS_PER_MP_LIMB
+ * 2. If the result is to be written over the input, WP must be >= UP.
+ */
+
+mpi_limb_t
+_gcry_mpih_lshift( mpi_ptr_t wp, mpi_ptr_t up, mpi_size_t usize,
+					    unsigned int cnt)
+{
+  mpi_limb_t high_limb, low_limb;
+  unsigned sh_1, sh_2;
+  mpi_size_t i;
+  mpi_limb_t retval;
+
+  sh_1 = cnt;
+  wp += 1;
+  sh_2 = BITS_PER_MPI_LIMB - sh_1;
+  i = usize - 1;
+  low_limb = up[i];
+  retval = low_limb >> sh_2;
+  high_limb = low_limb;
+  while ( --i >= 0 ) 
+    {
+      low_limb = up[i];
+      wp[i] = (high_limb << sh_1) | (low_limb >> sh_2);
+      high_limb = low_limb;
+    }
+  wp[i] = high_limb << sh_1;
+
+  return retval;
+}
+
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul1.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul1.c
new file mode 100644
index 000000000..0e8197d88
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul1.c
@@ -0,0 +1,62 @@
+/* mpihelp-mul_1.c  -  MPI helper functions
+ * Copyright (C) 1994, 1996, 1997, 1998, 2001,
+ *               2002 Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+#include "longlong.h"
+
+mpi_limb_t
+_gcry_mpih_mul_1( mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr, mpi_size_t s1_size,
+						    mpi_limb_t s2_limb)
+{
+  mpi_limb_t cy_limb;
+  mpi_size_t j;
+  mpi_limb_t prod_high, prod_low;
+
+  /* The loop counter and index J goes from -S1_SIZE to -1.  This way
+   * the loop becomes faster.  */
+  j = -s1_size;
+
+  /* Offset the base pointers to compensate for the negative indices.  */
+  s1_ptr -= j;
+  res_ptr -= j;
+
+  cy_limb = 0;
+  do 
+    {
+      umul_ppmm( prod_high, prod_low, s1_ptr[j], s2_limb );
+      prod_low += cy_limb;
+      cy_limb = (prod_low < cy_limb?1:0) + prod_high;
+      res_ptr[j] = prod_low;
+    } 
+  while( ++j );
+
+  return cy_limb;
+}
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul2.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul2.c
new file mode 100644
index 000000000..3b7549605
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul2.c
@@ -0,0 +1,68 @@
+/* mpih-mul2.c  -  MPI helper functions
+ * Copyright (C) 1994, 1996, 1997, 1998, 2001,
+ *               2002  Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+#include "longlong.h"
+
+
+mpi_limb_t
+_gcry_mpih_addmul_1( mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
+		  mpi_size_t s1_size, mpi_limb_t s2_limb)
+{
+  mpi_limb_t cy_limb;
+  mpi_size_t j;
+  mpi_limb_t prod_high, prod_low;
+  mpi_limb_t x;
+
+  /* The loop counter and index J goes from -SIZE to -1.  This way
+   * the loop becomes faster.  */
+  j = -s1_size;
+  res_ptr -= j;
+  s1_ptr -= j;
+
+  cy_limb = 0;
+  do 
+    {
+      umul_ppmm( prod_high, prod_low, s1_ptr[j], s2_limb );
+
+      prod_low += cy_limb;
+      cy_limb = (prod_low < cy_limb?1:0) + prod_high;
+
+      x = res_ptr[j];
+      prod_low = x + prod_low;
+      cy_limb += prod_low < x?1:0;
+      res_ptr[j] = prod_low;
+    } 
+  while ( ++j );
+    
+  return cy_limb;
+}
+
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul3.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul3.c
new file mode 100644
index 000000000..5e84f94f3
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-mul3.c
@@ -0,0 +1,68 @@
+/* mpih-mul3.c  -  MPI helper functions
+ * Copyright (C) 1994, 1996, 1997, 1998, 2001,
+ *               2002 Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+#include "longlong.h"
+
+
+mpi_limb_t
+_gcry_mpih_submul_1( mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
+		  mpi_size_t s1_size, mpi_limb_t s2_limb)
+{
+  mpi_limb_t cy_limb;
+  mpi_size_t j;
+  mpi_limb_t prod_high, prod_low;
+  mpi_limb_t x;
+
+  /* The loop counter and index J goes from -SIZE to -1.  This way
+   * the loop becomes faster.  */
+  j = -s1_size;
+  res_ptr -= j;
+  s1_ptr -= j;
+
+  cy_limb = 0;
+  do 
+    {
+      umul_ppmm( prod_high, prod_low, s1_ptr[j], s2_limb);
+
+      prod_low += cy_limb;
+      cy_limb = (prod_low < cy_limb?1:0) + prod_high;
+
+      x = res_ptr[j];
+      prod_low = x - prod_low;
+      cy_limb += prod_low > x?1:0;
+      res_ptr[j] = prod_low;
+    } 
+  while( ++j );
+
+  return cy_limb;
+}
+
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-rshift.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-rshift.c
new file mode 100644
index 000000000..e40794fcf
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-rshift.c
@@ -0,0 +1,67 @@
+/* mpih-rshift.c  -  MPI helper functions
+ * Copyright (C) 1994, 1996, 1998, 1999,
+ *               2000, 2001, 2002 Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+
+
+/* Shift U (pointed to by UP and USIZE limbs long) CNT bits to the right
+ * and store the USIZE least significant limbs of the result at WP.
+ * The bits shifted out to the right are returned.
+ *
+ * Argument constraints:
+ * 1. 0 < CNT < BITS_PER_MP_LIMB
+ * 2. If the result is to be written over the input, WP must be <= UP.
+ */
+
+mpi_limb_t
+_gcry_mpih_rshift( mpi_ptr_t wp, mpi_ptr_t up, mpi_size_t usize, unsigned cnt)
+{
+  mpi_limb_t high_limb, low_limb;
+  unsigned sh_1, sh_2;
+  mpi_size_t i;
+  mpi_limb_t retval;
+
+  sh_1 = cnt;
+  wp -= 1;
+  sh_2 = BITS_PER_MPI_LIMB - sh_1;
+  high_limb = up[0];
+  retval = high_limb << sh_2;
+  low_limb = high_limb;
+  for (i=1; i < usize; i++)
+    {
+      high_limb = up[i];
+      wp[i] = (low_limb >> sh_1) | (high_limb << sh_2);
+      low_limb = high_limb;
+    }
+  wp[i] = low_limb >> sh_1;
+
+  return retval;
+}
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-sub1.c b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-sub1.c
new file mode 100644
index 000000000..e88821bfb
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/mpi/mpih-sub1.c
@@ -0,0 +1,66 @@
+/* mpihelp-add_2.c  -  MPI helper functions
+ * Copyright (C) 1994, 1996, 1997, 1998, 2001,
+ *               2002 Free Software Foundation, Inc.
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Note: This code is heavily based on the GNU MP Library.
+ *	 Actually it's the same code with only minor changes in the
+ *	 way the data is stored; this is to support the abstraction
+ *	 of an optional secure memory allocation which may be used
+ *	 to avoid revealing of sensitive data due to paging etc.
+ */
+
+#include <config.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "mpi-internal.h"
+#include "longlong.h"
+
+mpi_limb_t
+_gcry_mpih_sub_n( mpi_ptr_t res_ptr, mpi_ptr_t s1_ptr,
+				  mpi_ptr_t s2_ptr, mpi_size_t size)
+{
+  mpi_limb_t x, y, cy;
+  mpi_size_t j;
+
+  /* The loop counter and index J goes from -SIZE to -1.  This way
+     the loop becomes faster.  */
+  j = -size;
+
+  /* Offset the base pointers to compensate for the negative indices.  */
+  s1_ptr -= j;
+  s2_ptr -= j;
+  res_ptr -= j;
+
+  cy = 0;
+  do 
+    {
+      y = s2_ptr[j];
+      x = s1_ptr[j];
+      y += cy;		  /* add previous carry to subtrahend */
+      cy = y < cy;		  /* get out carry from that addition */
+      y = x - y;		  /* main subtract */
+      cy += y > x;		  /* get out carry from the subtract, combine */
+      res_ptr[j] = y;
+    } 
+  while( ++j );
+
+  return cy;
+}
+
+
diff --git a/libraries/cmake/source/libgcrypt/generated/ppc64le/src/gcrypt.h b/libraries/cmake/source/libgcrypt/generated/ppc64le/src/gcrypt.h
new file mode 100644
index 000000000..2f78b1073
--- /dev/null
+++ b/libraries/cmake/source/libgcrypt/generated/ppc64le/src/gcrypt.h
@@ -0,0 +1,1798 @@
+/* gcrypt.h -  GNU Cryptographic Library Interface              -*- c -*-
+ * Copyright (C) 1998-2017 Free Software Foundation, Inc.
+ * Copyright (C) 2012-2017 g10 Code GmbH
+ *
+ * This file is part of Libgcrypt.
+ *
+ * Libgcrypt is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as
+ * published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * Libgcrypt is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * File: src/gcrypt.h.  Generated from gcrypt.h.in by configure.
+ */
+
+#ifndef _GCRYPT_H
+#define _GCRYPT_H
+
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+
+#include <gpg-error.h>
+
+#include <sys/types.h>
+
+#if defined _WIN32 || defined __WIN32__
+# include <winsock2.h>
+# include <ws2tcpip.h>
+# include <time.h>
+# ifndef __GNUC__
+  typedef long ssize_t;
+  typedef int  pid_t;
+# endif /*!__GNUC__*/
+#else
+# include <sys/socket.h>
+# include <sys/time.h>
+# include <sys/select.h>
+#endif /*!_WIN32*/
+
+typedef socklen_t gcry_socklen_t;
+
+/* This is required for error code compatibility. */
+#define _GCRY_ERR_SOURCE_DEFAULT GPG_ERR_SOURCE_GCRYPT
+
+#ifdef __cplusplus
+extern "C" {
+#if 0 /* (Keep Emacsens' auto-indent happy.) */
+}
+#endif
+#endif
+
+/* The version of this header should match the one of the library. It
+   should not be used by a program because gcry_check_version() should
+   return the same version.  The purpose of this macro is to let
+   autoconf (using the AM_PATH_GCRYPT macro) check that this header
+   matches the installed library.  */
+#define GCRYPT_VERSION "1.8.1"
+
+/* The version number of this header.  It may be used to handle minor
+   API incompatibilities.  */
+#define GCRYPT_VERSION_NUMBER 0x010801
+
+
+/* Internal: We can't use the convenience macros for the multi
+   precision integer functions when building this library. */
+#ifdef _GCRYPT_IN_LIBGCRYPT
+#ifndef GCRYPT_NO_MPI_MACROS
+#define GCRYPT_NO_MPI_MACROS 1
+#endif
+#endif
+
+/* We want to use gcc attributes when possible.  Warning: Don't use
+   these macros in your programs: As indicated by the leading
+   underscore they are subject to change without notice. */
+#ifdef __GNUC__
+
+#define _GCRY_GCC_VERSION (__GNUC__ * 10000 \
+                             + __GNUC_MINOR__ * 100 \
+                             + __GNUC_PATCHLEVEL__)
+
+#if _GCRY_GCC_VERSION >= 30100
+#define _GCRY_GCC_ATTR_DEPRECATED __attribute__ ((__deprecated__))
+#endif
+
+#if _GCRY_GCC_VERSION >= 29600
+#define _GCRY_GCC_ATTR_PURE  __attribute__ ((__pure__))
+#endif
+
+#if _GCRY_GCC_VERSION >= 30200
+#define _GCRY_GCC_ATTR_MALLOC  __attribute__ ((__malloc__))
+#endif
+
+#define _GCRY_GCC_ATTR_PRINTF(f,a)  __attribute__ ((format (printf,f,a)))
+
+#if _GCRY_GCC_VERSION >= 40000
+#define _GCRY_GCC_ATTR_SENTINEL(a) __attribute__ ((sentinel(a)))
+#endif
+
+#endif /*__GNUC__*/
+
+#ifndef _GCRY_GCC_ATTR_DEPRECATED
+#define _GCRY_GCC_ATTR_DEPRECATED
+#endif
+#ifndef _GCRY_GCC_ATTR_PURE
+#define _GCRY_GCC_ATTR_PURE
+#endif
+#ifndef _GCRY_GCC_ATTR_MALLOC
+#define _GCRY_GCC_ATTR_MALLOC
+#endif
+#ifndef _GCRY_GCC_ATTR_PRINTF
+#define _GCRY_GCC_ATTR_PRINTF(f,a)
+#endif
+#ifndef _GCRY_GCC_ATTR_SENTINEL
+#define _GCRY_GCC_ATTR_SENTINEL(a)
+#endif
+
+/* Make up an attribute to mark functions and types as deprecated but
+   allow internal use by Libgcrypt.  */
+#ifdef _GCRYPT_IN_LIBGCRYPT
+#define _GCRY_ATTR_INTERNAL
+#else
+#define _GCRY_ATTR_INTERNAL	_GCRY_GCC_ATTR_DEPRECATED
+#endif
+
+/* Wrappers for the libgpg-error library.  */
+
+typedef gpg_error_t gcry_error_t;
+typedef gpg_err_code_t gcry_err_code_t;
+typedef gpg_err_source_t gcry_err_source_t;
+
+static GPG_ERR_INLINE gcry_error_t
+gcry_err_make (gcry_err_source_t source, gcry_err_code_t code)
+{
+  return gpg_err_make (source, code);
+}
+
+/* The user can define GPG_ERR_SOURCE_DEFAULT before including this
+   file to specify a default source for gpg_error.  */
+#ifndef GCRY_ERR_SOURCE_DEFAULT
+#define GCRY_ERR_SOURCE_DEFAULT  GPG_ERR_SOURCE_USER_1
+#endif
+
+static GPG_ERR_INLINE gcry_error_t
+gcry_error (gcry_err_code_t code)
+{
+  return gcry_err_make (GCRY_ERR_SOURCE_DEFAULT, code);
+}
+
+static GPG_ERR_INLINE gcry_err_code_t
+gcry_err_code (gcry_error_t err)
+{
+  return gpg_err_code (err);
+}
+
+
+static GPG_ERR_INLINE gcry_err_source_t
+gcry_err_source (gcry_error_t err)
+{
+  return gpg_err_source (err);
+}
+
+/* Return a pointer to a string containing a description of the error
+   code in the error value ERR.  */
+const char *gcry_strerror (gcry_error_t err);
+
+/* Return a pointer to a string containing a description of the error
+   source in the error value ERR.  */
+const char *gcry_strsource (gcry_error_t err);
+
+/* Retrieve the error code for the system error ERR.  This returns
+   GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped (report
+   this).  */
+gcry_err_code_t gcry_err_code_from_errno (int err);
+
+/* Retrieve the system error for the error code CODE.  This returns 0
+   if CODE is not a system error code.  */
+int gcry_err_code_to_errno (gcry_err_code_t code);
+
+/* Return an error value with the error source SOURCE and the system
+   error ERR.  */
+gcry_error_t gcry_err_make_from_errno (gcry_err_source_t source, int err);
+
+/* Return an error value with the system error ERR.  */
+gcry_error_t gcry_error_from_errno (int err);
+
+
+/* NOTE: Since Libgcrypt 1.6 the thread callbacks are not anymore
+   used.  However we keep it to allow for some source code
+   compatibility if used in the standard way.  */
+
+/* Constants defining the thread model to use.  Used with the OPTION
+   field of the struct gcry_thread_cbs.  */
+#define GCRY_THREAD_OPTION_DEFAULT  0
+#define GCRY_THREAD_OPTION_USER     1
+#define GCRY_THREAD_OPTION_PTH      2
+#define GCRY_THREAD_OPTION_PTHREAD  3
+
+/* The version number encoded in the OPTION field of the struct
+   gcry_thread_cbs.  */
+#define GCRY_THREAD_OPTION_VERSION  1
+
+/* Wrapper for struct ath_ops.  */
+struct gcry_thread_cbs
+{
+  /* The OPTION field encodes the thread model and the version number
+     of this structure.
+       Bits  7 - 0  are used for the thread model
+       Bits 15 - 8  are used for the version number.  */
+  unsigned int option;
+} _GCRY_ATTR_INTERNAL;
+
+#define GCRY_THREAD_OPTION_PTH_IMPL                                     \
+  static struct gcry_thread_cbs gcry_threads_pth = {                    \
+    (GCRY_THREAD_OPTION_PTH | (GCRY_THREAD_OPTION_VERSION << 8))}
+
+#define GCRY_THREAD_OPTION_PTHREAD_IMPL                                 \
+  static struct gcry_thread_cbs gcry_threads_pthread = {                \
+    (GCRY_THREAD_OPTION_PTHREAD | (GCRY_THREAD_OPTION_VERSION << 8))}
+
+
+
+/* A generic context object as used by some functions.  */
+struct gcry_context;
+typedef struct gcry_context *gcry_ctx_t;
+
+/* The data objects used to hold multi precision integers.  */
+struct gcry_mpi;
+typedef struct gcry_mpi *gcry_mpi_t;
+struct gcry_mpi_point;
+typedef struct gcry_mpi_point *gcry_mpi_point_t;
+
+#ifndef GCRYPT_NO_DEPRECATED
+typedef struct gcry_mpi *GCRY_MPI _GCRY_GCC_ATTR_DEPRECATED;
+typedef struct gcry_mpi *GcryMPI _GCRY_GCC_ATTR_DEPRECATED;
+#endif
+
+/* A structure used for scatter gather hashing.  */
+typedef struct
+{
+  size_t size;  /* The allocated size of the buffer or 0.  */
+  size_t off;   /* Offset into the buffer.  */
+  size_t len;   /* The used length of the buffer.  */
+  void *data;   /* The buffer.  */
+} gcry_buffer_t;
+
+
+
+
+/* Check that the library fulfills the version requirement.  */
+const char *gcry_check_version (const char *req_version);
+
+/* Codes for function dispatchers.  */
+
+/* Codes used with the gcry_control function. */
+enum gcry_ctl_cmds
+  {
+    /* Note: 1 .. 2 are not anymore used. */
+    GCRYCTL_CFB_SYNC = 3,
+    GCRYCTL_RESET    = 4,   /* e.g. for MDs */
+    GCRYCTL_FINALIZE = 5,
+    GCRYCTL_GET_KEYLEN = 6,
+    GCRYCTL_GET_BLKLEN = 7,
+    GCRYCTL_TEST_ALGO = 8,
+    GCRYCTL_IS_SECURE = 9,
+    GCRYCTL_GET_ASNOID = 10,
+    GCRYCTL_ENABLE_ALGO = 11,
+    GCRYCTL_DISABLE_ALGO = 12,
+    GCRYCTL_DUMP_RANDOM_STATS = 13,
+    GCRYCTL_DUMP_SECMEM_STATS = 14,
+    GCRYCTL_GET_ALGO_NPKEY    = 15,
+    GCRYCTL_GET_ALGO_NSKEY    = 16,
+    GCRYCTL_GET_ALGO_NSIGN    = 17,
+    GCRYCTL_GET_ALGO_NENCR    = 18,
+    GCRYCTL_SET_VERBOSITY     = 19,
+    GCRYCTL_SET_DEBUG_FLAGS   = 20,
+    GCRYCTL_CLEAR_DEBUG_FLAGS = 21,
+    GCRYCTL_USE_SECURE_RNDPOOL= 22,
+    GCRYCTL_DUMP_MEMORY_STATS = 23,
+    GCRYCTL_INIT_SECMEM       = 24,
+    GCRYCTL_TERM_SECMEM       = 25,
+    GCRYCTL_DISABLE_SECMEM_WARN = 27,
+    GCRYCTL_SUSPEND_SECMEM_WARN = 28,
+    GCRYCTL_RESUME_SECMEM_WARN  = 29,
+    GCRYCTL_DROP_PRIVS          = 30,
+    GCRYCTL_ENABLE_M_GUARD      = 31,
+    GCRYCTL_START_DUMP          = 32,
+    GCRYCTL_STOP_DUMP           = 33,
+    GCRYCTL_GET_ALGO_USAGE      = 34,
+    GCRYCTL_IS_ALGO_ENABLED     = 35,
+    GCRYCTL_DISABLE_INTERNAL_LOCKING = 36,
+    GCRYCTL_DISABLE_SECMEM      = 37,
+    GCRYCTL_INITIALIZATION_FINISHED = 38,
+    GCRYCTL_INITIALIZATION_FINISHED_P = 39,
+    GCRYCTL_ANY_INITIALIZATION_P = 40,
+    GCRYCTL_SET_CBC_CTS = 41,
+    GCRYCTL_SET_CBC_MAC = 42,
+    /* Note: 43 is not anymore used. */
+    GCRYCTL_ENABLE_QUICK_RANDOM = 44,
+    GCRYCTL_SET_RANDOM_SEED_FILE = 45,
+    GCRYCTL_UPDATE_RANDOM_SEED_FILE = 46,
+    GCRYCTL_SET_THREAD_CBS = 47,
+    GCRYCTL_FAST_POLL = 48,
+    GCRYCTL_SET_RANDOM_DAEMON_SOCKET = 49,
+    GCRYCTL_USE_RANDOM_DAEMON = 50,
+    GCRYCTL_FAKED_RANDOM_P = 51,
+    GCRYCTL_SET_RNDEGD_SOCKET = 52,
+    GCRYCTL_PRINT_CONFIG = 53,
+    GCRYCTL_OPERATIONAL_P = 54,
+    GCRYCTL_FIPS_MODE_P = 55,
+    GCRYCTL_FORCE_FIPS_MODE = 56,
+    GCRYCTL_SELFTEST = 57,
+    /* Note: 58 .. 62 are used internally.  */
+    GCRYCTL_DISABLE_HWF = 63,
+    GCRYCTL_SET_ENFORCED_FIPS_FLAG = 64,
+    GCRYCTL_SET_PREFERRED_RNG_TYPE = 65,
+    GCRYCTL_GET_CURRENT_RNG_TYPE = 66,
+    GCRYCTL_DISABLE_LOCKED_SECMEM = 67,
+    GCRYCTL_DISABLE_PRIV_DROP = 68,
+    GCRYCTL_SET_CCM_LENGTHS = 69,
+    GCRYCTL_CLOSE_RANDOM_DEVICE = 70,
+    GCRYCTL_INACTIVATE_FIPS_FLAG = 71,
+    GCRYCTL_REACTIVATE_FIPS_FLAG = 72,
+    GCRYCTL_SET_SBOX = 73,
+    GCRYCTL_DRBG_REINIT = 74,
+    GCRYCTL_SET_TAGLEN = 75,
+    GCRYCTL_GET_TAGLEN = 76,
+    GCRYCTL_REINIT_SYSCALL_CLAMP = 77
+  };
+
+/* Perform various operations defined by CMD. */
+gcry_error_t gcry_control (enum gcry_ctl_cmds CMD, ...);
+
+
+/* S-expression management. */
+
+/* The object to represent an S-expression as used with the public key
+   functions.  */
+struct gcry_sexp;
+typedef struct gcry_sexp *gcry_sexp_t;
+
+#ifndef GCRYPT_NO_DEPRECATED
+typedef struct gcry_sexp *GCRY_SEXP _GCRY_GCC_ATTR_DEPRECATED;
+typedef struct gcry_sexp *GcrySexp _GCRY_GCC_ATTR_DEPRECATED;
+#endif
+
+/* The possible values for the S-expression format. */
+enum gcry_sexp_format
+  {
+    GCRYSEXP_FMT_DEFAULT   = 0,
+    GCRYSEXP_FMT_CANON     = 1,
+    GCRYSEXP_FMT_BASE64    = 2,
+    GCRYSEXP_FMT_ADVANCED  = 3
+  };
+
+/* Create an new S-expression object from BUFFER of size LENGTH and
+   return it in RETSEXP.  With AUTODETECT set to 0 the data in BUFFER
+   is expected to be in canonized format.  */
+gcry_error_t gcry_sexp_new (gcry_sexp_t *retsexp,
+                            const void *buffer, size_t length,
+                            int autodetect);
+
+ /* Same as gcry_sexp_new but allows to pass a FREEFNC which has the
+    effect to transfer ownership of BUFFER to the created object.  */
+gcry_error_t gcry_sexp_create (gcry_sexp_t *retsexp,
+                               void *buffer, size_t length,
+                               int autodetect, void (*freefnc) (void *));
+
+/* Scan BUFFER and return a new S-expression object in RETSEXP.  This
+   function expects a printf like string in BUFFER.  */
+gcry_error_t gcry_sexp_sscan (gcry_sexp_t *retsexp, size_t *erroff,
+                              const char *buffer, size_t length);
+
+/* Same as gcry_sexp_sscan but expects a string in FORMAT and can thus
+   only be used for certain encodings.  */
+gcry_error_t gcry_sexp_build (gcry_sexp_t *retsexp, size_t *erroff,
+                              const char *format, ...);
+
+/* Like gcry_sexp_build, but uses an array instead of variable
+   function arguments.  */
+gcry_error_t gcry_sexp_build_array (gcry_sexp_t *retsexp, size_t *erroff,
+				    const char *format, void **arg_list);
+
+/* Release the S-expression object SEXP */
+void gcry_sexp_release (gcry_sexp_t sexp);
+
+/* Calculate the length of an canonized S-expression in BUFFER and
+   check for a valid encoding. */
+size_t gcry_sexp_canon_len (const unsigned char *buffer, size_t length,
+                            size_t *erroff, gcry_error_t *errcode);
+
+/* Copies the S-expression object SEXP into BUFFER using the format
+   specified in MODE.  */
+size_t gcry_sexp_sprint (gcry_sexp_t sexp, int mode, void *buffer,
+                         size_t maxlength);
+
+/* Dumps the S-expression object A in a format suitable for debugging
+   to Libgcrypt's logging stream.  */
+void gcry_sexp_dump (const gcry_sexp_t a);
+
+gcry_sexp_t gcry_sexp_cons (const gcry_sexp_t a, const gcry_sexp_t b);
+gcry_sexp_t gcry_sexp_alist (const gcry_sexp_t *array);
+gcry_sexp_t gcry_sexp_vlist (const gcry_sexp_t a, ...);
+gcry_sexp_t gcry_sexp_append (const gcry_sexp_t a, const gcry_sexp_t n);
+gcry_sexp_t gcry_sexp_prepend (const gcry_sexp_t a, const gcry_sexp_t n);
+
+/* Scan the S-expression for a sublist with a type (the car of the
+   list) matching the string TOKEN.  If TOKLEN is not 0, the token is
+   assumed to be raw memory of this length.  The function returns a
+   newly allocated S-expression consisting of the found sublist or
+   `NULL' when not found.  */
+gcry_sexp_t gcry_sexp_find_token (gcry_sexp_t list,
+                                const char *tok, size_t toklen);
+/* Return the length of the LIST.  For a valid S-expression this
+   should be at least 1.  */
+int gcry_sexp_length (const gcry_sexp_t list);
+
+/* Create and return a new S-expression from the element with index
+   NUMBER in LIST.  Note that the first element has the index 0.  If
+   there is no such element, `NULL' is returned.  */
+gcry_sexp_t gcry_sexp_nth (const gcry_sexp_t list, int number);
+
+/* Create and return a new S-expression from the first element in
+   LIST; this called the "type" and should always exist and be a
+   string. `NULL' is returned in case of a problem.  */
+gcry_sexp_t gcry_sexp_car (const gcry_sexp_t list);
+
+/* Create and return a new list form all elements except for the first
+   one.  Note, that this function may return an invalid S-expression
+   because it is not guaranteed, that the type exists and is a string.
+   However, for parsing a complex S-expression it might be useful for
+   intermediate lists.  Returns `NULL' on error.  */
+gcry_sexp_t gcry_sexp_cdr (const gcry_sexp_t list);
+
+gcry_sexp_t gcry_sexp_cadr (const gcry_sexp_t list);
+
+
+/* This function is used to get data from a LIST.  A pointer to the
+   actual data with index NUMBER is returned and the length of this
+   data will be stored to DATALEN.  If there is no data at the given
+   index or the index represents another list, `NULL' is returned.
+   *Note:* The returned pointer is valid as long as LIST is not
+   modified or released.  */
+const char *gcry_sexp_nth_data (const gcry_sexp_t list, int number,
+                                size_t *datalen);
+
+/* This function is used to get data from a LIST.  A malloced buffer to the
+   data with index NUMBER is returned and the length of this
+   data will be stored to RLENGTH.  If there is no data at the given
+   index or the index represents another list, `NULL' is returned.  */
+void *gcry_sexp_nth_buffer (const gcry_sexp_t list, int number,
+                            size_t *rlength);
+
+/* This function is used to get and convert data from a LIST.  The
+   data is assumed to be a Nul terminated string.  The caller must
+   release the returned value using `gcry_free'.  If there is no data
+   at the given index, the index represents a list or the value can't
+   be converted to a string, `NULL' is returned.  */
+char *gcry_sexp_nth_string (gcry_sexp_t list, int number);
+
+/* This function is used to get and convert data from a LIST. This
+   data is assumed to be an MPI stored in the format described by
+   MPIFMT and returned as a standard Libgcrypt MPI.  The caller must
+   release this returned value using `gcry_mpi_release'.  If there is
+   no data at the given index, the index represents a list or the
+   value can't be converted to an MPI, `NULL' is returned.  */
+gcry_mpi_t gcry_sexp_nth_mpi (gcry_sexp_t list, int number, int mpifmt);
+
+/* Extract MPIs from an s-expression using a list of parameters.  The
+ * names of these parameters are given by the string LIST.  Some
+ * special characters may be given to control the conversion:
+ *
+ *    + :: Switch to unsigned integer format (default).
+ *    - :: Switch to standard signed format.
+ *    / :: Switch to opaque format.
+ *    & :: Switch to buffer descriptor mode - see below.
+ *    ? :: The previous parameter is optional.
+ *
+ * In general parameter names are single letters.  To use a string for
+ * a parameter name, enclose the name in single quotes.
+ *
+ * Unless in gcry_buffer_t mode for each parameter name a pointer to
+ * an MPI variable is expected that must be set to NULL prior to
+ * invoking this function, and finally a NULL is expected.  Example:
+ *
+ *   _gcry_sexp_extract_param (key, NULL, "n/x+ed",
+ *                             &mpi_n, &mpi_x, &mpi_e, NULL)
+ *
+ * This stores the parameter "N" from KEY as an unsigned MPI into
+ * MPI_N, the parameter "X" as an opaque MPI into MPI_X, and the
+ * parameter "E" again as an unsigned MPI into MPI_E.
+ *
+ * If in buffer descriptor mode a pointer to gcry_buffer_t descriptor
+ * is expected instead of a pointer to an MPI.  The caller may use two
+ * different operation modes: If the DATA field of the provided buffer
+ * descriptor is NULL, the function allocates a new buffer and stores
+ * it at DATA; the other fields are set accordingly with OFF being 0.
+ * If DATA is not NULL, the function assumes that DATA, SIZE, and OFF
+ * describe a buffer where to but the data; on return the LEN field
+ * receives the number of bytes copied to that buffer; if the buffer
+ * is too small, the function immediately returns with an error code
+ * (and LEN set to 0).
+ *
+ * PATH is an optional string used to locate a token.  The exclamation
+ * mark separated tokens are used to via gcry_sexp_find_token to find
+ * a start point inside SEXP.
+ *
+ * The function returns 0 on success.  On error an error code is
+ * returned, all passed MPIs that might have been allocated up to this
+ * point are deallocated and set to NULL, and all passed buffers are
+ * either truncated if the caller supplied the buffer, or deallocated
+ * if the function allocated the buffer.
+ */
+gpg_error_t gcry_sexp_extract_param (gcry_sexp_t sexp,
+                                     const char *path,
+                                     const char *list,
+                                     ...) _GCRY_GCC_ATTR_SENTINEL(0);
+
+
+/*******************************************
+ *                                         *
+ *  Multi Precision Integer Functions      *
+ *                                         *
+ *******************************************/
+
+/* Different formats of external big integer representation. */
+enum gcry_mpi_format
+  {
+    GCRYMPI_FMT_NONE= 0,
+    GCRYMPI_FMT_STD = 1,    /* Twos complement stored without length.  */
+    GCRYMPI_FMT_PGP = 2,    /* As used by OpenPGP (unsigned only).  */
+    GCRYMPI_FMT_SSH = 3,    /* As used by SSH (like STD but with length).  */
+    GCRYMPI_FMT_HEX = 4,    /* Hex format. */
+    GCRYMPI_FMT_USG = 5,    /* Like STD but unsigned. */
+    GCRYMPI_FMT_OPAQUE = 8  /* Opaque format (some functions only).  */
+  };
+
+/* Flags used for creating big integers.  */
+enum gcry_mpi_flag
+  {
+    GCRYMPI_FLAG_SECURE = 1,  /* Allocate the number in "secure" memory.  */
+    GCRYMPI_FLAG_OPAQUE = 2,  /* The number is not a real one but just
+                                 a way to store some bytes.  This is
+                                 useful for encrypted big integers.  */
+    GCRYMPI_FLAG_IMMUTABLE = 4, /* Mark the MPI as immutable.  */
+    GCRYMPI_FLAG_CONST     = 8, /* Mark the MPI as a constant.  */
+    GCRYMPI_FLAG_USER1 = 0x0100,/* User flag 1.  */
+    GCRYMPI_FLAG_USER2 = 0x0200,/* User flag 2.  */
+    GCRYMPI_FLAG_USER3 = 0x0400,/* User flag 3.  */
+    GCRYMPI_FLAG_USER4 = 0x0800 /* User flag 4.  */
+  };
+
+
+/* Macros to return pre-defined MPI constants.  */
+#define GCRYMPI_CONST_ONE   (_gcry_mpi_get_const (1))
+#define GCRYMPI_CONST_TWO   (_gcry_mpi_get_const (2))
+#define GCRYMPI_CONST_THREE (_gcry_mpi_get_const (3))
+#define GCRYMPI_CONST_FOUR  (_gcry_mpi_get_const (4))
+#define GCRYMPI_CONST_EIGHT (_gcry_mpi_get_const (8))
+
+/* Allocate a new big integer object, initialize it with 0 and
+   initially allocate memory for a number of at least NBITS. */
+gcry_mpi_t gcry_mpi_new (unsigned int nbits);
+
+/* Same as gcry_mpi_new() but allocate in "secure" memory. */
+gcry_mpi_t gcry_mpi_snew (unsigned int nbits);
+
+/* Release the number A and free all associated resources. */
+void gcry_mpi_release (gcry_mpi_t a);
+
+/* Create a new number with the same value as A. */
+gcry_mpi_t gcry_mpi_copy (const gcry_mpi_t a);
+
+/* Store the big integer value U in W and release U.  */
+void gcry_mpi_snatch (gcry_mpi_t w, gcry_mpi_t u);
+
+/* Store the big integer value U in W. */
+gcry_mpi_t gcry_mpi_set (gcry_mpi_t w, const gcry_mpi_t u);
+
+/* Store the unsigned integer value U in W. */
+gcry_mpi_t gcry_mpi_set_ui (gcry_mpi_t w, unsigned long u);
+
+/* Swap the values of A and B. */
+void gcry_mpi_swap (gcry_mpi_t a, gcry_mpi_t b);
+
+/* Return 1 if A is negative; 0 if zero or positive.  */
+int gcry_mpi_is_neg (gcry_mpi_t a);
+
+/* W = - U */
+void gcry_mpi_neg (gcry_mpi_t w, gcry_mpi_t u);
+
+/* W = [W] */
+void gcry_mpi_abs (gcry_mpi_t w);
+
+/* Compare the big integer number U and V returning 0 for equality, a
+   positive value for U > V and a negative for U < V. */
+int gcry_mpi_cmp (const gcry_mpi_t u, const gcry_mpi_t v);
+
+/* Compare the big integer number U with the unsigned integer V
+   returning 0 for equality, a positive value for U > V and a negative
+   for U < V. */
+int gcry_mpi_cmp_ui (const gcry_mpi_t u, unsigned long v);
+
+/* Convert the external representation of an integer stored in BUFFER
+   with a length of BUFLEN into a newly create MPI returned in
+   RET_MPI.  If NSCANNED is not NULL, it will receive the number of
+   bytes actually scanned after a successful operation. */
+gcry_error_t gcry_mpi_scan (gcry_mpi_t *ret_mpi, enum gcry_mpi_format format,
+                            const void *buffer, size_t buflen,
+                            size_t *nscanned);
+
+/* Convert the big integer A into the external representation
+   described by FORMAT and store it in the provided BUFFER which has
+   been allocated by the user with a size of BUFLEN bytes.  NWRITTEN
+   receives the actual length of the external representation unless it
+   has been passed as NULL. */
+gcry_error_t gcry_mpi_print (enum gcry_mpi_format format,
+                             unsigned char *buffer, size_t buflen,
+                             size_t *nwritten,
+                             const gcry_mpi_t a);
+
+/* Convert the big integer A into the external representation described
+   by FORMAT and store it in a newly allocated buffer which address
+   will be put into BUFFER.  NWRITTEN receives the actual lengths of the
+   external representation. */
+gcry_error_t gcry_mpi_aprint (enum gcry_mpi_format format,
+                              unsigned char **buffer, size_t *nwritten,
+                              const gcry_mpi_t a);
+
+/* Dump the value of A in a format suitable for debugging to
+   Libgcrypt's logging stream.  Note that one leading space but no
+   trailing space or linefeed will be printed.  It is okay to pass
+   NULL for A. */
+void gcry_mpi_dump (const gcry_mpi_t a);
+
+
+/* W = U + V.  */
+void gcry_mpi_add (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v);
+
+/* W = U + V.  V is an unsigned integer. */
+void gcry_mpi_add_ui (gcry_mpi_t w, gcry_mpi_t u, unsigned long v);
+
+/* W = U + V mod M. */
+void gcry_mpi_addm (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v, gcry_mpi_t m);
+
+/* W = U - V. */
+void gcry_mpi_sub (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v);
+
+/* W = U - V.  V is an unsigned integer. */
+void gcry_mpi_sub_ui (gcry_mpi_t w, gcry_mpi_t u, unsigned long v );
+
+/* W = U - V mod M */
+void gcry_mpi_subm (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v, gcry_mpi_t m);
+
+/* W = U * V. */
+void gcry_mpi_mul (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v);
+
+/* W = U * V.  V is an unsigned integer. */
+void gcry_mpi_mul_ui (gcry_mpi_t w, gcry_mpi_t u, unsigned long v );
+
+/* W = U * V mod M. */
+void gcry_mpi_mulm (gcry_mpi_t w, gcry_mpi_t u, gcry_mpi_t v, gcry_mpi_t m);
+
+/* W = U * (2 ^ CNT). */
+void gcry_mpi_mul_2exp (gcry_mpi_t w, gcry_mpi_t u, unsigned long cnt);
+
+/* Q = DIVIDEND / DIVISOR, R = DIVIDEND % DIVISOR,
+   Q or R may be passed as NULL.  ROUND should be negative or 0. */
+void gcry_mpi_div (gcry_mpi_t q, gcry_mpi_t r,
+                   gcry_mpi_t dividend, gcry_mpi_t divisor, int round);
+
+/* R = DIVIDEND % DIVISOR */
+void gcry_mpi_mod (gcry_mpi_t r, gcry_mpi_t dividend, gcry_mpi_t divisor);
+
+/* W = B ^ E mod M. */
+void gcry_mpi_powm (gcry_mpi_t w,
+                    const gcry_mpi_t b, const gcry_mpi_t e,
+                    const gcry_mpi_t m);
+
+/* Set G to the greatest common divisor of A and B.
+   Return true if the G is 1. */
+int gcry_mpi_gcd (gcry_mpi_t g, gcry_mpi_t a, gcry_mpi_t b);
+
+/* Set X to the multiplicative inverse of A mod M.
+   Return true if the value exists. */
+int gcry_mpi_invm (gcry_mpi_t x, gcry_mpi_t a, gcry_mpi_t m);
+
+/* Create a new point object.  NBITS is usually 0.  */
+gcry_mpi_point_t gcry_mpi_point_new (unsigned int nbits);
+
+/* Release the object POINT.  POINT may be NULL. */
+void gcry_mpi_point_release (gcry_mpi_point_t point);
+
+/* Return a copy of POINT. */
+gcry_mpi_point_t gcry_mpi_point_copy (gcry_mpi_point_t point);
+
+/* Store the projective coordinates from POINT into X, Y, and Z.  */
+void gcry_mpi_point_get (gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z,
+                         gcry_mpi_point_t point);
+
+/* Store the projective coordinates from POINT into X, Y, and Z and
+   release POINT.  */
+void gcry_mpi_point_snatch_get (gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z,
+                                gcry_mpi_point_t point);
+
+/* Store the projective coordinates X, Y, and Z into POINT.  */
+gcry_mpi_point_t gcry_mpi_point_set (gcry_mpi_point_t point,
+                                     gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_t z);
+
+/* Store the projective coordinates X, Y, and Z into POINT and release
+   X, Y, and Z.  */
+gcry_mpi_point_t gcry_mpi_point_snatch_set (gcry_mpi_point_t point,
+                                            gcry_mpi_t x, gcry_mpi_t y,
+                                            gcry_mpi_t z);
+
+/* Allocate a new context for elliptic curve operations based on the
+   parameters given by KEYPARAM or using CURVENAME.  */
+gpg_error_t gcry_mpi_ec_new (gcry_ctx_t *r_ctx,
+                             gcry_sexp_t keyparam, const char *curvename);
+
+/* Get a named MPI from an elliptic curve context.  */
+gcry_mpi_t gcry_mpi_ec_get_mpi (const char *name, gcry_ctx_t ctx, int copy);
+
+/* Get a named point from an elliptic curve context.  */
+gcry_mpi_point_t gcry_mpi_ec_get_point (const char *name,
+                                        gcry_ctx_t ctx, int copy);
+
+/* Store a named MPI into an elliptic curve context.  */
+gpg_error_t gcry_mpi_ec_set_mpi (const char *name, gcry_mpi_t newvalue,
+                                 gcry_ctx_t ctx);
+
+/* Store a named point into an elliptic curve context.  */
+gpg_error_t gcry_mpi_ec_set_point (const char *name, gcry_mpi_point_t newvalue,
+                                   gcry_ctx_t ctx);
+
+/* Decode and store VALUE into RESULT.  */
+gpg_error_t gcry_mpi_ec_decode_point (gcry_mpi_point_t result,
+                                      gcry_mpi_t value, gcry_ctx_t ctx);
+
+/* Store the affine coordinates of POINT into X and Y.  */
+int gcry_mpi_ec_get_affine (gcry_mpi_t x, gcry_mpi_t y, gcry_mpi_point_t point,
+                            gcry_ctx_t ctx);
+
+/* W = 2 * U.  */
+void gcry_mpi_ec_dup (gcry_mpi_point_t w, gcry_mpi_point_t u, gcry_ctx_t ctx);
+
+/* W = U + V.  */
+void gcry_mpi_ec_add (gcry_mpi_point_t w,
+                      gcry_mpi_point_t u, gcry_mpi_point_t v, gcry_ctx_t ctx);
+
+/* W = U - V.  */
+void gcry_mpi_ec_sub (gcry_mpi_point_t w,
+                      gcry_mpi_point_t u, gcry_mpi_point_t v, gcry_ctx_t ctx);
+
+/* W = N * U.  */
+void gcry_mpi_ec_mul (gcry_mpi_point_t w, gcry_mpi_t n, gcry_mpi_point_t u,
+                      gcry_ctx_t ctx);
+
+/* Return true if POINT is on the curve described by CTX.  */
+int gcry_mpi_ec_curve_point (gcry_mpi_point_t w, gcry_ctx_t ctx);
+
+/* Return the number of bits required to represent A. */
+unsigned int gcry_mpi_get_nbits (gcry_mpi_t a);
+
+/* Return true when bit number N (counting from 0) is set in A. */
+int      gcry_mpi_test_bit (gcry_mpi_t a, unsigned int n);
+
+/* Set bit number N in A. */
+void     gcry_mpi_set_bit (gcry_mpi_t a, unsigned int n);
+
+/* Clear bit number N in A. */
+void     gcry_mpi_clear_bit (gcry_mpi_t a, unsigned int n);
+
+/* Set bit number N in A and clear all bits greater than N. */
+void     gcry_mpi_set_highbit (gcry_mpi_t a, unsigned int n);
+
+/* Clear bit number N in A and all bits greater than N. */
+void     gcry_mpi_clear_highbit (gcry_mpi_t a, unsigned int n);
+
+/* Shift the value of A by N bits to the right and store the result in X. */
+void     gcry_mpi_rshift (gcry_mpi_t x, gcry_mpi_t a, unsigned int n);
+
+/* Shift the value of A by N bits to the left and store the result in X. */
+void     gcry_mpi_lshift (gcry_mpi_t x, gcry_mpi_t a, unsigned int n);
+
+/* Store NBITS of the value P points to in A and mark A as an opaque
+   value.  On success A received the the ownership of the value P.
+   WARNING: Never use an opaque MPI for anything thing else than
+   gcry_mpi_release, gcry_mpi_get_opaque. */
+gcry_mpi_t gcry_mpi_set_opaque (gcry_mpi_t a, void *p, unsigned int nbits);
+
+/* Store NBITS of the value P points to in A and mark A as an opaque
+   value.  The function takes a copy of the provided value P.
+   WARNING: Never use an opaque MPI for anything thing else than
+   gcry_mpi_release, gcry_mpi_get_opaque. */
+gcry_mpi_t gcry_mpi_set_opaque_copy (gcry_mpi_t a,
+                                     const void *p, unsigned int nbits);
+
+/* Return a pointer to an opaque value stored in A and return its size
+   in NBITS.  Note that the returned pointer is still owned by A and
+   that the function should never be used for an non-opaque MPI. */
+void *gcry_mpi_get_opaque (gcry_mpi_t a, unsigned int *nbits);
+
+/* Set the FLAG for the big integer A.  Currently only the flag
+   GCRYMPI_FLAG_SECURE is allowed to convert A into an big intger
+   stored in "secure" memory. */
+void gcry_mpi_set_flag (gcry_mpi_t a, enum gcry_mpi_flag flag);
+
+/* Clear FLAG for the big integer A.  Note that this function is
+   currently useless as no flags are allowed. */
+void gcry_mpi_clear_flag (gcry_mpi_t a, enum gcry_mpi_flag flag);
+
+/* Return true if the FLAG is set for A. */
+int gcry_mpi_get_flag (gcry_mpi_t a, enum gcry_mpi_flag flag);
+
+/* Private function - do not use.  */
+gcry_mpi_t _gcry_mpi_get_const (int no);
+
+/* Unless the GCRYPT_NO_MPI_MACROS is used, provide a couple of
+   convenience macros for the big integer functions. */
+#ifndef GCRYPT_NO_MPI_MACROS
+#define mpi_new(n)          gcry_mpi_new( (n) )
+#define mpi_secure_new( n ) gcry_mpi_snew( (n) )
+#define mpi_release(a)      \
+  do \
+    { \
+      gcry_mpi_release ((a)); \
+      (a) = NULL; \
+    } \
+  while (0)
+
+#define mpi_copy( a )          gcry_mpi_copy( (a) )
+#define mpi_snatch( w, u)      gcry_mpi_snatch( (w), (u) )
+#define mpi_set( w, u)         gcry_mpi_set( (w), (u) )
+#define mpi_set_ui( w, u)      gcry_mpi_set_ui( (w), (u) )
+#define mpi_abs( w )           gcry_mpi_abs( (w) )
+#define mpi_neg( w, u)         gcry_mpi_neg( (w), (u) )
+#define mpi_cmp( u, v )        gcry_mpi_cmp( (u), (v) )
+#define mpi_cmp_ui( u, v )     gcry_mpi_cmp_ui( (u), (v) )
+#define mpi_is_neg( a )        gcry_mpi_is_neg ((a))
+
+#define mpi_add_ui(w,u,v)      gcry_mpi_add_ui((w),(u),(v))
+#define mpi_add(w,u,v)         gcry_mpi_add ((w),(u),(v))
+#define mpi_addm(w,u,v,m)      gcry_mpi_addm ((w),(u),(v),(m))
+#define mpi_sub_ui(w,u,v)      gcry_mpi_sub_ui ((w),(u),(v))
+#define mpi_sub(w,u,v)         gcry_mpi_sub ((w),(u),(v))
+#define mpi_subm(w,u,v,m)      gcry_mpi_subm ((w),(u),(v),(m))
+#define mpi_mul_ui(w,u,v)      gcry_mpi_mul_ui ((w),(u),(v))
+#define mpi_mul_2exp(w,u,v)    gcry_mpi_mul_2exp ((w),(u),(v))
+#define mpi_mul(w,u,v)         gcry_mpi_mul ((w),(u),(v))
+#define mpi_mulm(w,u,v,m)      gcry_mpi_mulm ((w),(u),(v),(m))
+#define mpi_powm(w,b,e,m)      gcry_mpi_powm ( (w), (b), (e), (m) )
+#define mpi_tdiv(q,r,a,m)      gcry_mpi_div ( (q), (r), (a), (m), 0)
+#define mpi_fdiv(q,r,a,m)      gcry_mpi_div ( (q), (r), (a), (m), -1)
+#define mpi_mod(r,a,m)         gcry_mpi_mod ((r), (a), (m))
+#define mpi_gcd(g,a,b)         gcry_mpi_gcd ( (g), (a), (b) )
+#define mpi_invm(g,a,b)        gcry_mpi_invm ( (g), (a), (b) )
+
+#define mpi_point_new(n)              gcry_mpi_point_new((n))
+#define mpi_point_release(p)                    \
+  do                                            \
+    {                                           \
+      gcry_mpi_point_release ((p));             \
+      (p) = NULL;                               \
+    }                                           \
+  while (0)
+#define mpi_point_copy(p)             gcry_mpi_point_copy((p))
+#define mpi_point_get(x,y,z,p)        gcry_mpi_point_get((x),(y),(z),(p))
+#define mpi_point_snatch_get(x,y,z,p) gcry_mpi_point_snatch_get((x),(y),(z),(p))
+#define mpi_point_set(p,x,y,z)        gcry_mpi_point_set((p),(x),(y),(z))
+#define mpi_point_snatch_set(p,x,y,z) gcry_mpi_point_snatch_set((p),(x),(y),(z))
+
+#define mpi_get_nbits(a)       gcry_mpi_get_nbits ((a))
+#define mpi_test_bit(a,b)      gcry_mpi_test_bit ((a),(b))
+#define mpi_set_bit(a,b)       gcry_mpi_set_bit ((a),(b))
+#define mpi_set_highbit(a,b)   gcry_mpi_set_highbit ((a),(b))
+#define mpi_clear_bit(a,b)     gcry_mpi_clear_bit ((a),(b))
+#define mpi_clear_highbit(a,b) gcry_mpi_clear_highbit ((a),(b))
+#define mpi_rshift(a,b,c)      gcry_mpi_rshift ((a),(b),(c))
+#define mpi_lshift(a,b,c)      gcry_mpi_lshift ((a),(b),(c))
+
+#define mpi_set_opaque(a,b,c)  gcry_mpi_set_opaque( (a), (b), (c) )
+#define mpi_get_opaque(a,b)    gcry_mpi_get_opaque( (a), (b) )
+#endif /* GCRYPT_NO_MPI_MACROS */
+
+
+
+/************************************
+ *                                  *
+ *   Symmetric Cipher Functions     *
+ *                                  *
+ ************************************/
+
+/* The data object used to hold a handle to an encryption object.  */
+struct gcry_cipher_handle;
+typedef struct gcry_cipher_handle *gcry_cipher_hd_t;
+
+#ifndef GCRYPT_NO_DEPRECATED
+typedef struct gcry_cipher_handle *GCRY_CIPHER_HD _GCRY_GCC_ATTR_DEPRECATED;
+typedef struct gcry_cipher_handle *GcryCipherHd _GCRY_GCC_ATTR_DEPRECATED;
+#endif
+
+/* All symmetric encryption algorithms are identified by their IDs.
+   More IDs may be registered at runtime. */
+enum gcry_cipher_algos
+  {
+    GCRY_CIPHER_NONE        = 0,
+    GCRY_CIPHER_IDEA        = 1,
+    GCRY_CIPHER_3DES        = 2,
+    GCRY_CIPHER_CAST5       = 3,
+    GCRY_CIPHER_BLOWFISH    = 4,
+    GCRY_CIPHER_SAFER_SK128 = 5,
+    GCRY_CIPHER_DES_SK      = 6,
+    GCRY_CIPHER_AES         = 7,
+    GCRY_CIPHER_AES192      = 8,
+    GCRY_CIPHER_AES256      = 9,
+    GCRY_CIPHER_TWOFISH     = 10,
+
+    /* Other cipher numbers are above 300 for OpenPGP reasons. */
+    GCRY_CIPHER_ARCFOUR     = 301,  /* Fully compatible with RSA's RC4 (tm). */
+    GCRY_CIPHER_DES         = 302,  /* Yes, this is single key 56 bit DES. */
+    GCRY_CIPHER_TWOFISH128  = 303,
+    GCRY_CIPHER_SERPENT128  = 304,
+    GCRY_CIPHER_SERPENT192  = 305,
+    GCRY_CIPHER_SERPENT256  = 306,
+    GCRY_CIPHER_RFC2268_40  = 307,  /* Ron's Cipher 2 (40 bit). */
+    GCRY_CIPHER_RFC2268_128 = 308,  /* Ron's Cipher 2 (128 bit). */
+    GCRY_CIPHER_SEED        = 309,  /* 128 bit cipher described in RFC4269. */
+    GCRY_CIPHER_CAMELLIA128 = 310,
+    GCRY_CIPHER_CAMELLIA192 = 311,
+    GCRY_CIPHER_CAMELLIA256 = 312,
+    GCRY_CIPHER_SALSA20     = 313,
+    GCRY_CIPHER_SALSA20R12  = 314,
+    GCRY_CIPHER_GOST28147   = 315,
+    GCRY_CIPHER_CHACHA20    = 316
+  };
+
+/* The Rijndael algorithm is basically AES, so provide some macros. */
+#define GCRY_CIPHER_AES128      GCRY_CIPHER_AES
+#define GCRY_CIPHER_RIJNDAEL    GCRY_CIPHER_AES
+#define GCRY_CIPHER_RIJNDAEL128 GCRY_CIPHER_AES128
+#define GCRY_CIPHER_RIJNDAEL192 GCRY_CIPHER_AES192
+#define GCRY_CIPHER_RIJNDAEL256 GCRY_CIPHER_AES256
+
+/* The supported encryption modes.  Note that not all of them are
+   supported for each algorithm. */
+enum gcry_cipher_modes
+  {
+    GCRY_CIPHER_MODE_NONE     = 0,   /* Not yet specified. */
+    GCRY_CIPHER_MODE_ECB      = 1,   /* Electronic codebook. */
+    GCRY_CIPHER_MODE_CFB      = 2,   /* Cipher feedback. */
+    GCRY_CIPHER_MODE_CBC      = 3,   /* Cipher block chaining. */
+    GCRY_CIPHER_MODE_STREAM   = 4,   /* Used with stream ciphers. */
+    GCRY_CIPHER_MODE_OFB      = 5,   /* Outer feedback. */
+    GCRY_CIPHER_MODE_CTR      = 6,   /* Counter. */
+    GCRY_CIPHER_MODE_AESWRAP  = 7,   /* AES-WRAP algorithm.  */
+    GCRY_CIPHER_MODE_CCM      = 8,   /* Counter with CBC-MAC.  */
+    GCRY_CIPHER_MODE_GCM      = 9,   /* Galois Counter Mode. */
+    GCRY_CIPHER_MODE_POLY1305 = 10,  /* Poly1305 based AEAD mode. */
+    GCRY_CIPHER_MODE_OCB      = 11,  /* OCB3 mode.  */
+    GCRY_CIPHER_MODE_CFB8     = 12,  /* Cipher feedback (8 bit mode). */
+    GCRY_CIPHER_MODE_XTS      = 13  /* XTS mode.  */
+  };
+
+/* Flags used with the open function. */
+enum gcry_cipher_flags
+  {
+    GCRY_CIPHER_SECURE      = 1,  /* Allocate in secure memory. */
+    GCRY_CIPHER_ENABLE_SYNC = 2,  /* Enable CFB sync mode. */
+    GCRY_CIPHER_CBC_CTS     = 4,  /* Enable CBC cipher text stealing (CTS). */
+    GCRY_CIPHER_CBC_MAC     = 8   /* Enable CBC message auth. code (MAC). */
+  };
+
+/* GCM works only with blocks of 128 bits */
+#define GCRY_GCM_BLOCK_LEN  (128 / 8)
+
+/* CCM works only with blocks of 128 bits.  */
+#define GCRY_CCM_BLOCK_LEN  (128 / 8)
+
+/* OCB works only with blocks of 128 bits.  */
+#define GCRY_OCB_BLOCK_LEN  (128 / 8)
+
+/* XTS works only with blocks of 128 bits.  */
+#define GCRY_XTS_BLOCK_LEN  (128 / 8)
+
+/* Create a handle for algorithm ALGO to be used in MODE.  FLAGS may
+   be given as an bitwise OR of the gcry_cipher_flags values. */
+gcry_error_t gcry_cipher_open (gcry_cipher_hd_t *handle,
+                              int algo, int mode, unsigned int flags);
+
+/* Close the cipher handle H and release all resource. */
+void gcry_cipher_close (gcry_cipher_hd_t h);
+
+/* Perform various operations on the cipher object H. */
+gcry_error_t gcry_cipher_ctl (gcry_cipher_hd_t h, int cmd, void *buffer,
+                             size_t buflen);
+
+/* Retrieve various information about the cipher object H. */
+gcry_error_t gcry_cipher_info (gcry_cipher_hd_t h, int what, void *buffer,
+                              size_t *nbytes);
+
+/* Retrieve various information about the cipher algorithm ALGO. */
+gcry_error_t gcry_cipher_algo_info (int algo, int what, void *buffer,
+                                   size_t *nbytes);
+
+/* Map the cipher algorithm whose ID is contained in ALGORITHM to a
+   string representation of the algorithm name.  For unknown algorithm
+   IDs this function returns "?".  */
+const char *gcry_cipher_algo_name (int algorithm) _GCRY_GCC_ATTR_PURE;
+
+/* Map the algorithm name NAME to an cipher algorithm ID.  Return 0 if
+   the algorithm name is not known. */
+int gcry_cipher_map_name (const char *name) _GCRY_GCC_ATTR_PURE;
+
+/* Given an ASN.1 object identifier in standard IETF dotted decimal
+   format in STRING, return the encryption mode associated with that
+   OID or 0 if not known or applicable. */
+int gcry_cipher_mode_from_oid (const char *string) _GCRY_GCC_ATTR_PURE;
+
+/* Encrypt the plaintext of size INLEN in IN using the cipher handle H
+   into the buffer OUT which has an allocated length of OUTSIZE.  For
+   most algorithms it is possible to pass NULL for in and 0 for INLEN
+   and do a in-place decryption of the data provided in OUT.  */
+gcry_error_t gcry_cipher_encrypt (gcry_cipher_hd_t h,
+                                  void *out, size_t outsize,
+                                  const void *in, size_t inlen);
+
+/* The counterpart to gcry_cipher_encrypt.  */
+gcry_error_t gcry_cipher_decrypt (gcry_cipher_hd_t h,
+                                  void *out, size_t outsize,
+                                  const void *in, size_t inlen);
+
+/* Set KEY of length KEYLEN bytes for the cipher handle HD.  */
+gcry_error_t gcry_cipher_setkey (gcry_cipher_hd_t hd,
+                                 const void *key, size_t keylen);
+
+
+/* Set initialization vector IV of length IVLEN for the cipher handle HD. */
+gcry_error_t gcry_cipher_setiv (gcry_cipher_hd_t hd,
+                                const void *iv, size_t ivlen);
+
+/* Provide additional authentication data for AEAD modes/ciphers.  */
+gcry_error_t gcry_cipher_authenticate (gcry_cipher_hd_t hd, const void *abuf,
+                                       size_t abuflen);
+
+/* Get authentication tag for AEAD modes/ciphers.  */
+gcry_error_t gcry_cipher_gettag (gcry_cipher_hd_t hd, void *outtag,
+                                 size_t taglen);
+
+/* Check authentication tag for AEAD modes/ciphers.  */
+gcry_error_t gcry_cipher_checktag (gcry_cipher_hd_t hd, const void *intag,
+                                   size_t taglen);
+
+/* Reset the handle to the state after open.  */
+#define gcry_cipher_reset(h)  gcry_cipher_ctl ((h), GCRYCTL_RESET, NULL, 0)
+
+/* Perform the OpenPGP sync operation if this is enabled for the
+   cipher handle H. */
+#define gcry_cipher_sync(h)  gcry_cipher_ctl( (h), GCRYCTL_CFB_SYNC, NULL, 0)
+
+/* Enable or disable CTS in future calls to gcry_encrypt(). CBC mode only. */
+#define gcry_cipher_cts(h,on)  gcry_cipher_ctl( (h), GCRYCTL_SET_CBC_CTS, \
+                                                                   NULL, on )
+
+#define gcry_cipher_set_sbox(h,oid) gcry_cipher_ctl( (h), GCRYCTL_SET_SBOX, \
+                                                     (void *) oid, 0);
+
+/* Indicate to the encrypt and decrypt functions that the next call
+   provides the final data.  Only used with some modes.  */
+#define gcry_cipher_final(a) \
+            gcry_cipher_ctl ((a), GCRYCTL_FINALIZE, NULL, 0)
+
+/* Set counter for CTR mode.  (CTR,CTRLEN) must denote a buffer of
+   block size length, or (NULL,0) to set the CTR to the all-zero block. */
+gpg_error_t gcry_cipher_setctr (gcry_cipher_hd_t hd,
+                                const void *ctr, size_t ctrlen);
+
+/* Retrieve the key length in bytes used with algorithm A. */
+size_t gcry_cipher_get_algo_keylen (int algo);
+
+/* Retrieve the block length in bytes used with algorithm A. */
+size_t gcry_cipher_get_algo_blklen (int algo);
+
+/* Return 0 if the algorithm A is available for use. */
+#define gcry_cipher_test_algo(a) \
+            gcry_cipher_algo_info( (a), GCRYCTL_TEST_ALGO, NULL, NULL )
+
+
+/************************************
+ *                                  *
+ *    Asymmetric Cipher Functions   *
+ *                                  *
+ ************************************/
+
+/* The algorithms and their IDs we support.  */
+enum gcry_pk_algos
+  {
+    GCRY_PK_RSA   = 1,      /* RSA */
+    GCRY_PK_RSA_E = 2,      /* (deprecated: use 1).  */
+    GCRY_PK_RSA_S = 3,      /* (deprecated: use 1).  */
+    GCRY_PK_ELG_E = 16,     /* (deprecated: use 20). */
+    GCRY_PK_DSA   = 17,     /* Digital Signature Algorithm.  */
+    GCRY_PK_ECC   = 18,     /* Generic ECC.  */
+    GCRY_PK_ELG   = 20,     /* Elgamal       */
+    GCRY_PK_ECDSA = 301,    /* (only for external use).  */
+    GCRY_PK_ECDH  = 302,    /* (only for external use).  */
+    GCRY_PK_EDDSA = 303     /* (only for external use).  */
+  };
+
+/* Flags describing usage capabilities of a PK algorithm. */
+#define GCRY_PK_USAGE_SIGN 1   /* Good for signatures. */
+#define GCRY_PK_USAGE_ENCR 2   /* Good for encryption. */
+#define GCRY_PK_USAGE_CERT 4   /* Good to certify other keys. */
+#define GCRY_PK_USAGE_AUTH 8   /* Good for authentication. */
+#define GCRY_PK_USAGE_UNKN 128 /* Unknown usage flag. */
+
+/* Modes used with gcry_pubkey_get_sexp.  */
+#define GCRY_PK_GET_PUBKEY 1
+#define GCRY_PK_GET_SECKEY 2
+
+/* Encrypt the DATA using the public key PKEY and store the result as
+   a newly created S-expression at RESULT. */
+gcry_error_t gcry_pk_encrypt (gcry_sexp_t *result,
+                              gcry_sexp_t data, gcry_sexp_t pkey);
+
+/* Decrypt the DATA using the private key SKEY and store the result as
+   a newly created S-expression at RESULT. */
+gcry_error_t gcry_pk_decrypt (gcry_sexp_t *result,
+                              gcry_sexp_t data, gcry_sexp_t skey);
+
+/* Sign the DATA using the private key SKEY and store the result as
+   a newly created S-expression at RESULT. */
+gcry_error_t gcry_pk_sign (gcry_sexp_t *result,
+                           gcry_sexp_t data, gcry_sexp_t skey);
+
+/* Check the signature SIGVAL on DATA using the public key PKEY. */
+gcry_error_t gcry_pk_verify (gcry_sexp_t sigval,
+                             gcry_sexp_t data, gcry_sexp_t pkey);
+
+/* Check that private KEY is sane. */
+gcry_error_t gcry_pk_testkey (gcry_sexp_t key);
+
+/* Generate a new key pair according to the parameters given in
+   S_PARMS.  The new key pair is returned in as an S-expression in
+   R_KEY. */
+gcry_error_t gcry_pk_genkey (gcry_sexp_t *r_key, gcry_sexp_t s_parms);
+
+/* Catch all function for miscellaneous operations. */
+gcry_error_t gcry_pk_ctl (int cmd, void *buffer, size_t buflen);
+
+/* Retrieve information about the public key algorithm ALGO. */
+gcry_error_t gcry_pk_algo_info (int algo, int what,
+                                void *buffer, size_t *nbytes);
+
+/* Map the public key algorithm whose ID is contained in ALGORITHM to
+   a string representation of the algorithm name.  For unknown
+   algorithm IDs this functions returns "?". */
+const char *gcry_pk_algo_name (int algorithm) _GCRY_GCC_ATTR_PURE;
+
+/* Map the algorithm NAME to a public key algorithm Id.  Return 0 if
+   the algorithm name is not known. */
+int gcry_pk_map_name (const char* name) _GCRY_GCC_ATTR_PURE;
+
+/* Return what is commonly referred as the key length for the given
+   public or private KEY.  */
+unsigned int gcry_pk_get_nbits (gcry_sexp_t key) _GCRY_GCC_ATTR_PURE;
+
+/* Return the so called KEYGRIP which is the SHA-1 hash of the public
+   key parameters expressed in a way depending on the algorithm.  */
+unsigned char *gcry_pk_get_keygrip (gcry_sexp_t key, unsigned char *array);
+
+/* Return the name of the curve matching KEY.  */
+const char *gcry_pk_get_curve (gcry_sexp_t key, int iterator,
+                               unsigned int *r_nbits);
+
+/* Return an S-expression with the parameters of the named ECC curve
+   NAME.  ALGO must be set to an ECC algorithm.  */
+gcry_sexp_t gcry_pk_get_param (int algo, const char *name);
+
+/* Return 0 if the public key algorithm A is available for use. */
+#define gcry_pk_test_algo(a) \
+            gcry_pk_algo_info( (a), GCRYCTL_TEST_ALGO, NULL, NULL )
+
+/* Return an S-expression representing the context CTX.  */
+gcry_error_t gcry_pubkey_get_sexp (gcry_sexp_t *r_sexp,
+                                   int mode, gcry_ctx_t ctx);
+
+
+
+/************************************
+ *                                  *
+ *   Cryptograhic Hash Functions    *
+ *                                  *
+ ************************************/
+
+/* Algorithm IDs for the hash functions we know about. Not all of them
+   are implemented. */
+enum gcry_md_algos
+  {
+    GCRY_MD_NONE    = 0,
+    GCRY_MD_MD5     = 1,
+    GCRY_MD_SHA1    = 2,
+    GCRY_MD_RMD160  = 3,
+    GCRY_MD_MD2     = 5,
+    GCRY_MD_TIGER   = 6,   /* TIGER/192 as used by gpg <= 1.3.2. */
+    GCRY_MD_HAVAL   = 7,   /* HAVAL, 5 pass, 160 bit. */
+    GCRY_MD_SHA256  = 8,
+    GCRY_MD_SHA384  = 9,
+    GCRY_MD_SHA512  = 10,
+    GCRY_MD_SHA224  = 11,
+
+    GCRY_MD_MD4           = 301,
+    GCRY_MD_CRC32         = 302,
+    GCRY_MD_CRC32_RFC1510 = 303,
+    GCRY_MD_CRC24_RFC2440 = 304,
+    GCRY_MD_WHIRLPOOL     = 305,
+    GCRY_MD_TIGER1        = 306, /* TIGER fixed.  */
+    GCRY_MD_TIGER2        = 307, /* TIGER2 variant.   */
+    GCRY_MD_GOSTR3411_94  = 308, /* GOST R 34.11-94.  */
+    GCRY_MD_STRIBOG256    = 309, /* GOST R 34.11-2012, 256 bit.  */
+    GCRY_MD_STRIBOG512    = 310, /* GOST R 34.11-2012, 512 bit.  */
+    GCRY_MD_GOSTR3411_CP  = 311, /* GOST R 34.11-94 with CryptoPro-A S-Box.  */
+    GCRY_MD_SHA3_224      = 312,
+    GCRY_MD_SHA3_256      = 313,
+    GCRY_MD_SHA3_384      = 314,
+    GCRY_MD_SHA3_512      = 315,
+    GCRY_MD_SHAKE128      = 316,
+    GCRY_MD_SHAKE256      = 317,
+    GCRY_MD_BLAKE2B_512   = 318,
+    GCRY_MD_BLAKE2B_384   = 319,
+    GCRY_MD_BLAKE2B_256   = 320,
+    GCRY_MD_BLAKE2B_160   = 321,
+    GCRY_MD_BLAKE2S_256   = 322,
+    GCRY_MD_BLAKE2S_224   = 323,
+    GCRY_MD_BLAKE2S_160   = 324,
+    GCRY_MD_BLAKE2S_128   = 325
+  };
+
+/* Flags used with the open function.  */
+enum gcry_md_flags
+  {
+    GCRY_MD_FLAG_SECURE = 1,  /* Allocate all buffers in "secure" memory.  */
+    GCRY_MD_FLAG_HMAC   = 2,  /* Make an HMAC out of this algorithm.  */
+    GCRY_MD_FLAG_BUGEMU1 = 0x0100
+  };
+
+/* (Forward declaration.)  */
+struct gcry_md_context;
+
+/* This object is used to hold a handle to a message digest object.
+   This structure is private - only to be used by the public gcry_md_*
+   macros.  */
+typedef struct gcry_md_handle
+{
+  /* Actual context.  */
+  struct gcry_md_context *ctx;
+
+  /* Buffer management.  */
+  int  bufpos;
+  int  bufsize;
+  unsigned char buf[1];
+} *gcry_md_hd_t;
+
+/* Compatibility types, do not use them.  */
+#ifndef GCRYPT_NO_DEPRECATED
+typedef struct gcry_md_handle *GCRY_MD_HD _GCRY_GCC_ATTR_DEPRECATED;
+typedef struct gcry_md_handle *GcryMDHd _GCRY_GCC_ATTR_DEPRECATED;
+#endif
+
+/* Create a message digest object for algorithm ALGO.  FLAGS may be
+   given as an bitwise OR of the gcry_md_flags values.  ALGO may be
+   given as 0 if the algorithms to be used are later set using
+   gcry_md_enable.  */
+gcry_error_t gcry_md_open (gcry_md_hd_t *h, int algo, unsigned int flags);
+
+/* Release the message digest object HD.  */
+void gcry_md_close (gcry_md_hd_t hd);
+
+/* Add the message digest algorithm ALGO to the digest object HD.  */
+gcry_error_t gcry_md_enable (gcry_md_hd_t hd, int algo);
+
+/* Create a new digest object as an exact copy of the object HD.  */
+gcry_error_t gcry_md_copy (gcry_md_hd_t *bhd, gcry_md_hd_t ahd);
+
+/* Reset the digest object HD to its initial state.  */
+void gcry_md_reset (gcry_md_hd_t hd);
+
+/* Perform various operations on the digest object HD. */
+gcry_error_t gcry_md_ctl (gcry_md_hd_t hd, int cmd,
+                          void *buffer, size_t buflen);
+
+/* Pass LENGTH bytes of data in BUFFER to the digest object HD so that
+   it can update the digest values.  This is the actual hash
+   function. */
+void gcry_md_write (gcry_md_hd_t hd, const void *buffer, size_t length);
+
+/* Read out the final digest from HD return the digest value for
+   algorithm ALGO. */
+unsigned char *gcry_md_read (gcry_md_hd_t hd, int algo);
+
+/* Read more output from algorithm ALGO to BUFFER of size LENGTH from
+ * digest object HD. Algorithm needs to be 'expendable-output function'. */
+gpg_error_t gcry_md_extract (gcry_md_hd_t hd, int algo, void *buffer,
+                             size_t length);
+
+/* Convenience function to calculate the hash from the data in BUFFER
+   of size LENGTH using the algorithm ALGO avoiding the creating of a
+   hash object.  The hash is returned in the caller provided buffer
+   DIGEST which must be large enough to hold the digest of the given
+   algorithm. */
+void gcry_md_hash_buffer (int algo, void *digest,
+                          const void *buffer, size_t length);
+
+/* Convenience function to hash multiple buffers.  */
+gpg_error_t gcry_md_hash_buffers (int algo, unsigned int flags, void *digest,
+                                  const gcry_buffer_t *iov, int iovcnt);
+
+/* Retrieve the algorithm used with HD.  This does not work reliable
+   if more than one algorithm is enabled in HD. */
+int gcry_md_get_algo (gcry_md_hd_t hd);
+
+/* Retrieve the length in bytes of the digest yielded by algorithm
+   ALGO. */
+unsigned int gcry_md_get_algo_dlen (int algo);
+
+/* Return true if the the algorithm ALGO is enabled in the digest
+   object A. */
+int gcry_md_is_enabled (gcry_md_hd_t a, int algo);
+
+/* Return true if the digest object A is allocated in "secure" memory. */
+int gcry_md_is_secure (gcry_md_hd_t a);
+
+/* Deprecated: Use gcry_md_is_enabled or gcry_md_is_secure.  */
+gcry_error_t gcry_md_info (gcry_md_hd_t h, int what, void *buffer,
+                          size_t *nbytes) _GCRY_ATTR_INTERNAL;
+
+/* Retrieve various information about the algorithm ALGO.  */
+gcry_error_t gcry_md_algo_info (int algo, int what, void *buffer,
+                               size_t *nbytes);
+
+/* Map the digest algorithm id ALGO to a string representation of the
+   algorithm name.  For unknown algorithms this function returns
+   "?". */
+const char *gcry_md_algo_name (int algo) _GCRY_GCC_ATTR_PURE;
+
+/* Map the algorithm NAME to a digest algorithm Id.  Return 0 if
+   the algorithm name is not known. */
+int gcry_md_map_name (const char* name) _GCRY_GCC_ATTR_PURE;
+
+/* For use with the HMAC feature, the set MAC key to the KEY of
+   KEYLEN bytes. */
+gcry_error_t gcry_md_setkey (gcry_md_hd_t hd, const void *key, size_t keylen);
+
+/* Start or stop debugging for digest handle HD; i.e. create a file
+   named dbgmd-<n>.<suffix> while hashing.  If SUFFIX is NULL,
+   debugging stops and the file will be closed. */
+void gcry_md_debug (gcry_md_hd_t hd, const char *suffix);
+
+
+/* Update the hash(s) of H with the character C.  This is a buffered
+   version of the gcry_md_write function. */
+#define gcry_md_putc(h,c)  \
+            do {                                          \
+                gcry_md_hd_t h__ = (h);                   \
+                if( (h__)->bufpos == (h__)->bufsize )     \
+                    gcry_md_write( (h__), NULL, 0 );      \
+                (h__)->buf[(h__)->bufpos++] = (c) & 0xff; \
+            } while(0)
+
+/* Finalize the digest calculation.  This is not really needed because
+   gcry_md_read() does this implicitly. */
+#define gcry_md_final(a) \
+            gcry_md_ctl ((a), GCRYCTL_FINALIZE, NULL, 0)
+
+/* Return 0 if the algorithm A is available for use. */
+#define gcry_md_test_algo(a) \
+            gcry_md_algo_info( (a), GCRYCTL_TEST_ALGO, NULL, NULL )
+
+/* Return an DER encoded ASN.1 OID for the algorithm A in buffer B. N
+   must point to size_t variable with the available size of buffer B.
+   After return it will receive the actual size of the returned
+   OID. */
+#define gcry_md_get_asnoid(a,b,n) \
+            gcry_md_algo_info((a), GCRYCTL_GET_ASNOID, (b), (n))
+
+
+
+/**********************************************
+ *                                            *
+ *   Message Authentication Code Functions    *
+ *                                            *
+ **********************************************/
+
+/* The data object used to hold a handle to an encryption object.  */
+struct gcry_mac_handle;
+typedef struct gcry_mac_handle *gcry_mac_hd_t;
+
+/* Algorithm IDs for the hash functions we know about. Not all of them
+   are implemented. */
+enum gcry_mac_algos
+  {
+    GCRY_MAC_NONE               = 0,
+
+    GCRY_MAC_HMAC_SHA256        = 101,
+    GCRY_MAC_HMAC_SHA224        = 102,
+    GCRY_MAC_HMAC_SHA512        = 103,
+    GCRY_MAC_HMAC_SHA384        = 104,
+    GCRY_MAC_HMAC_SHA1          = 105,
+    GCRY_MAC_HMAC_MD5           = 106,
+    GCRY_MAC_HMAC_MD4           = 107,
+    GCRY_MAC_HMAC_RMD160        = 108,
+    GCRY_MAC_HMAC_TIGER1        = 109, /* The fixed TIGER variant */
+    GCRY_MAC_HMAC_WHIRLPOOL     = 110,
+    GCRY_MAC_HMAC_GOSTR3411_94  = 111,
+    GCRY_MAC_HMAC_STRIBOG256    = 112,
+    GCRY_MAC_HMAC_STRIBOG512    = 113,
+    GCRY_MAC_HMAC_MD2           = 114,
+    GCRY_MAC_HMAC_SHA3_224      = 115,
+    GCRY_MAC_HMAC_SHA3_256      = 116,
+    GCRY_MAC_HMAC_SHA3_384      = 117,
+    GCRY_MAC_HMAC_SHA3_512      = 118,
+
+    GCRY_MAC_CMAC_AES           = 201,
+    GCRY_MAC_CMAC_3DES          = 202,
+    GCRY_MAC_CMAC_CAMELLIA      = 203,
+    GCRY_MAC_CMAC_CAST5         = 204,
+    GCRY_MAC_CMAC_BLOWFISH      = 205,
+    GCRY_MAC_CMAC_TWOFISH       = 206,
+    GCRY_MAC_CMAC_SERPENT       = 207,
+    GCRY_MAC_CMAC_SEED          = 208,
+    GCRY_MAC_CMAC_RFC2268       = 209,
+    GCRY_MAC_CMAC_IDEA          = 210,
+    GCRY_MAC_CMAC_GOST28147     = 211,
+
+    GCRY_MAC_GMAC_AES           = 401,
+    GCRY_MAC_GMAC_CAMELLIA      = 402,
+    GCRY_MAC_GMAC_TWOFISH       = 403,
+    GCRY_MAC_GMAC_SERPENT       = 404,
+    GCRY_MAC_GMAC_SEED          = 405,
+
+    GCRY_MAC_POLY1305           = 501,
+    GCRY_MAC_POLY1305_AES       = 502,
+    GCRY_MAC_POLY1305_CAMELLIA  = 503,
+    GCRY_MAC_POLY1305_TWOFISH   = 504,
+    GCRY_MAC_POLY1305_SERPENT   = 505,
+    GCRY_MAC_POLY1305_SEED      = 506
+  };
+
+/* Flags used with the open function.  */
+enum gcry_mac_flags
+  {
+    GCRY_MAC_FLAG_SECURE = 1   /* Allocate all buffers in "secure" memory.  */
+  };
+
+/* Create a MAC handle for algorithm ALGO.  FLAGS may be given as an bitwise OR
+   of the gcry_mac_flags values.  CTX maybe NULL or gcry_ctx_t object to be
+   associated with HANDLE.  */
+gcry_error_t gcry_mac_open (gcry_mac_hd_t *handle, int algo,
+                            unsigned int flags, gcry_ctx_t ctx);
+
+/* Close the MAC handle H and release all resource. */
+void gcry_mac_close (gcry_mac_hd_t h);
+
+/* Perform various operations on the MAC object H. */
+gcry_error_t gcry_mac_ctl (gcry_mac_hd_t h, int cmd, void *buffer,
+                           size_t buflen);
+
+/* Retrieve various information about the MAC algorithm ALGO. */
+gcry_error_t gcry_mac_algo_info (int algo, int what, void *buffer,
+                                 size_t *nbytes);
+
+/* Set KEY of length KEYLEN bytes for the MAC handle HD.  */
+gcry_error_t gcry_mac_setkey (gcry_mac_hd_t hd, const void *key,
+                              size_t keylen);
+
+/* Set initialization vector IV of length IVLEN for the MAC handle HD. */
+gcry_error_t gcry_mac_setiv (gcry_mac_hd_t hd, const void *iv,
+                             size_t ivlen);
+
+/* Pass LENGTH bytes of data in BUFFER to the MAC object HD so that
+   it can update the MAC values.  */
+gcry_error_t gcry_mac_write (gcry_mac_hd_t hd, const void *buffer,
+                             size_t length);
+
+/* Read out the final authentication code from the MAC object HD to BUFFER. */
+gcry_error_t gcry_mac_read (gcry_mac_hd_t hd, void *buffer, size_t *buflen);
+
+/* Verify the final authentication code from the MAC object HD with BUFFER. */
+gcry_error_t gcry_mac_verify (gcry_mac_hd_t hd, const void *buffer,
+                              size_t buflen);
+
+/* Retrieve the algorithm used with MAC. */
+int gcry_mac_get_algo (gcry_mac_hd_t hd);
+
+/* Retrieve the length in bytes of the MAC yielded by algorithm ALGO. */
+unsigned int gcry_mac_get_algo_maclen (int algo);
+
+/* Retrieve the default key length in bytes used with algorithm A. */
+unsigned int gcry_mac_get_algo_keylen (int algo);
+
+/* Map the MAC algorithm whose ID is contained in ALGORITHM to a
+   string representation of the algorithm name.  For unknown algorithm
+   IDs this function returns "?".  */
+const char *gcry_mac_algo_name (int algorithm) _GCRY_GCC_ATTR_PURE;
+
+/* Map the algorithm name NAME to an MAC algorithm ID.  Return 0 if
+   the algorithm name is not known. */
+int gcry_mac_map_name (const char *name) _GCRY_GCC_ATTR_PURE;
+
+/* Reset the handle to the state after open/setkey.  */
+#define gcry_mac_reset(h)  gcry_mac_ctl ((h), GCRYCTL_RESET, NULL, 0)
+
+/* Return 0 if the algorithm A is available for use. */
+#define gcry_mac_test_algo(a) \
+            gcry_mac_algo_info( (a), GCRYCTL_TEST_ALGO, NULL, NULL )
+
+
+/******************************
+ *                            *
+ *  Key Derivation Functions  *
+ *                            *
+ ******************************/
+
+/* Algorithm IDs for the KDFs.  */
+enum gcry_kdf_algos
+  {
+    GCRY_KDF_NONE = 0,
+    GCRY_KDF_SIMPLE_S2K = 16,
+    GCRY_KDF_SALTED_S2K = 17,
+    GCRY_KDF_ITERSALTED_S2K = 19,
+    GCRY_KDF_PBKDF1 = 33,
+    GCRY_KDF_PBKDF2 = 34,
+    GCRY_KDF_SCRYPT = 48
+  };
+
+/* Derive a key from a passphrase.  */
+gpg_error_t gcry_kdf_derive (const void *passphrase, size_t passphraselen,
+                             int algo, int subalgo,
+                             const void *salt, size_t saltlen,
+                             unsigned long iterations,
+                             size_t keysize, void *keybuffer);
+
+
+
+
+/************************************
+ *                                  *
+ *   Random Generating Functions    *
+ *                                  *
+ ************************************/
+
+/* The type of the random number generator.  */
+enum gcry_rng_types
+  {
+    GCRY_RNG_TYPE_STANDARD   = 1, /* The default CSPRNG generator.  */
+    GCRY_RNG_TYPE_FIPS       = 2, /* The FIPS X9.31 AES generator.  */
+    GCRY_RNG_TYPE_SYSTEM     = 3  /* The system's native generator. */
+  };
+
+/* The possible values for the random quality.  The rule of thumb is
+   to use STRONG for session keys and VERY_STRONG for key material.
+   WEAK is usually an alias for STRONG and should not be used anymore
+   (except with gcry_mpi_randomize); use gcry_create_nonce instead. */
+typedef enum gcry_random_level
+  {
+    GCRY_WEAK_RANDOM = 0,
+    GCRY_STRONG_RANDOM = 1,
+    GCRY_VERY_STRONG_RANDOM = 2
+  }
+gcry_random_level_t;
+
+/* Fill BUFFER with LENGTH bytes of random, using random numbers of
+   quality LEVEL. */
+void gcry_randomize (void *buffer, size_t length,
+                     enum gcry_random_level level);
+
+/* Add the external random from BUFFER with LENGTH bytes into the
+   pool. QUALITY should either be -1 for unknown or in the range of 0
+   to 100 */
+gcry_error_t gcry_random_add_bytes (const void *buffer, size_t length,
+                                    int quality);
+
+/* If random numbers are used in an application, this macro should be
+   called from time to time so that new stuff gets added to the
+   internal pool of the RNG.  */
+#define gcry_fast_random_poll()  gcry_control (GCRYCTL_FAST_POLL, NULL)
+
+
+/* Return NBYTES of allocated random using a random numbers of quality
+   LEVEL. */
+void *gcry_random_bytes (size_t nbytes, enum gcry_random_level level)
+                         _GCRY_GCC_ATTR_MALLOC;
+
+/* Return NBYTES of allocated random using a random numbers of quality
+   LEVEL.  The random numbers are created returned in "secure"
+   memory. */
+void *gcry_random_bytes_secure (size_t nbytes, enum gcry_random_level level)
+                                _GCRY_GCC_ATTR_MALLOC;
+
+
+/* Set the big integer W to a random value of NBITS using a random
+   generator with quality LEVEL.  Note that by using a level of
+   GCRY_WEAK_RANDOM gcry_create_nonce is used internally. */
+void gcry_mpi_randomize (gcry_mpi_t w,
+                         unsigned int nbits, enum gcry_random_level level);
+
+
+/* Create an unpredicable nonce of LENGTH bytes in BUFFER. */
+void gcry_create_nonce (void *buffer, size_t length);
+
+
+
+
+
+/*******************************/
+/*                             */
+/*    Prime Number Functions   */
+/*                             */
+/*******************************/
+
+/* Mode values passed to a gcry_prime_check_func_t. */
+#define GCRY_PRIME_CHECK_AT_FINISH      0
+#define GCRY_PRIME_CHECK_AT_GOT_PRIME   1
+#define GCRY_PRIME_CHECK_AT_MAYBE_PRIME 2
+
+/* The function should return 1 if the operation shall continue, 0 to
+   reject the prime candidate. */
+typedef int (*gcry_prime_check_func_t) (void *arg, int mode,
+                                        gcry_mpi_t candidate);
+
+/* Flags for gcry_prime_generate():  */
+
+/* Allocate prime numbers and factors in secure memory.  */
+#define GCRY_PRIME_FLAG_SECRET         (1 << 0)
+
+/* Make sure that at least one prime factor is of size
+   `FACTOR_BITS'.  */
+#define GCRY_PRIME_FLAG_SPECIAL_FACTOR (1 << 1)
+
+/* Generate a new prime number of PRIME_BITS bits and store it in
+   PRIME.  If FACTOR_BITS is non-zero, one of the prime factors of
+   (prime - 1) / 2 must be FACTOR_BITS bits long.  If FACTORS is
+   non-zero, allocate a new, NULL-terminated array holding the prime
+   factors and store it in FACTORS.  FLAGS might be used to influence
+   the prime number generation process.  */
+gcry_error_t gcry_prime_generate (gcry_mpi_t *prime,
+                                  unsigned int prime_bits,
+                                  unsigned int factor_bits,
+                                  gcry_mpi_t **factors,
+                                  gcry_prime_check_func_t cb_func,
+                                  void *cb_arg,
+                                  gcry_random_level_t random_level,
+                                  unsigned int flags);
+
+/* Find a generator for PRIME where the factorization of (prime-1) is
+   in the NULL terminated array FACTORS. Return the generator as a
+   newly allocated MPI in R_G.  If START_G is not NULL, use this as
+   the start for the search. */
+gcry_error_t gcry_prime_group_generator (gcry_mpi_t *r_g,
+                                         gcry_mpi_t prime,
+                                         gcry_mpi_t *factors,
+                                         gcry_mpi_t start_g);
+
+
+/* Convenience function to release the FACTORS array. */
+void gcry_prime_release_factors (gcry_mpi_t *factors);
+
+
+/* Check whether the number X is prime.  */
+gcry_error_t gcry_prime_check (gcry_mpi_t x, unsigned int flags);
+
+
+
+/************************************
+ *                                  *
+ *     Miscellaneous Stuff          *
+ *                                  *
+ ************************************/
+
+/* Release the context object CTX.  */
+void gcry_ctx_release (gcry_ctx_t ctx);
+
+/* Log data using Libgcrypt's own log interface.  */
+void gcry_log_debug (const char *fmt, ...) _GCRY_GCC_ATTR_PRINTF(1,2);
+void gcry_log_debughex (const char *text, const void *buffer, size_t length);
+void gcry_log_debugmpi (const char *text, gcry_mpi_t mpi);
+void gcry_log_debugpnt (const char *text,
+                        gcry_mpi_point_t point, gcry_ctx_t ctx);
+void gcry_log_debugsxp (const char *text, gcry_sexp_t sexp);
+
+char *gcry_get_config (int mode, const char *what);
+
+/* Log levels used by the internal logging facility. */
+enum gcry_log_levels
+  {
+    GCRY_LOG_CONT   = 0,    /* (Continue the last log line.) */
+    GCRY_LOG_INFO   = 10,
+    GCRY_LOG_WARN   = 20,
+    GCRY_LOG_ERROR  = 30,
+    GCRY_LOG_FATAL  = 40,
+    GCRY_LOG_BUG    = 50,
+    GCRY_LOG_DEBUG  = 100
+  };
+
+/* Type for progress handlers.  */
+typedef void (*gcry_handler_progress_t) (void *, const char *, int, int, int);
+
+/* Type for memory allocation handlers.  */
+typedef void *(*gcry_handler_alloc_t) (size_t n);
+
+/* Type for secure memory check handlers.  */
+typedef int (*gcry_handler_secure_check_t) (const void *);
+
+/* Type for memory reallocation handlers.  */
+typedef void *(*gcry_handler_realloc_t) (void *p, size_t n);
+
+/* Type for memory free handlers.  */
+typedef void (*gcry_handler_free_t) (void *);
+
+/* Type for out-of-memory handlers.  */
+typedef int (*gcry_handler_no_mem_t) (void *, size_t, unsigned int);
+
+/* Type for fatal error handlers.  */
+typedef void (*gcry_handler_error_t) (void *, int, const char *);
+
+/* Type for logging handlers.  */
+typedef void (*gcry_handler_log_t) (void *, int, const char *, va_list);
+
+/* Certain operations can provide progress information.  This function
+   is used to register a handler for retrieving these information. */
+void gcry_set_progress_handler (gcry_handler_progress_t cb, void *cb_data);
+
+
+/* Register a custom memory allocation functions. */
+void gcry_set_allocation_handler (
+                             gcry_handler_alloc_t func_alloc,
+                             gcry_handler_alloc_t func_alloc_secure,
+                             gcry_handler_secure_check_t func_secure_check,
+                             gcry_handler_realloc_t func_realloc,
+                             gcry_handler_free_t func_free);
+
+/* Register a function used instead of the internal out of memory
+   handler. */
+void gcry_set_outofcore_handler (gcry_handler_no_mem_t h, void *opaque);
+
+/* Register a function used instead of the internal fatal error
+   handler. */
+void gcry_set_fatalerror_handler (gcry_handler_error_t fnc, void *opaque);
+
+/* Register a function used instead of the internal logging
+   facility. */
+void gcry_set_log_handler (gcry_handler_log_t f, void *opaque);
+
+/* Reserved for future use. */
+void gcry_set_gettext_handler (const char *(*f)(const char*));
+
+/* Libgcrypt uses its own memory allocation.  It is important to use
+   gcry_free () to release memory allocated by libgcrypt. */
+void *gcry_malloc (size_t n) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_calloc (size_t n, size_t m) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_malloc_secure (size_t n) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_calloc_secure (size_t n, size_t m) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_realloc (void *a, size_t n);
+char *gcry_strdup (const char *string) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_xmalloc (size_t n) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_xcalloc (size_t n, size_t m) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_xmalloc_secure (size_t n) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_xcalloc_secure (size_t n, size_t m) _GCRY_GCC_ATTR_MALLOC;
+void *gcry_xrealloc (void *a, size_t n);
+char *gcry_xstrdup (const char * a) _GCRY_GCC_ATTR_MALLOC;
+void  gcry_free (void *a);
+
+/* Return true if A is allocated in "secure" memory. */
+int gcry_is_secure (const void *a) _GCRY_GCC_ATTR_PURE;
+
+/* Return true if Libgcrypt is in FIPS mode.  */
+#define gcry_fips_mode_active()  !!gcry_control (GCRYCTL_FIPS_MODE_P, 0)
+
+
+#if 0 /* (Keep Emacsens' auto-indent happy.) */
+{
+#endif
+#ifdef __cplusplus
+}
+#endif
+#endif /* _GCRYPT_H */
+/*
+Local Variables:
+buffer-read-only: t
+End:
+*/
diff --git a/libraries/cmake/source/libgpg-error/config/ppc64le/config.h b/libraries/cmake/source/libgpg-error/config/ppc64le/config.h
new file mode 100644
index 000000000..ed4739f3b
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/config/ppc64le/config.h
@@ -0,0 +1,274 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* GIT commit id revision used to build this package */
+#define BUILD_REVISION "c1668f6"
+
+/* The time this package was configured for a build */
+#define BUILD_TIMESTAMP "<none>"
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#define ENABLE_NLS 1
+
+/* Define to use the GNU C visibility attribute. */
+#define GPGRT_USE_VISIBILITY 1
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `flockfile' function. */
+#define HAVE_FLOCKFILE 1
+
+/* Defined if a GCC style "__attribute__ ((aligned (n))" is supported */
+#define HAVE_GCC_ATTRIBUTE_ALIGNED 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define if you have the iconv() function and it works. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if the system has the type `intmax_t'. */
+#define HAVE_INTMAX_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(THOUSANDS_SEP). */
+#define HAVE_LANGINFO_THOUSANDS_SEP 1
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if the system has the type `long double'. */
+#define HAVE_LONG_DOUBLE 1
+
+/* Define to 1 if the system has the type `long long int'. */
+#define HAVE_LONG_LONG_INT 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memrchr' function. */
+#define HAVE_MEMRCHR 1
+
+/* Define if the <pthread.h> defines PTHREAD_MUTEX_RECURSIVE. */
+#define HAVE_PTHREAD_MUTEX_RECURSIVE 1
+
+/* Define if the POSIX multithreading library has read/write locks. */
+#define HAVE_PTHREAD_RWLOCK 1
+
+/* Define to 1 if the system has the type `ptrdiff_t'. */
+#define HAVE_PTRDIFF_T 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if the system has the type `uintmax_t'. */
+#define HAVE_UINTMAX_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if the system has the type `unsigned long long int'. */
+#define HAVE_UNSIGNED_LONG_LONG_INT 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Defined if we run on WindowsCE */
+/* #undef HAVE_W32CE_SYSTEM */
+
+/* Defined if we run on a W32 API based system */
+/* #undef HAVE_W32_SYSTEM */
+
+/* Defined if we run on 64 bit W32 API system */
+/* #undef HAVE_W64_SYSTEM */
+
+/* The host triplet */
+#define HOST_TRIPLET_STRING "powerpc64le-unknown-linux-gnu"
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "libgpg-error"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "https://bugs.gnupg.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libgpg-error"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "libgpg-error 1.27"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "libgpg-error"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.27"
+
+/* Define if the pthread_in_use() detection is hard. */
+/* #undef PTHREAD_IN_USE_DETECTION_HARD */
+
+/* Used by mkheader to insert the replacement type. */
+#define REPLACEMENT_FOR_OFF_T "long"
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 8
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `pthread_mutex_t', as computed by sizeof. */
+#define SIZEOF_PTHREAD_MUTEX_T 40
+
+/* The size of `time_t', as computed by sizeof. */
+#define SIZEOF_TIME_T 8
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 8
+
+/* The size of `void *', as computed by sizeof. */
+#define SIZEOF_VOID_P 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r returns char *. */
+#define STRERROR_R_CHAR_P 1
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#define TIME_WITH_SYS_TIME 1
+
+/* Define if the POSIX multithreading library can be used. */
+#define USE_POSIX_THREADS 1
+
+/* Define if references to the POSIX multithreading library should be made
+   weak. */
+#define USE_POSIX_THREADS_WEAK 1
+
+/* Define if the old Solaris multithreading library can be used. */
+/* #undef USE_SOLARIS_THREADS */
+
+/* Define if references to the old Solaris multithreading library should be
+   made weak. */
+/* #undef USE_SOLARIS_THREADS_WEAK */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Define if the native Windows multithreading API can be used. */
+/* #undef USE_WINDOWS_THREADS */
+
+/* Version number of package */
+#define VERSION "1.27"
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to the widest signed integer type if <stdint.h> and <inttypes.h> do
+   not define. */
+/* #undef intmax_t */
+
+/* Define to the widest unsigned integer type if <stdint.h> and <inttypes.h>
+   do not define. */
+/* #undef uintmax_t */
+
+
+/* Force using of NLS for W32 even if no libintl has been found.  This is
+   okay because we have our own gettext implementation for W32.  */
+#if defined(HAVE_W32_SYSTEM) && !defined(ENABLE_NLS)
+#define ENABLE_NLS 1
+#endif
+
+/* Connect the generic estream-printf.c to our framework.  */
+#define _ESTREAM_PRINTF_REALLOC _gpgrt_realloc
+#define _ESTREAM_PRINTF_EXTRA_INCLUDE "gpgrt-int.h"
+
+/* For building we need to define these macro.  */
+#define GPG_ERR_ENABLE_GETTEXT_MACROS 1
+#define GPG_ERR_ENABLE_ERRNO_MACROS 1
+#define GPGRT_ENABLE_ES_MACROS 1
+
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/code-from-errno.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/code-from-errno.h
new file mode 100644
index 000000000..1fa1e9f8e
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/code-from-errno.h
@@ -0,0 +1,156 @@
+/* Output of mkerrcodes2.awk.  DO NOT EDIT.  */
+
+/* errnos.h - List of system error values.
+   Copyright (C) 2004 g10 Code GmbH
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+static const int err_code_from_index[] = {
+  GPG_ERR_EPERM,
+  GPG_ERR_ENOENT,
+  GPG_ERR_ESRCH,
+  GPG_ERR_EINTR,
+  GPG_ERR_EIO,
+  GPG_ERR_ENXIO,
+  GPG_ERR_E2BIG,
+  GPG_ERR_ENOEXEC,
+  GPG_ERR_EBADF,
+  GPG_ERR_ECHILD,
+  GPG_ERR_EAGAIN,
+  GPG_ERR_EWOULDBLOCK,
+  GPG_ERR_ENOMEM,
+  GPG_ERR_EACCES,
+  GPG_ERR_EFAULT,
+  GPG_ERR_ENOTBLK,
+  GPG_ERR_EBUSY,
+  GPG_ERR_EEXIST,
+  GPG_ERR_EXDEV,
+  GPG_ERR_ENODEV,
+  GPG_ERR_ENOTDIR,
+  GPG_ERR_EISDIR,
+  GPG_ERR_EINVAL,
+  GPG_ERR_ENFILE,
+  GPG_ERR_EMFILE,
+  GPG_ERR_ENOTTY,
+  GPG_ERR_ETXTBSY,
+  GPG_ERR_EFBIG,
+  GPG_ERR_ENOSPC,
+  GPG_ERR_ESPIPE,
+  GPG_ERR_EROFS,
+  GPG_ERR_EMLINK,
+  GPG_ERR_EPIPE,
+  GPG_ERR_EDOM,
+  GPG_ERR_ERANGE,
+  GPG_ERR_EDEADLK,
+  GPG_ERR_ENAMETOOLONG,
+  GPG_ERR_ENOLCK,
+  GPG_ERR_ENOSYS,
+  GPG_ERR_ENOTEMPTY,
+  GPG_ERR_ELOOP,
+  GPG_ERR_ENOMSG,
+  GPG_ERR_EIDRM,
+  GPG_ERR_ECHRNG,
+  GPG_ERR_EL2NSYNC,
+  GPG_ERR_EL3HLT,
+  GPG_ERR_EL3RST,
+  GPG_ERR_ELNRNG,
+  GPG_ERR_EUNATCH,
+  GPG_ERR_ENOCSI,
+  GPG_ERR_EL2HLT,
+  GPG_ERR_EBADE,
+  GPG_ERR_EBADR,
+  GPG_ERR_EXFULL,
+  GPG_ERR_ENOANO,
+  GPG_ERR_EBADRQC,
+  GPG_ERR_EBADSLT,
+  GPG_ERR_EDEADLOCK,
+  GPG_ERR_EBFONT,
+  GPG_ERR_ENOSTR,
+  GPG_ERR_ENODATA,
+  GPG_ERR_ETIME,
+  GPG_ERR_ENOSR,
+  GPG_ERR_ENONET,
+  GPG_ERR_ENOPKG,
+  GPG_ERR_EREMOTE,
+  GPG_ERR_ENOLINK,
+  GPG_ERR_EADV,
+  GPG_ERR_ESRMNT,
+  GPG_ERR_ECOMM,
+  GPG_ERR_EPROTO,
+  GPG_ERR_EMULTIHOP,
+  GPG_ERR_EDOTDOT,
+  GPG_ERR_EBADMSG,
+  GPG_ERR_EOVERFLOW,
+  GPG_ERR_ENOTUNIQ,
+  GPG_ERR_EBADFD,
+  GPG_ERR_EREMCHG,
+  GPG_ERR_ELIBACC,
+  GPG_ERR_ELIBBAD,
+  GPG_ERR_ELIBSCN,
+  GPG_ERR_ELIBMAX,
+  GPG_ERR_ELIBEXEC,
+  GPG_ERR_EILSEQ,
+  GPG_ERR_ERESTART,
+  GPG_ERR_ESTRPIPE,
+  GPG_ERR_EUSERS,
+  GPG_ERR_ENOTSOCK,
+  GPG_ERR_EDESTADDRREQ,
+  GPG_ERR_EMSGSIZE,
+  GPG_ERR_EPROTOTYPE,
+  GPG_ERR_ENOPROTOOPT,
+  GPG_ERR_EPROTONOSUPPORT,
+  GPG_ERR_ESOCKTNOSUPPORT,
+  GPG_ERR_ENOTSUP,
+  GPG_ERR_EOPNOTSUPP,
+  GPG_ERR_EPFNOSUPPORT,
+  GPG_ERR_EAFNOSUPPORT,
+  GPG_ERR_EADDRINUSE,
+  GPG_ERR_EADDRNOTAVAIL,
+  GPG_ERR_ENETDOWN,
+  GPG_ERR_ENETUNREACH,
+  GPG_ERR_ENETRESET,
+  GPG_ERR_ECONNABORTED,
+  GPG_ERR_ECONNRESET,
+  GPG_ERR_ENOBUFS,
+  GPG_ERR_EISCONN,
+  GPG_ERR_ENOTCONN,
+  GPG_ERR_ESHUTDOWN,
+  GPG_ERR_ETOOMANYREFS,
+  GPG_ERR_ETIMEDOUT,
+  GPG_ERR_ECONNREFUSED,
+  GPG_ERR_EHOSTDOWN,
+  GPG_ERR_EHOSTUNREACH,
+  GPG_ERR_EALREADY,
+  GPG_ERR_EINPROGRESS,
+  GPG_ERR_ESTALE,
+  GPG_ERR_EUCLEAN,
+  GPG_ERR_ENOTNAM,
+  GPG_ERR_ENAVAIL,
+  GPG_ERR_EISNAM,
+  GPG_ERR_EREMOTEIO,
+  GPG_ERR_EDQUOT,
+  GPG_ERR_ENOMEDIUM,
+  GPG_ERR_EMEDIUMTYPE,
+  GPG_ERR_ECANCELED,
+};
+
+#define errno_to_idx(code) (0 ? -1 \
+  : ((code >= 1) && (code <= 11)) ? (code - 1) \
+  : ((code >= 11) && (code <= 40)) ? (code - 0) \
+  : ((code >= 42) && (code <= 95)) ? (code - 1) \
+  : ((code >= 95) && (code <= 125)) ? (code - 0) \
+  : -1)
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/code-to-errno.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/code-to-errno.h
new file mode 100644
index 000000000..8907fc094
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/code-to-errno.h
@@ -0,0 +1,1300 @@
+/* Output of mkerrnos.awk.  DO NOT EDIT.  */
+
+/* errnos.in - List of system error values.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+
+#include <errno.h>
+#ifdef _WIN32
+#include <winsock2.h>
+#endif
+
+static const int err_code_to_errno [] = {
+#ifdef E2BIG
+  E2BIG,
+#else
+#ifdef WSAE2BIG
+  WSAE2BIG,
+#else
+  0,
+#endif
+#endif
+#ifdef EACCES
+  EACCES,
+#else
+#ifdef WSAEACCES
+  WSAEACCES,
+#else
+  0,
+#endif
+#endif
+#ifdef EADDRINUSE
+  EADDRINUSE,
+#else
+#ifdef WSAEADDRINUSE
+  WSAEADDRINUSE,
+#else
+  0,
+#endif
+#endif
+#ifdef EADDRNOTAVAIL
+  EADDRNOTAVAIL,
+#else
+#ifdef WSAEADDRNOTAVAIL
+  WSAEADDRNOTAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef EADV
+  EADV,
+#else
+#ifdef WSAEADV
+  WSAEADV,
+#else
+  0,
+#endif
+#endif
+#ifdef EAFNOSUPPORT
+  EAFNOSUPPORT,
+#else
+#ifdef WSAEAFNOSUPPORT
+  WSAEAFNOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef EAGAIN
+  EAGAIN,
+#else
+#ifdef WSAEAGAIN
+  WSAEAGAIN,
+#else
+  0,
+#endif
+#endif
+#ifdef EALREADY
+  EALREADY,
+#else
+#ifdef WSAEALREADY
+  WSAEALREADY,
+#else
+  0,
+#endif
+#endif
+#ifdef EAUTH
+  EAUTH,
+#else
+#ifdef WSAEAUTH
+  WSAEAUTH,
+#else
+  0,
+#endif
+#endif
+#ifdef EBACKGROUND
+  EBACKGROUND,
+#else
+#ifdef WSAEBACKGROUND
+  WSAEBACKGROUND,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADE
+  EBADE,
+#else
+#ifdef WSAEBADE
+  WSAEBADE,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADF
+  EBADF,
+#else
+#ifdef WSAEBADF
+  WSAEBADF,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADFD
+  EBADFD,
+#else
+#ifdef WSAEBADFD
+  WSAEBADFD,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADMSG
+  EBADMSG,
+#else
+#ifdef WSAEBADMSG
+  WSAEBADMSG,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADR
+  EBADR,
+#else
+#ifdef WSAEBADR
+  WSAEBADR,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADRPC
+  EBADRPC,
+#else
+#ifdef WSAEBADRPC
+  WSAEBADRPC,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADRQC
+  EBADRQC,
+#else
+#ifdef WSAEBADRQC
+  WSAEBADRQC,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADSLT
+  EBADSLT,
+#else
+#ifdef WSAEBADSLT
+  WSAEBADSLT,
+#else
+  0,
+#endif
+#endif
+#ifdef EBFONT
+  EBFONT,
+#else
+#ifdef WSAEBFONT
+  WSAEBFONT,
+#else
+  0,
+#endif
+#endif
+#ifdef EBUSY
+  EBUSY,
+#else
+#ifdef WSAEBUSY
+  WSAEBUSY,
+#else
+  0,
+#endif
+#endif
+#ifdef ECANCELED
+  ECANCELED,
+#else
+#ifdef WSAECANCELED
+  WSAECANCELED,
+#else
+  0,
+#endif
+#endif
+#ifdef ECHILD
+  ECHILD,
+#else
+#ifdef WSAECHILD
+  WSAECHILD,
+#else
+  0,
+#endif
+#endif
+#ifdef ECHRNG
+  ECHRNG,
+#else
+#ifdef WSAECHRNG
+  WSAECHRNG,
+#else
+  0,
+#endif
+#endif
+#ifdef ECOMM
+  ECOMM,
+#else
+#ifdef WSAECOMM
+  WSAECOMM,
+#else
+  0,
+#endif
+#endif
+#ifdef ECONNABORTED
+  ECONNABORTED,
+#else
+#ifdef WSAECONNABORTED
+  WSAECONNABORTED,
+#else
+  0,
+#endif
+#endif
+#ifdef ECONNREFUSED
+  ECONNREFUSED,
+#else
+#ifdef WSAECONNREFUSED
+  WSAECONNREFUSED,
+#else
+  0,
+#endif
+#endif
+#ifdef ECONNRESET
+  ECONNRESET,
+#else
+#ifdef WSAECONNRESET
+  WSAECONNRESET,
+#else
+  0,
+#endif
+#endif
+#ifdef ED
+  ED,
+#else
+#ifdef WSAED
+  WSAED,
+#else
+  0,
+#endif
+#endif
+#ifdef EDEADLK
+  EDEADLK,
+#else
+#ifdef WSAEDEADLK
+  WSAEDEADLK,
+#else
+  0,
+#endif
+#endif
+#ifdef EDEADLOCK
+  EDEADLOCK,
+#else
+#ifdef WSAEDEADLOCK
+  WSAEDEADLOCK,
+#else
+  0,
+#endif
+#endif
+#ifdef EDESTADDRREQ
+  EDESTADDRREQ,
+#else
+#ifdef WSAEDESTADDRREQ
+  WSAEDESTADDRREQ,
+#else
+  0,
+#endif
+#endif
+#ifdef EDIED
+  EDIED,
+#else
+#ifdef WSAEDIED
+  WSAEDIED,
+#else
+  0,
+#endif
+#endif
+#ifdef EDOM
+  EDOM,
+#else
+#ifdef WSAEDOM
+  WSAEDOM,
+#else
+  0,
+#endif
+#endif
+#ifdef EDOTDOT
+  EDOTDOT,
+#else
+#ifdef WSAEDOTDOT
+  WSAEDOTDOT,
+#else
+  0,
+#endif
+#endif
+#ifdef EDQUOT
+  EDQUOT,
+#else
+#ifdef WSAEDQUOT
+  WSAEDQUOT,
+#else
+  0,
+#endif
+#endif
+#ifdef EEXIST
+  EEXIST,
+#else
+#ifdef WSAEEXIST
+  WSAEEXIST,
+#else
+  0,
+#endif
+#endif
+#ifdef EFAULT
+  EFAULT,
+#else
+#ifdef WSAEFAULT
+  WSAEFAULT,
+#else
+  0,
+#endif
+#endif
+#ifdef EFBIG
+  EFBIG,
+#else
+#ifdef WSAEFBIG
+  WSAEFBIG,
+#else
+  0,
+#endif
+#endif
+#ifdef EFTYPE
+  EFTYPE,
+#else
+#ifdef WSAEFTYPE
+  WSAEFTYPE,
+#else
+  0,
+#endif
+#endif
+#ifdef EGRATUITOUS
+  EGRATUITOUS,
+#else
+#ifdef WSAEGRATUITOUS
+  WSAEGRATUITOUS,
+#else
+  0,
+#endif
+#endif
+#ifdef EGREGIOUS
+  EGREGIOUS,
+#else
+#ifdef WSAEGREGIOUS
+  WSAEGREGIOUS,
+#else
+  0,
+#endif
+#endif
+#ifdef EHOSTDOWN
+  EHOSTDOWN,
+#else
+#ifdef WSAEHOSTDOWN
+  WSAEHOSTDOWN,
+#else
+  0,
+#endif
+#endif
+#ifdef EHOSTUNREACH
+  EHOSTUNREACH,
+#else
+#ifdef WSAEHOSTUNREACH
+  WSAEHOSTUNREACH,
+#else
+  0,
+#endif
+#endif
+#ifdef EIDRM
+  EIDRM,
+#else
+#ifdef WSAEIDRM
+  WSAEIDRM,
+#else
+  0,
+#endif
+#endif
+#ifdef EIEIO
+  EIEIO,
+#else
+#ifdef WSAEIEIO
+  WSAEIEIO,
+#else
+  0,
+#endif
+#endif
+#ifdef EILSEQ
+  EILSEQ,
+#else
+#ifdef WSAEILSEQ
+  WSAEILSEQ,
+#else
+  0,
+#endif
+#endif
+#ifdef EINPROGRESS
+  EINPROGRESS,
+#else
+#ifdef WSAEINPROGRESS
+  WSAEINPROGRESS,
+#else
+  0,
+#endif
+#endif
+#ifdef EINTR
+  EINTR,
+#else
+#ifdef WSAEINTR
+  WSAEINTR,
+#else
+  0,
+#endif
+#endif
+#ifdef EINVAL
+  EINVAL,
+#else
+#ifdef WSAEINVAL
+  WSAEINVAL,
+#else
+  0,
+#endif
+#endif
+#ifdef EIO
+  EIO,
+#else
+#ifdef WSAEIO
+  WSAEIO,
+#else
+  0,
+#endif
+#endif
+#ifdef EISCONN
+  EISCONN,
+#else
+#ifdef WSAEISCONN
+  WSAEISCONN,
+#else
+  0,
+#endif
+#endif
+#ifdef EISDIR
+  EISDIR,
+#else
+#ifdef WSAEISDIR
+  WSAEISDIR,
+#else
+  0,
+#endif
+#endif
+#ifdef EISNAM
+  EISNAM,
+#else
+#ifdef WSAEISNAM
+  WSAEISNAM,
+#else
+  0,
+#endif
+#endif
+#ifdef EL2HLT
+  EL2HLT,
+#else
+#ifdef WSAEL2HLT
+  WSAEL2HLT,
+#else
+  0,
+#endif
+#endif
+#ifdef EL2NSYNC
+  EL2NSYNC,
+#else
+#ifdef WSAEL2NSYNC
+  WSAEL2NSYNC,
+#else
+  0,
+#endif
+#endif
+#ifdef EL3HLT
+  EL3HLT,
+#else
+#ifdef WSAEL3HLT
+  WSAEL3HLT,
+#else
+  0,
+#endif
+#endif
+#ifdef EL3RST
+  EL3RST,
+#else
+#ifdef WSAEL3RST
+  WSAEL3RST,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBACC
+  ELIBACC,
+#else
+#ifdef WSAELIBACC
+  WSAELIBACC,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBBAD
+  ELIBBAD,
+#else
+#ifdef WSAELIBBAD
+  WSAELIBBAD,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBEXEC
+  ELIBEXEC,
+#else
+#ifdef WSAELIBEXEC
+  WSAELIBEXEC,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBMAX
+  ELIBMAX,
+#else
+#ifdef WSAELIBMAX
+  WSAELIBMAX,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBSCN
+  ELIBSCN,
+#else
+#ifdef WSAELIBSCN
+  WSAELIBSCN,
+#else
+  0,
+#endif
+#endif
+#ifdef ELNRNG
+  ELNRNG,
+#else
+#ifdef WSAELNRNG
+  WSAELNRNG,
+#else
+  0,
+#endif
+#endif
+#ifdef ELOOP
+  ELOOP,
+#else
+#ifdef WSAELOOP
+  WSAELOOP,
+#else
+  0,
+#endif
+#endif
+#ifdef EMEDIUMTYPE
+  EMEDIUMTYPE,
+#else
+#ifdef WSAEMEDIUMTYPE
+  WSAEMEDIUMTYPE,
+#else
+  0,
+#endif
+#endif
+#ifdef EMFILE
+  EMFILE,
+#else
+#ifdef WSAEMFILE
+  WSAEMFILE,
+#else
+  0,
+#endif
+#endif
+#ifdef EMLINK
+  EMLINK,
+#else
+#ifdef WSAEMLINK
+  WSAEMLINK,
+#else
+  0,
+#endif
+#endif
+#ifdef EMSGSIZE
+  EMSGSIZE,
+#else
+#ifdef WSAEMSGSIZE
+  WSAEMSGSIZE,
+#else
+  0,
+#endif
+#endif
+#ifdef EMULTIHOP
+  EMULTIHOP,
+#else
+#ifdef WSAEMULTIHOP
+  WSAEMULTIHOP,
+#else
+  0,
+#endif
+#endif
+#ifdef ENAMETOOLONG
+  ENAMETOOLONG,
+#else
+#ifdef WSAENAMETOOLONG
+  WSAENAMETOOLONG,
+#else
+  0,
+#endif
+#endif
+#ifdef ENAVAIL
+  ENAVAIL,
+#else
+#ifdef WSAENAVAIL
+  WSAENAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef ENEEDAUTH
+  ENEEDAUTH,
+#else
+#ifdef WSAENEEDAUTH
+  WSAENEEDAUTH,
+#else
+  0,
+#endif
+#endif
+#ifdef ENETDOWN
+  ENETDOWN,
+#else
+#ifdef WSAENETDOWN
+  WSAENETDOWN,
+#else
+  0,
+#endif
+#endif
+#ifdef ENETRESET
+  ENETRESET,
+#else
+#ifdef WSAENETRESET
+  WSAENETRESET,
+#else
+  0,
+#endif
+#endif
+#ifdef ENETUNREACH
+  ENETUNREACH,
+#else
+#ifdef WSAENETUNREACH
+  WSAENETUNREACH,
+#else
+  0,
+#endif
+#endif
+#ifdef ENFILE
+  ENFILE,
+#else
+#ifdef WSAENFILE
+  WSAENFILE,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOANO
+  ENOANO,
+#else
+#ifdef WSAENOANO
+  WSAENOANO,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOBUFS
+  ENOBUFS,
+#else
+#ifdef WSAENOBUFS
+  WSAENOBUFS,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOCSI
+  ENOCSI,
+#else
+#ifdef WSAENOCSI
+  WSAENOCSI,
+#else
+  0,
+#endif
+#endif
+#ifdef ENODATA
+  ENODATA,
+#else
+#ifdef WSAENODATA
+  WSAENODATA,
+#else
+  0,
+#endif
+#endif
+#ifdef ENODEV
+  ENODEV,
+#else
+#ifdef WSAENODEV
+  WSAENODEV,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOENT
+  ENOENT,
+#else
+#ifdef WSAENOENT
+  WSAENOENT,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOEXEC
+  ENOEXEC,
+#else
+#ifdef WSAENOEXEC
+  WSAENOEXEC,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOLCK
+  ENOLCK,
+#else
+#ifdef WSAENOLCK
+  WSAENOLCK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOLINK
+  ENOLINK,
+#else
+#ifdef WSAENOLINK
+  WSAENOLINK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOMEDIUM
+  ENOMEDIUM,
+#else
+#ifdef WSAENOMEDIUM
+  WSAENOMEDIUM,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOMEM
+  ENOMEM,
+#else
+#ifdef WSAENOMEM
+  WSAENOMEM,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOMSG
+  ENOMSG,
+#else
+#ifdef WSAENOMSG
+  WSAENOMSG,
+#else
+  0,
+#endif
+#endif
+#ifdef ENONET
+  ENONET,
+#else
+#ifdef WSAENONET
+  WSAENONET,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOPKG
+  ENOPKG,
+#else
+#ifdef WSAENOPKG
+  WSAENOPKG,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOPROTOOPT
+  ENOPROTOOPT,
+#else
+#ifdef WSAENOPROTOOPT
+  WSAENOPROTOOPT,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSPC
+  ENOSPC,
+#else
+#ifdef WSAENOSPC
+  WSAENOSPC,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSR
+  ENOSR,
+#else
+#ifdef WSAENOSR
+  WSAENOSR,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSTR
+  ENOSTR,
+#else
+#ifdef WSAENOSTR
+  WSAENOSTR,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSYS
+  ENOSYS,
+#else
+#ifdef WSAENOSYS
+  WSAENOSYS,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTBLK
+  ENOTBLK,
+#else
+#ifdef WSAENOTBLK
+  WSAENOTBLK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTCONN
+  ENOTCONN,
+#else
+#ifdef WSAENOTCONN
+  WSAENOTCONN,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTDIR
+  ENOTDIR,
+#else
+#ifdef WSAENOTDIR
+  WSAENOTDIR,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTEMPTY
+  ENOTEMPTY,
+#else
+#ifdef WSAENOTEMPTY
+  WSAENOTEMPTY,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTNAM
+  ENOTNAM,
+#else
+#ifdef WSAENOTNAM
+  WSAENOTNAM,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTSOCK
+  ENOTSOCK,
+#else
+#ifdef WSAENOTSOCK
+  WSAENOTSOCK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTSUP
+  ENOTSUP,
+#else
+#ifdef WSAENOTSUP
+  WSAENOTSUP,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTTY
+  ENOTTY,
+#else
+#ifdef WSAENOTTY
+  WSAENOTTY,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTUNIQ
+  ENOTUNIQ,
+#else
+#ifdef WSAENOTUNIQ
+  WSAENOTUNIQ,
+#else
+  0,
+#endif
+#endif
+#ifdef ENXIO
+  ENXIO,
+#else
+#ifdef WSAENXIO
+  WSAENXIO,
+#else
+  0,
+#endif
+#endif
+#ifdef EOPNOTSUPP
+  EOPNOTSUPP,
+#else
+#ifdef WSAEOPNOTSUPP
+  WSAEOPNOTSUPP,
+#else
+  0,
+#endif
+#endif
+#ifdef EOVERFLOW
+  EOVERFLOW,
+#else
+#ifdef WSAEOVERFLOW
+  WSAEOVERFLOW,
+#else
+  0,
+#endif
+#endif
+#ifdef EPERM
+  EPERM,
+#else
+#ifdef WSAEPERM
+  WSAEPERM,
+#else
+  0,
+#endif
+#endif
+#ifdef EPFNOSUPPORT
+  EPFNOSUPPORT,
+#else
+#ifdef WSAEPFNOSUPPORT
+  WSAEPFNOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef EPIPE
+  EPIPE,
+#else
+#ifdef WSAEPIPE
+  WSAEPIPE,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROCLIM
+  EPROCLIM,
+#else
+#ifdef WSAEPROCLIM
+  WSAEPROCLIM,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROCUNAVAIL
+  EPROCUNAVAIL,
+#else
+#ifdef WSAEPROCUNAVAIL
+  WSAEPROCUNAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROGMISMATCH
+  EPROGMISMATCH,
+#else
+#ifdef WSAEPROGMISMATCH
+  WSAEPROGMISMATCH,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROGUNAVAIL
+  EPROGUNAVAIL,
+#else
+#ifdef WSAEPROGUNAVAIL
+  WSAEPROGUNAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROTO
+  EPROTO,
+#else
+#ifdef WSAEPROTO
+  WSAEPROTO,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROTONOSUPPORT
+  EPROTONOSUPPORT,
+#else
+#ifdef WSAEPROTONOSUPPORT
+  WSAEPROTONOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROTOTYPE
+  EPROTOTYPE,
+#else
+#ifdef WSAEPROTOTYPE
+  WSAEPROTOTYPE,
+#else
+  0,
+#endif
+#endif
+#ifdef ERANGE
+  ERANGE,
+#else
+#ifdef WSAERANGE
+  WSAERANGE,
+#else
+  0,
+#endif
+#endif
+#ifdef EREMCHG
+  EREMCHG,
+#else
+#ifdef WSAEREMCHG
+  WSAEREMCHG,
+#else
+  0,
+#endif
+#endif
+#ifdef EREMOTE
+  EREMOTE,
+#else
+#ifdef WSAEREMOTE
+  WSAEREMOTE,
+#else
+  0,
+#endif
+#endif
+#ifdef EREMOTEIO
+  EREMOTEIO,
+#else
+#ifdef WSAEREMOTEIO
+  WSAEREMOTEIO,
+#else
+  0,
+#endif
+#endif
+#ifdef ERESTART
+  ERESTART,
+#else
+#ifdef WSAERESTART
+  WSAERESTART,
+#else
+  0,
+#endif
+#endif
+#ifdef EROFS
+  EROFS,
+#else
+#ifdef WSAEROFS
+  WSAEROFS,
+#else
+  0,
+#endif
+#endif
+#ifdef ERPCMISMATCH
+  ERPCMISMATCH,
+#else
+#ifdef WSAERPCMISMATCH
+  WSAERPCMISMATCH,
+#else
+  0,
+#endif
+#endif
+#ifdef ESHUTDOWN
+  ESHUTDOWN,
+#else
+#ifdef WSAESHUTDOWN
+  WSAESHUTDOWN,
+#else
+  0,
+#endif
+#endif
+#ifdef ESOCKTNOSUPPORT
+  ESOCKTNOSUPPORT,
+#else
+#ifdef WSAESOCKTNOSUPPORT
+  WSAESOCKTNOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef ESPIPE
+  ESPIPE,
+#else
+#ifdef WSAESPIPE
+  WSAESPIPE,
+#else
+  0,
+#endif
+#endif
+#ifdef ESRCH
+  ESRCH,
+#else
+#ifdef WSAESRCH
+  WSAESRCH,
+#else
+  0,
+#endif
+#endif
+#ifdef ESRMNT
+  ESRMNT,
+#else
+#ifdef WSAESRMNT
+  WSAESRMNT,
+#else
+  0,
+#endif
+#endif
+#ifdef ESTALE
+  ESTALE,
+#else
+#ifdef WSAESTALE
+  WSAESTALE,
+#else
+  0,
+#endif
+#endif
+#ifdef ESTRPIPE
+  ESTRPIPE,
+#else
+#ifdef WSAESTRPIPE
+  WSAESTRPIPE,
+#else
+  0,
+#endif
+#endif
+#ifdef ETIME
+  ETIME,
+#else
+#ifdef WSAETIME
+  WSAETIME,
+#else
+  0,
+#endif
+#endif
+#ifdef ETIMEDOUT
+  ETIMEDOUT,
+#else
+#ifdef WSAETIMEDOUT
+  WSAETIMEDOUT,
+#else
+  0,
+#endif
+#endif
+#ifdef ETOOMANYREFS
+  ETOOMANYREFS,
+#else
+#ifdef WSAETOOMANYREFS
+  WSAETOOMANYREFS,
+#else
+  0,
+#endif
+#endif
+#ifdef ETXTBSY
+  ETXTBSY,
+#else
+#ifdef WSAETXTBSY
+  WSAETXTBSY,
+#else
+  0,
+#endif
+#endif
+#ifdef EUCLEAN
+  EUCLEAN,
+#else
+#ifdef WSAEUCLEAN
+  WSAEUCLEAN,
+#else
+  0,
+#endif
+#endif
+#ifdef EUNATCH
+  EUNATCH,
+#else
+#ifdef WSAEUNATCH
+  WSAEUNATCH,
+#else
+  0,
+#endif
+#endif
+#ifdef EUSERS
+  EUSERS,
+#else
+#ifdef WSAEUSERS
+  WSAEUSERS,
+#else
+  0,
+#endif
+#endif
+#ifdef EWOULDBLOCK
+  EWOULDBLOCK,
+#else
+#ifdef WSAEWOULDBLOCK
+  WSAEWOULDBLOCK,
+#else
+  0,
+#endif
+#endif
+#ifdef EXDEV
+  EXDEV,
+#else
+#ifdef WSAEXDEV
+  WSAEXDEV,
+#else
+  0,
+#endif
+#endif
+#ifdef EXFULL
+  EXFULL,
+#else
+#ifdef WSAEXFULL
+  WSAEXFULL,
+#else
+  0,
+#endif
+#endif
+};
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/err-codes-sym.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-codes-sym.h
new file mode 100644
index 000000000..d02f23ba5
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-codes-sym.h
@@ -0,0 +1,860 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* err-codes.h - List of error codes and their description.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char msgstr[] = 
+  "GPG_ERR_NO_ERROR" "\0"
+  "GPG_ERR_GENERAL" "\0"
+  "GPG_ERR_UNKNOWN_PACKET" "\0"
+  "GPG_ERR_UNKNOWN_VERSION" "\0"
+  "GPG_ERR_PUBKEY_ALGO" "\0"
+  "GPG_ERR_DIGEST_ALGO" "\0"
+  "GPG_ERR_BAD_PUBKEY" "\0"
+  "GPG_ERR_BAD_SECKEY" "\0"
+  "GPG_ERR_BAD_SIGNATURE" "\0"
+  "GPG_ERR_NO_PUBKEY" "\0"
+  "GPG_ERR_CHECKSUM" "\0"
+  "GPG_ERR_BAD_PASSPHRASE" "\0"
+  "GPG_ERR_CIPHER_ALGO" "\0"
+  "GPG_ERR_KEYRING_OPEN" "\0"
+  "GPG_ERR_INV_PACKET" "\0"
+  "GPG_ERR_INV_ARMOR" "\0"
+  "GPG_ERR_NO_USER_ID" "\0"
+  "GPG_ERR_NO_SECKEY" "\0"
+  "GPG_ERR_WRONG_SECKEY" "\0"
+  "GPG_ERR_BAD_KEY" "\0"
+  "GPG_ERR_COMPR_ALGO" "\0"
+  "GPG_ERR_NO_PRIME" "\0"
+  "GPG_ERR_NO_ENCODING_METHOD" "\0"
+  "GPG_ERR_NO_ENCRYPTION_SCHEME" "\0"
+  "GPG_ERR_NO_SIGNATURE_SCHEME" "\0"
+  "GPG_ERR_INV_ATTR" "\0"
+  "GPG_ERR_NO_VALUE" "\0"
+  "GPG_ERR_NOT_FOUND" "\0"
+  "GPG_ERR_VALUE_NOT_FOUND" "\0"
+  "GPG_ERR_SYNTAX" "\0"
+  "GPG_ERR_BAD_MPI" "\0"
+  "GPG_ERR_INV_PASSPHRASE" "\0"
+  "GPG_ERR_SIG_CLASS" "\0"
+  "GPG_ERR_RESOURCE_LIMIT" "\0"
+  "GPG_ERR_INV_KEYRING" "\0"
+  "GPG_ERR_TRUSTDB" "\0"
+  "GPG_ERR_BAD_CERT" "\0"
+  "GPG_ERR_INV_USER_ID" "\0"
+  "GPG_ERR_UNEXPECTED" "\0"
+  "GPG_ERR_TIME_CONFLICT" "\0"
+  "GPG_ERR_KEYSERVER" "\0"
+  "GPG_ERR_WRONG_PUBKEY_ALGO" "\0"
+  "GPG_ERR_TRIBUTE_TO_D_A" "\0"
+  "GPG_ERR_WEAK_KEY" "\0"
+  "GPG_ERR_INV_KEYLEN" "\0"
+  "GPG_ERR_INV_ARG" "\0"
+  "GPG_ERR_BAD_URI" "\0"
+  "GPG_ERR_INV_URI" "\0"
+  "GPG_ERR_NETWORK" "\0"
+  "GPG_ERR_UNKNOWN_HOST" "\0"
+  "GPG_ERR_SELFTEST_FAILED" "\0"
+  "GPG_ERR_NOT_ENCRYPTED" "\0"
+  "GPG_ERR_NOT_PROCESSED" "\0"
+  "GPG_ERR_UNUSABLE_PUBKEY" "\0"
+  "GPG_ERR_UNUSABLE_SECKEY" "\0"
+  "GPG_ERR_INV_VALUE" "\0"
+  "GPG_ERR_BAD_CERT_CHAIN" "\0"
+  "GPG_ERR_MISSING_CERT" "\0"
+  "GPG_ERR_NO_DATA" "\0"
+  "GPG_ERR_BUG" "\0"
+  "GPG_ERR_NOT_SUPPORTED" "\0"
+  "GPG_ERR_INV_OP" "\0"
+  "GPG_ERR_TIMEOUT" "\0"
+  "GPG_ERR_INTERNAL" "\0"
+  "GPG_ERR_EOF_GCRYPT" "\0"
+  "GPG_ERR_INV_OBJ" "\0"
+  "GPG_ERR_TOO_SHORT" "\0"
+  "GPG_ERR_TOO_LARGE" "\0"
+  "GPG_ERR_NO_OBJ" "\0"
+  "GPG_ERR_NOT_IMPLEMENTED" "\0"
+  "GPG_ERR_CONFLICT" "\0"
+  "GPG_ERR_INV_CIPHER_MODE" "\0"
+  "GPG_ERR_INV_FLAG" "\0"
+  "GPG_ERR_INV_HANDLE" "\0"
+  "GPG_ERR_TRUNCATED" "\0"
+  "GPG_ERR_INCOMPLETE_LINE" "\0"
+  "GPG_ERR_INV_RESPONSE" "\0"
+  "GPG_ERR_NO_AGENT" "\0"
+  "GPG_ERR_AGENT" "\0"
+  "GPG_ERR_INV_DATA" "\0"
+  "GPG_ERR_ASSUAN_SERVER_FAULT" "\0"
+  "GPG_ERR_ASSUAN" "\0"
+  "GPG_ERR_INV_SESSION_KEY" "\0"
+  "GPG_ERR_INV_SEXP" "\0"
+  "GPG_ERR_UNSUPPORTED_ALGORITHM" "\0"
+  "GPG_ERR_NO_PIN_ENTRY" "\0"
+  "GPG_ERR_PIN_ENTRY" "\0"
+  "GPG_ERR_BAD_PIN" "\0"
+  "GPG_ERR_INV_NAME" "\0"
+  "GPG_ERR_BAD_DATA" "\0"
+  "GPG_ERR_INV_PARAMETER" "\0"
+  "GPG_ERR_WRONG_CARD" "\0"
+  "GPG_ERR_NO_DIRMNGR" "\0"
+  "GPG_ERR_DIRMNGR" "\0"
+  "GPG_ERR_CERT_REVOKED" "\0"
+  "GPG_ERR_NO_CRL_KNOWN" "\0"
+  "GPG_ERR_CRL_TOO_OLD" "\0"
+  "GPG_ERR_LINE_TOO_LONG" "\0"
+  "GPG_ERR_NOT_TRUSTED" "\0"
+  "GPG_ERR_CANCELED" "\0"
+  "GPG_ERR_BAD_CA_CERT" "\0"
+  "GPG_ERR_CERT_EXPIRED" "\0"
+  "GPG_ERR_CERT_TOO_YOUNG" "\0"
+  "GPG_ERR_UNSUPPORTED_CERT" "\0"
+  "GPG_ERR_UNKNOWN_SEXP" "\0"
+  "GPG_ERR_UNSUPPORTED_PROTECTION" "\0"
+  "GPG_ERR_CORRUPTED_PROTECTION" "\0"
+  "GPG_ERR_AMBIGUOUS_NAME" "\0"
+  "GPG_ERR_CARD" "\0"
+  "GPG_ERR_CARD_RESET" "\0"
+  "GPG_ERR_CARD_REMOVED" "\0"
+  "GPG_ERR_INV_CARD" "\0"
+  "GPG_ERR_CARD_NOT_PRESENT" "\0"
+  "GPG_ERR_NO_PKCS15_APP" "\0"
+  "GPG_ERR_NOT_CONFIRMED" "\0"
+  "GPG_ERR_CONFIGURATION" "\0"
+  "GPG_ERR_NO_POLICY_MATCH" "\0"
+  "GPG_ERR_INV_INDEX" "\0"
+  "GPG_ERR_INV_ID" "\0"
+  "GPG_ERR_NO_SCDAEMON" "\0"
+  "GPG_ERR_SCDAEMON" "\0"
+  "GPG_ERR_UNSUPPORTED_PROTOCOL" "\0"
+  "GPG_ERR_BAD_PIN_METHOD" "\0"
+  "GPG_ERR_CARD_NOT_INITIALIZED" "\0"
+  "GPG_ERR_UNSUPPORTED_OPERATION" "\0"
+  "GPG_ERR_WRONG_KEY_USAGE" "\0"
+  "GPG_ERR_NOTHING_FOUND" "\0"
+  "GPG_ERR_WRONG_BLOB_TYPE" "\0"
+  "GPG_ERR_MISSING_VALUE" "\0"
+  "GPG_ERR_HARDWARE" "\0"
+  "GPG_ERR_PIN_BLOCKED" "\0"
+  "GPG_ERR_USE_CONDITIONS" "\0"
+  "GPG_ERR_PIN_NOT_SYNCED" "\0"
+  "GPG_ERR_INV_CRL" "\0"
+  "GPG_ERR_BAD_BER" "\0"
+  "GPG_ERR_INV_BER" "\0"
+  "GPG_ERR_ELEMENT_NOT_FOUND" "\0"
+  "GPG_ERR_IDENTIFIER_NOT_FOUND" "\0"
+  "GPG_ERR_INV_TAG" "\0"
+  "GPG_ERR_INV_LENGTH" "\0"
+  "GPG_ERR_INV_KEYINFO" "\0"
+  "GPG_ERR_UNEXPECTED_TAG" "\0"
+  "GPG_ERR_NOT_DER_ENCODED" "\0"
+  "GPG_ERR_NO_CMS_OBJ" "\0"
+  "GPG_ERR_INV_CMS_OBJ" "\0"
+  "GPG_ERR_UNKNOWN_CMS_OBJ" "\0"
+  "GPG_ERR_UNSUPPORTED_CMS_OBJ" "\0"
+  "GPG_ERR_UNSUPPORTED_ENCODING" "\0"
+  "GPG_ERR_UNSUPPORTED_CMS_VERSION" "\0"
+  "GPG_ERR_UNKNOWN_ALGORITHM" "\0"
+  "GPG_ERR_INV_ENGINE" "\0"
+  "GPG_ERR_PUBKEY_NOT_TRUSTED" "\0"
+  "GPG_ERR_DECRYPT_FAILED" "\0"
+  "GPG_ERR_KEY_EXPIRED" "\0"
+  "GPG_ERR_SIG_EXPIRED" "\0"
+  "GPG_ERR_ENCODING_PROBLEM" "\0"
+  "GPG_ERR_INV_STATE" "\0"
+  "GPG_ERR_DUP_VALUE" "\0"
+  "GPG_ERR_MISSING_ACTION" "\0"
+  "GPG_ERR_MODULE_NOT_FOUND" "\0"
+  "GPG_ERR_INV_OID_STRING" "\0"
+  "GPG_ERR_INV_TIME" "\0"
+  "GPG_ERR_INV_CRL_OBJ" "\0"
+  "GPG_ERR_UNSUPPORTED_CRL_VERSION" "\0"
+  "GPG_ERR_INV_CERT_OBJ" "\0"
+  "GPG_ERR_UNKNOWN_NAME" "\0"
+  "GPG_ERR_LOCALE_PROBLEM" "\0"
+  "GPG_ERR_NOT_LOCKED" "\0"
+  "GPG_ERR_PROTOCOL_VIOLATION" "\0"
+  "GPG_ERR_INV_MAC" "\0"
+  "GPG_ERR_INV_REQUEST" "\0"
+  "GPG_ERR_UNKNOWN_EXTN" "\0"
+  "GPG_ERR_UNKNOWN_CRIT_EXTN" "\0"
+  "GPG_ERR_LOCKED" "\0"
+  "GPG_ERR_UNKNOWN_OPTION" "\0"
+  "GPG_ERR_UNKNOWN_COMMAND" "\0"
+  "GPG_ERR_NOT_OPERATIONAL" "\0"
+  "GPG_ERR_NO_PASSPHRASE" "\0"
+  "GPG_ERR_NO_PIN" "\0"
+  "GPG_ERR_NOT_ENABLED" "\0"
+  "GPG_ERR_NO_ENGINE" "\0"
+  "GPG_ERR_MISSING_KEY" "\0"
+  "GPG_ERR_TOO_MANY" "\0"
+  "GPG_ERR_LIMIT_REACHED" "\0"
+  "GPG_ERR_NOT_INITIALIZED" "\0"
+  "GPG_ERR_MISSING_ISSUER_CERT" "\0"
+  "GPG_ERR_NO_KEYSERVER" "\0"
+  "GPG_ERR_INV_CURVE" "\0"
+  "GPG_ERR_UNKNOWN_CURVE" "\0"
+  "GPG_ERR_DUP_KEY" "\0"
+  "GPG_ERR_AMBIGUOUS" "\0"
+  "GPG_ERR_NO_CRYPT_CTX" "\0"
+  "GPG_ERR_WRONG_CRYPT_CTX" "\0"
+  "GPG_ERR_BAD_CRYPT_CTX" "\0"
+  "GPG_ERR_CRYPT_CTX_CONFLICT" "\0"
+  "GPG_ERR_BROKEN_PUBKEY" "\0"
+  "GPG_ERR_BROKEN_SECKEY" "\0"
+  "GPG_ERR_MAC_ALGO" "\0"
+  "GPG_ERR_FULLY_CANCELED" "\0"
+  "GPG_ERR_UNFINISHED" "\0"
+  "GPG_ERR_BUFFER_TOO_SHORT" "\0"
+  "GPG_ERR_SEXP_INV_LEN_SPEC" "\0"
+  "GPG_ERR_SEXP_STRING_TOO_LONG" "\0"
+  "GPG_ERR_SEXP_UNMATCHED_PAREN" "\0"
+  "GPG_ERR_SEXP_NOT_CANONICAL" "\0"
+  "GPG_ERR_SEXP_BAD_CHARACTER" "\0"
+  "GPG_ERR_SEXP_BAD_QUOTATION" "\0"
+  "GPG_ERR_SEXP_ZERO_PREFIX" "\0"
+  "GPG_ERR_SEXP_NESTED_DH" "\0"
+  "GPG_ERR_SEXP_UNMATCHED_DH" "\0"
+  "GPG_ERR_SEXP_UNEXPECTED_PUNC" "\0"
+  "GPG_ERR_SEXP_BAD_HEX_CHAR" "\0"
+  "GPG_ERR_SEXP_ODD_HEX_NUMBERS" "\0"
+  "GPG_ERR_SEXP_BAD_OCT_CHAR" "\0"
+  "GPG_ERR_SUBKEYS_EXP_OR_REV" "\0"
+  "GPG_ERR_DB_CORRUPTED" "\0"
+  "GPG_ERR_SERVER_FAILED" "\0"
+  "GPG_ERR_NO_NAME" "\0"
+  "GPG_ERR_NO_KEY" "\0"
+  "GPG_ERR_LEGACY_KEY" "\0"
+  "GPG_ERR_REQUEST_TOO_SHORT" "\0"
+  "GPG_ERR_REQUEST_TOO_LONG" "\0"
+  "GPG_ERR_OBJ_TERM_STATE" "\0"
+  "GPG_ERR_NO_CERT_CHAIN" "\0"
+  "GPG_ERR_CERT_TOO_LARGE" "\0"
+  "GPG_ERR_INV_RECORD" "\0"
+  "GPG_ERR_BAD_MAC" "\0"
+  "GPG_ERR_UNEXPECTED_MSG" "\0"
+  "GPG_ERR_COMPR_FAILED" "\0"
+  "GPG_ERR_WOULD_WRAP" "\0"
+  "GPG_ERR_FATAL_ALERT" "\0"
+  "GPG_ERR_NO_CIPHER" "\0"
+  "GPG_ERR_MISSING_CLIENT_CERT" "\0"
+  "GPG_ERR_CLOSE_NOTIFY" "\0"
+  "GPG_ERR_TICKET_EXPIRED" "\0"
+  "GPG_ERR_BAD_TICKET" "\0"
+  "GPG_ERR_UNKNOWN_IDENTITY" "\0"
+  "GPG_ERR_BAD_HS_CERT" "\0"
+  "GPG_ERR_BAD_HS_CERT_REQ" "\0"
+  "GPG_ERR_BAD_HS_CERT_VER" "\0"
+  "GPG_ERR_BAD_HS_CHANGE_CIPHER" "\0"
+  "GPG_ERR_BAD_HS_CLIENT_HELLO" "\0"
+  "GPG_ERR_BAD_HS_SERVER_HELLO" "\0"
+  "GPG_ERR_BAD_HS_SERVER_HELLO_DONE" "\0"
+  "GPG_ERR_BAD_HS_FINISHED" "\0"
+  "GPG_ERR_BAD_HS_SERVER_KEX" "\0"
+  "GPG_ERR_BAD_HS_CLIENT_KEX" "\0"
+  "GPG_ERR_BOGUS_STRING" "\0"
+  "GPG_ERR_FORBIDDEN" "\0"
+  "GPG_ERR_KEY_DISABLED" "\0"
+  "GPG_ERR_KEY_ON_CARD" "\0"
+  "GPG_ERR_INV_LOCK_OBJ" "\0"
+  "GPG_ERR_TRUE" "\0"
+  "GPG_ERR_FALSE" "\0"
+  "GPG_ERR_ASS_GENERAL" "\0"
+  "GPG_ERR_ASS_ACCEPT_FAILED" "\0"
+  "GPG_ERR_ASS_CONNECT_FAILED" "\0"
+  "GPG_ERR_ASS_INV_RESPONSE" "\0"
+  "GPG_ERR_ASS_INV_VALUE" "\0"
+  "GPG_ERR_ASS_INCOMPLETE_LINE" "\0"
+  "GPG_ERR_ASS_LINE_TOO_LONG" "\0"
+  "GPG_ERR_ASS_NESTED_COMMANDS" "\0"
+  "GPG_ERR_ASS_NO_DATA_CB" "\0"
+  "GPG_ERR_ASS_NO_INQUIRE_CB" "\0"
+  "GPG_ERR_ASS_NOT_A_SERVER" "\0"
+  "GPG_ERR_ASS_NOT_A_CLIENT" "\0"
+  "GPG_ERR_ASS_SERVER_START" "\0"
+  "GPG_ERR_ASS_READ_ERROR" "\0"
+  "GPG_ERR_ASS_WRITE_ERROR" "\0"
+  "GPG_ERR_ASS_TOO_MUCH_DATA" "\0"
+  "GPG_ERR_ASS_UNEXPECTED_CMD" "\0"
+  "GPG_ERR_ASS_UNKNOWN_CMD" "\0"
+  "GPG_ERR_ASS_SYNTAX" "\0"
+  "GPG_ERR_ASS_CANCELED" "\0"
+  "GPG_ERR_ASS_NO_INPUT" "\0"
+  "GPG_ERR_ASS_NO_OUTPUT" "\0"
+  "GPG_ERR_ASS_PARAMETER" "\0"
+  "GPG_ERR_ASS_UNKNOWN_INQUIRE" "\0"
+  "GPG_ERR_ENGINE_TOO_OLD" "\0"
+  "GPG_ERR_WINDOW_TOO_SMALL" "\0"
+  "GPG_ERR_WINDOW_TOO_LARGE" "\0"
+  "GPG_ERR_MISSING_ENVVAR" "\0"
+  "GPG_ERR_USER_ID_EXISTS" "\0"
+  "GPG_ERR_NAME_EXISTS" "\0"
+  "GPG_ERR_DUP_NAME" "\0"
+  "GPG_ERR_TOO_YOUNG" "\0"
+  "GPG_ERR_TOO_OLD" "\0"
+  "GPG_ERR_UNKNOWN_FLAG" "\0"
+  "GPG_ERR_INV_ORDER" "\0"
+  "GPG_ERR_ALREADY_FETCHED" "\0"
+  "GPG_ERR_TRY_LATER" "\0"
+  "GPG_ERR_WRONG_NAME" "\0"
+  "GPG_ERR_SYSTEM_BUG" "\0"
+  "GPG_ERR_DNS_UNKNOWN" "\0"
+  "GPG_ERR_DNS_SECTION" "\0"
+  "GPG_ERR_DNS_ADDRESS" "\0"
+  "GPG_ERR_DNS_NO_QUERY" "\0"
+  "GPG_ERR_DNS_NO_ANSWER" "\0"
+  "GPG_ERR_DNS_CLOSED" "\0"
+  "GPG_ERR_DNS_VERIFY" "\0"
+  "GPG_ERR_DNS_TIMEOUT" "\0"
+  "GPG_ERR_LDAP_GENERAL" "\0"
+  "GPG_ERR_LDAP_ATTR_GENERAL" "\0"
+  "GPG_ERR_LDAP_NAME_GENERAL" "\0"
+  "GPG_ERR_LDAP_SECURITY_GENERAL" "\0"
+  "GPG_ERR_LDAP_SERVICE_GENERAL" "\0"
+  "GPG_ERR_LDAP_UPDATE_GENERAL" "\0"
+  "GPG_ERR_LDAP_E_GENERAL" "\0"
+  "GPG_ERR_LDAP_X_GENERAL" "\0"
+  "GPG_ERR_LDAP_OTHER_GENERAL" "\0"
+  "GPG_ERR_LDAP_X_CONNECTING" "\0"
+  "GPG_ERR_LDAP_REFERRAL_LIMIT" "\0"
+  "GPG_ERR_LDAP_CLIENT_LOOP" "\0"
+  "GPG_ERR_LDAP_NO_RESULTS" "\0"
+  "GPG_ERR_LDAP_CONTROL_NOT_FOUND" "\0"
+  "GPG_ERR_LDAP_NOT_SUPPORTED" "\0"
+  "GPG_ERR_LDAP_CONNECT" "\0"
+  "GPG_ERR_LDAP_NO_MEMORY" "\0"
+  "GPG_ERR_LDAP_PARAM" "\0"
+  "GPG_ERR_LDAP_USER_CANCELLED" "\0"
+  "GPG_ERR_LDAP_FILTER" "\0"
+  "GPG_ERR_LDAP_AUTH_UNKNOWN" "\0"
+  "GPG_ERR_LDAP_TIMEOUT" "\0"
+  "GPG_ERR_LDAP_DECODING" "\0"
+  "GPG_ERR_LDAP_ENCODING" "\0"
+  "GPG_ERR_LDAP_LOCAL" "\0"
+  "GPG_ERR_LDAP_SERVER_DOWN" "\0"
+  "GPG_ERR_LDAP_SUCCESS" "\0"
+  "GPG_ERR_LDAP_OPERATIONS" "\0"
+  "GPG_ERR_LDAP_PROTOCOL" "\0"
+  "GPG_ERR_LDAP_TIMELIMIT" "\0"
+  "GPG_ERR_LDAP_SIZELIMIT" "\0"
+  "GPG_ERR_LDAP_COMPARE_FALSE" "\0"
+  "GPG_ERR_LDAP_COMPARE_TRUE" "\0"
+  "GPG_ERR_LDAP_UNSUPPORTED_AUTH" "\0"
+  "GPG_ERR_LDAP_STRONG_AUTH_RQRD" "\0"
+  "GPG_ERR_LDAP_PARTIAL_RESULTS" "\0"
+  "GPG_ERR_LDAP_REFERRAL" "\0"
+  "GPG_ERR_LDAP_ADMINLIMIT" "\0"
+  "GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN" "\0"
+  "GPG_ERR_LDAP_CONFIDENT_RQRD" "\0"
+  "GPG_ERR_LDAP_SASL_BIND_INPROG" "\0"
+  "GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE" "\0"
+  "GPG_ERR_LDAP_UNDEFINED_TYPE" "\0"
+  "GPG_ERR_LDAP_BAD_MATCHING" "\0"
+  "GPG_ERR_LDAP_CONST_VIOLATION" "\0"
+  "GPG_ERR_LDAP_TYPE_VALUE_EXISTS" "\0"
+  "GPG_ERR_LDAP_INV_SYNTAX" "\0"
+  "GPG_ERR_LDAP_NO_SUCH_OBJ" "\0"
+  "GPG_ERR_LDAP_ALIAS_PROBLEM" "\0"
+  "GPG_ERR_LDAP_INV_DN_SYNTAX" "\0"
+  "GPG_ERR_LDAP_IS_LEAF" "\0"
+  "GPG_ERR_LDAP_ALIAS_DEREF" "\0"
+  "GPG_ERR_LDAP_X_PROXY_AUTH_FAIL" "\0"
+  "GPG_ERR_LDAP_BAD_AUTH" "\0"
+  "GPG_ERR_LDAP_INV_CREDENTIALS" "\0"
+  "GPG_ERR_LDAP_INSUFFICIENT_ACC" "\0"
+  "GPG_ERR_LDAP_BUSY" "\0"
+  "GPG_ERR_LDAP_UNAVAILABLE" "\0"
+  "GPG_ERR_LDAP_UNWILL_TO_PERFORM" "\0"
+  "GPG_ERR_LDAP_LOOP_DETECT" "\0"
+  "GPG_ERR_LDAP_NAMING_VIOLATION" "\0"
+  "GPG_ERR_LDAP_OBJ_CLS_VIOLATION" "\0"
+  "GPG_ERR_LDAP_NOT_ALLOW_NONLEAF" "\0"
+  "GPG_ERR_LDAP_NOT_ALLOW_ON_RDN" "\0"
+  "GPG_ERR_LDAP_ALREADY_EXISTS" "\0"
+  "GPG_ERR_LDAP_NO_OBJ_CLASS_MODS" "\0"
+  "GPG_ERR_LDAP_RESULTS_TOO_LARGE" "\0"
+  "GPG_ERR_LDAP_AFFECTS_MULT_DSAS" "\0"
+  "GPG_ERR_LDAP_VLV" "\0"
+  "GPG_ERR_LDAP_OTHER" "\0"
+  "GPG_ERR_LDAP_CUP_RESOURCE_LIMIT" "\0"
+  "GPG_ERR_LDAP_CUP_SEC_VIOLATION" "\0"
+  "GPG_ERR_LDAP_CUP_INV_DATA" "\0"
+  "GPG_ERR_LDAP_CUP_UNSUP_SCHEME" "\0"
+  "GPG_ERR_LDAP_CUP_RELOAD" "\0"
+  "GPG_ERR_LDAP_CANCELLED" "\0"
+  "GPG_ERR_LDAP_NO_SUCH_OPERATION" "\0"
+  "GPG_ERR_LDAP_TOO_LATE" "\0"
+  "GPG_ERR_LDAP_CANNOT_CANCEL" "\0"
+  "GPG_ERR_LDAP_ASSERTION_FAILED" "\0"
+  "GPG_ERR_LDAP_PROX_AUTH_DENIED" "\0"
+  "GPG_ERR_USER_1" "\0"
+  "GPG_ERR_USER_2" "\0"
+  "GPG_ERR_USER_3" "\0"
+  "GPG_ERR_USER_4" "\0"
+  "GPG_ERR_USER_5" "\0"
+  "GPG_ERR_USER_6" "\0"
+  "GPG_ERR_USER_7" "\0"
+  "GPG_ERR_USER_8" "\0"
+  "GPG_ERR_USER_9" "\0"
+  "GPG_ERR_USER_10" "\0"
+  "GPG_ERR_USER_11" "\0"
+  "GPG_ERR_USER_12" "\0"
+  "GPG_ERR_USER_13" "\0"
+  "GPG_ERR_USER_14" "\0"
+  "GPG_ERR_USER_15" "\0"
+  "GPG_ERR_USER_16" "\0"
+  "GPG_ERR_MISSING_ERRNO" "\0"
+  "GPG_ERR_UNKNOWN_ERRNO" "\0"
+  "GPG_ERR_EOF" "\0"
+  "GPG_ERR_CODE_DIM";
+
+static const int msgidx[] =
+  {
+    0,
+    17,
+    33,
+    56,
+    80,
+    100,
+    120,
+    139,
+    158,
+    180,
+    198,
+    215,
+    238,
+    258,
+    279,
+    298,
+    316,
+    335,
+    353,
+    374,
+    390,
+    409,
+    426,
+    453,
+    482,
+    510,
+    527,
+    544,
+    562,
+    586,
+    601,
+    617,
+    640,
+    658,
+    681,
+    701,
+    717,
+    734,
+    754,
+    773,
+    795,
+    813,
+    839,
+    862,
+    879,
+    898,
+    914,
+    930,
+    946,
+    962,
+    983,
+    1007,
+    1029,
+    1051,
+    1075,
+    1099,
+    1117,
+    1140,
+    1161,
+    1177,
+    1189,
+    1211,
+    1226,
+    1242,
+    1259,
+    1278,
+    1294,
+    1312,
+    1330,
+    1345,
+    1369,
+    1386,
+    1410,
+    1427,
+    1446,
+    1464,
+    1488,
+    1509,
+    1526,
+    1540,
+    1557,
+    1585,
+    1600,
+    1624,
+    1641,
+    1671,
+    1692,
+    1710,
+    1726,
+    1743,
+    1760,
+    1782,
+    1801,
+    1820,
+    1836,
+    1857,
+    1878,
+    1898,
+    1920,
+    1940,
+    1957,
+    1977,
+    1998,
+    2021,
+    2046,
+    2067,
+    2098,
+    2127,
+    2150,
+    2163,
+    2182,
+    2203,
+    2220,
+    2245,
+    2267,
+    2289,
+    2311,
+    2335,
+    2353,
+    2368,
+    2388,
+    2405,
+    2434,
+    2457,
+    2486,
+    2516,
+    2540,
+    2562,
+    2586,
+    2608,
+    2625,
+    2645,
+    2668,
+    2691,
+    2707,
+    2723,
+    2739,
+    2765,
+    2794,
+    2810,
+    2829,
+    2849,
+    2872,
+    2896,
+    2915,
+    2935,
+    2959,
+    2987,
+    3016,
+    3048,
+    3074,
+    3093,
+    3120,
+    3143,
+    3163,
+    3183,
+    3208,
+    3226,
+    3244,
+    3267,
+    3292,
+    3315,
+    3332,
+    3352,
+    3384,
+    3405,
+    3426,
+    3449,
+    3468,
+    3495,
+    3511,
+    3531,
+    3552,
+    3578,
+    3593,
+    3616,
+    3640,
+    3664,
+    3686,
+    3701,
+    3721,
+    3739,
+    3759,
+    3776,
+    3798,
+    3822,
+    3850,
+    3871,
+    3889,
+    3911,
+    3927,
+    3945,
+    3966,
+    3990,
+    4012,
+    4039,
+    4061,
+    4083,
+    4100,
+    4123,
+    4142,
+    4167,
+    4193,
+    4222,
+    4251,
+    4278,
+    4305,
+    4332,
+    4357,
+    4380,
+    4406,
+    4435,
+    4461,
+    4490,
+    4516,
+    4543,
+    4564,
+    4586,
+    4602,
+    4617,
+    4636,
+    4662,
+    4687,
+    4710,
+    4732,
+    4755,
+    4774,
+    4790,
+    4813,
+    4834,
+    4853,
+    4873,
+    4891,
+    4919,
+    4940,
+    4963,
+    4982,
+    5007,
+    5027,
+    5051,
+    5075,
+    5104,
+    5132,
+    5160,
+    5193,
+    5217,
+    5243,
+    5269,
+    5290,
+    5308,
+    5329,
+    5349,
+    5370,
+    5383,
+    5397,
+    5417,
+    5443,
+    5470,
+    5495,
+    5517,
+    5545,
+    5571,
+    5599,
+    5622,
+    5648,
+    5673,
+    5698,
+    5723,
+    5746,
+    5770,
+    5796,
+    5823,
+    5847,
+    5866,
+    5887,
+    5908,
+    5930,
+    5952,
+    5980,
+    6003,
+    6028,
+    6053,
+    6076,
+    6099,
+    6119,
+    6136,
+    6154,
+    6170,
+    6191,
+    6209,
+    6233,
+    6251,
+    6270,
+    6289,
+    6309,
+    6329,
+    6349,
+    6370,
+    6392,
+    6411,
+    6430,
+    6450,
+    6471,
+    6497,
+    6523,
+    6553,
+    6582,
+    6610,
+    6633,
+    6656,
+    6683,
+    6709,
+    6737,
+    6762,
+    6786,
+    6817,
+    6844,
+    6865,
+    6888,
+    6907,
+    6935,
+    6955,
+    6981,
+    7002,
+    7024,
+    7046,
+    7065,
+    7090,
+    7111,
+    7135,
+    7157,
+    7180,
+    7203,
+    7230,
+    7256,
+    7286,
+    7316,
+    7345,
+    7367,
+    7391,
+    7422,
+    7450,
+    7480,
+    7511,
+    7539,
+    7565,
+    7594,
+    7625,
+    7649,
+    7674,
+    7701,
+    7728,
+    7749,
+    7774,
+    7805,
+    7827,
+    7856,
+    7886,
+    7904,
+    7929,
+    7960,
+    7985,
+    8015,
+    8046,
+    8077,
+    8107,
+    8135,
+    8166,
+    8197,
+    8228,
+    8245,
+    8264,
+    8296,
+    8327,
+    8353,
+    8383,
+    8407,
+    8430,
+    8461,
+    8483,
+    8510,
+    8540,
+    8570,
+    8585,
+    8600,
+    8615,
+    8630,
+    8645,
+    8660,
+    8675,
+    8690,
+    8705,
+    8721,
+    8737,
+    8753,
+    8769,
+    8785,
+    8801,
+    8817,
+    8839,
+    8861,
+    8873
+  };
+
+static GPG_ERR_INLINE int
+msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 213)) ? (code - 0)
+  : ((code >= 217) && (code <= 271)) ? (code - 3)
+  : ((code >= 273) && (code <= 281)) ? (code - 4)
+  : ((code >= 300) && (code <= 313)) ? (code - 22)
+  : ((code >= 666) && (code <= 666)) ? (code - 374)
+  : ((code >= 711) && (code <= 718)) ? (code - 418)
+  : ((code >= 721) && (code <= 729)) ? (code - 420)
+  : ((code >= 750) && (code <= 752)) ? (code - 440)
+  : ((code >= 754) && (code <= 782)) ? (code - 441)
+  : ((code >= 784) && (code <= 789)) ? (code - 442)
+  : ((code >= 800) && (code <= 804)) ? (code - 452)
+  : ((code >= 815) && (code <= 822)) ? (code - 462)
+  : ((code >= 832) && (code <= 839)) ? (code - 471)
+  : ((code >= 844) && (code <= 844)) ? (code - 475)
+  : ((code >= 848) && (code <= 848)) ? (code - 478)
+  : ((code >= 881) && (code <= 891)) ? (code - 510)
+  : ((code >= 1024) && (code <= 1039)) ? (code - 642)
+  : ((code >= 16381) && (code <= 16383)) ? (code - 15983)
+  : 16384 - 15983);
+}
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/err-codes.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-codes.h
new file mode 100644
index 000000000..5249b0875
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-codes.h
@@ -0,0 +1,860 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* err-codes.h - List of error codes and their description.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char msgstr[] = 
+  gettext_noop ("Success") "\0"
+  gettext_noop ("General error") "\0"
+  gettext_noop ("Unknown packet") "\0"
+  gettext_noop ("Unknown version in packet") "\0"
+  gettext_noop ("Invalid public key algorithm") "\0"
+  gettext_noop ("Invalid digest algorithm") "\0"
+  gettext_noop ("Bad public key") "\0"
+  gettext_noop ("Bad secret key") "\0"
+  gettext_noop ("Bad signature") "\0"
+  gettext_noop ("No public key") "\0"
+  gettext_noop ("Checksum error") "\0"
+  gettext_noop ("Bad passphrase") "\0"
+  gettext_noop ("Invalid cipher algorithm") "\0"
+  gettext_noop ("Cannot open keyring") "\0"
+  gettext_noop ("Invalid packet") "\0"
+  gettext_noop ("Invalid armor") "\0"
+  gettext_noop ("No user ID") "\0"
+  gettext_noop ("No secret key") "\0"
+  gettext_noop ("Wrong secret key used") "\0"
+  gettext_noop ("Bad session key") "\0"
+  gettext_noop ("Unknown compression algorithm") "\0"
+  gettext_noop ("Number is not prime") "\0"
+  gettext_noop ("Invalid encoding method") "\0"
+  gettext_noop ("Invalid encryption scheme") "\0"
+  gettext_noop ("Invalid signature scheme") "\0"
+  gettext_noop ("Invalid attribute") "\0"
+  gettext_noop ("No value") "\0"
+  gettext_noop ("Not found") "\0"
+  gettext_noop ("Value not found") "\0"
+  gettext_noop ("Syntax error") "\0"
+  gettext_noop ("Bad MPI value") "\0"
+  gettext_noop ("Invalid passphrase") "\0"
+  gettext_noop ("Invalid signature class") "\0"
+  gettext_noop ("Resources exhausted") "\0"
+  gettext_noop ("Invalid keyring") "\0"
+  gettext_noop ("Trust DB error") "\0"
+  gettext_noop ("Bad certificate") "\0"
+  gettext_noop ("Invalid user ID") "\0"
+  gettext_noop ("Unexpected error") "\0"
+  gettext_noop ("Time conflict") "\0"
+  gettext_noop ("Keyserver error") "\0"
+  gettext_noop ("Wrong public key algorithm") "\0"
+  gettext_noop ("Tribute to D. A.") "\0"
+  gettext_noop ("Weak encryption key") "\0"
+  gettext_noop ("Invalid key length") "\0"
+  gettext_noop ("Invalid argument") "\0"
+  gettext_noop ("Syntax error in URI") "\0"
+  gettext_noop ("Invalid URI") "\0"
+  gettext_noop ("Network error") "\0"
+  gettext_noop ("Unknown host") "\0"
+  gettext_noop ("Selftest failed") "\0"
+  gettext_noop ("Data not encrypted") "\0"
+  gettext_noop ("Data not processed") "\0"
+  gettext_noop ("Unusable public key") "\0"
+  gettext_noop ("Unusable secret key") "\0"
+  gettext_noop ("Invalid value") "\0"
+  gettext_noop ("Bad certificate chain") "\0"
+  gettext_noop ("Missing certificate") "\0"
+  gettext_noop ("No data") "\0"
+  gettext_noop ("Bug") "\0"
+  gettext_noop ("Not supported") "\0"
+  gettext_noop ("Invalid operation code") "\0"
+  gettext_noop ("Timeout") "\0"
+  gettext_noop ("Internal error") "\0"
+  gettext_noop ("EOF (gcrypt)") "\0"
+  gettext_noop ("Invalid object") "\0"
+  gettext_noop ("Provided object is too short") "\0"
+  gettext_noop ("Provided object is too large") "\0"
+  gettext_noop ("Missing item in object") "\0"
+  gettext_noop ("Not implemented") "\0"
+  gettext_noop ("Conflicting use") "\0"
+  gettext_noop ("Invalid cipher mode") "\0"
+  gettext_noop ("Invalid flag") "\0"
+  gettext_noop ("Invalid handle") "\0"
+  gettext_noop ("Result truncated") "\0"
+  gettext_noop ("Incomplete line") "\0"
+  gettext_noop ("Invalid response") "\0"
+  gettext_noop ("No agent running") "\0"
+  gettext_noop ("Agent error") "\0"
+  gettext_noop ("Invalid data") "\0"
+  gettext_noop ("Unspecific Assuan server fault") "\0"
+  gettext_noop ("General Assuan error") "\0"
+  gettext_noop ("Invalid session key") "\0"
+  gettext_noop ("Invalid S-expression") "\0"
+  gettext_noop ("Unsupported algorithm") "\0"
+  gettext_noop ("No pinentry") "\0"
+  gettext_noop ("pinentry error") "\0"
+  gettext_noop ("Bad PIN") "\0"
+  gettext_noop ("Invalid name") "\0"
+  gettext_noop ("Bad data") "\0"
+  gettext_noop ("Invalid parameter") "\0"
+  gettext_noop ("Wrong card") "\0"
+  gettext_noop ("No dirmngr") "\0"
+  gettext_noop ("dirmngr error") "\0"
+  gettext_noop ("Certificate revoked") "\0"
+  gettext_noop ("No CRL known") "\0"
+  gettext_noop ("CRL too old") "\0"
+  gettext_noop ("Line too long") "\0"
+  gettext_noop ("Not trusted") "\0"
+  gettext_noop ("Operation cancelled") "\0"
+  gettext_noop ("Bad CA certificate") "\0"
+  gettext_noop ("Certificate expired") "\0"
+  gettext_noop ("Certificate too young") "\0"
+  gettext_noop ("Unsupported certificate") "\0"
+  gettext_noop ("Unknown S-expression") "\0"
+  gettext_noop ("Unsupported protection") "\0"
+  gettext_noop ("Corrupted protection") "\0"
+  gettext_noop ("Ambiguous name") "\0"
+  gettext_noop ("Card error") "\0"
+  gettext_noop ("Card reset required") "\0"
+  gettext_noop ("Card removed") "\0"
+  gettext_noop ("Invalid card") "\0"
+  gettext_noop ("Card not present") "\0"
+  gettext_noop ("No PKCS15 application") "\0"
+  gettext_noop ("Not confirmed") "\0"
+  gettext_noop ("Configuration error") "\0"
+  gettext_noop ("No policy match") "\0"
+  gettext_noop ("Invalid index") "\0"
+  gettext_noop ("Invalid ID") "\0"
+  gettext_noop ("No SmartCard daemon") "\0"
+  gettext_noop ("SmartCard daemon error") "\0"
+  gettext_noop ("Unsupported protocol") "\0"
+  gettext_noop ("Bad PIN method") "\0"
+  gettext_noop ("Card not initialized") "\0"
+  gettext_noop ("Unsupported operation") "\0"
+  gettext_noop ("Wrong key usage") "\0"
+  gettext_noop ("Nothing found") "\0"
+  gettext_noop ("Wrong blob type") "\0"
+  gettext_noop ("Missing value") "\0"
+  gettext_noop ("Hardware problem") "\0"
+  gettext_noop ("PIN blocked") "\0"
+  gettext_noop ("Conditions of use not satisfied") "\0"
+  gettext_noop ("PINs are not synced") "\0"
+  gettext_noop ("Invalid CRL") "\0"
+  gettext_noop ("BER error") "\0"
+  gettext_noop ("Invalid BER") "\0"
+  gettext_noop ("Element not found") "\0"
+  gettext_noop ("Identifier not found") "\0"
+  gettext_noop ("Invalid tag") "\0"
+  gettext_noop ("Invalid length") "\0"
+  gettext_noop ("Invalid key info") "\0"
+  gettext_noop ("Unexpected tag") "\0"
+  gettext_noop ("Not DER encoded") "\0"
+  gettext_noop ("No CMS object") "\0"
+  gettext_noop ("Invalid CMS object") "\0"
+  gettext_noop ("Unknown CMS object") "\0"
+  gettext_noop ("Unsupported CMS object") "\0"
+  gettext_noop ("Unsupported encoding") "\0"
+  gettext_noop ("Unsupported CMS version") "\0"
+  gettext_noop ("Unknown algorithm") "\0"
+  gettext_noop ("Invalid crypto engine") "\0"
+  gettext_noop ("Public key not trusted") "\0"
+  gettext_noop ("Decryption failed") "\0"
+  gettext_noop ("Key expired") "\0"
+  gettext_noop ("Signature expired") "\0"
+  gettext_noop ("Encoding problem") "\0"
+  gettext_noop ("Invalid state") "\0"
+  gettext_noop ("Duplicated value") "\0"
+  gettext_noop ("Missing action") "\0"
+  gettext_noop ("ASN.1 module not found") "\0"
+  gettext_noop ("Invalid OID string") "\0"
+  gettext_noop ("Invalid time") "\0"
+  gettext_noop ("Invalid CRL object") "\0"
+  gettext_noop ("Unsupported CRL version") "\0"
+  gettext_noop ("Invalid certificate object") "\0"
+  gettext_noop ("Unknown name") "\0"
+  gettext_noop ("A locale function failed") "\0"
+  gettext_noop ("Not locked") "\0"
+  gettext_noop ("Protocol violation") "\0"
+  gettext_noop ("Invalid MAC") "\0"
+  gettext_noop ("Invalid request") "\0"
+  gettext_noop ("Unknown extension") "\0"
+  gettext_noop ("Unknown critical extension") "\0"
+  gettext_noop ("Locked") "\0"
+  gettext_noop ("Unknown option") "\0"
+  gettext_noop ("Unknown command") "\0"
+  gettext_noop ("Not operational") "\0"
+  gettext_noop ("No passphrase given") "\0"
+  gettext_noop ("No PIN given") "\0"
+  gettext_noop ("Not enabled") "\0"
+  gettext_noop ("No crypto engine") "\0"
+  gettext_noop ("Missing key") "\0"
+  gettext_noop ("Too many objects") "\0"
+  gettext_noop ("Limit reached") "\0"
+  gettext_noop ("Not initialized") "\0"
+  gettext_noop ("Missing issuer certificate") "\0"
+  gettext_noop ("No keyserver available") "\0"
+  gettext_noop ("Invalid elliptic curve") "\0"
+  gettext_noop ("Unknown elliptic curve") "\0"
+  gettext_noop ("Duplicated key") "\0"
+  gettext_noop ("Ambiguous result") "\0"
+  gettext_noop ("No crypto context") "\0"
+  gettext_noop ("Wrong crypto context") "\0"
+  gettext_noop ("Bad crypto context") "\0"
+  gettext_noop ("Conflict in the crypto context") "\0"
+  gettext_noop ("Broken public key") "\0"
+  gettext_noop ("Broken secret key") "\0"
+  gettext_noop ("Invalid MAC algorithm") "\0"
+  gettext_noop ("Operation fully cancelled") "\0"
+  gettext_noop ("Operation not yet finished") "\0"
+  gettext_noop ("Buffer too short") "\0"
+  gettext_noop ("Invalid length specifier in S-expression") "\0"
+  gettext_noop ("String too long in S-expression") "\0"
+  gettext_noop ("Unmatched parentheses in S-expression") "\0"
+  gettext_noop ("S-expression not canonical") "\0"
+  gettext_noop ("Bad character in S-expression") "\0"
+  gettext_noop ("Bad quotation in S-expression") "\0"
+  gettext_noop ("Zero prefix in S-expression") "\0"
+  gettext_noop ("Nested display hints in S-expression") "\0"
+  gettext_noop ("Unmatched display hints") "\0"
+  gettext_noop ("Unexpected reserved punctuation in S-expression") "\0"
+  gettext_noop ("Bad hexadecimal character in S-expression") "\0"
+  gettext_noop ("Odd hexadecimal numbers in S-expression") "\0"
+  gettext_noop ("Bad octal character in S-expression") "\0"
+  gettext_noop ("All subkeys are expired or revoked") "\0"
+  gettext_noop ("Database is corrupted") "\0"
+  gettext_noop ("Server indicated a failure") "\0"
+  gettext_noop ("No name") "\0"
+  gettext_noop ("No key") "\0"
+  gettext_noop ("Legacy key") "\0"
+  gettext_noop ("Request too short") "\0"
+  gettext_noop ("Request too long") "\0"
+  gettext_noop ("Object is in termination state") "\0"
+  gettext_noop ("No certificate chain") "\0"
+  gettext_noop ("Certificate is too large") "\0"
+  gettext_noop ("Invalid record") "\0"
+  gettext_noop ("The MAC does not verify") "\0"
+  gettext_noop ("Unexpected message") "\0"
+  gettext_noop ("Compression or decompression failed") "\0"
+  gettext_noop ("A counter would wrap") "\0"
+  gettext_noop ("Fatal alert message received") "\0"
+  gettext_noop ("No cipher algorithm") "\0"
+  gettext_noop ("Missing client certificate") "\0"
+  gettext_noop ("Close notification received") "\0"
+  gettext_noop ("Ticket expired") "\0"
+  gettext_noop ("Bad ticket") "\0"
+  gettext_noop ("Unknown identity") "\0"
+  gettext_noop ("Bad certificate message in handshake") "\0"
+  gettext_noop ("Bad certificate request message in handshake") "\0"
+  gettext_noop ("Bad certificate verify message in handshake") "\0"
+  gettext_noop ("Bad change cipher message in handshake") "\0"
+  gettext_noop ("Bad client hello message in handshake") "\0"
+  gettext_noop ("Bad server hello message in handshake") "\0"
+  gettext_noop ("Bad server hello done message in handshake") "\0"
+  gettext_noop ("Bad finished message in handshake") "\0"
+  gettext_noop ("Bad server key exchange message in handshake") "\0"
+  gettext_noop ("Bad client key exchange message in handshake") "\0"
+  gettext_noop ("Bogus string") "\0"
+  gettext_noop ("Forbidden") "\0"
+  gettext_noop ("Key disabled") "\0"
+  gettext_noop ("Not possible with a card based key") "\0"
+  gettext_noop ("Invalid lock object") "\0"
+  gettext_noop ("True") "\0"
+  gettext_noop ("False") "\0"
+  gettext_noop ("General IPC error") "\0"
+  gettext_noop ("IPC accept call failed") "\0"
+  gettext_noop ("IPC connect call failed") "\0"
+  gettext_noop ("Invalid IPC response") "\0"
+  gettext_noop ("Invalid value passed to IPC") "\0"
+  gettext_noop ("Incomplete line passed to IPC") "\0"
+  gettext_noop ("Line passed to IPC too long") "\0"
+  gettext_noop ("Nested IPC commands") "\0"
+  gettext_noop ("No data callback in IPC") "\0"
+  gettext_noop ("No inquire callback in IPC") "\0"
+  gettext_noop ("Not an IPC server") "\0"
+  gettext_noop ("Not an IPC client") "\0"
+  gettext_noop ("Problem starting IPC server") "\0"
+  gettext_noop ("IPC read error") "\0"
+  gettext_noop ("IPC write error") "\0"
+  gettext_noop ("Too much data for IPC layer") "\0"
+  gettext_noop ("Unexpected IPC command") "\0"
+  gettext_noop ("Unknown IPC command") "\0"
+  gettext_noop ("IPC syntax error") "\0"
+  gettext_noop ("IPC call has been cancelled") "\0"
+  gettext_noop ("No input source for IPC") "\0"
+  gettext_noop ("No output source for IPC") "\0"
+  gettext_noop ("IPC parameter error") "\0"
+  gettext_noop ("Unknown IPC inquire") "\0"
+  gettext_noop ("Crypto engine too old") "\0"
+  gettext_noop ("Screen or window too small") "\0"
+  gettext_noop ("Screen or window too large") "\0"
+  gettext_noop ("Required environment variable not set") "\0"
+  gettext_noop ("User ID already exists") "\0"
+  gettext_noop ("Name already exists") "\0"
+  gettext_noop ("Duplicated name") "\0"
+  gettext_noop ("Object is too young") "\0"
+  gettext_noop ("Object is too old") "\0"
+  gettext_noop ("Unknown flag") "\0"
+  gettext_noop ("Invalid execution order") "\0"
+  gettext_noop ("Already fetched") "\0"
+  gettext_noop ("Try again later") "\0"
+  gettext_noop ("Wrong name") "\0"
+  gettext_noop ("System bug detected") "\0"
+  gettext_noop ("Unknown DNS error") "\0"
+  gettext_noop ("Invalid DNS section") "\0"
+  gettext_noop ("Invalid textual address form") "\0"
+  gettext_noop ("Missing DNS query packet") "\0"
+  gettext_noop ("Missing DNS answer packet") "\0"
+  gettext_noop ("Connection closed in DNS") "\0"
+  gettext_noop ("Verification failed in DNS") "\0"
+  gettext_noop ("DNS Timeout") "\0"
+  gettext_noop ("General LDAP error") "\0"
+  gettext_noop ("General LDAP attribute error") "\0"
+  gettext_noop ("General LDAP name error") "\0"
+  gettext_noop ("General LDAP security error") "\0"
+  gettext_noop ("General LDAP service error") "\0"
+  gettext_noop ("General LDAP update error") "\0"
+  gettext_noop ("Experimental LDAP error code") "\0"
+  gettext_noop ("Private LDAP error code") "\0"
+  gettext_noop ("Other general LDAP error") "\0"
+  gettext_noop ("LDAP connecting failed (X)") "\0"
+  gettext_noop ("LDAP referral limit exceeded") "\0"
+  gettext_noop ("LDAP client loop") "\0"
+  gettext_noop ("No LDAP results returned") "\0"
+  gettext_noop ("LDAP control not found") "\0"
+  gettext_noop ("Not supported by LDAP") "\0"
+  gettext_noop ("LDAP connect error") "\0"
+  gettext_noop ("Out of memory in LDAP") "\0"
+  gettext_noop ("Bad parameter to an LDAP routine") "\0"
+  gettext_noop ("User cancelled LDAP operation") "\0"
+  gettext_noop ("Bad LDAP search filter") "\0"
+  gettext_noop ("Unknown LDAP authentication method") "\0"
+  gettext_noop ("Timeout in LDAP") "\0"
+  gettext_noop ("LDAP decoding error") "\0"
+  gettext_noop ("LDAP encoding error") "\0"
+  gettext_noop ("LDAP local error") "\0"
+  gettext_noop ("Cannot contact LDAP server") "\0"
+  gettext_noop ("LDAP success") "\0"
+  gettext_noop ("LDAP operations error") "\0"
+  gettext_noop ("LDAP protocol error") "\0"
+  gettext_noop ("Time limit exceeded in LDAP") "\0"
+  gettext_noop ("Size limit exceeded in LDAP") "\0"
+  gettext_noop ("LDAP compare false") "\0"
+  gettext_noop ("LDAP compare true") "\0"
+  gettext_noop ("LDAP authentication method not supported") "\0"
+  gettext_noop ("Strong(er) LDAP authentication required") "\0"
+  gettext_noop ("Partial LDAP results+referral received") "\0"
+  gettext_noop ("LDAP referral") "\0"
+  gettext_noop ("Administrative LDAP limit exceeded") "\0"
+  gettext_noop ("Critical LDAP extension is unavailable") "\0"
+  gettext_noop ("Confidentiality required by LDAP") "\0"
+  gettext_noop ("LDAP SASL bind in progress") "\0"
+  gettext_noop ("No such LDAP attribute") "\0"
+  gettext_noop ("Undefined LDAP attribute type") "\0"
+  gettext_noop ("Inappropriate matching in LDAP") "\0"
+  gettext_noop ("Constraint violation in LDAP") "\0"
+  gettext_noop ("LDAP type or value exists") "\0"
+  gettext_noop ("Invalid syntax in LDAP") "\0"
+  gettext_noop ("No such LDAP object") "\0"
+  gettext_noop ("LDAP alias problem") "\0"
+  gettext_noop ("Invalid DN syntax in LDAP") "\0"
+  gettext_noop ("LDAP entry is a leaf") "\0"
+  gettext_noop ("LDAP alias dereferencing problem") "\0"
+  gettext_noop ("LDAP proxy authorization failure (X)") "\0"
+  gettext_noop ("Inappropriate LDAP authentication") "\0"
+  gettext_noop ("Invalid LDAP credentials") "\0"
+  gettext_noop ("Insufficient access for LDAP") "\0"
+  gettext_noop ("LDAP server is busy") "\0"
+  gettext_noop ("LDAP server is unavailable") "\0"
+  gettext_noop ("LDAP server is unwilling to perform") "\0"
+  gettext_noop ("Loop detected by LDAP") "\0"
+  gettext_noop ("LDAP naming violation") "\0"
+  gettext_noop ("LDAP object class violation") "\0"
+  gettext_noop ("LDAP operation not allowed on non-leaf") "\0"
+  gettext_noop ("LDAP operation not allowed on RDN") "\0"
+  gettext_noop ("Already exists (LDAP)") "\0"
+  gettext_noop ("Cannot modify LDAP object class") "\0"
+  gettext_noop ("LDAP results too large") "\0"
+  gettext_noop ("LDAP operation affects multiple DSAs") "\0"
+  gettext_noop ("Virtual LDAP list view error") "\0"
+  gettext_noop ("Other LDAP error") "\0"
+  gettext_noop ("Resources exhausted in LCUP") "\0"
+  gettext_noop ("Security violation in LCUP") "\0"
+  gettext_noop ("Invalid data in LCUP") "\0"
+  gettext_noop ("Unsupported scheme in LCUP") "\0"
+  gettext_noop ("Reload required in LCUP") "\0"
+  gettext_noop ("LDAP cancelled") "\0"
+  gettext_noop ("No LDAP operation to cancel") "\0"
+  gettext_noop ("Too late to cancel LDAP") "\0"
+  gettext_noop ("Cannot cancel LDAP") "\0"
+  gettext_noop ("LDAP assertion failed") "\0"
+  gettext_noop ("Proxied authorization denied by LDAP") "\0"
+  gettext_noop ("User defined error code 1") "\0"
+  gettext_noop ("User defined error code 2") "\0"
+  gettext_noop ("User defined error code 3") "\0"
+  gettext_noop ("User defined error code 4") "\0"
+  gettext_noop ("User defined error code 5") "\0"
+  gettext_noop ("User defined error code 6") "\0"
+  gettext_noop ("User defined error code 7") "\0"
+  gettext_noop ("User defined error code 8") "\0"
+  gettext_noop ("User defined error code 9") "\0"
+  gettext_noop ("User defined error code 10") "\0"
+  gettext_noop ("User defined error code 11") "\0"
+  gettext_noop ("User defined error code 12") "\0"
+  gettext_noop ("User defined error code 13") "\0"
+  gettext_noop ("User defined error code 14") "\0"
+  gettext_noop ("User defined error code 15") "\0"
+  gettext_noop ("User defined error code 16") "\0"
+  gettext_noop ("System error w/o errno") "\0"
+  gettext_noop ("Unknown system error") "\0"
+  gettext_noop ("End of file") "\0"
+  gettext_noop ("Unknown error code");
+
+static const int msgidx[] =
+  {
+    0,
+    8,
+    22,
+    37,
+    63,
+    92,
+    117,
+    132,
+    147,
+    161,
+    175,
+    190,
+    205,
+    230,
+    250,
+    265,
+    279,
+    290,
+    304,
+    326,
+    342,
+    372,
+    392,
+    416,
+    442,
+    467,
+    485,
+    494,
+    504,
+    520,
+    533,
+    547,
+    566,
+    590,
+    610,
+    626,
+    641,
+    657,
+    673,
+    690,
+    704,
+    720,
+    747,
+    764,
+    784,
+    803,
+    820,
+    840,
+    852,
+    866,
+    879,
+    895,
+    914,
+    933,
+    953,
+    973,
+    987,
+    1009,
+    1029,
+    1037,
+    1041,
+    1055,
+    1078,
+    1086,
+    1101,
+    1114,
+    1129,
+    1158,
+    1187,
+    1210,
+    1226,
+    1242,
+    1262,
+    1275,
+    1290,
+    1307,
+    1323,
+    1340,
+    1357,
+    1369,
+    1382,
+    1413,
+    1434,
+    1454,
+    1475,
+    1497,
+    1509,
+    1524,
+    1532,
+    1545,
+    1554,
+    1572,
+    1583,
+    1594,
+    1608,
+    1628,
+    1641,
+    1653,
+    1667,
+    1679,
+    1699,
+    1718,
+    1738,
+    1760,
+    1784,
+    1805,
+    1828,
+    1849,
+    1864,
+    1875,
+    1895,
+    1908,
+    1921,
+    1938,
+    1960,
+    1974,
+    1994,
+    2010,
+    2024,
+    2035,
+    2055,
+    2078,
+    2099,
+    2114,
+    2135,
+    2157,
+    2173,
+    2187,
+    2203,
+    2217,
+    2234,
+    2246,
+    2278,
+    2298,
+    2310,
+    2320,
+    2332,
+    2350,
+    2371,
+    2383,
+    2398,
+    2415,
+    2430,
+    2446,
+    2460,
+    2479,
+    2498,
+    2521,
+    2542,
+    2566,
+    2584,
+    2606,
+    2629,
+    2647,
+    2659,
+    2677,
+    2694,
+    2708,
+    2725,
+    2740,
+    2763,
+    2782,
+    2795,
+    2814,
+    2838,
+    2865,
+    2878,
+    2903,
+    2914,
+    2933,
+    2945,
+    2961,
+    2979,
+    3006,
+    3013,
+    3028,
+    3044,
+    3060,
+    3080,
+    3093,
+    3105,
+    3122,
+    3134,
+    3151,
+    3165,
+    3181,
+    3208,
+    3231,
+    3254,
+    3277,
+    3292,
+    3309,
+    3327,
+    3348,
+    3367,
+    3398,
+    3416,
+    3434,
+    3456,
+    3482,
+    3509,
+    3526,
+    3567,
+    3599,
+    3637,
+    3664,
+    3694,
+    3724,
+    3752,
+    3789,
+    3813,
+    3861,
+    3903,
+    3943,
+    3979,
+    4014,
+    4036,
+    4063,
+    4071,
+    4078,
+    4089,
+    4107,
+    4124,
+    4155,
+    4176,
+    4201,
+    4216,
+    4240,
+    4259,
+    4295,
+    4316,
+    4345,
+    4365,
+    4392,
+    4420,
+    4435,
+    4446,
+    4463,
+    4500,
+    4545,
+    4589,
+    4628,
+    4666,
+    4704,
+    4747,
+    4781,
+    4826,
+    4871,
+    4884,
+    4894,
+    4907,
+    4942,
+    4962,
+    4967,
+    4973,
+    4991,
+    5014,
+    5038,
+    5059,
+    5087,
+    5117,
+    5145,
+    5165,
+    5189,
+    5216,
+    5234,
+    5252,
+    5280,
+    5295,
+    5311,
+    5339,
+    5362,
+    5382,
+    5399,
+    5427,
+    5451,
+    5476,
+    5496,
+    5516,
+    5538,
+    5565,
+    5592,
+    5630,
+    5653,
+    5673,
+    5689,
+    5709,
+    5727,
+    5740,
+    5764,
+    5780,
+    5796,
+    5807,
+    5827,
+    5845,
+    5865,
+    5894,
+    5919,
+    5945,
+    5970,
+    5997,
+    6009,
+    6028,
+    6057,
+    6081,
+    6109,
+    6136,
+    6162,
+    6191,
+    6215,
+    6240,
+    6267,
+    6296,
+    6313,
+    6338,
+    6361,
+    6383,
+    6402,
+    6424,
+    6457,
+    6487,
+    6510,
+    6545,
+    6561,
+    6581,
+    6601,
+    6618,
+    6645,
+    6658,
+    6680,
+    6700,
+    6728,
+    6756,
+    6775,
+    6793,
+    6834,
+    6874,
+    6913,
+    6927,
+    6962,
+    7001,
+    7034,
+    7061,
+    7084,
+    7114,
+    7145,
+    7174,
+    7200,
+    7223,
+    7243,
+    7262,
+    7288,
+    7309,
+    7342,
+    7379,
+    7413,
+    7438,
+    7467,
+    7487,
+    7514,
+    7550,
+    7572,
+    7594,
+    7622,
+    7661,
+    7695,
+    7717,
+    7749,
+    7772,
+    7809,
+    7838,
+    7855,
+    7883,
+    7910,
+    7931,
+    7958,
+    7982,
+    7997,
+    8025,
+    8049,
+    8068,
+    8090,
+    8127,
+    8153,
+    8179,
+    8205,
+    8231,
+    8257,
+    8283,
+    8309,
+    8335,
+    8361,
+    8388,
+    8415,
+    8442,
+    8469,
+    8496,
+    8523,
+    8550,
+    8573,
+    8594,
+    8606
+  };
+
+static GPG_ERR_INLINE int
+msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 213)) ? (code - 0)
+  : ((code >= 217) && (code <= 271)) ? (code - 3)
+  : ((code >= 273) && (code <= 281)) ? (code - 4)
+  : ((code >= 300) && (code <= 313)) ? (code - 22)
+  : ((code >= 666) && (code <= 666)) ? (code - 374)
+  : ((code >= 711) && (code <= 718)) ? (code - 418)
+  : ((code >= 721) && (code <= 729)) ? (code - 420)
+  : ((code >= 750) && (code <= 752)) ? (code - 440)
+  : ((code >= 754) && (code <= 782)) ? (code - 441)
+  : ((code >= 784) && (code <= 789)) ? (code - 442)
+  : ((code >= 800) && (code <= 804)) ? (code - 452)
+  : ((code >= 815) && (code <= 822)) ? (code - 462)
+  : ((code >= 832) && (code <= 839)) ? (code - 471)
+  : ((code >= 844) && (code <= 844)) ? (code - 475)
+  : ((code >= 848) && (code <= 848)) ? (code - 478)
+  : ((code >= 881) && (code <= 891)) ? (code - 510)
+  : ((code >= 1024) && (code <= 1039)) ? (code - 642)
+  : ((code >= 16381) && (code <= 16383)) ? (code - 15983)
+  : 16384 - 15983);
+}
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/err-sources-sym.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-sources-sym.h
new file mode 100644
index 000000000..98388e9da
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-sources-sym.h
@@ -0,0 +1,87 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* err-sources.h - List of error sources and their description.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char msgstr[] = 
+  "GPG_ERR_SOURCE_UNKNOWN" "\0"
+  "GPG_ERR_SOURCE_GCRYPT" "\0"
+  "GPG_ERR_SOURCE_GPG" "\0"
+  "GPG_ERR_SOURCE_GPGSM" "\0"
+  "GPG_ERR_SOURCE_GPGAGENT" "\0"
+  "GPG_ERR_SOURCE_PINENTRY" "\0"
+  "GPG_ERR_SOURCE_SCD" "\0"
+  "GPG_ERR_SOURCE_GPGME" "\0"
+  "GPG_ERR_SOURCE_KEYBOX" "\0"
+  "GPG_ERR_SOURCE_KSBA" "\0"
+  "GPG_ERR_SOURCE_DIRMNGR" "\0"
+  "GPG_ERR_SOURCE_GSTI" "\0"
+  "GPG_ERR_SOURCE_GPA" "\0"
+  "GPG_ERR_SOURCE_KLEO" "\0"
+  "GPG_ERR_SOURCE_G13" "\0"
+  "GPG_ERR_SOURCE_ASSUAN" "\0"
+  "GPG_ERR_SOURCE_TLS" "\0"
+  "GPG_ERR_SOURCE_ANY" "\0"
+  "GPG_ERR_SOURCE_USER_1" "\0"
+  "GPG_ERR_SOURCE_USER_2" "\0"
+  "GPG_ERR_SOURCE_USER_3" "\0"
+  "GPG_ERR_SOURCE_USER_4" "\0"
+  "GPG_ERR_SOURCE_DIM";
+
+static const int msgidx[] =
+  {
+    0,
+    23,
+    45,
+    64,
+    85,
+    109,
+    133,
+    152,
+    173,
+    195,
+    215,
+    238,
+    258,
+    277,
+    297,
+    316,
+    338,
+    357,
+    376,
+    398,
+    420,
+    442,
+    464
+  };
+
+static GPG_ERR_INLINE int
+msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 15)) ? (code - 0)
+  : ((code >= 17) && (code <= 17)) ? (code - 1)
+  : ((code >= 31) && (code <= 35)) ? (code - 14)
+  : 36 - 14);
+}
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/err-sources.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-sources.h
new file mode 100644
index 000000000..5160fd791
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/err-sources.h
@@ -0,0 +1,87 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* err-sources.h - List of error sources and their description.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char msgstr[] = 
+  gettext_noop ("Unspecified source") "\0"
+  gettext_noop ("gcrypt") "\0"
+  gettext_noop ("GnuPG") "\0"
+  gettext_noop ("GpgSM") "\0"
+  gettext_noop ("GPG Agent") "\0"
+  gettext_noop ("Pinentry") "\0"
+  gettext_noop ("SCD") "\0"
+  gettext_noop ("GPGME") "\0"
+  gettext_noop ("Keybox") "\0"
+  gettext_noop ("KSBA") "\0"
+  gettext_noop ("Dirmngr") "\0"
+  gettext_noop ("GSTI") "\0"
+  gettext_noop ("GPA") "\0"
+  gettext_noop ("Kleopatra") "\0"
+  gettext_noop ("G13") "\0"
+  gettext_noop ("Assuan") "\0"
+  gettext_noop ("TLS") "\0"
+  gettext_noop ("Any source") "\0"
+  gettext_noop ("User defined source 1") "\0"
+  gettext_noop ("User defined source 2") "\0"
+  gettext_noop ("User defined source 3") "\0"
+  gettext_noop ("User defined source 4") "\0"
+  gettext_noop ("Unknown source");
+
+static const int msgidx[] =
+  {
+    0,
+    19,
+    26,
+    32,
+    38,
+    48,
+    57,
+    61,
+    67,
+    74,
+    79,
+    87,
+    92,
+    96,
+    106,
+    110,
+    117,
+    121,
+    132,
+    154,
+    176,
+    198,
+    220
+  };
+
+static GPG_ERR_INLINE int
+msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 15)) ? (code - 0)
+  : ((code >= 17) && (code <= 17)) ? (code - 1)
+  : ((code >= 31) && (code <= 35)) ? (code - 14)
+  : 36 - 14);
+}
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/errnos-sym.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/errnos-sym.h
new file mode 100644
index 000000000..42804ae21
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/errnos-sym.h
@@ -0,0 +1,323 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* errnos.in - List of system error values.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char errnos_msgstr[] = 
+  "GPG_ERR_E2BIG" "\0"
+  "GPG_ERR_EACCES" "\0"
+  "GPG_ERR_EADDRINUSE" "\0"
+  "GPG_ERR_EADDRNOTAVAIL" "\0"
+  "GPG_ERR_EADV" "\0"
+  "GPG_ERR_EAFNOSUPPORT" "\0"
+  "GPG_ERR_EAGAIN" "\0"
+  "GPG_ERR_EALREADY" "\0"
+  "GPG_ERR_EAUTH" "\0"
+  "GPG_ERR_EBACKGROUND" "\0"
+  "GPG_ERR_EBADE" "\0"
+  "GPG_ERR_EBADF" "\0"
+  "GPG_ERR_EBADFD" "\0"
+  "GPG_ERR_EBADMSG" "\0"
+  "GPG_ERR_EBADR" "\0"
+  "GPG_ERR_EBADRPC" "\0"
+  "GPG_ERR_EBADRQC" "\0"
+  "GPG_ERR_EBADSLT" "\0"
+  "GPG_ERR_EBFONT" "\0"
+  "GPG_ERR_EBUSY" "\0"
+  "GPG_ERR_ECANCELED" "\0"
+  "GPG_ERR_ECHILD" "\0"
+  "GPG_ERR_ECHRNG" "\0"
+  "GPG_ERR_ECOMM" "\0"
+  "GPG_ERR_ECONNABORTED" "\0"
+  "GPG_ERR_ECONNREFUSED" "\0"
+  "GPG_ERR_ECONNRESET" "\0"
+  "GPG_ERR_ED" "\0"
+  "GPG_ERR_EDEADLK" "\0"
+  "GPG_ERR_EDEADLOCK" "\0"
+  "GPG_ERR_EDESTADDRREQ" "\0"
+  "GPG_ERR_EDIED" "\0"
+  "GPG_ERR_EDOM" "\0"
+  "GPG_ERR_EDOTDOT" "\0"
+  "GPG_ERR_EDQUOT" "\0"
+  "GPG_ERR_EEXIST" "\0"
+  "GPG_ERR_EFAULT" "\0"
+  "GPG_ERR_EFBIG" "\0"
+  "GPG_ERR_EFTYPE" "\0"
+  "GPG_ERR_EGRATUITOUS" "\0"
+  "GPG_ERR_EGREGIOUS" "\0"
+  "GPG_ERR_EHOSTDOWN" "\0"
+  "GPG_ERR_EHOSTUNREACH" "\0"
+  "GPG_ERR_EIDRM" "\0"
+  "GPG_ERR_EIEIO" "\0"
+  "GPG_ERR_EILSEQ" "\0"
+  "GPG_ERR_EINPROGRESS" "\0"
+  "GPG_ERR_EINTR" "\0"
+  "GPG_ERR_EINVAL" "\0"
+  "GPG_ERR_EIO" "\0"
+  "GPG_ERR_EISCONN" "\0"
+  "GPG_ERR_EISDIR" "\0"
+  "GPG_ERR_EISNAM" "\0"
+  "GPG_ERR_EL2HLT" "\0"
+  "GPG_ERR_EL2NSYNC" "\0"
+  "GPG_ERR_EL3HLT" "\0"
+  "GPG_ERR_EL3RST" "\0"
+  "GPG_ERR_ELIBACC" "\0"
+  "GPG_ERR_ELIBBAD" "\0"
+  "GPG_ERR_ELIBEXEC" "\0"
+  "GPG_ERR_ELIBMAX" "\0"
+  "GPG_ERR_ELIBSCN" "\0"
+  "GPG_ERR_ELNRNG" "\0"
+  "GPG_ERR_ELOOP" "\0"
+  "GPG_ERR_EMEDIUMTYPE" "\0"
+  "GPG_ERR_EMFILE" "\0"
+  "GPG_ERR_EMLINK" "\0"
+  "GPG_ERR_EMSGSIZE" "\0"
+  "GPG_ERR_EMULTIHOP" "\0"
+  "GPG_ERR_ENAMETOOLONG" "\0"
+  "GPG_ERR_ENAVAIL" "\0"
+  "GPG_ERR_ENEEDAUTH" "\0"
+  "GPG_ERR_ENETDOWN" "\0"
+  "GPG_ERR_ENETRESET" "\0"
+  "GPG_ERR_ENETUNREACH" "\0"
+  "GPG_ERR_ENFILE" "\0"
+  "GPG_ERR_ENOANO" "\0"
+  "GPG_ERR_ENOBUFS" "\0"
+  "GPG_ERR_ENOCSI" "\0"
+  "GPG_ERR_ENODATA" "\0"
+  "GPG_ERR_ENODEV" "\0"
+  "GPG_ERR_ENOENT" "\0"
+  "GPG_ERR_ENOEXEC" "\0"
+  "GPG_ERR_ENOLCK" "\0"
+  "GPG_ERR_ENOLINK" "\0"
+  "GPG_ERR_ENOMEDIUM" "\0"
+  "GPG_ERR_ENOMEM" "\0"
+  "GPG_ERR_ENOMSG" "\0"
+  "GPG_ERR_ENONET" "\0"
+  "GPG_ERR_ENOPKG" "\0"
+  "GPG_ERR_ENOPROTOOPT" "\0"
+  "GPG_ERR_ENOSPC" "\0"
+  "GPG_ERR_ENOSR" "\0"
+  "GPG_ERR_ENOSTR" "\0"
+  "GPG_ERR_ENOSYS" "\0"
+  "GPG_ERR_ENOTBLK" "\0"
+  "GPG_ERR_ENOTCONN" "\0"
+  "GPG_ERR_ENOTDIR" "\0"
+  "GPG_ERR_ENOTEMPTY" "\0"
+  "GPG_ERR_ENOTNAM" "\0"
+  "GPG_ERR_ENOTSOCK" "\0"
+  "GPG_ERR_ENOTSUP" "\0"
+  "GPG_ERR_ENOTTY" "\0"
+  "GPG_ERR_ENOTUNIQ" "\0"
+  "GPG_ERR_ENXIO" "\0"
+  "GPG_ERR_EOPNOTSUPP" "\0"
+  "GPG_ERR_EOVERFLOW" "\0"
+  "GPG_ERR_EPERM" "\0"
+  "GPG_ERR_EPFNOSUPPORT" "\0"
+  "GPG_ERR_EPIPE" "\0"
+  "GPG_ERR_EPROCLIM" "\0"
+  "GPG_ERR_EPROCUNAVAIL" "\0"
+  "GPG_ERR_EPROGMISMATCH" "\0"
+  "GPG_ERR_EPROGUNAVAIL" "\0"
+  "GPG_ERR_EPROTO" "\0"
+  "GPG_ERR_EPROTONOSUPPORT" "\0"
+  "GPG_ERR_EPROTOTYPE" "\0"
+  "GPG_ERR_ERANGE" "\0"
+  "GPG_ERR_EREMCHG" "\0"
+  "GPG_ERR_EREMOTE" "\0"
+  "GPG_ERR_EREMOTEIO" "\0"
+  "GPG_ERR_ERESTART" "\0"
+  "GPG_ERR_EROFS" "\0"
+  "GPG_ERR_ERPCMISMATCH" "\0"
+  "GPG_ERR_ESHUTDOWN" "\0"
+  "GPG_ERR_ESOCKTNOSUPPORT" "\0"
+  "GPG_ERR_ESPIPE" "\0"
+  "GPG_ERR_ESRCH" "\0"
+  "GPG_ERR_ESRMNT" "\0"
+  "GPG_ERR_ESTALE" "\0"
+  "GPG_ERR_ESTRPIPE" "\0"
+  "GPG_ERR_ETIME" "\0"
+  "GPG_ERR_ETIMEDOUT" "\0"
+  "GPG_ERR_ETOOMANYREFS" "\0"
+  "GPG_ERR_ETXTBSY" "\0"
+  "GPG_ERR_EUCLEAN" "\0"
+  "GPG_ERR_EUNATCH" "\0"
+  "GPG_ERR_EUSERS" "\0"
+  "GPG_ERR_EWOULDBLOCK" "\0"
+  "GPG_ERR_EXDEV" "\0"
+  "GPG_ERR_EXFULL";
+
+static const int errnos_msgidx[] =
+  {
+    0,
+    14,
+    29,
+    48,
+    70,
+    83,
+    104,
+    119,
+    136,
+    150,
+    170,
+    184,
+    198,
+    213,
+    229,
+    243,
+    259,
+    275,
+    291,
+    306,
+    320,
+    338,
+    353,
+    368,
+    382,
+    403,
+    424,
+    443,
+    454,
+    470,
+    488,
+    509,
+    523,
+    536,
+    552,
+    567,
+    582,
+    597,
+    611,
+    626,
+    646,
+    664,
+    682,
+    703,
+    717,
+    731,
+    746,
+    766,
+    780,
+    795,
+    807,
+    823,
+    838,
+    853,
+    868,
+    885,
+    900,
+    915,
+    931,
+    947,
+    964,
+    980,
+    996,
+    1011,
+    1025,
+    1045,
+    1060,
+    1075,
+    1092,
+    1110,
+    1131,
+    1147,
+    1165,
+    1182,
+    1200,
+    1220,
+    1235,
+    1250,
+    1266,
+    1281,
+    1297,
+    1312,
+    1327,
+    1343,
+    1358,
+    1374,
+    1392,
+    1407,
+    1422,
+    1437,
+    1452,
+    1472,
+    1487,
+    1501,
+    1516,
+    1531,
+    1547,
+    1564,
+    1580,
+    1598,
+    1614,
+    1631,
+    1647,
+    1662,
+    1679,
+    1693,
+    1712,
+    1730,
+    1744,
+    1765,
+    1779,
+    1796,
+    1817,
+    1839,
+    1860,
+    1875,
+    1899,
+    1918,
+    1933,
+    1949,
+    1965,
+    1983,
+    2000,
+    2014,
+    2035,
+    2053,
+    2077,
+    2092,
+    2106,
+    2121,
+    2136,
+    2153,
+    2167,
+    2185,
+    2206,
+    2222,
+    2238,
+    2254,
+    2269,
+    2289,
+    2303,
+    
+  };
+
+static GPG_ERR_INLINE int
+errnos_msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 140)) ? (code - 0)
+  : -1);
+}
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/gpg-error.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/gpg-error.h
new file mode 100644
index 000000000..137ff14b0
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/gpg-error.h
@@ -0,0 +1,1462 @@
+/* gpg-error.h or gpgrt.h - Public interface to libgpg-error.   -*- c -*-
+ * Copyright (C) 2003-2004, 2010, 2013-2017 g10 Code GmbH
+ *
+ * This file is part of libgpg-error.
+ *
+ * libgpg-error is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * libgpg-error is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, see <https://www.gnu.org/licenses/>.
+ *
+ * Do not edit.  Generated from gpg-error.h.in for:
+                 powerpc64le-unknown-linux-gnu
+ */
+
+#ifndef GPG_ERROR_H
+#define GPG_ERROR_H 1
+#ifndef GPGRT_H
+#define GPGRT_H 1
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+/* The version string of this header. */
+#define GPG_ERROR_VERSION "1.27"
+#define GPGRT_VERSION     "1.27"
+
+/* The version number of this header. */
+#define GPG_ERROR_VERSION_NUMBER 0x011b00
+#define GPGRT_VERSION_NUMBER     0x011b00
+
+
+#ifdef __GNUC__
+# define GPG_ERR_INLINE __inline__
+#elif defined(_MSC_VER) && _MSC_VER >= 1300
+# define GPG_ERR_INLINE __inline
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+# define GPG_ERR_INLINE inline
+#else
+# ifndef GPG_ERR_INLINE
+#  define GPG_ERR_INLINE
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+#endif /* __cplusplus */
+
+/* The GnuPG project consists of many components.  Error codes are
+   exchanged between all components.  The common error codes and their
+   user-presentable descriptions are kept into a shared library to
+   allow adding new error codes and components without recompiling any
+   of the other components.  The interface will not change in a
+   backward incompatible way.
+
+   An error code together with an error source build up an error
+   value.  As the error value is been passed from one component to
+   another, it preserver the information about the source and nature
+   of the error.
+
+   A component of the GnuPG project can define the following macros to
+   tune the behaviour of the library:
+
+   GPG_ERR_SOURCE_DEFAULT: Define to an error source of type
+   gpg_err_source_t to make that source the default for gpg_error().
+   Otherwise GPG_ERR_SOURCE_UNKNOWN is used as default.
+
+   GPG_ERR_ENABLE_GETTEXT_MACROS: Define to provide macros to map the
+   internal gettext API to standard names.  This has only an effect on
+   Windows platforms.
+
+   GPGRT_ENABLE_ES_MACROS: Define to provide "es_" macros for the
+   estream functions.
+
+   In addition to the error codes, Libgpg-error also provides a set of
+   functions used by most GnuPG components.  */
+
+
+/* The error source type gpg_err_source_t.
+
+   Where as the Poo out of a welle small
+   Taketh his firste springing and his sours.
+					--Chaucer.  */
+
+/* Only use free slots, never change or reorder the existing
+   entries.  */
+typedef enum
+  {
+    GPG_ERR_SOURCE_UNKNOWN = 0,
+    GPG_ERR_SOURCE_GCRYPT = 1,
+    GPG_ERR_SOURCE_GPG = 2,
+    GPG_ERR_SOURCE_GPGSM = 3,
+    GPG_ERR_SOURCE_GPGAGENT = 4,
+    GPG_ERR_SOURCE_PINENTRY = 5,
+    GPG_ERR_SOURCE_SCD = 6,
+    GPG_ERR_SOURCE_GPGME = 7,
+    GPG_ERR_SOURCE_KEYBOX = 8,
+    GPG_ERR_SOURCE_KSBA = 9,
+    GPG_ERR_SOURCE_DIRMNGR = 10,
+    GPG_ERR_SOURCE_GSTI = 11,
+    GPG_ERR_SOURCE_GPA = 12,
+    GPG_ERR_SOURCE_KLEO = 13,
+    GPG_ERR_SOURCE_G13 = 14,
+    GPG_ERR_SOURCE_ASSUAN = 15,
+    GPG_ERR_SOURCE_TLS = 17,
+    GPG_ERR_SOURCE_ANY = 31,
+    GPG_ERR_SOURCE_USER_1 = 32,
+    GPG_ERR_SOURCE_USER_2 = 33,
+    GPG_ERR_SOURCE_USER_3 = 34,
+    GPG_ERR_SOURCE_USER_4 = 35,
+
+    /* This is one more than the largest allowed entry.  */
+    GPG_ERR_SOURCE_DIM = 128
+  } gpg_err_source_t;
+
+
+/* The error code type gpg_err_code_t.  */
+
+/* Only use free slots, never change or reorder the existing
+   entries.  */
+typedef enum
+  {
+    GPG_ERR_NO_ERROR = 0,
+    GPG_ERR_GENERAL = 1,
+    GPG_ERR_UNKNOWN_PACKET = 2,
+    GPG_ERR_UNKNOWN_VERSION = 3,
+    GPG_ERR_PUBKEY_ALGO = 4,
+    GPG_ERR_DIGEST_ALGO = 5,
+    GPG_ERR_BAD_PUBKEY = 6,
+    GPG_ERR_BAD_SECKEY = 7,
+    GPG_ERR_BAD_SIGNATURE = 8,
+    GPG_ERR_NO_PUBKEY = 9,
+    GPG_ERR_CHECKSUM = 10,
+    GPG_ERR_BAD_PASSPHRASE = 11,
+    GPG_ERR_CIPHER_ALGO = 12,
+    GPG_ERR_KEYRING_OPEN = 13,
+    GPG_ERR_INV_PACKET = 14,
+    GPG_ERR_INV_ARMOR = 15,
+    GPG_ERR_NO_USER_ID = 16,
+    GPG_ERR_NO_SECKEY = 17,
+    GPG_ERR_WRONG_SECKEY = 18,
+    GPG_ERR_BAD_KEY = 19,
+    GPG_ERR_COMPR_ALGO = 20,
+    GPG_ERR_NO_PRIME = 21,
+    GPG_ERR_NO_ENCODING_METHOD = 22,
+    GPG_ERR_NO_ENCRYPTION_SCHEME = 23,
+    GPG_ERR_NO_SIGNATURE_SCHEME = 24,
+    GPG_ERR_INV_ATTR = 25,
+    GPG_ERR_NO_VALUE = 26,
+    GPG_ERR_NOT_FOUND = 27,
+    GPG_ERR_VALUE_NOT_FOUND = 28,
+    GPG_ERR_SYNTAX = 29,
+    GPG_ERR_BAD_MPI = 30,
+    GPG_ERR_INV_PASSPHRASE = 31,
+    GPG_ERR_SIG_CLASS = 32,
+    GPG_ERR_RESOURCE_LIMIT = 33,
+    GPG_ERR_INV_KEYRING = 34,
+    GPG_ERR_TRUSTDB = 35,
+    GPG_ERR_BAD_CERT = 36,
+    GPG_ERR_INV_USER_ID = 37,
+    GPG_ERR_UNEXPECTED = 38,
+    GPG_ERR_TIME_CONFLICT = 39,
+    GPG_ERR_KEYSERVER = 40,
+    GPG_ERR_WRONG_PUBKEY_ALGO = 41,
+    GPG_ERR_TRIBUTE_TO_D_A = 42,
+    GPG_ERR_WEAK_KEY = 43,
+    GPG_ERR_INV_KEYLEN = 44,
+    GPG_ERR_INV_ARG = 45,
+    GPG_ERR_BAD_URI = 46,
+    GPG_ERR_INV_URI = 47,
+    GPG_ERR_NETWORK = 48,
+    GPG_ERR_UNKNOWN_HOST = 49,
+    GPG_ERR_SELFTEST_FAILED = 50,
+    GPG_ERR_NOT_ENCRYPTED = 51,
+    GPG_ERR_NOT_PROCESSED = 52,
+    GPG_ERR_UNUSABLE_PUBKEY = 53,
+    GPG_ERR_UNUSABLE_SECKEY = 54,
+    GPG_ERR_INV_VALUE = 55,
+    GPG_ERR_BAD_CERT_CHAIN = 56,
+    GPG_ERR_MISSING_CERT = 57,
+    GPG_ERR_NO_DATA = 58,
+    GPG_ERR_BUG = 59,
+    GPG_ERR_NOT_SUPPORTED = 60,
+    GPG_ERR_INV_OP = 61,
+    GPG_ERR_TIMEOUT = 62,
+    GPG_ERR_INTERNAL = 63,
+    GPG_ERR_EOF_GCRYPT = 64,
+    GPG_ERR_INV_OBJ = 65,
+    GPG_ERR_TOO_SHORT = 66,
+    GPG_ERR_TOO_LARGE = 67,
+    GPG_ERR_NO_OBJ = 68,
+    GPG_ERR_NOT_IMPLEMENTED = 69,
+    GPG_ERR_CONFLICT = 70,
+    GPG_ERR_INV_CIPHER_MODE = 71,
+    GPG_ERR_INV_FLAG = 72,
+    GPG_ERR_INV_HANDLE = 73,
+    GPG_ERR_TRUNCATED = 74,
+    GPG_ERR_INCOMPLETE_LINE = 75,
+    GPG_ERR_INV_RESPONSE = 76,
+    GPG_ERR_NO_AGENT = 77,
+    GPG_ERR_AGENT = 78,
+    GPG_ERR_INV_DATA = 79,
+    GPG_ERR_ASSUAN_SERVER_FAULT = 80,
+    GPG_ERR_ASSUAN = 81,
+    GPG_ERR_INV_SESSION_KEY = 82,
+    GPG_ERR_INV_SEXP = 83,
+    GPG_ERR_UNSUPPORTED_ALGORITHM = 84,
+    GPG_ERR_NO_PIN_ENTRY = 85,
+    GPG_ERR_PIN_ENTRY = 86,
+    GPG_ERR_BAD_PIN = 87,
+    GPG_ERR_INV_NAME = 88,
+    GPG_ERR_BAD_DATA = 89,
+    GPG_ERR_INV_PARAMETER = 90,
+    GPG_ERR_WRONG_CARD = 91,
+    GPG_ERR_NO_DIRMNGR = 92,
+    GPG_ERR_DIRMNGR = 93,
+    GPG_ERR_CERT_REVOKED = 94,
+    GPG_ERR_NO_CRL_KNOWN = 95,
+    GPG_ERR_CRL_TOO_OLD = 96,
+    GPG_ERR_LINE_TOO_LONG = 97,
+    GPG_ERR_NOT_TRUSTED = 98,
+    GPG_ERR_CANCELED = 99,
+    GPG_ERR_BAD_CA_CERT = 100,
+    GPG_ERR_CERT_EXPIRED = 101,
+    GPG_ERR_CERT_TOO_YOUNG = 102,
+    GPG_ERR_UNSUPPORTED_CERT = 103,
+    GPG_ERR_UNKNOWN_SEXP = 104,
+    GPG_ERR_UNSUPPORTED_PROTECTION = 105,
+    GPG_ERR_CORRUPTED_PROTECTION = 106,
+    GPG_ERR_AMBIGUOUS_NAME = 107,
+    GPG_ERR_CARD = 108,
+    GPG_ERR_CARD_RESET = 109,
+    GPG_ERR_CARD_REMOVED = 110,
+    GPG_ERR_INV_CARD = 111,
+    GPG_ERR_CARD_NOT_PRESENT = 112,
+    GPG_ERR_NO_PKCS15_APP = 113,
+    GPG_ERR_NOT_CONFIRMED = 114,
+    GPG_ERR_CONFIGURATION = 115,
+    GPG_ERR_NO_POLICY_MATCH = 116,
+    GPG_ERR_INV_INDEX = 117,
+    GPG_ERR_INV_ID = 118,
+    GPG_ERR_NO_SCDAEMON = 119,
+    GPG_ERR_SCDAEMON = 120,
+    GPG_ERR_UNSUPPORTED_PROTOCOL = 121,
+    GPG_ERR_BAD_PIN_METHOD = 122,
+    GPG_ERR_CARD_NOT_INITIALIZED = 123,
+    GPG_ERR_UNSUPPORTED_OPERATION = 124,
+    GPG_ERR_WRONG_KEY_USAGE = 125,
+    GPG_ERR_NOTHING_FOUND = 126,
+    GPG_ERR_WRONG_BLOB_TYPE = 127,
+    GPG_ERR_MISSING_VALUE = 128,
+    GPG_ERR_HARDWARE = 129,
+    GPG_ERR_PIN_BLOCKED = 130,
+    GPG_ERR_USE_CONDITIONS = 131,
+    GPG_ERR_PIN_NOT_SYNCED = 132,
+    GPG_ERR_INV_CRL = 133,
+    GPG_ERR_BAD_BER = 134,
+    GPG_ERR_INV_BER = 135,
+    GPG_ERR_ELEMENT_NOT_FOUND = 136,
+    GPG_ERR_IDENTIFIER_NOT_FOUND = 137,
+    GPG_ERR_INV_TAG = 138,
+    GPG_ERR_INV_LENGTH = 139,
+    GPG_ERR_INV_KEYINFO = 140,
+    GPG_ERR_UNEXPECTED_TAG = 141,
+    GPG_ERR_NOT_DER_ENCODED = 142,
+    GPG_ERR_NO_CMS_OBJ = 143,
+    GPG_ERR_INV_CMS_OBJ = 144,
+    GPG_ERR_UNKNOWN_CMS_OBJ = 145,
+    GPG_ERR_UNSUPPORTED_CMS_OBJ = 146,
+    GPG_ERR_UNSUPPORTED_ENCODING = 147,
+    GPG_ERR_UNSUPPORTED_CMS_VERSION = 148,
+    GPG_ERR_UNKNOWN_ALGORITHM = 149,
+    GPG_ERR_INV_ENGINE = 150,
+    GPG_ERR_PUBKEY_NOT_TRUSTED = 151,
+    GPG_ERR_DECRYPT_FAILED = 152,
+    GPG_ERR_KEY_EXPIRED = 153,
+    GPG_ERR_SIG_EXPIRED = 154,
+    GPG_ERR_ENCODING_PROBLEM = 155,
+    GPG_ERR_INV_STATE = 156,
+    GPG_ERR_DUP_VALUE = 157,
+    GPG_ERR_MISSING_ACTION = 158,
+    GPG_ERR_MODULE_NOT_FOUND = 159,
+    GPG_ERR_INV_OID_STRING = 160,
+    GPG_ERR_INV_TIME = 161,
+    GPG_ERR_INV_CRL_OBJ = 162,
+    GPG_ERR_UNSUPPORTED_CRL_VERSION = 163,
+    GPG_ERR_INV_CERT_OBJ = 164,
+    GPG_ERR_UNKNOWN_NAME = 165,
+    GPG_ERR_LOCALE_PROBLEM = 166,
+    GPG_ERR_NOT_LOCKED = 167,
+    GPG_ERR_PROTOCOL_VIOLATION = 168,
+    GPG_ERR_INV_MAC = 169,
+    GPG_ERR_INV_REQUEST = 170,
+    GPG_ERR_UNKNOWN_EXTN = 171,
+    GPG_ERR_UNKNOWN_CRIT_EXTN = 172,
+    GPG_ERR_LOCKED = 173,
+    GPG_ERR_UNKNOWN_OPTION = 174,
+    GPG_ERR_UNKNOWN_COMMAND = 175,
+    GPG_ERR_NOT_OPERATIONAL = 176,
+    GPG_ERR_NO_PASSPHRASE = 177,
+    GPG_ERR_NO_PIN = 178,
+    GPG_ERR_NOT_ENABLED = 179,
+    GPG_ERR_NO_ENGINE = 180,
+    GPG_ERR_MISSING_KEY = 181,
+    GPG_ERR_TOO_MANY = 182,
+    GPG_ERR_LIMIT_REACHED = 183,
+    GPG_ERR_NOT_INITIALIZED = 184,
+    GPG_ERR_MISSING_ISSUER_CERT = 185,
+    GPG_ERR_NO_KEYSERVER = 186,
+    GPG_ERR_INV_CURVE = 187,
+    GPG_ERR_UNKNOWN_CURVE = 188,
+    GPG_ERR_DUP_KEY = 189,
+    GPG_ERR_AMBIGUOUS = 190,
+    GPG_ERR_NO_CRYPT_CTX = 191,
+    GPG_ERR_WRONG_CRYPT_CTX = 192,
+    GPG_ERR_BAD_CRYPT_CTX = 193,
+    GPG_ERR_CRYPT_CTX_CONFLICT = 194,
+    GPG_ERR_BROKEN_PUBKEY = 195,
+    GPG_ERR_BROKEN_SECKEY = 196,
+    GPG_ERR_MAC_ALGO = 197,
+    GPG_ERR_FULLY_CANCELED = 198,
+    GPG_ERR_UNFINISHED = 199,
+    GPG_ERR_BUFFER_TOO_SHORT = 200,
+    GPG_ERR_SEXP_INV_LEN_SPEC = 201,
+    GPG_ERR_SEXP_STRING_TOO_LONG = 202,
+    GPG_ERR_SEXP_UNMATCHED_PAREN = 203,
+    GPG_ERR_SEXP_NOT_CANONICAL = 204,
+    GPG_ERR_SEXP_BAD_CHARACTER = 205,
+    GPG_ERR_SEXP_BAD_QUOTATION = 206,
+    GPG_ERR_SEXP_ZERO_PREFIX = 207,
+    GPG_ERR_SEXP_NESTED_DH = 208,
+    GPG_ERR_SEXP_UNMATCHED_DH = 209,
+    GPG_ERR_SEXP_UNEXPECTED_PUNC = 210,
+    GPG_ERR_SEXP_BAD_HEX_CHAR = 211,
+    GPG_ERR_SEXP_ODD_HEX_NUMBERS = 212,
+    GPG_ERR_SEXP_BAD_OCT_CHAR = 213,
+    GPG_ERR_SUBKEYS_EXP_OR_REV = 217,
+    GPG_ERR_DB_CORRUPTED = 218,
+    GPG_ERR_SERVER_FAILED = 219,
+    GPG_ERR_NO_NAME = 220,
+    GPG_ERR_NO_KEY = 221,
+    GPG_ERR_LEGACY_KEY = 222,
+    GPG_ERR_REQUEST_TOO_SHORT = 223,
+    GPG_ERR_REQUEST_TOO_LONG = 224,
+    GPG_ERR_OBJ_TERM_STATE = 225,
+    GPG_ERR_NO_CERT_CHAIN = 226,
+    GPG_ERR_CERT_TOO_LARGE = 227,
+    GPG_ERR_INV_RECORD = 228,
+    GPG_ERR_BAD_MAC = 229,
+    GPG_ERR_UNEXPECTED_MSG = 230,
+    GPG_ERR_COMPR_FAILED = 231,
+    GPG_ERR_WOULD_WRAP = 232,
+    GPG_ERR_FATAL_ALERT = 233,
+    GPG_ERR_NO_CIPHER = 234,
+    GPG_ERR_MISSING_CLIENT_CERT = 235,
+    GPG_ERR_CLOSE_NOTIFY = 236,
+    GPG_ERR_TICKET_EXPIRED = 237,
+    GPG_ERR_BAD_TICKET = 238,
+    GPG_ERR_UNKNOWN_IDENTITY = 239,
+    GPG_ERR_BAD_HS_CERT = 240,
+    GPG_ERR_BAD_HS_CERT_REQ = 241,
+    GPG_ERR_BAD_HS_CERT_VER = 242,
+    GPG_ERR_BAD_HS_CHANGE_CIPHER = 243,
+    GPG_ERR_BAD_HS_CLIENT_HELLO = 244,
+    GPG_ERR_BAD_HS_SERVER_HELLO = 245,
+    GPG_ERR_BAD_HS_SERVER_HELLO_DONE = 246,
+    GPG_ERR_BAD_HS_FINISHED = 247,
+    GPG_ERR_BAD_HS_SERVER_KEX = 248,
+    GPG_ERR_BAD_HS_CLIENT_KEX = 249,
+    GPG_ERR_BOGUS_STRING = 250,
+    GPG_ERR_FORBIDDEN = 251,
+    GPG_ERR_KEY_DISABLED = 252,
+    GPG_ERR_KEY_ON_CARD = 253,
+    GPG_ERR_INV_LOCK_OBJ = 254,
+    GPG_ERR_TRUE = 255,
+    GPG_ERR_FALSE = 256,
+    GPG_ERR_ASS_GENERAL = 257,
+    GPG_ERR_ASS_ACCEPT_FAILED = 258,
+    GPG_ERR_ASS_CONNECT_FAILED = 259,
+    GPG_ERR_ASS_INV_RESPONSE = 260,
+    GPG_ERR_ASS_INV_VALUE = 261,
+    GPG_ERR_ASS_INCOMPLETE_LINE = 262,
+    GPG_ERR_ASS_LINE_TOO_LONG = 263,
+    GPG_ERR_ASS_NESTED_COMMANDS = 264,
+    GPG_ERR_ASS_NO_DATA_CB = 265,
+    GPG_ERR_ASS_NO_INQUIRE_CB = 266,
+    GPG_ERR_ASS_NOT_A_SERVER = 267,
+    GPG_ERR_ASS_NOT_A_CLIENT = 268,
+    GPG_ERR_ASS_SERVER_START = 269,
+    GPG_ERR_ASS_READ_ERROR = 270,
+    GPG_ERR_ASS_WRITE_ERROR = 271,
+    GPG_ERR_ASS_TOO_MUCH_DATA = 273,
+    GPG_ERR_ASS_UNEXPECTED_CMD = 274,
+    GPG_ERR_ASS_UNKNOWN_CMD = 275,
+    GPG_ERR_ASS_SYNTAX = 276,
+    GPG_ERR_ASS_CANCELED = 277,
+    GPG_ERR_ASS_NO_INPUT = 278,
+    GPG_ERR_ASS_NO_OUTPUT = 279,
+    GPG_ERR_ASS_PARAMETER = 280,
+    GPG_ERR_ASS_UNKNOWN_INQUIRE = 281,
+    GPG_ERR_ENGINE_TOO_OLD = 300,
+    GPG_ERR_WINDOW_TOO_SMALL = 301,
+    GPG_ERR_WINDOW_TOO_LARGE = 302,
+    GPG_ERR_MISSING_ENVVAR = 303,
+    GPG_ERR_USER_ID_EXISTS = 304,
+    GPG_ERR_NAME_EXISTS = 305,
+    GPG_ERR_DUP_NAME = 306,
+    GPG_ERR_TOO_YOUNG = 307,
+    GPG_ERR_TOO_OLD = 308,
+    GPG_ERR_UNKNOWN_FLAG = 309,
+    GPG_ERR_INV_ORDER = 310,
+    GPG_ERR_ALREADY_FETCHED = 311,
+    GPG_ERR_TRY_LATER = 312,
+    GPG_ERR_WRONG_NAME = 313,
+    GPG_ERR_SYSTEM_BUG = 666,
+    GPG_ERR_DNS_UNKNOWN = 711,
+    GPG_ERR_DNS_SECTION = 712,
+    GPG_ERR_DNS_ADDRESS = 713,
+    GPG_ERR_DNS_NO_QUERY = 714,
+    GPG_ERR_DNS_NO_ANSWER = 715,
+    GPG_ERR_DNS_CLOSED = 716,
+    GPG_ERR_DNS_VERIFY = 717,
+    GPG_ERR_DNS_TIMEOUT = 718,
+    GPG_ERR_LDAP_GENERAL = 721,
+    GPG_ERR_LDAP_ATTR_GENERAL = 722,
+    GPG_ERR_LDAP_NAME_GENERAL = 723,
+    GPG_ERR_LDAP_SECURITY_GENERAL = 724,
+    GPG_ERR_LDAP_SERVICE_GENERAL = 725,
+    GPG_ERR_LDAP_UPDATE_GENERAL = 726,
+    GPG_ERR_LDAP_E_GENERAL = 727,
+    GPG_ERR_LDAP_X_GENERAL = 728,
+    GPG_ERR_LDAP_OTHER_GENERAL = 729,
+    GPG_ERR_LDAP_X_CONNECTING = 750,
+    GPG_ERR_LDAP_REFERRAL_LIMIT = 751,
+    GPG_ERR_LDAP_CLIENT_LOOP = 752,
+    GPG_ERR_LDAP_NO_RESULTS = 754,
+    GPG_ERR_LDAP_CONTROL_NOT_FOUND = 755,
+    GPG_ERR_LDAP_NOT_SUPPORTED = 756,
+    GPG_ERR_LDAP_CONNECT = 757,
+    GPG_ERR_LDAP_NO_MEMORY = 758,
+    GPG_ERR_LDAP_PARAM = 759,
+    GPG_ERR_LDAP_USER_CANCELLED = 760,
+    GPG_ERR_LDAP_FILTER = 761,
+    GPG_ERR_LDAP_AUTH_UNKNOWN = 762,
+    GPG_ERR_LDAP_TIMEOUT = 763,
+    GPG_ERR_LDAP_DECODING = 764,
+    GPG_ERR_LDAP_ENCODING = 765,
+    GPG_ERR_LDAP_LOCAL = 766,
+    GPG_ERR_LDAP_SERVER_DOWN = 767,
+    GPG_ERR_LDAP_SUCCESS = 768,
+    GPG_ERR_LDAP_OPERATIONS = 769,
+    GPG_ERR_LDAP_PROTOCOL = 770,
+    GPG_ERR_LDAP_TIMELIMIT = 771,
+    GPG_ERR_LDAP_SIZELIMIT = 772,
+    GPG_ERR_LDAP_COMPARE_FALSE = 773,
+    GPG_ERR_LDAP_COMPARE_TRUE = 774,
+    GPG_ERR_LDAP_UNSUPPORTED_AUTH = 775,
+    GPG_ERR_LDAP_STRONG_AUTH_RQRD = 776,
+    GPG_ERR_LDAP_PARTIAL_RESULTS = 777,
+    GPG_ERR_LDAP_REFERRAL = 778,
+    GPG_ERR_LDAP_ADMINLIMIT = 779,
+    GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN = 780,
+    GPG_ERR_LDAP_CONFIDENT_RQRD = 781,
+    GPG_ERR_LDAP_SASL_BIND_INPROG = 782,
+    GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE = 784,
+    GPG_ERR_LDAP_UNDEFINED_TYPE = 785,
+    GPG_ERR_LDAP_BAD_MATCHING = 786,
+    GPG_ERR_LDAP_CONST_VIOLATION = 787,
+    GPG_ERR_LDAP_TYPE_VALUE_EXISTS = 788,
+    GPG_ERR_LDAP_INV_SYNTAX = 789,
+    GPG_ERR_LDAP_NO_SUCH_OBJ = 800,
+    GPG_ERR_LDAP_ALIAS_PROBLEM = 801,
+    GPG_ERR_LDAP_INV_DN_SYNTAX = 802,
+    GPG_ERR_LDAP_IS_LEAF = 803,
+    GPG_ERR_LDAP_ALIAS_DEREF = 804,
+    GPG_ERR_LDAP_X_PROXY_AUTH_FAIL = 815,
+    GPG_ERR_LDAP_BAD_AUTH = 816,
+    GPG_ERR_LDAP_INV_CREDENTIALS = 817,
+    GPG_ERR_LDAP_INSUFFICIENT_ACC = 818,
+    GPG_ERR_LDAP_BUSY = 819,
+    GPG_ERR_LDAP_UNAVAILABLE = 820,
+    GPG_ERR_LDAP_UNWILL_TO_PERFORM = 821,
+    GPG_ERR_LDAP_LOOP_DETECT = 822,
+    GPG_ERR_LDAP_NAMING_VIOLATION = 832,
+    GPG_ERR_LDAP_OBJ_CLS_VIOLATION = 833,
+    GPG_ERR_LDAP_NOT_ALLOW_NONLEAF = 834,
+    GPG_ERR_LDAP_NOT_ALLOW_ON_RDN = 835,
+    GPG_ERR_LDAP_ALREADY_EXISTS = 836,
+    GPG_ERR_LDAP_NO_OBJ_CLASS_MODS = 837,
+    GPG_ERR_LDAP_RESULTS_TOO_LARGE = 838,
+    GPG_ERR_LDAP_AFFECTS_MULT_DSAS = 839,
+    GPG_ERR_LDAP_VLV = 844,
+    GPG_ERR_LDAP_OTHER = 848,
+    GPG_ERR_LDAP_CUP_RESOURCE_LIMIT = 881,
+    GPG_ERR_LDAP_CUP_SEC_VIOLATION = 882,
+    GPG_ERR_LDAP_CUP_INV_DATA = 883,
+    GPG_ERR_LDAP_CUP_UNSUP_SCHEME = 884,
+    GPG_ERR_LDAP_CUP_RELOAD = 885,
+    GPG_ERR_LDAP_CANCELLED = 886,
+    GPG_ERR_LDAP_NO_SUCH_OPERATION = 887,
+    GPG_ERR_LDAP_TOO_LATE = 888,
+    GPG_ERR_LDAP_CANNOT_CANCEL = 889,
+    GPG_ERR_LDAP_ASSERTION_FAILED = 890,
+    GPG_ERR_LDAP_PROX_AUTH_DENIED = 891,
+    GPG_ERR_USER_1 = 1024,
+    GPG_ERR_USER_2 = 1025,
+    GPG_ERR_USER_3 = 1026,
+    GPG_ERR_USER_4 = 1027,
+    GPG_ERR_USER_5 = 1028,
+    GPG_ERR_USER_6 = 1029,
+    GPG_ERR_USER_7 = 1030,
+    GPG_ERR_USER_8 = 1031,
+    GPG_ERR_USER_9 = 1032,
+    GPG_ERR_USER_10 = 1033,
+    GPG_ERR_USER_11 = 1034,
+    GPG_ERR_USER_12 = 1035,
+    GPG_ERR_USER_13 = 1036,
+    GPG_ERR_USER_14 = 1037,
+    GPG_ERR_USER_15 = 1038,
+    GPG_ERR_USER_16 = 1039,
+    GPG_ERR_MISSING_ERRNO = 16381,
+    GPG_ERR_UNKNOWN_ERRNO = 16382,
+    GPG_ERR_EOF = 16383,
+
+    /* The following error codes are used to map system errors.  */
+#define GPG_ERR_SYSTEM_ERROR	(1 << 15)
+    GPG_ERR_E2BIG = GPG_ERR_SYSTEM_ERROR | 0,
+    GPG_ERR_EACCES = GPG_ERR_SYSTEM_ERROR | 1,
+    GPG_ERR_EADDRINUSE = GPG_ERR_SYSTEM_ERROR | 2,
+    GPG_ERR_EADDRNOTAVAIL = GPG_ERR_SYSTEM_ERROR | 3,
+    GPG_ERR_EADV = GPG_ERR_SYSTEM_ERROR | 4,
+    GPG_ERR_EAFNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 5,
+    GPG_ERR_EAGAIN = GPG_ERR_SYSTEM_ERROR | 6,
+    GPG_ERR_EALREADY = GPG_ERR_SYSTEM_ERROR | 7,
+    GPG_ERR_EAUTH = GPG_ERR_SYSTEM_ERROR | 8,
+    GPG_ERR_EBACKGROUND = GPG_ERR_SYSTEM_ERROR | 9,
+    GPG_ERR_EBADE = GPG_ERR_SYSTEM_ERROR | 10,
+    GPG_ERR_EBADF = GPG_ERR_SYSTEM_ERROR | 11,
+    GPG_ERR_EBADFD = GPG_ERR_SYSTEM_ERROR | 12,
+    GPG_ERR_EBADMSG = GPG_ERR_SYSTEM_ERROR | 13,
+    GPG_ERR_EBADR = GPG_ERR_SYSTEM_ERROR | 14,
+    GPG_ERR_EBADRPC = GPG_ERR_SYSTEM_ERROR | 15,
+    GPG_ERR_EBADRQC = GPG_ERR_SYSTEM_ERROR | 16,
+    GPG_ERR_EBADSLT = GPG_ERR_SYSTEM_ERROR | 17,
+    GPG_ERR_EBFONT = GPG_ERR_SYSTEM_ERROR | 18,
+    GPG_ERR_EBUSY = GPG_ERR_SYSTEM_ERROR | 19,
+    GPG_ERR_ECANCELED = GPG_ERR_SYSTEM_ERROR | 20,
+    GPG_ERR_ECHILD = GPG_ERR_SYSTEM_ERROR | 21,
+    GPG_ERR_ECHRNG = GPG_ERR_SYSTEM_ERROR | 22,
+    GPG_ERR_ECOMM = GPG_ERR_SYSTEM_ERROR | 23,
+    GPG_ERR_ECONNABORTED = GPG_ERR_SYSTEM_ERROR | 24,
+    GPG_ERR_ECONNREFUSED = GPG_ERR_SYSTEM_ERROR | 25,
+    GPG_ERR_ECONNRESET = GPG_ERR_SYSTEM_ERROR | 26,
+    GPG_ERR_ED = GPG_ERR_SYSTEM_ERROR | 27,
+    GPG_ERR_EDEADLK = GPG_ERR_SYSTEM_ERROR | 28,
+    GPG_ERR_EDEADLOCK = GPG_ERR_SYSTEM_ERROR | 29,
+    GPG_ERR_EDESTADDRREQ = GPG_ERR_SYSTEM_ERROR | 30,
+    GPG_ERR_EDIED = GPG_ERR_SYSTEM_ERROR | 31,
+    GPG_ERR_EDOM = GPG_ERR_SYSTEM_ERROR | 32,
+    GPG_ERR_EDOTDOT = GPG_ERR_SYSTEM_ERROR | 33,
+    GPG_ERR_EDQUOT = GPG_ERR_SYSTEM_ERROR | 34,
+    GPG_ERR_EEXIST = GPG_ERR_SYSTEM_ERROR | 35,
+    GPG_ERR_EFAULT = GPG_ERR_SYSTEM_ERROR | 36,
+    GPG_ERR_EFBIG = GPG_ERR_SYSTEM_ERROR | 37,
+    GPG_ERR_EFTYPE = GPG_ERR_SYSTEM_ERROR | 38,
+    GPG_ERR_EGRATUITOUS = GPG_ERR_SYSTEM_ERROR | 39,
+    GPG_ERR_EGREGIOUS = GPG_ERR_SYSTEM_ERROR | 40,
+    GPG_ERR_EHOSTDOWN = GPG_ERR_SYSTEM_ERROR | 41,
+    GPG_ERR_EHOSTUNREACH = GPG_ERR_SYSTEM_ERROR | 42,
+    GPG_ERR_EIDRM = GPG_ERR_SYSTEM_ERROR | 43,
+    GPG_ERR_EIEIO = GPG_ERR_SYSTEM_ERROR | 44,
+    GPG_ERR_EILSEQ = GPG_ERR_SYSTEM_ERROR | 45,
+    GPG_ERR_EINPROGRESS = GPG_ERR_SYSTEM_ERROR | 46,
+    GPG_ERR_EINTR = GPG_ERR_SYSTEM_ERROR | 47,
+    GPG_ERR_EINVAL = GPG_ERR_SYSTEM_ERROR | 48,
+    GPG_ERR_EIO = GPG_ERR_SYSTEM_ERROR | 49,
+    GPG_ERR_EISCONN = GPG_ERR_SYSTEM_ERROR | 50,
+    GPG_ERR_EISDIR = GPG_ERR_SYSTEM_ERROR | 51,
+    GPG_ERR_EISNAM = GPG_ERR_SYSTEM_ERROR | 52,
+    GPG_ERR_EL2HLT = GPG_ERR_SYSTEM_ERROR | 53,
+    GPG_ERR_EL2NSYNC = GPG_ERR_SYSTEM_ERROR | 54,
+    GPG_ERR_EL3HLT = GPG_ERR_SYSTEM_ERROR | 55,
+    GPG_ERR_EL3RST = GPG_ERR_SYSTEM_ERROR | 56,
+    GPG_ERR_ELIBACC = GPG_ERR_SYSTEM_ERROR | 57,
+    GPG_ERR_ELIBBAD = GPG_ERR_SYSTEM_ERROR | 58,
+    GPG_ERR_ELIBEXEC = GPG_ERR_SYSTEM_ERROR | 59,
+    GPG_ERR_ELIBMAX = GPG_ERR_SYSTEM_ERROR | 60,
+    GPG_ERR_ELIBSCN = GPG_ERR_SYSTEM_ERROR | 61,
+    GPG_ERR_ELNRNG = GPG_ERR_SYSTEM_ERROR | 62,
+    GPG_ERR_ELOOP = GPG_ERR_SYSTEM_ERROR | 63,
+    GPG_ERR_EMEDIUMTYPE = GPG_ERR_SYSTEM_ERROR | 64,
+    GPG_ERR_EMFILE = GPG_ERR_SYSTEM_ERROR | 65,
+    GPG_ERR_EMLINK = GPG_ERR_SYSTEM_ERROR | 66,
+    GPG_ERR_EMSGSIZE = GPG_ERR_SYSTEM_ERROR | 67,
+    GPG_ERR_EMULTIHOP = GPG_ERR_SYSTEM_ERROR | 68,
+    GPG_ERR_ENAMETOOLONG = GPG_ERR_SYSTEM_ERROR | 69,
+    GPG_ERR_ENAVAIL = GPG_ERR_SYSTEM_ERROR | 70,
+    GPG_ERR_ENEEDAUTH = GPG_ERR_SYSTEM_ERROR | 71,
+    GPG_ERR_ENETDOWN = GPG_ERR_SYSTEM_ERROR | 72,
+    GPG_ERR_ENETRESET = GPG_ERR_SYSTEM_ERROR | 73,
+    GPG_ERR_ENETUNREACH = GPG_ERR_SYSTEM_ERROR | 74,
+    GPG_ERR_ENFILE = GPG_ERR_SYSTEM_ERROR | 75,
+    GPG_ERR_ENOANO = GPG_ERR_SYSTEM_ERROR | 76,
+    GPG_ERR_ENOBUFS = GPG_ERR_SYSTEM_ERROR | 77,
+    GPG_ERR_ENOCSI = GPG_ERR_SYSTEM_ERROR | 78,
+    GPG_ERR_ENODATA = GPG_ERR_SYSTEM_ERROR | 79,
+    GPG_ERR_ENODEV = GPG_ERR_SYSTEM_ERROR | 80,
+    GPG_ERR_ENOENT = GPG_ERR_SYSTEM_ERROR | 81,
+    GPG_ERR_ENOEXEC = GPG_ERR_SYSTEM_ERROR | 82,
+    GPG_ERR_ENOLCK = GPG_ERR_SYSTEM_ERROR | 83,
+    GPG_ERR_ENOLINK = GPG_ERR_SYSTEM_ERROR | 84,
+    GPG_ERR_ENOMEDIUM = GPG_ERR_SYSTEM_ERROR | 85,
+    GPG_ERR_ENOMEM = GPG_ERR_SYSTEM_ERROR | 86,
+    GPG_ERR_ENOMSG = GPG_ERR_SYSTEM_ERROR | 87,
+    GPG_ERR_ENONET = GPG_ERR_SYSTEM_ERROR | 88,
+    GPG_ERR_ENOPKG = GPG_ERR_SYSTEM_ERROR | 89,
+    GPG_ERR_ENOPROTOOPT = GPG_ERR_SYSTEM_ERROR | 90,
+    GPG_ERR_ENOSPC = GPG_ERR_SYSTEM_ERROR | 91,
+    GPG_ERR_ENOSR = GPG_ERR_SYSTEM_ERROR | 92,
+    GPG_ERR_ENOSTR = GPG_ERR_SYSTEM_ERROR | 93,
+    GPG_ERR_ENOSYS = GPG_ERR_SYSTEM_ERROR | 94,
+    GPG_ERR_ENOTBLK = GPG_ERR_SYSTEM_ERROR | 95,
+    GPG_ERR_ENOTCONN = GPG_ERR_SYSTEM_ERROR | 96,
+    GPG_ERR_ENOTDIR = GPG_ERR_SYSTEM_ERROR | 97,
+    GPG_ERR_ENOTEMPTY = GPG_ERR_SYSTEM_ERROR | 98,
+    GPG_ERR_ENOTNAM = GPG_ERR_SYSTEM_ERROR | 99,
+    GPG_ERR_ENOTSOCK = GPG_ERR_SYSTEM_ERROR | 100,
+    GPG_ERR_ENOTSUP = GPG_ERR_SYSTEM_ERROR | 101,
+    GPG_ERR_ENOTTY = GPG_ERR_SYSTEM_ERROR | 102,
+    GPG_ERR_ENOTUNIQ = GPG_ERR_SYSTEM_ERROR | 103,
+    GPG_ERR_ENXIO = GPG_ERR_SYSTEM_ERROR | 104,
+    GPG_ERR_EOPNOTSUPP = GPG_ERR_SYSTEM_ERROR | 105,
+    GPG_ERR_EOVERFLOW = GPG_ERR_SYSTEM_ERROR | 106,
+    GPG_ERR_EPERM = GPG_ERR_SYSTEM_ERROR | 107,
+    GPG_ERR_EPFNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 108,
+    GPG_ERR_EPIPE = GPG_ERR_SYSTEM_ERROR | 109,
+    GPG_ERR_EPROCLIM = GPG_ERR_SYSTEM_ERROR | 110,
+    GPG_ERR_EPROCUNAVAIL = GPG_ERR_SYSTEM_ERROR | 111,
+    GPG_ERR_EPROGMISMATCH = GPG_ERR_SYSTEM_ERROR | 112,
+    GPG_ERR_EPROGUNAVAIL = GPG_ERR_SYSTEM_ERROR | 113,
+    GPG_ERR_EPROTO = GPG_ERR_SYSTEM_ERROR | 114,
+    GPG_ERR_EPROTONOSUPPORT = GPG_ERR_SYSTEM_ERROR | 115,
+    GPG_ERR_EPROTOTYPE = GPG_ERR_SYSTEM_ERROR | 116,
+    GPG_ERR_ERANGE = GPG_ERR_SYSTEM_ERROR | 117,
+    GPG_ERR_EREMCHG = GPG_ERR_SYSTEM_ERROR | 118,
+    GPG_ERR_EREMOTE = GPG_ERR_SYSTEM_ERROR | 119,
+    GPG_ERR_EREMOTEIO = GPG_ERR_SYSTEM_ERROR | 120,
+    GPG_ERR_ERESTART = GPG_ERR_SYSTEM_ERROR | 121,
+    GPG_ERR_EROFS = GPG_ERR_SYSTEM_ERROR | 122,
+    GPG_ERR_ERPCMISMATCH = GPG_ERR_SYSTEM_ERROR | 123,
+    GPG_ERR_ESHUTDOWN = GPG_ERR_SYSTEM_ERROR | 124,
+    GPG_ERR_ESOCKTNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 125,
+    GPG_ERR_ESPIPE = GPG_ERR_SYSTEM_ERROR | 126,
+    GPG_ERR_ESRCH = GPG_ERR_SYSTEM_ERROR | 127,
+    GPG_ERR_ESRMNT = GPG_ERR_SYSTEM_ERROR | 128,
+    GPG_ERR_ESTALE = GPG_ERR_SYSTEM_ERROR | 129,
+    GPG_ERR_ESTRPIPE = GPG_ERR_SYSTEM_ERROR | 130,
+    GPG_ERR_ETIME = GPG_ERR_SYSTEM_ERROR | 131,
+    GPG_ERR_ETIMEDOUT = GPG_ERR_SYSTEM_ERROR | 132,
+    GPG_ERR_ETOOMANYREFS = GPG_ERR_SYSTEM_ERROR | 133,
+    GPG_ERR_ETXTBSY = GPG_ERR_SYSTEM_ERROR | 134,
+    GPG_ERR_EUCLEAN = GPG_ERR_SYSTEM_ERROR | 135,
+    GPG_ERR_EUNATCH = GPG_ERR_SYSTEM_ERROR | 136,
+    GPG_ERR_EUSERS = GPG_ERR_SYSTEM_ERROR | 137,
+    GPG_ERR_EWOULDBLOCK = GPG_ERR_SYSTEM_ERROR | 138,
+    GPG_ERR_EXDEV = GPG_ERR_SYSTEM_ERROR | 139,
+    GPG_ERR_EXFULL = GPG_ERR_SYSTEM_ERROR | 140,
+
+    /* This is one more than the largest allowed entry.  */
+    GPG_ERR_CODE_DIM = 65536
+  } gpg_err_code_t;
+
+
+/* The error value type gpg_error_t.  */
+
+/* We would really like to use bit-fields in a struct, but using
+   structs as return values can cause binary compatibility issues, in
+   particular if you want to do it efficiently (also see
+   -freg-struct-return option to GCC).  */
+typedef unsigned int gpg_error_t;
+
+/* We use the lowest 16 bits of gpg_error_t for error codes.  The 16th
+   bit indicates system errors.  */
+#define GPG_ERR_CODE_MASK	(GPG_ERR_CODE_DIM - 1)
+
+/* Bits 17 to 24 are reserved.  */
+
+/* We use the upper 7 bits of gpg_error_t for error sources.  */
+#define GPG_ERR_SOURCE_MASK	(GPG_ERR_SOURCE_DIM - 1)
+#define GPG_ERR_SOURCE_SHIFT	24
+
+/* The highest bit is reserved.  It shouldn't be used to prevent
+   potential negative numbers when transmitting error values as
+   text.  */
+
+
+/* GCC feature test.  */
+#if __GNUC__
+# define _GPG_ERR_GCC_VERSION (__GNUC__ * 10000 \
+                               + __GNUC_MINOR__ * 100 \
+                               + __GNUC_PATCHLEVEL__)
+#else
+# define _GPG_ERR_GCC_VERSION 0
+#endif
+
+#undef _GPG_ERR_HAVE_CONSTRUCTOR
+#if _GPG_ERR_GCC_VERSION > 30100
+# define _GPG_ERR_CONSTRUCTOR	__attribute__ ((__constructor__))
+# define _GPG_ERR_HAVE_CONSTRUCTOR
+#else
+# define _GPG_ERR_CONSTRUCTOR
+#endif
+
+#define GPGRT_GCC_VERSION  _GPG_ERR_GCC_VERSION
+
+#if _GPG_ERR_GCC_VERSION >= 29200
+# define _GPGRT__RESTRICT __restrict__
+#else
+# define _GPGRT__RESTRICT
+#endif
+
+/* The noreturn attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_ATTR_NORETURN   __attribute__ ((noreturn))
+#else
+# define GPGRT_ATTR_NORETURN
+#endif
+
+/* The printf attributes.  */
+#if _GPG_ERR_GCC_VERSION >= 40400
+# define GPGRT_ATTR_PRINTF(f, a) \
+                    __attribute__ ((format(__gnu_printf__,f,a)))
+# define GPGRT_ATTR_NR_PRINTF(f, a) \
+                    __attribute__ ((noreturn, format(__gnu_printf__,f,a)))
+#elif _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_ATTR_PRINTF(f, a) \
+                    __attribute__ ((format(printf,f,a)))
+# define GPGRT_ATTR_NR_PRINTF(f, a) \
+                    __attribute__ ((noreturn, format(printf,f,a)))
+#else
+# define GPGRT_ATTR_PRINTF(f, a)
+# define GPGRT_ATTR_NR_PRINTF(f, a)
+#endif
+#if _GPG_ERR_GCC_VERSION >= 20800
+# define GPGRT_ATTR_FORMAT_ARG(a)  __attribute__ ((__format_arg__ (a)))
+#else
+# define GPGRT_ATTR_FORMAT_ARG(a)
+#endif
+
+/* The sentinel attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 40000
+# define GPGRT_ATTR_SENTINEL(a)  __attribute__ ((sentinel(a)))
+#else
+# define GPGRT_ATTR_SENTINEL(a)
+#endif
+
+/* The used and unused attributes.
+   I am not sure since when the unused attribute is really supported.
+   In any case it it only needed for gcc versions which print a
+   warning.  Thus let us require gcc >= 3.5.  */
+#if _GPG_ERR_GCC_VERSION >= 40000
+# define GPGRT_ATTR_USED  __attribute__ ((used))
+#else
+# define GPGRT_ATTR_USED
+#endif
+#if _GPG_ERR_GCC_VERSION >= 30500
+# define GPGRT_ATTR_UNUSED  __attribute__ ((unused))
+#else
+# define GPGRT_ATTR_UNUSED
+#endif
+
+/* The deprecated attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 30100
+# define GPGRT_ATTR_DEPRECATED  __attribute__ ((__deprecated__))
+#else
+# define GPGRT_ATTR_DEPRECATED
+#endif
+
+/* The pure attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 29600
+# define GPGRT_ATTR_PURE  __attribute__ ((__pure__))
+#else
+# define GPGRT_ATTR_PURE
+#endif
+
+/* The malloc attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 30200
+# define GPGRT_ATTR_MALLOC  __attribute__ ((__malloc__))
+#else
+# define GPGRT_ATTR_MALLOC
+#endif
+
+/* A macro defined if a GCC style __FUNCTION__ macro is available.  */
+#undef GPGRT_HAVE_MACRO_FUNCTION
+#if _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_HAVE_MACRO_FUNCTION 1
+#endif
+
+/* A macro defined if the pragma GCC push_options is available.  */
+#undef GPGRT_HAVE_PRAGMA_GCC_PUSH
+#if _GPG_ERR_GCC_VERSION >= 40400
+# define GPGRT_HAVE_PRAGMA_GCC_PUSH 1
+#endif
+
+/* Detect LeakSanitizer (LSan) support for GCC and Clang based on
+ * whether AddressSanitizer (ASAN) is enabled via -fsanitize=address).
+ * Note that -fsanitize=leak just affect the linker options which
+ * cannot be detected here.  In that case you have to define the
+ * GPGRT_HAVE_LEAK_SANITIZER macro manually.  */
+#ifdef __GNUC__
+# ifdef __SANITIZE_ADDRESS__
+#  define GPGRT_HAVE_LEAK_SANITIZER
+# elif defined(__has_feature)
+#  if __has_feature(address_sanitizer)
+#   define GPGRT_HAVE_LEAK_SANITIZER
+#  endif
+# endif
+#endif
+
+
+/* The new name for the inline macro.  */
+#define GPGRT_INLINE GPG_ERR_INLINE
+
+#ifdef GPGRT_HAVE_LEAK_SANITIZER
+# include <sanitizer/lsan_interface.h>
+#endif
+
+/* Mark heap objects as non-leaked memory. */
+static GPGRT_INLINE void
+gpgrt_annotate_leaked_object (const void *p)
+{
+#ifdef GPGRT_HAVE_LEAK_SANITIZER
+  __lsan_ignore_object(p);
+#else
+  (void)p;
+#endif
+}
+
+
+/* Initialization function.  */
+
+/* Initialize the library.  This function should be run early.  */
+gpg_error_t gpg_err_init (void) _GPG_ERR_CONSTRUCTOR;
+
+/* If this is defined, the library is already initialized by the
+   constructor and does not need to be initialized explicitely.  */
+#undef GPG_ERR_INITIALIZED
+#ifdef _GPG_ERR_HAVE_CONSTRUCTOR
+# define GPG_ERR_INITIALIZED	1
+# define gpgrt_init() do { gpg_err_init (); } while (0)
+#else
+# define gpgrt_init() do { ; } while (0)
+#endif
+
+/* See the source on how to use the deinit function; it is usually not
+   required.  */
+void gpg_err_deinit (int mode);
+
+/* Register blocking system I/O clamping functions.  */
+void gpgrt_set_syscall_clamp (void (*pre)(void), void (*post)(void));
+
+/* Get current I/O clamping functions.  */
+void gpgrt_get_syscall_clamp (void (**r_pre)(void), void (**r_post)(void));
+
+/* Register a custom malloc/realloc/free function.  */
+void gpgrt_set_alloc_func  (void *(*f)(void *a, size_t n));
+
+
+
+/* Constructor and accessor functions.  */
+
+/* Construct an error value from an error code and source.  Within a
+   subsystem, use gpg_error.  */
+static GPG_ERR_INLINE gpg_error_t
+gpg_err_make (gpg_err_source_t source, gpg_err_code_t code)
+{
+  return code == GPG_ERR_NO_ERROR ? GPG_ERR_NO_ERROR
+    : (((source & GPG_ERR_SOURCE_MASK) << GPG_ERR_SOURCE_SHIFT)
+       | (code & GPG_ERR_CODE_MASK));
+}
+
+
+/* The user should define GPG_ERR_SOURCE_DEFAULT before including this
+   file to specify a default source for gpg_error.  */
+#ifndef GPG_ERR_SOURCE_DEFAULT
+#define GPG_ERR_SOURCE_DEFAULT	GPG_ERR_SOURCE_UNKNOWN
+#endif
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error (gpg_err_code_t code)
+{
+  return gpg_err_make (GPG_ERR_SOURCE_DEFAULT, code);
+}
+
+
+/* Retrieve the error code from an error value.  */
+static GPG_ERR_INLINE gpg_err_code_t
+gpg_err_code (gpg_error_t err)
+{
+  return (gpg_err_code_t) (err & GPG_ERR_CODE_MASK);
+}
+
+
+/* Retrieve the error source from an error value.  */
+static GPG_ERR_INLINE gpg_err_source_t
+gpg_err_source (gpg_error_t err)
+{
+  return (gpg_err_source_t) ((err >> GPG_ERR_SOURCE_SHIFT)
+			     & GPG_ERR_SOURCE_MASK);
+}
+
+
+/* String functions.  */
+
+/* Return a pointer to a string containing a description of the error
+   code in the error value ERR.  This function is not thread-safe.  */
+const char *gpg_strerror (gpg_error_t err);
+
+/* Return the error string for ERR in the user-supplied buffer BUF of
+   size BUFLEN.  This function is, in contrast to gpg_strerror,
+   thread-safe if a thread-safe strerror_r() function is provided by
+   the system.  If the function succeeds, 0 is returned and BUF
+   contains the string describing the error.  If the buffer was not
+   large enough, ERANGE is returned and BUF contains as much of the
+   beginning of the error string as fits into the buffer.  */
+int gpg_strerror_r (gpg_error_t err, char *buf, size_t buflen);
+
+/* Return a pointer to a string containing a description of the error
+   source in the error value ERR.  */
+const char *gpg_strsource (gpg_error_t err);
+
+
+/* Mapping of system errors (errno).  */
+
+/* Retrieve the error code for the system error ERR.  This returns
+   GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped (report
+   this). */
+gpg_err_code_t gpg_err_code_from_errno (int err);
+
+
+/* Retrieve the system error for the error code CODE.  This returns 0
+   if CODE is not a system error code.  */
+int gpg_err_code_to_errno (gpg_err_code_t code);
+
+
+/* Retrieve the error code directly from the ERRNO variable.  This
+   returns GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped
+   (report this) and GPG_ERR_MISSING_ERRNO if ERRNO has the value 0. */
+gpg_err_code_t gpg_err_code_from_syserror (void);
+
+
+/* Set the ERRNO variable.  This function is the preferred way to set
+   ERRNO due to peculiarities on WindowsCE.  */
+void gpg_err_set_errno (int err);
+
+/* Return or check the version.  Both functions are identical.  */
+const char *gpgrt_check_version (const char *req_version);
+const char *gpg_error_check_version (const char *req_version);
+
+/* System specific type definitions.  */
+#include <sys/types.h>
+typedef ssize_t gpgrt_ssize_t;
+
+typedef long gpgrt_off_t;
+
+
+
+
+/* Self-documenting convenience functions.  */
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_err_make_from_errno (gpg_err_source_t source, int err)
+{
+  return gpg_err_make (source, gpg_err_code_from_errno (err));
+}
+
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error_from_errno (int err)
+{
+  return gpg_error (gpg_err_code_from_errno (err));
+}
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error_from_syserror (void)
+{
+  return gpg_error (gpg_err_code_from_syserror ());
+}
+
+
+
+/* Lock functions.  */
+
+
+typedef struct
+{
+  long _vers;
+  union {
+    volatile char _priv[40];
+    long _x_align;
+    long *_xp_align;
+  } u;
+} gpgrt_lock_t;
+
+#define GPGRT_LOCK_INITIALIZER {1,{{0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0}}}
+
+
+#define GPGRT_LOCK_DEFINE(name) \
+  static gpgrt_lock_t name  = GPGRT_LOCK_INITIALIZER
+
+/* NB: If GPGRT_LOCK_DEFINE is not used, zero out the lock variable
+   before passing it to gpgrt_lock_init.  */
+gpg_err_code_t gpgrt_lock_init (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_lock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_trylock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_unlock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_destroy (gpgrt_lock_t *lockhd);
+
+
+
+/* Thread functions.  */
+
+gpg_err_code_t gpgrt_yield (void);
+
+
+
+
+/* Estream */
+
+/* The definition of this struct is entirely private.  You must not
+   use it for anything.  It is only here so some functions can be
+   implemented as macros.  */
+struct _gpgrt_stream_internal;
+struct _gpgrt__stream
+{
+  /* The layout of this struct must never change.  It may be grown,
+     but only if all functions which access the new members are
+     versioned.  */
+
+  /* Various flags.  */
+  struct {
+    unsigned int magic: 16;
+    unsigned int writing: 1;
+    unsigned int reserved: 15;
+  } flags;
+
+  /* A pointer to the stream buffer.  */
+  unsigned char *buffer;
+
+  /* The size of the buffer in bytes.  */
+  size_t buffer_size;
+
+  /* The length of the usable data in the buffer, only valid when in
+     read mode (see flags).  */
+  size_t data_len;
+
+  /* The current position of the offset pointer, valid in read and
+     write mode.  */
+  size_t data_offset;
+
+  size_t data_flushed;
+  unsigned char *unread_buffer;
+  size_t unread_buffer_size;
+
+  /* The number of unread bytes.  */
+  size_t unread_data_len;
+
+  /* A pointer to our internal data for this stream.  */
+  struct _gpgrt_stream_internal *intern;
+};
+
+/* The opaque type for an estream.  */
+typedef struct _gpgrt__stream *gpgrt_stream_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt__stream *estream_t;
+#endif
+
+typedef ssize_t (*gpgrt_cookie_read_function_t) (void *cookie,
+                                                 void *buffer, size_t size);
+typedef ssize_t (*gpgrt_cookie_write_function_t) (void *cookie,
+                                                  const void *buffer,
+                                                  size_t size);
+typedef int (*gpgrt_cookie_seek_function_t) (void *cookie,
+                                             gpgrt_off_t *pos, int whence);
+typedef int (*gpgrt_cookie_close_function_t) (void *cookie);
+
+struct _gpgrt_cookie_io_functions
+{
+  gpgrt_cookie_read_function_t func_read;
+  gpgrt_cookie_write_function_t func_write;
+  gpgrt_cookie_seek_function_t func_seek;
+  gpgrt_cookie_close_function_t func_close;
+};
+typedef struct _gpgrt_cookie_io_functions gpgrt_cookie_io_functions_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_cookie_io_functions  es_cookie_io_functions_t;
+#define es_cookie_read_function_t  gpgrt_cookie_read_function_t
+#define es_cookie_write_function_t gpgrt_cookie_read_function_t
+#define es_cookie_seek_function_t  gpgrt_cookie_read_function_t
+#define es_cookie_close_function_t gpgrt_cookie_read_function_t
+#endif
+
+enum gpgrt_syshd_types
+  {
+    GPGRT_SYSHD_NONE = 0,  /* No system handle available.                   */
+    GPGRT_SYSHD_FD = 1,    /* A file descriptor as returned by open().      */
+    GPGRT_SYSHD_SOCK = 2,  /* A socket as returned by socket().             */
+    GPGRT_SYSHD_RVID = 3,  /* A rendezvous id (see libassuan's gpgcedev.c).  */
+    GPGRT_SYSHD_HANDLE = 4 /* A HANDLE object (Windows).                    */
+  };
+
+struct _gpgrt_syshd
+{
+  enum gpgrt_syshd_types type;
+  union {
+    int fd;
+    int sock;
+    int rvid;
+    void *handle;
+  } u;
+};
+typedef struct _gpgrt_syshd gpgrt_syshd_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_syshd es_syshd_t;
+#define ES_SYSHD_NONE   GPGRT_SYSHD_NONE
+#define ES_SYSHD_FD     GPGRT_SYSHD_FD
+#define ES_SYSHD_SOCK   GPGRT_SYSHD_SOCK
+#define ES_SYSHD_RVID   GPGRT_SYSHD_RVID
+#define ES_SYSHD_HANDLE GPGRT_SYSHD_HANDLE
+#endif
+
+/* The object used with gpgrt_poll.  */
+struct _gpgrt_poll_s
+{
+  gpgrt_stream_t stream;
+  unsigned int want_read:1;
+  unsigned int want_write:1;
+  unsigned int want_oob:1;
+  unsigned int want_rdhup:1;
+  unsigned int _reserv1:4;
+  unsigned int got_read:1;
+  unsigned int got_write:1;
+  unsigned int got_oob:1;
+  unsigned int got_rdhup:1;
+  unsigned int _reserv2:4;
+  unsigned int got_err:1;
+  unsigned int got_hup:1;
+  unsigned int got_nval:1;
+  unsigned int _reserv3:4;
+  unsigned int ignore:1;
+  unsigned int user:8;       /* For application use.  */
+};
+typedef struct _gpgrt_poll_s gpgrt_poll_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_poll_s es_poll_t;
+#endif
+
+gpgrt_stream_t gpgrt_fopen (const char *_GPGRT__RESTRICT path,
+                            const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_mopen (void *_GPGRT__RESTRICT data,
+                            size_t data_n, size_t data_len,
+                            unsigned int grow,
+                            void *(*func_realloc) (void *mem, size_t size),
+                            void (*func_free) (void *mem),
+                            const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_fopenmem (size_t memlimit,
+                               const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_fopenmem_init (size_t memlimit,
+                                    const char *_GPGRT__RESTRICT mode,
+                                    const void *data, size_t datalen);
+gpgrt_stream_t gpgrt_fdopen    (int filedes, const char *mode);
+gpgrt_stream_t gpgrt_fdopen_nc (int filedes, const char *mode);
+gpgrt_stream_t gpgrt_sysopen    (gpgrt_syshd_t *syshd, const char *mode);
+gpgrt_stream_t gpgrt_sysopen_nc (gpgrt_syshd_t *syshd, const char *mode);
+gpgrt_stream_t gpgrt_fpopen    (FILE *fp, const char *mode);
+gpgrt_stream_t gpgrt_fpopen_nc (FILE *fp, const char *mode);
+gpgrt_stream_t gpgrt_freopen (const char *_GPGRT__RESTRICT path,
+                              const char *_GPGRT__RESTRICT mode,
+                              gpgrt_stream_t _GPGRT__RESTRICT stream);
+gpgrt_stream_t gpgrt_fopencookie (void *_GPGRT__RESTRICT cookie,
+                                  const char *_GPGRT__RESTRICT mode,
+                                  gpgrt_cookie_io_functions_t functions);
+int gpgrt_fclose (gpgrt_stream_t stream);
+int gpgrt_fclose_snatch (gpgrt_stream_t stream,
+                         void **r_buffer, size_t *r_buflen);
+int gpgrt_onclose (gpgrt_stream_t stream, int mode,
+                   void (*fnc) (gpgrt_stream_t, void*), void *fnc_value);
+int gpgrt_fileno (gpgrt_stream_t stream);
+int gpgrt_fileno_unlocked (gpgrt_stream_t stream);
+int gpgrt_syshd (gpgrt_stream_t stream, gpgrt_syshd_t *syshd);
+int gpgrt_syshd_unlocked (gpgrt_stream_t stream, gpgrt_syshd_t *syshd);
+
+void _gpgrt_set_std_fd (int no, int fd);
+gpgrt_stream_t _gpgrt_get_std_stream (int fd);
+
+#define gpgrt_stdin  _gpgrt_get_std_stream (0)
+#define gpgrt_stdout _gpgrt_get_std_stream (1)
+#define gpgrt_stderr _gpgrt_get_std_stream (2)
+
+
+void gpgrt_flockfile (gpgrt_stream_t stream);
+int  gpgrt_ftrylockfile (gpgrt_stream_t stream);
+void gpgrt_funlockfile (gpgrt_stream_t stream);
+
+int gpgrt_feof (gpgrt_stream_t stream);
+int gpgrt_feof_unlocked (gpgrt_stream_t stream);
+int gpgrt_ferror (gpgrt_stream_t stream);
+int gpgrt_ferror_unlocked (gpgrt_stream_t stream);
+void gpgrt_clearerr (gpgrt_stream_t stream);
+void gpgrt_clearerr_unlocked (gpgrt_stream_t stream);
+
+int _gpgrt_pending (gpgrt_stream_t stream);          /* (private) */
+int _gpgrt_pending_unlocked (gpgrt_stream_t stream); /* (private) */
+
+#define gpgrt_pending(stream) _gpgrt_pending (stream)
+
+#define gpgrt_pending_unlocked(stream)				\
+  (((!(stream)->flags.writing)					\
+    && (((stream)->data_offset < (stream)->data_len)		\
+        || ((stream)->unread_data_len)))                        \
+   ? 1 : _gpgrt_pending_unlocked ((stream)))
+
+int gpgrt_fflush (gpgrt_stream_t stream);
+int gpgrt_fseek (gpgrt_stream_t stream, long int offset, int whence);
+int gpgrt_fseeko (gpgrt_stream_t stream, gpgrt_off_t offset, int whence);
+long int gpgrt_ftell (gpgrt_stream_t stream);
+gpgrt_off_t gpgrt_ftello (gpgrt_stream_t stream);
+void gpgrt_rewind (gpgrt_stream_t stream);
+
+int gpgrt_fgetc (gpgrt_stream_t stream);
+int gpgrt_fputc (int c, gpgrt_stream_t stream);
+
+int _gpgrt_getc_underflow (gpgrt_stream_t stream);       /* (private) */
+int _gpgrt_putc_overflow (int c, gpgrt_stream_t stream); /* (private) */
+
+#define gpgrt_getc_unlocked(stream)				\
+  (((!(stream)->flags.writing)					\
+    && ((stream)->data_offset < (stream)->data_len)		\
+    && (! (stream)->unread_data_len))				\
+  ? ((int) (stream)->buffer[((stream)->data_offset)++])		\
+  : _gpgrt_getc_underflow ((stream)))
+
+#define gpgrt_putc_unlocked(c, stream)				\
+  (((stream)->flags.writing					\
+    && ((stream)->data_offset < (stream)->buffer_size)		\
+    && (c != '\n'))						\
+  ? ((int) ((stream)->buffer[((stream)->data_offset)++] = (c)))	\
+  : _gpgrt_putc_overflow ((c), (stream)))
+
+#define gpgrt_getc(stream)    gpgrt_fgetc (stream)
+#define gpgrt_putc(c, stream) gpgrt_fputc (c, stream)
+
+int gpgrt_ungetc (int c, gpgrt_stream_t stream);
+
+int gpgrt_read (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                void *_GPGRT__RESTRICT buffer, size_t bytes_to_read,
+                size_t *_GPGRT__RESTRICT bytes_read);
+int gpgrt_write (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                 const void *_GPGRT__RESTRICT buffer, size_t bytes_to_write,
+                 size_t *_GPGRT__RESTRICT bytes_written);
+int gpgrt_write_sanitized (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                           const void *_GPGRT__RESTRICT buffer, size_t length,
+                           const char *delimiters,
+                           size_t *_GPGRT__RESTRICT bytes_written);
+int gpgrt_write_hexstring (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                           const void *_GPGRT__RESTRICT buffer, size_t length,
+                           int reserved,
+                           size_t *_GPGRT__RESTRICT bytes_written);
+
+size_t gpgrt_fread (void *_GPGRT__RESTRICT ptr, size_t size, size_t nitems,
+                    gpgrt_stream_t _GPGRT__RESTRICT stream);
+size_t gpgrt_fwrite (const void *_GPGRT__RESTRICT ptr, size_t size, size_t memb,
+                     gpgrt_stream_t _GPGRT__RESTRICT stream);
+
+char *gpgrt_fgets (char *_GPGRT__RESTRICT s, int n,
+                   gpgrt_stream_t _GPGRT__RESTRICT stream);
+int gpgrt_fputs (const char *_GPGRT__RESTRICT s,
+                 gpgrt_stream_t _GPGRT__RESTRICT stream);
+int gpgrt_fputs_unlocked (const char *_GPGRT__RESTRICT s,
+                          gpgrt_stream_t _GPGRT__RESTRICT stream);
+
+ssize_t gpgrt_getline (char *_GPGRT__RESTRICT *_GPGRT__RESTRICT lineptr,
+                       size_t *_GPGRT__RESTRICT n,
+                       gpgrt_stream_t stream);
+ssize_t gpgrt_read_line (gpgrt_stream_t stream,
+                         char **addr_of_buffer, size_t *length_of_buffer,
+                         size_t *max_length);
+void gpgrt_free (void *a);
+
+int gpgrt_fprintf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   const char *_GPGRT__RESTRICT format, ...)
+                   GPGRT_ATTR_PRINTF(2,3);
+int gpgrt_fprintf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                            const char *_GPGRT__RESTRICT format, ...)
+                            GPGRT_ATTR_PRINTF(2,3);
+
+int gpgrt_printf (const char *_GPGRT__RESTRICT format, ...)
+                  GPGRT_ATTR_PRINTF(1,2);
+int gpgrt_printf_unlocked (const char *_GPGRT__RESTRICT format, ...)
+                           GPGRT_ATTR_PRINTF(1,2);
+
+int gpgrt_vfprintf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                    const char *_GPGRT__RESTRICT format, va_list ap)
+                    GPGRT_ATTR_PRINTF(2,0);
+int gpgrt_vfprintf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                             const char *_GPGRT__RESTRICT format, va_list ap)
+                             GPGRT_ATTR_PRINTF(2,0);
+
+int gpgrt_setvbuf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   char *_GPGRT__RESTRICT buf, int mode, size_t size);
+void gpgrt_setbuf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   char *_GPGRT__RESTRICT buf);
+
+void gpgrt_set_binary (gpgrt_stream_t stream);
+int  gpgrt_set_nonblock (gpgrt_stream_t stream, int onoff);
+int  gpgrt_get_nonblock (gpgrt_stream_t stream);
+
+int gpgrt_poll (gpgrt_poll_t *fdlist, unsigned int nfds, int timeout);
+
+gpgrt_stream_t gpgrt_tmpfile (void);
+
+void gpgrt_opaque_set (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                       void *_GPGRT__RESTRICT opaque);
+void *gpgrt_opaque_get (gpgrt_stream_t stream);
+
+void gpgrt_fname_set (gpgrt_stream_t stream, const char *fname);
+const char *gpgrt_fname_get (gpgrt_stream_t stream);
+
+int gpgrt_asprintf (char **r_buf, const char * _GPGRT__RESTRICT format, ...)
+                    GPGRT_ATTR_PRINTF(2,3);
+int gpgrt_vasprintf (char **r_buf, const char * _GPGRT__RESTRICT format,
+                     va_list ap)
+                     GPGRT_ATTR_PRINTF(2,0);
+char *gpgrt_bsprintf (const char * _GPGRT__RESTRICT format, ...)
+                      GPGRT_ATTR_PRINTF(1,2);
+char *gpgrt_vbsprintf (const char * _GPGRT__RESTRICT format, va_list ap)
+                       GPGRT_ATTR_PRINTF(1,0);
+int gpgrt_snprintf (char *buf, size_t bufsize,
+                    const char * _GPGRT__RESTRICT format, ...)
+                    GPGRT_ATTR_PRINTF(3,4);
+int gpgrt_vsnprintf (char *buf,size_t bufsize,
+                     const char * _GPGRT__RESTRICT format, va_list arg_ptr)
+                     GPGRT_ATTR_PRINTF(3,0);
+
+
+#ifdef GPGRT_ENABLE_ES_MACROS
+# define es_fopen             gpgrt_fopen
+# define es_mopen             gpgrt_mopen
+# define es_fopenmem          gpgrt_fopenmem
+# define es_fopenmem_init     gpgrt_fopenmem_init
+# define es_fdopen            gpgrt_fdopen
+# define es_fdopen_nc         gpgrt_fdopen_nc
+# define es_sysopen           gpgrt_sysopen
+# define es_sysopen_nc        gpgrt_sysopen_nc
+# define es_fpopen            gpgrt_fpopen
+# define es_fpopen_nc         gpgrt_fpopen_nc
+# define es_freopen           gpgrt_freopen
+# define es_fopencookie       gpgrt_fopencookie
+# define es_fclose            gpgrt_fclose
+# define es_fclose_snatch     gpgrt_fclose_snatch
+# define es_onclose           gpgrt_onclose
+# define es_fileno            gpgrt_fileno
+# define es_fileno_unlocked   gpgrt_fileno_unlocked
+# define es_syshd             gpgrt_syshd
+# define es_syshd_unlocked    gpgrt_syshd_unlocked
+# define es_stdin             _gpgrt_get_std_stream (0)
+# define es_stdout            _gpgrt_get_std_stream (1)
+# define es_stderr            _gpgrt_get_std_stream (2)
+# define es_flockfile         gpgrt_flockfile
+# define es_ftrylockfile      gpgrt_ftrylockfile
+# define es_funlockfile       gpgrt_funlockfile
+# define es_feof              gpgrt_feof
+# define es_feof_unlocked     gpgrt_feof_unlocked
+# define es_ferror            gpgrt_ferror
+# define es_ferror_unlocked   gpgrt_ferror_unlocked
+# define es_clearerr          gpgrt_clearerr
+# define es_clearerr_unlocked gpgrt_clearerr_unlocked
+# define es_pending           gpgrt_pending
+# define es_pending_unlocked  gpgrt_pending_unlocked
+# define es_fflush            gpgrt_fflush
+# define es_fseek             gpgrt_fseek
+# define es_fseeko            gpgrt_fseeko
+# define es_ftell             gpgrt_ftell
+# define es_ftello            gpgrt_ftello
+# define es_rewind            gpgrt_rewind
+# define es_fgetc             gpgrt_fgetc
+# define es_fputc             gpgrt_fputc
+# define es_getc_unlocked     gpgrt_getc_unlocked
+# define es_putc_unlocked     gpgrt_putc_unlocked
+# define es_getc              gpgrt_getc
+# define es_putc              gpgrt_putc
+# define es_ungetc            gpgrt_ungetc
+# define es_read              gpgrt_read
+# define es_write             gpgrt_write
+# define es_write_sanitized   gpgrt_write_sanitized
+# define es_write_hexstring   gpgrt_write_hexstring
+# define es_fread             gpgrt_fread
+# define es_fwrite            gpgrt_fwrite
+# define es_fgets             gpgrt_fgets
+# define es_fputs             gpgrt_fputs
+# define es_fputs_unlocked    gpgrt_fputs_unlocked
+# define es_getline           gpgrt_getline
+# define es_read_line         gpgrt_read_line
+# define es_free              gpgrt_free
+# define es_fprintf           gpgrt_fprintf
+# define es_fprintf_unlocked  gpgrt_fprintf_unlocked
+# define es_printf            gpgrt_printf
+# define es_printf_unlocked   gpgrt_printf_unlocked
+# define es_vfprintf          gpgrt_vfprintf
+# define es_vfprintf_unlocked gpgrt_vfprintf_unlocked
+# define es_setvbuf           gpgrt_setvbuf
+# define es_setbuf            gpgrt_setbuf
+# define es_set_binary        gpgrt_set_binary
+# define es_set_nonblock      gpgrt_set_nonblock
+# define es_get_nonblock      gpgrt_get_nonblock
+# define es_poll              gpgrt_poll
+# define es_tmpfile           gpgrt_tmpfile
+# define es_opaque_set        gpgrt_opaque_set
+# define es_opaque_get        gpgrt_opaque_get
+# define es_fname_set         gpgrt_fname_set
+# define es_fname_get         gpgrt_fname_get
+# define es_asprintf          gpgrt_asprintf
+# define es_vasprintf         gpgrt_vasprintf
+# define es_bsprintf          gpgrt_bsprintf
+# define es_vbsprintf         gpgrt_vbsprintf
+#endif /*GPGRT_ENABLE_ES_MACROS*/
+
+/* Base64 decode functions.  */
+
+struct _gpgrt_b64state;
+typedef struct _gpgrt_b64state *gpgrt_b64state_t;
+
+gpgrt_b64state_t gpgrt_b64dec_start (const char *title);
+gpg_error_t gpgrt_b64dec_proc (gpgrt_b64state_t state,
+                               void *buffer, size_t length, size_t *r_nbytes);
+gpg_error_t gpgrt_b64dec_finish (gpgrt_b64state_t state);
+
+#ifdef __cplusplus
+}
+#endif
+#endif	/* GPGRT_H */
+#endif	/* GPG_ERROR_H */
+/*
+Local Variables:
+buffer-read-only: t
+End:
+*/
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/gpgrt.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/gpgrt.h
new file mode 100644
index 000000000..137ff14b0
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/gpgrt.h
@@ -0,0 +1,1462 @@
+/* gpg-error.h or gpgrt.h - Public interface to libgpg-error.   -*- c -*-
+ * Copyright (C) 2003-2004, 2010, 2013-2017 g10 Code GmbH
+ *
+ * This file is part of libgpg-error.
+ *
+ * libgpg-error is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * libgpg-error is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, see <https://www.gnu.org/licenses/>.
+ *
+ * Do not edit.  Generated from gpg-error.h.in for:
+                 powerpc64le-unknown-linux-gnu
+ */
+
+#ifndef GPG_ERROR_H
+#define GPG_ERROR_H 1
+#ifndef GPGRT_H
+#define GPGRT_H 1
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+/* The version string of this header. */
+#define GPG_ERROR_VERSION "1.27"
+#define GPGRT_VERSION     "1.27"
+
+/* The version number of this header. */
+#define GPG_ERROR_VERSION_NUMBER 0x011b00
+#define GPGRT_VERSION_NUMBER     0x011b00
+
+
+#ifdef __GNUC__
+# define GPG_ERR_INLINE __inline__
+#elif defined(_MSC_VER) && _MSC_VER >= 1300
+# define GPG_ERR_INLINE __inline
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+# define GPG_ERR_INLINE inline
+#else
+# ifndef GPG_ERR_INLINE
+#  define GPG_ERR_INLINE
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+#endif /* __cplusplus */
+
+/* The GnuPG project consists of many components.  Error codes are
+   exchanged between all components.  The common error codes and their
+   user-presentable descriptions are kept into a shared library to
+   allow adding new error codes and components without recompiling any
+   of the other components.  The interface will not change in a
+   backward incompatible way.
+
+   An error code together with an error source build up an error
+   value.  As the error value is been passed from one component to
+   another, it preserver the information about the source and nature
+   of the error.
+
+   A component of the GnuPG project can define the following macros to
+   tune the behaviour of the library:
+
+   GPG_ERR_SOURCE_DEFAULT: Define to an error source of type
+   gpg_err_source_t to make that source the default for gpg_error().
+   Otherwise GPG_ERR_SOURCE_UNKNOWN is used as default.
+
+   GPG_ERR_ENABLE_GETTEXT_MACROS: Define to provide macros to map the
+   internal gettext API to standard names.  This has only an effect on
+   Windows platforms.
+
+   GPGRT_ENABLE_ES_MACROS: Define to provide "es_" macros for the
+   estream functions.
+
+   In addition to the error codes, Libgpg-error also provides a set of
+   functions used by most GnuPG components.  */
+
+
+/* The error source type gpg_err_source_t.
+
+   Where as the Poo out of a welle small
+   Taketh his firste springing and his sours.
+					--Chaucer.  */
+
+/* Only use free slots, never change or reorder the existing
+   entries.  */
+typedef enum
+  {
+    GPG_ERR_SOURCE_UNKNOWN = 0,
+    GPG_ERR_SOURCE_GCRYPT = 1,
+    GPG_ERR_SOURCE_GPG = 2,
+    GPG_ERR_SOURCE_GPGSM = 3,
+    GPG_ERR_SOURCE_GPGAGENT = 4,
+    GPG_ERR_SOURCE_PINENTRY = 5,
+    GPG_ERR_SOURCE_SCD = 6,
+    GPG_ERR_SOURCE_GPGME = 7,
+    GPG_ERR_SOURCE_KEYBOX = 8,
+    GPG_ERR_SOURCE_KSBA = 9,
+    GPG_ERR_SOURCE_DIRMNGR = 10,
+    GPG_ERR_SOURCE_GSTI = 11,
+    GPG_ERR_SOURCE_GPA = 12,
+    GPG_ERR_SOURCE_KLEO = 13,
+    GPG_ERR_SOURCE_G13 = 14,
+    GPG_ERR_SOURCE_ASSUAN = 15,
+    GPG_ERR_SOURCE_TLS = 17,
+    GPG_ERR_SOURCE_ANY = 31,
+    GPG_ERR_SOURCE_USER_1 = 32,
+    GPG_ERR_SOURCE_USER_2 = 33,
+    GPG_ERR_SOURCE_USER_3 = 34,
+    GPG_ERR_SOURCE_USER_4 = 35,
+
+    /* This is one more than the largest allowed entry.  */
+    GPG_ERR_SOURCE_DIM = 128
+  } gpg_err_source_t;
+
+
+/* The error code type gpg_err_code_t.  */
+
+/* Only use free slots, never change or reorder the existing
+   entries.  */
+typedef enum
+  {
+    GPG_ERR_NO_ERROR = 0,
+    GPG_ERR_GENERAL = 1,
+    GPG_ERR_UNKNOWN_PACKET = 2,
+    GPG_ERR_UNKNOWN_VERSION = 3,
+    GPG_ERR_PUBKEY_ALGO = 4,
+    GPG_ERR_DIGEST_ALGO = 5,
+    GPG_ERR_BAD_PUBKEY = 6,
+    GPG_ERR_BAD_SECKEY = 7,
+    GPG_ERR_BAD_SIGNATURE = 8,
+    GPG_ERR_NO_PUBKEY = 9,
+    GPG_ERR_CHECKSUM = 10,
+    GPG_ERR_BAD_PASSPHRASE = 11,
+    GPG_ERR_CIPHER_ALGO = 12,
+    GPG_ERR_KEYRING_OPEN = 13,
+    GPG_ERR_INV_PACKET = 14,
+    GPG_ERR_INV_ARMOR = 15,
+    GPG_ERR_NO_USER_ID = 16,
+    GPG_ERR_NO_SECKEY = 17,
+    GPG_ERR_WRONG_SECKEY = 18,
+    GPG_ERR_BAD_KEY = 19,
+    GPG_ERR_COMPR_ALGO = 20,
+    GPG_ERR_NO_PRIME = 21,
+    GPG_ERR_NO_ENCODING_METHOD = 22,
+    GPG_ERR_NO_ENCRYPTION_SCHEME = 23,
+    GPG_ERR_NO_SIGNATURE_SCHEME = 24,
+    GPG_ERR_INV_ATTR = 25,
+    GPG_ERR_NO_VALUE = 26,
+    GPG_ERR_NOT_FOUND = 27,
+    GPG_ERR_VALUE_NOT_FOUND = 28,
+    GPG_ERR_SYNTAX = 29,
+    GPG_ERR_BAD_MPI = 30,
+    GPG_ERR_INV_PASSPHRASE = 31,
+    GPG_ERR_SIG_CLASS = 32,
+    GPG_ERR_RESOURCE_LIMIT = 33,
+    GPG_ERR_INV_KEYRING = 34,
+    GPG_ERR_TRUSTDB = 35,
+    GPG_ERR_BAD_CERT = 36,
+    GPG_ERR_INV_USER_ID = 37,
+    GPG_ERR_UNEXPECTED = 38,
+    GPG_ERR_TIME_CONFLICT = 39,
+    GPG_ERR_KEYSERVER = 40,
+    GPG_ERR_WRONG_PUBKEY_ALGO = 41,
+    GPG_ERR_TRIBUTE_TO_D_A = 42,
+    GPG_ERR_WEAK_KEY = 43,
+    GPG_ERR_INV_KEYLEN = 44,
+    GPG_ERR_INV_ARG = 45,
+    GPG_ERR_BAD_URI = 46,
+    GPG_ERR_INV_URI = 47,
+    GPG_ERR_NETWORK = 48,
+    GPG_ERR_UNKNOWN_HOST = 49,
+    GPG_ERR_SELFTEST_FAILED = 50,
+    GPG_ERR_NOT_ENCRYPTED = 51,
+    GPG_ERR_NOT_PROCESSED = 52,
+    GPG_ERR_UNUSABLE_PUBKEY = 53,
+    GPG_ERR_UNUSABLE_SECKEY = 54,
+    GPG_ERR_INV_VALUE = 55,
+    GPG_ERR_BAD_CERT_CHAIN = 56,
+    GPG_ERR_MISSING_CERT = 57,
+    GPG_ERR_NO_DATA = 58,
+    GPG_ERR_BUG = 59,
+    GPG_ERR_NOT_SUPPORTED = 60,
+    GPG_ERR_INV_OP = 61,
+    GPG_ERR_TIMEOUT = 62,
+    GPG_ERR_INTERNAL = 63,
+    GPG_ERR_EOF_GCRYPT = 64,
+    GPG_ERR_INV_OBJ = 65,
+    GPG_ERR_TOO_SHORT = 66,
+    GPG_ERR_TOO_LARGE = 67,
+    GPG_ERR_NO_OBJ = 68,
+    GPG_ERR_NOT_IMPLEMENTED = 69,
+    GPG_ERR_CONFLICT = 70,
+    GPG_ERR_INV_CIPHER_MODE = 71,
+    GPG_ERR_INV_FLAG = 72,
+    GPG_ERR_INV_HANDLE = 73,
+    GPG_ERR_TRUNCATED = 74,
+    GPG_ERR_INCOMPLETE_LINE = 75,
+    GPG_ERR_INV_RESPONSE = 76,
+    GPG_ERR_NO_AGENT = 77,
+    GPG_ERR_AGENT = 78,
+    GPG_ERR_INV_DATA = 79,
+    GPG_ERR_ASSUAN_SERVER_FAULT = 80,
+    GPG_ERR_ASSUAN = 81,
+    GPG_ERR_INV_SESSION_KEY = 82,
+    GPG_ERR_INV_SEXP = 83,
+    GPG_ERR_UNSUPPORTED_ALGORITHM = 84,
+    GPG_ERR_NO_PIN_ENTRY = 85,
+    GPG_ERR_PIN_ENTRY = 86,
+    GPG_ERR_BAD_PIN = 87,
+    GPG_ERR_INV_NAME = 88,
+    GPG_ERR_BAD_DATA = 89,
+    GPG_ERR_INV_PARAMETER = 90,
+    GPG_ERR_WRONG_CARD = 91,
+    GPG_ERR_NO_DIRMNGR = 92,
+    GPG_ERR_DIRMNGR = 93,
+    GPG_ERR_CERT_REVOKED = 94,
+    GPG_ERR_NO_CRL_KNOWN = 95,
+    GPG_ERR_CRL_TOO_OLD = 96,
+    GPG_ERR_LINE_TOO_LONG = 97,
+    GPG_ERR_NOT_TRUSTED = 98,
+    GPG_ERR_CANCELED = 99,
+    GPG_ERR_BAD_CA_CERT = 100,
+    GPG_ERR_CERT_EXPIRED = 101,
+    GPG_ERR_CERT_TOO_YOUNG = 102,
+    GPG_ERR_UNSUPPORTED_CERT = 103,
+    GPG_ERR_UNKNOWN_SEXP = 104,
+    GPG_ERR_UNSUPPORTED_PROTECTION = 105,
+    GPG_ERR_CORRUPTED_PROTECTION = 106,
+    GPG_ERR_AMBIGUOUS_NAME = 107,
+    GPG_ERR_CARD = 108,
+    GPG_ERR_CARD_RESET = 109,
+    GPG_ERR_CARD_REMOVED = 110,
+    GPG_ERR_INV_CARD = 111,
+    GPG_ERR_CARD_NOT_PRESENT = 112,
+    GPG_ERR_NO_PKCS15_APP = 113,
+    GPG_ERR_NOT_CONFIRMED = 114,
+    GPG_ERR_CONFIGURATION = 115,
+    GPG_ERR_NO_POLICY_MATCH = 116,
+    GPG_ERR_INV_INDEX = 117,
+    GPG_ERR_INV_ID = 118,
+    GPG_ERR_NO_SCDAEMON = 119,
+    GPG_ERR_SCDAEMON = 120,
+    GPG_ERR_UNSUPPORTED_PROTOCOL = 121,
+    GPG_ERR_BAD_PIN_METHOD = 122,
+    GPG_ERR_CARD_NOT_INITIALIZED = 123,
+    GPG_ERR_UNSUPPORTED_OPERATION = 124,
+    GPG_ERR_WRONG_KEY_USAGE = 125,
+    GPG_ERR_NOTHING_FOUND = 126,
+    GPG_ERR_WRONG_BLOB_TYPE = 127,
+    GPG_ERR_MISSING_VALUE = 128,
+    GPG_ERR_HARDWARE = 129,
+    GPG_ERR_PIN_BLOCKED = 130,
+    GPG_ERR_USE_CONDITIONS = 131,
+    GPG_ERR_PIN_NOT_SYNCED = 132,
+    GPG_ERR_INV_CRL = 133,
+    GPG_ERR_BAD_BER = 134,
+    GPG_ERR_INV_BER = 135,
+    GPG_ERR_ELEMENT_NOT_FOUND = 136,
+    GPG_ERR_IDENTIFIER_NOT_FOUND = 137,
+    GPG_ERR_INV_TAG = 138,
+    GPG_ERR_INV_LENGTH = 139,
+    GPG_ERR_INV_KEYINFO = 140,
+    GPG_ERR_UNEXPECTED_TAG = 141,
+    GPG_ERR_NOT_DER_ENCODED = 142,
+    GPG_ERR_NO_CMS_OBJ = 143,
+    GPG_ERR_INV_CMS_OBJ = 144,
+    GPG_ERR_UNKNOWN_CMS_OBJ = 145,
+    GPG_ERR_UNSUPPORTED_CMS_OBJ = 146,
+    GPG_ERR_UNSUPPORTED_ENCODING = 147,
+    GPG_ERR_UNSUPPORTED_CMS_VERSION = 148,
+    GPG_ERR_UNKNOWN_ALGORITHM = 149,
+    GPG_ERR_INV_ENGINE = 150,
+    GPG_ERR_PUBKEY_NOT_TRUSTED = 151,
+    GPG_ERR_DECRYPT_FAILED = 152,
+    GPG_ERR_KEY_EXPIRED = 153,
+    GPG_ERR_SIG_EXPIRED = 154,
+    GPG_ERR_ENCODING_PROBLEM = 155,
+    GPG_ERR_INV_STATE = 156,
+    GPG_ERR_DUP_VALUE = 157,
+    GPG_ERR_MISSING_ACTION = 158,
+    GPG_ERR_MODULE_NOT_FOUND = 159,
+    GPG_ERR_INV_OID_STRING = 160,
+    GPG_ERR_INV_TIME = 161,
+    GPG_ERR_INV_CRL_OBJ = 162,
+    GPG_ERR_UNSUPPORTED_CRL_VERSION = 163,
+    GPG_ERR_INV_CERT_OBJ = 164,
+    GPG_ERR_UNKNOWN_NAME = 165,
+    GPG_ERR_LOCALE_PROBLEM = 166,
+    GPG_ERR_NOT_LOCKED = 167,
+    GPG_ERR_PROTOCOL_VIOLATION = 168,
+    GPG_ERR_INV_MAC = 169,
+    GPG_ERR_INV_REQUEST = 170,
+    GPG_ERR_UNKNOWN_EXTN = 171,
+    GPG_ERR_UNKNOWN_CRIT_EXTN = 172,
+    GPG_ERR_LOCKED = 173,
+    GPG_ERR_UNKNOWN_OPTION = 174,
+    GPG_ERR_UNKNOWN_COMMAND = 175,
+    GPG_ERR_NOT_OPERATIONAL = 176,
+    GPG_ERR_NO_PASSPHRASE = 177,
+    GPG_ERR_NO_PIN = 178,
+    GPG_ERR_NOT_ENABLED = 179,
+    GPG_ERR_NO_ENGINE = 180,
+    GPG_ERR_MISSING_KEY = 181,
+    GPG_ERR_TOO_MANY = 182,
+    GPG_ERR_LIMIT_REACHED = 183,
+    GPG_ERR_NOT_INITIALIZED = 184,
+    GPG_ERR_MISSING_ISSUER_CERT = 185,
+    GPG_ERR_NO_KEYSERVER = 186,
+    GPG_ERR_INV_CURVE = 187,
+    GPG_ERR_UNKNOWN_CURVE = 188,
+    GPG_ERR_DUP_KEY = 189,
+    GPG_ERR_AMBIGUOUS = 190,
+    GPG_ERR_NO_CRYPT_CTX = 191,
+    GPG_ERR_WRONG_CRYPT_CTX = 192,
+    GPG_ERR_BAD_CRYPT_CTX = 193,
+    GPG_ERR_CRYPT_CTX_CONFLICT = 194,
+    GPG_ERR_BROKEN_PUBKEY = 195,
+    GPG_ERR_BROKEN_SECKEY = 196,
+    GPG_ERR_MAC_ALGO = 197,
+    GPG_ERR_FULLY_CANCELED = 198,
+    GPG_ERR_UNFINISHED = 199,
+    GPG_ERR_BUFFER_TOO_SHORT = 200,
+    GPG_ERR_SEXP_INV_LEN_SPEC = 201,
+    GPG_ERR_SEXP_STRING_TOO_LONG = 202,
+    GPG_ERR_SEXP_UNMATCHED_PAREN = 203,
+    GPG_ERR_SEXP_NOT_CANONICAL = 204,
+    GPG_ERR_SEXP_BAD_CHARACTER = 205,
+    GPG_ERR_SEXP_BAD_QUOTATION = 206,
+    GPG_ERR_SEXP_ZERO_PREFIX = 207,
+    GPG_ERR_SEXP_NESTED_DH = 208,
+    GPG_ERR_SEXP_UNMATCHED_DH = 209,
+    GPG_ERR_SEXP_UNEXPECTED_PUNC = 210,
+    GPG_ERR_SEXP_BAD_HEX_CHAR = 211,
+    GPG_ERR_SEXP_ODD_HEX_NUMBERS = 212,
+    GPG_ERR_SEXP_BAD_OCT_CHAR = 213,
+    GPG_ERR_SUBKEYS_EXP_OR_REV = 217,
+    GPG_ERR_DB_CORRUPTED = 218,
+    GPG_ERR_SERVER_FAILED = 219,
+    GPG_ERR_NO_NAME = 220,
+    GPG_ERR_NO_KEY = 221,
+    GPG_ERR_LEGACY_KEY = 222,
+    GPG_ERR_REQUEST_TOO_SHORT = 223,
+    GPG_ERR_REQUEST_TOO_LONG = 224,
+    GPG_ERR_OBJ_TERM_STATE = 225,
+    GPG_ERR_NO_CERT_CHAIN = 226,
+    GPG_ERR_CERT_TOO_LARGE = 227,
+    GPG_ERR_INV_RECORD = 228,
+    GPG_ERR_BAD_MAC = 229,
+    GPG_ERR_UNEXPECTED_MSG = 230,
+    GPG_ERR_COMPR_FAILED = 231,
+    GPG_ERR_WOULD_WRAP = 232,
+    GPG_ERR_FATAL_ALERT = 233,
+    GPG_ERR_NO_CIPHER = 234,
+    GPG_ERR_MISSING_CLIENT_CERT = 235,
+    GPG_ERR_CLOSE_NOTIFY = 236,
+    GPG_ERR_TICKET_EXPIRED = 237,
+    GPG_ERR_BAD_TICKET = 238,
+    GPG_ERR_UNKNOWN_IDENTITY = 239,
+    GPG_ERR_BAD_HS_CERT = 240,
+    GPG_ERR_BAD_HS_CERT_REQ = 241,
+    GPG_ERR_BAD_HS_CERT_VER = 242,
+    GPG_ERR_BAD_HS_CHANGE_CIPHER = 243,
+    GPG_ERR_BAD_HS_CLIENT_HELLO = 244,
+    GPG_ERR_BAD_HS_SERVER_HELLO = 245,
+    GPG_ERR_BAD_HS_SERVER_HELLO_DONE = 246,
+    GPG_ERR_BAD_HS_FINISHED = 247,
+    GPG_ERR_BAD_HS_SERVER_KEX = 248,
+    GPG_ERR_BAD_HS_CLIENT_KEX = 249,
+    GPG_ERR_BOGUS_STRING = 250,
+    GPG_ERR_FORBIDDEN = 251,
+    GPG_ERR_KEY_DISABLED = 252,
+    GPG_ERR_KEY_ON_CARD = 253,
+    GPG_ERR_INV_LOCK_OBJ = 254,
+    GPG_ERR_TRUE = 255,
+    GPG_ERR_FALSE = 256,
+    GPG_ERR_ASS_GENERAL = 257,
+    GPG_ERR_ASS_ACCEPT_FAILED = 258,
+    GPG_ERR_ASS_CONNECT_FAILED = 259,
+    GPG_ERR_ASS_INV_RESPONSE = 260,
+    GPG_ERR_ASS_INV_VALUE = 261,
+    GPG_ERR_ASS_INCOMPLETE_LINE = 262,
+    GPG_ERR_ASS_LINE_TOO_LONG = 263,
+    GPG_ERR_ASS_NESTED_COMMANDS = 264,
+    GPG_ERR_ASS_NO_DATA_CB = 265,
+    GPG_ERR_ASS_NO_INQUIRE_CB = 266,
+    GPG_ERR_ASS_NOT_A_SERVER = 267,
+    GPG_ERR_ASS_NOT_A_CLIENT = 268,
+    GPG_ERR_ASS_SERVER_START = 269,
+    GPG_ERR_ASS_READ_ERROR = 270,
+    GPG_ERR_ASS_WRITE_ERROR = 271,
+    GPG_ERR_ASS_TOO_MUCH_DATA = 273,
+    GPG_ERR_ASS_UNEXPECTED_CMD = 274,
+    GPG_ERR_ASS_UNKNOWN_CMD = 275,
+    GPG_ERR_ASS_SYNTAX = 276,
+    GPG_ERR_ASS_CANCELED = 277,
+    GPG_ERR_ASS_NO_INPUT = 278,
+    GPG_ERR_ASS_NO_OUTPUT = 279,
+    GPG_ERR_ASS_PARAMETER = 280,
+    GPG_ERR_ASS_UNKNOWN_INQUIRE = 281,
+    GPG_ERR_ENGINE_TOO_OLD = 300,
+    GPG_ERR_WINDOW_TOO_SMALL = 301,
+    GPG_ERR_WINDOW_TOO_LARGE = 302,
+    GPG_ERR_MISSING_ENVVAR = 303,
+    GPG_ERR_USER_ID_EXISTS = 304,
+    GPG_ERR_NAME_EXISTS = 305,
+    GPG_ERR_DUP_NAME = 306,
+    GPG_ERR_TOO_YOUNG = 307,
+    GPG_ERR_TOO_OLD = 308,
+    GPG_ERR_UNKNOWN_FLAG = 309,
+    GPG_ERR_INV_ORDER = 310,
+    GPG_ERR_ALREADY_FETCHED = 311,
+    GPG_ERR_TRY_LATER = 312,
+    GPG_ERR_WRONG_NAME = 313,
+    GPG_ERR_SYSTEM_BUG = 666,
+    GPG_ERR_DNS_UNKNOWN = 711,
+    GPG_ERR_DNS_SECTION = 712,
+    GPG_ERR_DNS_ADDRESS = 713,
+    GPG_ERR_DNS_NO_QUERY = 714,
+    GPG_ERR_DNS_NO_ANSWER = 715,
+    GPG_ERR_DNS_CLOSED = 716,
+    GPG_ERR_DNS_VERIFY = 717,
+    GPG_ERR_DNS_TIMEOUT = 718,
+    GPG_ERR_LDAP_GENERAL = 721,
+    GPG_ERR_LDAP_ATTR_GENERAL = 722,
+    GPG_ERR_LDAP_NAME_GENERAL = 723,
+    GPG_ERR_LDAP_SECURITY_GENERAL = 724,
+    GPG_ERR_LDAP_SERVICE_GENERAL = 725,
+    GPG_ERR_LDAP_UPDATE_GENERAL = 726,
+    GPG_ERR_LDAP_E_GENERAL = 727,
+    GPG_ERR_LDAP_X_GENERAL = 728,
+    GPG_ERR_LDAP_OTHER_GENERAL = 729,
+    GPG_ERR_LDAP_X_CONNECTING = 750,
+    GPG_ERR_LDAP_REFERRAL_LIMIT = 751,
+    GPG_ERR_LDAP_CLIENT_LOOP = 752,
+    GPG_ERR_LDAP_NO_RESULTS = 754,
+    GPG_ERR_LDAP_CONTROL_NOT_FOUND = 755,
+    GPG_ERR_LDAP_NOT_SUPPORTED = 756,
+    GPG_ERR_LDAP_CONNECT = 757,
+    GPG_ERR_LDAP_NO_MEMORY = 758,
+    GPG_ERR_LDAP_PARAM = 759,
+    GPG_ERR_LDAP_USER_CANCELLED = 760,
+    GPG_ERR_LDAP_FILTER = 761,
+    GPG_ERR_LDAP_AUTH_UNKNOWN = 762,
+    GPG_ERR_LDAP_TIMEOUT = 763,
+    GPG_ERR_LDAP_DECODING = 764,
+    GPG_ERR_LDAP_ENCODING = 765,
+    GPG_ERR_LDAP_LOCAL = 766,
+    GPG_ERR_LDAP_SERVER_DOWN = 767,
+    GPG_ERR_LDAP_SUCCESS = 768,
+    GPG_ERR_LDAP_OPERATIONS = 769,
+    GPG_ERR_LDAP_PROTOCOL = 770,
+    GPG_ERR_LDAP_TIMELIMIT = 771,
+    GPG_ERR_LDAP_SIZELIMIT = 772,
+    GPG_ERR_LDAP_COMPARE_FALSE = 773,
+    GPG_ERR_LDAP_COMPARE_TRUE = 774,
+    GPG_ERR_LDAP_UNSUPPORTED_AUTH = 775,
+    GPG_ERR_LDAP_STRONG_AUTH_RQRD = 776,
+    GPG_ERR_LDAP_PARTIAL_RESULTS = 777,
+    GPG_ERR_LDAP_REFERRAL = 778,
+    GPG_ERR_LDAP_ADMINLIMIT = 779,
+    GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN = 780,
+    GPG_ERR_LDAP_CONFIDENT_RQRD = 781,
+    GPG_ERR_LDAP_SASL_BIND_INPROG = 782,
+    GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE = 784,
+    GPG_ERR_LDAP_UNDEFINED_TYPE = 785,
+    GPG_ERR_LDAP_BAD_MATCHING = 786,
+    GPG_ERR_LDAP_CONST_VIOLATION = 787,
+    GPG_ERR_LDAP_TYPE_VALUE_EXISTS = 788,
+    GPG_ERR_LDAP_INV_SYNTAX = 789,
+    GPG_ERR_LDAP_NO_SUCH_OBJ = 800,
+    GPG_ERR_LDAP_ALIAS_PROBLEM = 801,
+    GPG_ERR_LDAP_INV_DN_SYNTAX = 802,
+    GPG_ERR_LDAP_IS_LEAF = 803,
+    GPG_ERR_LDAP_ALIAS_DEREF = 804,
+    GPG_ERR_LDAP_X_PROXY_AUTH_FAIL = 815,
+    GPG_ERR_LDAP_BAD_AUTH = 816,
+    GPG_ERR_LDAP_INV_CREDENTIALS = 817,
+    GPG_ERR_LDAP_INSUFFICIENT_ACC = 818,
+    GPG_ERR_LDAP_BUSY = 819,
+    GPG_ERR_LDAP_UNAVAILABLE = 820,
+    GPG_ERR_LDAP_UNWILL_TO_PERFORM = 821,
+    GPG_ERR_LDAP_LOOP_DETECT = 822,
+    GPG_ERR_LDAP_NAMING_VIOLATION = 832,
+    GPG_ERR_LDAP_OBJ_CLS_VIOLATION = 833,
+    GPG_ERR_LDAP_NOT_ALLOW_NONLEAF = 834,
+    GPG_ERR_LDAP_NOT_ALLOW_ON_RDN = 835,
+    GPG_ERR_LDAP_ALREADY_EXISTS = 836,
+    GPG_ERR_LDAP_NO_OBJ_CLASS_MODS = 837,
+    GPG_ERR_LDAP_RESULTS_TOO_LARGE = 838,
+    GPG_ERR_LDAP_AFFECTS_MULT_DSAS = 839,
+    GPG_ERR_LDAP_VLV = 844,
+    GPG_ERR_LDAP_OTHER = 848,
+    GPG_ERR_LDAP_CUP_RESOURCE_LIMIT = 881,
+    GPG_ERR_LDAP_CUP_SEC_VIOLATION = 882,
+    GPG_ERR_LDAP_CUP_INV_DATA = 883,
+    GPG_ERR_LDAP_CUP_UNSUP_SCHEME = 884,
+    GPG_ERR_LDAP_CUP_RELOAD = 885,
+    GPG_ERR_LDAP_CANCELLED = 886,
+    GPG_ERR_LDAP_NO_SUCH_OPERATION = 887,
+    GPG_ERR_LDAP_TOO_LATE = 888,
+    GPG_ERR_LDAP_CANNOT_CANCEL = 889,
+    GPG_ERR_LDAP_ASSERTION_FAILED = 890,
+    GPG_ERR_LDAP_PROX_AUTH_DENIED = 891,
+    GPG_ERR_USER_1 = 1024,
+    GPG_ERR_USER_2 = 1025,
+    GPG_ERR_USER_3 = 1026,
+    GPG_ERR_USER_4 = 1027,
+    GPG_ERR_USER_5 = 1028,
+    GPG_ERR_USER_6 = 1029,
+    GPG_ERR_USER_7 = 1030,
+    GPG_ERR_USER_8 = 1031,
+    GPG_ERR_USER_9 = 1032,
+    GPG_ERR_USER_10 = 1033,
+    GPG_ERR_USER_11 = 1034,
+    GPG_ERR_USER_12 = 1035,
+    GPG_ERR_USER_13 = 1036,
+    GPG_ERR_USER_14 = 1037,
+    GPG_ERR_USER_15 = 1038,
+    GPG_ERR_USER_16 = 1039,
+    GPG_ERR_MISSING_ERRNO = 16381,
+    GPG_ERR_UNKNOWN_ERRNO = 16382,
+    GPG_ERR_EOF = 16383,
+
+    /* The following error codes are used to map system errors.  */
+#define GPG_ERR_SYSTEM_ERROR	(1 << 15)
+    GPG_ERR_E2BIG = GPG_ERR_SYSTEM_ERROR | 0,
+    GPG_ERR_EACCES = GPG_ERR_SYSTEM_ERROR | 1,
+    GPG_ERR_EADDRINUSE = GPG_ERR_SYSTEM_ERROR | 2,
+    GPG_ERR_EADDRNOTAVAIL = GPG_ERR_SYSTEM_ERROR | 3,
+    GPG_ERR_EADV = GPG_ERR_SYSTEM_ERROR | 4,
+    GPG_ERR_EAFNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 5,
+    GPG_ERR_EAGAIN = GPG_ERR_SYSTEM_ERROR | 6,
+    GPG_ERR_EALREADY = GPG_ERR_SYSTEM_ERROR | 7,
+    GPG_ERR_EAUTH = GPG_ERR_SYSTEM_ERROR | 8,
+    GPG_ERR_EBACKGROUND = GPG_ERR_SYSTEM_ERROR | 9,
+    GPG_ERR_EBADE = GPG_ERR_SYSTEM_ERROR | 10,
+    GPG_ERR_EBADF = GPG_ERR_SYSTEM_ERROR | 11,
+    GPG_ERR_EBADFD = GPG_ERR_SYSTEM_ERROR | 12,
+    GPG_ERR_EBADMSG = GPG_ERR_SYSTEM_ERROR | 13,
+    GPG_ERR_EBADR = GPG_ERR_SYSTEM_ERROR | 14,
+    GPG_ERR_EBADRPC = GPG_ERR_SYSTEM_ERROR | 15,
+    GPG_ERR_EBADRQC = GPG_ERR_SYSTEM_ERROR | 16,
+    GPG_ERR_EBADSLT = GPG_ERR_SYSTEM_ERROR | 17,
+    GPG_ERR_EBFONT = GPG_ERR_SYSTEM_ERROR | 18,
+    GPG_ERR_EBUSY = GPG_ERR_SYSTEM_ERROR | 19,
+    GPG_ERR_ECANCELED = GPG_ERR_SYSTEM_ERROR | 20,
+    GPG_ERR_ECHILD = GPG_ERR_SYSTEM_ERROR | 21,
+    GPG_ERR_ECHRNG = GPG_ERR_SYSTEM_ERROR | 22,
+    GPG_ERR_ECOMM = GPG_ERR_SYSTEM_ERROR | 23,
+    GPG_ERR_ECONNABORTED = GPG_ERR_SYSTEM_ERROR | 24,
+    GPG_ERR_ECONNREFUSED = GPG_ERR_SYSTEM_ERROR | 25,
+    GPG_ERR_ECONNRESET = GPG_ERR_SYSTEM_ERROR | 26,
+    GPG_ERR_ED = GPG_ERR_SYSTEM_ERROR | 27,
+    GPG_ERR_EDEADLK = GPG_ERR_SYSTEM_ERROR | 28,
+    GPG_ERR_EDEADLOCK = GPG_ERR_SYSTEM_ERROR | 29,
+    GPG_ERR_EDESTADDRREQ = GPG_ERR_SYSTEM_ERROR | 30,
+    GPG_ERR_EDIED = GPG_ERR_SYSTEM_ERROR | 31,
+    GPG_ERR_EDOM = GPG_ERR_SYSTEM_ERROR | 32,
+    GPG_ERR_EDOTDOT = GPG_ERR_SYSTEM_ERROR | 33,
+    GPG_ERR_EDQUOT = GPG_ERR_SYSTEM_ERROR | 34,
+    GPG_ERR_EEXIST = GPG_ERR_SYSTEM_ERROR | 35,
+    GPG_ERR_EFAULT = GPG_ERR_SYSTEM_ERROR | 36,
+    GPG_ERR_EFBIG = GPG_ERR_SYSTEM_ERROR | 37,
+    GPG_ERR_EFTYPE = GPG_ERR_SYSTEM_ERROR | 38,
+    GPG_ERR_EGRATUITOUS = GPG_ERR_SYSTEM_ERROR | 39,
+    GPG_ERR_EGREGIOUS = GPG_ERR_SYSTEM_ERROR | 40,
+    GPG_ERR_EHOSTDOWN = GPG_ERR_SYSTEM_ERROR | 41,
+    GPG_ERR_EHOSTUNREACH = GPG_ERR_SYSTEM_ERROR | 42,
+    GPG_ERR_EIDRM = GPG_ERR_SYSTEM_ERROR | 43,
+    GPG_ERR_EIEIO = GPG_ERR_SYSTEM_ERROR | 44,
+    GPG_ERR_EILSEQ = GPG_ERR_SYSTEM_ERROR | 45,
+    GPG_ERR_EINPROGRESS = GPG_ERR_SYSTEM_ERROR | 46,
+    GPG_ERR_EINTR = GPG_ERR_SYSTEM_ERROR | 47,
+    GPG_ERR_EINVAL = GPG_ERR_SYSTEM_ERROR | 48,
+    GPG_ERR_EIO = GPG_ERR_SYSTEM_ERROR | 49,
+    GPG_ERR_EISCONN = GPG_ERR_SYSTEM_ERROR | 50,
+    GPG_ERR_EISDIR = GPG_ERR_SYSTEM_ERROR | 51,
+    GPG_ERR_EISNAM = GPG_ERR_SYSTEM_ERROR | 52,
+    GPG_ERR_EL2HLT = GPG_ERR_SYSTEM_ERROR | 53,
+    GPG_ERR_EL2NSYNC = GPG_ERR_SYSTEM_ERROR | 54,
+    GPG_ERR_EL3HLT = GPG_ERR_SYSTEM_ERROR | 55,
+    GPG_ERR_EL3RST = GPG_ERR_SYSTEM_ERROR | 56,
+    GPG_ERR_ELIBACC = GPG_ERR_SYSTEM_ERROR | 57,
+    GPG_ERR_ELIBBAD = GPG_ERR_SYSTEM_ERROR | 58,
+    GPG_ERR_ELIBEXEC = GPG_ERR_SYSTEM_ERROR | 59,
+    GPG_ERR_ELIBMAX = GPG_ERR_SYSTEM_ERROR | 60,
+    GPG_ERR_ELIBSCN = GPG_ERR_SYSTEM_ERROR | 61,
+    GPG_ERR_ELNRNG = GPG_ERR_SYSTEM_ERROR | 62,
+    GPG_ERR_ELOOP = GPG_ERR_SYSTEM_ERROR | 63,
+    GPG_ERR_EMEDIUMTYPE = GPG_ERR_SYSTEM_ERROR | 64,
+    GPG_ERR_EMFILE = GPG_ERR_SYSTEM_ERROR | 65,
+    GPG_ERR_EMLINK = GPG_ERR_SYSTEM_ERROR | 66,
+    GPG_ERR_EMSGSIZE = GPG_ERR_SYSTEM_ERROR | 67,
+    GPG_ERR_EMULTIHOP = GPG_ERR_SYSTEM_ERROR | 68,
+    GPG_ERR_ENAMETOOLONG = GPG_ERR_SYSTEM_ERROR | 69,
+    GPG_ERR_ENAVAIL = GPG_ERR_SYSTEM_ERROR | 70,
+    GPG_ERR_ENEEDAUTH = GPG_ERR_SYSTEM_ERROR | 71,
+    GPG_ERR_ENETDOWN = GPG_ERR_SYSTEM_ERROR | 72,
+    GPG_ERR_ENETRESET = GPG_ERR_SYSTEM_ERROR | 73,
+    GPG_ERR_ENETUNREACH = GPG_ERR_SYSTEM_ERROR | 74,
+    GPG_ERR_ENFILE = GPG_ERR_SYSTEM_ERROR | 75,
+    GPG_ERR_ENOANO = GPG_ERR_SYSTEM_ERROR | 76,
+    GPG_ERR_ENOBUFS = GPG_ERR_SYSTEM_ERROR | 77,
+    GPG_ERR_ENOCSI = GPG_ERR_SYSTEM_ERROR | 78,
+    GPG_ERR_ENODATA = GPG_ERR_SYSTEM_ERROR | 79,
+    GPG_ERR_ENODEV = GPG_ERR_SYSTEM_ERROR | 80,
+    GPG_ERR_ENOENT = GPG_ERR_SYSTEM_ERROR | 81,
+    GPG_ERR_ENOEXEC = GPG_ERR_SYSTEM_ERROR | 82,
+    GPG_ERR_ENOLCK = GPG_ERR_SYSTEM_ERROR | 83,
+    GPG_ERR_ENOLINK = GPG_ERR_SYSTEM_ERROR | 84,
+    GPG_ERR_ENOMEDIUM = GPG_ERR_SYSTEM_ERROR | 85,
+    GPG_ERR_ENOMEM = GPG_ERR_SYSTEM_ERROR | 86,
+    GPG_ERR_ENOMSG = GPG_ERR_SYSTEM_ERROR | 87,
+    GPG_ERR_ENONET = GPG_ERR_SYSTEM_ERROR | 88,
+    GPG_ERR_ENOPKG = GPG_ERR_SYSTEM_ERROR | 89,
+    GPG_ERR_ENOPROTOOPT = GPG_ERR_SYSTEM_ERROR | 90,
+    GPG_ERR_ENOSPC = GPG_ERR_SYSTEM_ERROR | 91,
+    GPG_ERR_ENOSR = GPG_ERR_SYSTEM_ERROR | 92,
+    GPG_ERR_ENOSTR = GPG_ERR_SYSTEM_ERROR | 93,
+    GPG_ERR_ENOSYS = GPG_ERR_SYSTEM_ERROR | 94,
+    GPG_ERR_ENOTBLK = GPG_ERR_SYSTEM_ERROR | 95,
+    GPG_ERR_ENOTCONN = GPG_ERR_SYSTEM_ERROR | 96,
+    GPG_ERR_ENOTDIR = GPG_ERR_SYSTEM_ERROR | 97,
+    GPG_ERR_ENOTEMPTY = GPG_ERR_SYSTEM_ERROR | 98,
+    GPG_ERR_ENOTNAM = GPG_ERR_SYSTEM_ERROR | 99,
+    GPG_ERR_ENOTSOCK = GPG_ERR_SYSTEM_ERROR | 100,
+    GPG_ERR_ENOTSUP = GPG_ERR_SYSTEM_ERROR | 101,
+    GPG_ERR_ENOTTY = GPG_ERR_SYSTEM_ERROR | 102,
+    GPG_ERR_ENOTUNIQ = GPG_ERR_SYSTEM_ERROR | 103,
+    GPG_ERR_ENXIO = GPG_ERR_SYSTEM_ERROR | 104,
+    GPG_ERR_EOPNOTSUPP = GPG_ERR_SYSTEM_ERROR | 105,
+    GPG_ERR_EOVERFLOW = GPG_ERR_SYSTEM_ERROR | 106,
+    GPG_ERR_EPERM = GPG_ERR_SYSTEM_ERROR | 107,
+    GPG_ERR_EPFNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 108,
+    GPG_ERR_EPIPE = GPG_ERR_SYSTEM_ERROR | 109,
+    GPG_ERR_EPROCLIM = GPG_ERR_SYSTEM_ERROR | 110,
+    GPG_ERR_EPROCUNAVAIL = GPG_ERR_SYSTEM_ERROR | 111,
+    GPG_ERR_EPROGMISMATCH = GPG_ERR_SYSTEM_ERROR | 112,
+    GPG_ERR_EPROGUNAVAIL = GPG_ERR_SYSTEM_ERROR | 113,
+    GPG_ERR_EPROTO = GPG_ERR_SYSTEM_ERROR | 114,
+    GPG_ERR_EPROTONOSUPPORT = GPG_ERR_SYSTEM_ERROR | 115,
+    GPG_ERR_EPROTOTYPE = GPG_ERR_SYSTEM_ERROR | 116,
+    GPG_ERR_ERANGE = GPG_ERR_SYSTEM_ERROR | 117,
+    GPG_ERR_EREMCHG = GPG_ERR_SYSTEM_ERROR | 118,
+    GPG_ERR_EREMOTE = GPG_ERR_SYSTEM_ERROR | 119,
+    GPG_ERR_EREMOTEIO = GPG_ERR_SYSTEM_ERROR | 120,
+    GPG_ERR_ERESTART = GPG_ERR_SYSTEM_ERROR | 121,
+    GPG_ERR_EROFS = GPG_ERR_SYSTEM_ERROR | 122,
+    GPG_ERR_ERPCMISMATCH = GPG_ERR_SYSTEM_ERROR | 123,
+    GPG_ERR_ESHUTDOWN = GPG_ERR_SYSTEM_ERROR | 124,
+    GPG_ERR_ESOCKTNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 125,
+    GPG_ERR_ESPIPE = GPG_ERR_SYSTEM_ERROR | 126,
+    GPG_ERR_ESRCH = GPG_ERR_SYSTEM_ERROR | 127,
+    GPG_ERR_ESRMNT = GPG_ERR_SYSTEM_ERROR | 128,
+    GPG_ERR_ESTALE = GPG_ERR_SYSTEM_ERROR | 129,
+    GPG_ERR_ESTRPIPE = GPG_ERR_SYSTEM_ERROR | 130,
+    GPG_ERR_ETIME = GPG_ERR_SYSTEM_ERROR | 131,
+    GPG_ERR_ETIMEDOUT = GPG_ERR_SYSTEM_ERROR | 132,
+    GPG_ERR_ETOOMANYREFS = GPG_ERR_SYSTEM_ERROR | 133,
+    GPG_ERR_ETXTBSY = GPG_ERR_SYSTEM_ERROR | 134,
+    GPG_ERR_EUCLEAN = GPG_ERR_SYSTEM_ERROR | 135,
+    GPG_ERR_EUNATCH = GPG_ERR_SYSTEM_ERROR | 136,
+    GPG_ERR_EUSERS = GPG_ERR_SYSTEM_ERROR | 137,
+    GPG_ERR_EWOULDBLOCK = GPG_ERR_SYSTEM_ERROR | 138,
+    GPG_ERR_EXDEV = GPG_ERR_SYSTEM_ERROR | 139,
+    GPG_ERR_EXFULL = GPG_ERR_SYSTEM_ERROR | 140,
+
+    /* This is one more than the largest allowed entry.  */
+    GPG_ERR_CODE_DIM = 65536
+  } gpg_err_code_t;
+
+
+/* The error value type gpg_error_t.  */
+
+/* We would really like to use bit-fields in a struct, but using
+   structs as return values can cause binary compatibility issues, in
+   particular if you want to do it efficiently (also see
+   -freg-struct-return option to GCC).  */
+typedef unsigned int gpg_error_t;
+
+/* We use the lowest 16 bits of gpg_error_t for error codes.  The 16th
+   bit indicates system errors.  */
+#define GPG_ERR_CODE_MASK	(GPG_ERR_CODE_DIM - 1)
+
+/* Bits 17 to 24 are reserved.  */
+
+/* We use the upper 7 bits of gpg_error_t for error sources.  */
+#define GPG_ERR_SOURCE_MASK	(GPG_ERR_SOURCE_DIM - 1)
+#define GPG_ERR_SOURCE_SHIFT	24
+
+/* The highest bit is reserved.  It shouldn't be used to prevent
+   potential negative numbers when transmitting error values as
+   text.  */
+
+
+/* GCC feature test.  */
+#if __GNUC__
+# define _GPG_ERR_GCC_VERSION (__GNUC__ * 10000 \
+                               + __GNUC_MINOR__ * 100 \
+                               + __GNUC_PATCHLEVEL__)
+#else
+# define _GPG_ERR_GCC_VERSION 0
+#endif
+
+#undef _GPG_ERR_HAVE_CONSTRUCTOR
+#if _GPG_ERR_GCC_VERSION > 30100
+# define _GPG_ERR_CONSTRUCTOR	__attribute__ ((__constructor__))
+# define _GPG_ERR_HAVE_CONSTRUCTOR
+#else
+# define _GPG_ERR_CONSTRUCTOR
+#endif
+
+#define GPGRT_GCC_VERSION  _GPG_ERR_GCC_VERSION
+
+#if _GPG_ERR_GCC_VERSION >= 29200
+# define _GPGRT__RESTRICT __restrict__
+#else
+# define _GPGRT__RESTRICT
+#endif
+
+/* The noreturn attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_ATTR_NORETURN   __attribute__ ((noreturn))
+#else
+# define GPGRT_ATTR_NORETURN
+#endif
+
+/* The printf attributes.  */
+#if _GPG_ERR_GCC_VERSION >= 40400
+# define GPGRT_ATTR_PRINTF(f, a) \
+                    __attribute__ ((format(__gnu_printf__,f,a)))
+# define GPGRT_ATTR_NR_PRINTF(f, a) \
+                    __attribute__ ((noreturn, format(__gnu_printf__,f,a)))
+#elif _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_ATTR_PRINTF(f, a) \
+                    __attribute__ ((format(printf,f,a)))
+# define GPGRT_ATTR_NR_PRINTF(f, a) \
+                    __attribute__ ((noreturn, format(printf,f,a)))
+#else
+# define GPGRT_ATTR_PRINTF(f, a)
+# define GPGRT_ATTR_NR_PRINTF(f, a)
+#endif
+#if _GPG_ERR_GCC_VERSION >= 20800
+# define GPGRT_ATTR_FORMAT_ARG(a)  __attribute__ ((__format_arg__ (a)))
+#else
+# define GPGRT_ATTR_FORMAT_ARG(a)
+#endif
+
+/* The sentinel attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 40000
+# define GPGRT_ATTR_SENTINEL(a)  __attribute__ ((sentinel(a)))
+#else
+# define GPGRT_ATTR_SENTINEL(a)
+#endif
+
+/* The used and unused attributes.
+   I am not sure since when the unused attribute is really supported.
+   In any case it it only needed for gcc versions which print a
+   warning.  Thus let us require gcc >= 3.5.  */
+#if _GPG_ERR_GCC_VERSION >= 40000
+# define GPGRT_ATTR_USED  __attribute__ ((used))
+#else
+# define GPGRT_ATTR_USED
+#endif
+#if _GPG_ERR_GCC_VERSION >= 30500
+# define GPGRT_ATTR_UNUSED  __attribute__ ((unused))
+#else
+# define GPGRT_ATTR_UNUSED
+#endif
+
+/* The deprecated attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 30100
+# define GPGRT_ATTR_DEPRECATED  __attribute__ ((__deprecated__))
+#else
+# define GPGRT_ATTR_DEPRECATED
+#endif
+
+/* The pure attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 29600
+# define GPGRT_ATTR_PURE  __attribute__ ((__pure__))
+#else
+# define GPGRT_ATTR_PURE
+#endif
+
+/* The malloc attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 30200
+# define GPGRT_ATTR_MALLOC  __attribute__ ((__malloc__))
+#else
+# define GPGRT_ATTR_MALLOC
+#endif
+
+/* A macro defined if a GCC style __FUNCTION__ macro is available.  */
+#undef GPGRT_HAVE_MACRO_FUNCTION
+#if _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_HAVE_MACRO_FUNCTION 1
+#endif
+
+/* A macro defined if the pragma GCC push_options is available.  */
+#undef GPGRT_HAVE_PRAGMA_GCC_PUSH
+#if _GPG_ERR_GCC_VERSION >= 40400
+# define GPGRT_HAVE_PRAGMA_GCC_PUSH 1
+#endif
+
+/* Detect LeakSanitizer (LSan) support for GCC and Clang based on
+ * whether AddressSanitizer (ASAN) is enabled via -fsanitize=address).
+ * Note that -fsanitize=leak just affect the linker options which
+ * cannot be detected here.  In that case you have to define the
+ * GPGRT_HAVE_LEAK_SANITIZER macro manually.  */
+#ifdef __GNUC__
+# ifdef __SANITIZE_ADDRESS__
+#  define GPGRT_HAVE_LEAK_SANITIZER
+# elif defined(__has_feature)
+#  if __has_feature(address_sanitizer)
+#   define GPGRT_HAVE_LEAK_SANITIZER
+#  endif
+# endif
+#endif
+
+
+/* The new name for the inline macro.  */
+#define GPGRT_INLINE GPG_ERR_INLINE
+
+#ifdef GPGRT_HAVE_LEAK_SANITIZER
+# include <sanitizer/lsan_interface.h>
+#endif
+
+/* Mark heap objects as non-leaked memory. */
+static GPGRT_INLINE void
+gpgrt_annotate_leaked_object (const void *p)
+{
+#ifdef GPGRT_HAVE_LEAK_SANITIZER
+  __lsan_ignore_object(p);
+#else
+  (void)p;
+#endif
+}
+
+
+/* Initialization function.  */
+
+/* Initialize the library.  This function should be run early.  */
+gpg_error_t gpg_err_init (void) _GPG_ERR_CONSTRUCTOR;
+
+/* If this is defined, the library is already initialized by the
+   constructor and does not need to be initialized explicitely.  */
+#undef GPG_ERR_INITIALIZED
+#ifdef _GPG_ERR_HAVE_CONSTRUCTOR
+# define GPG_ERR_INITIALIZED	1
+# define gpgrt_init() do { gpg_err_init (); } while (0)
+#else
+# define gpgrt_init() do { ; } while (0)
+#endif
+
+/* See the source on how to use the deinit function; it is usually not
+   required.  */
+void gpg_err_deinit (int mode);
+
+/* Register blocking system I/O clamping functions.  */
+void gpgrt_set_syscall_clamp (void (*pre)(void), void (*post)(void));
+
+/* Get current I/O clamping functions.  */
+void gpgrt_get_syscall_clamp (void (**r_pre)(void), void (**r_post)(void));
+
+/* Register a custom malloc/realloc/free function.  */
+void gpgrt_set_alloc_func  (void *(*f)(void *a, size_t n));
+
+
+
+/* Constructor and accessor functions.  */
+
+/* Construct an error value from an error code and source.  Within a
+   subsystem, use gpg_error.  */
+static GPG_ERR_INLINE gpg_error_t
+gpg_err_make (gpg_err_source_t source, gpg_err_code_t code)
+{
+  return code == GPG_ERR_NO_ERROR ? GPG_ERR_NO_ERROR
+    : (((source & GPG_ERR_SOURCE_MASK) << GPG_ERR_SOURCE_SHIFT)
+       | (code & GPG_ERR_CODE_MASK));
+}
+
+
+/* The user should define GPG_ERR_SOURCE_DEFAULT before including this
+   file to specify a default source for gpg_error.  */
+#ifndef GPG_ERR_SOURCE_DEFAULT
+#define GPG_ERR_SOURCE_DEFAULT	GPG_ERR_SOURCE_UNKNOWN
+#endif
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error (gpg_err_code_t code)
+{
+  return gpg_err_make (GPG_ERR_SOURCE_DEFAULT, code);
+}
+
+
+/* Retrieve the error code from an error value.  */
+static GPG_ERR_INLINE gpg_err_code_t
+gpg_err_code (gpg_error_t err)
+{
+  return (gpg_err_code_t) (err & GPG_ERR_CODE_MASK);
+}
+
+
+/* Retrieve the error source from an error value.  */
+static GPG_ERR_INLINE gpg_err_source_t
+gpg_err_source (gpg_error_t err)
+{
+  return (gpg_err_source_t) ((err >> GPG_ERR_SOURCE_SHIFT)
+			     & GPG_ERR_SOURCE_MASK);
+}
+
+
+/* String functions.  */
+
+/* Return a pointer to a string containing a description of the error
+   code in the error value ERR.  This function is not thread-safe.  */
+const char *gpg_strerror (gpg_error_t err);
+
+/* Return the error string for ERR in the user-supplied buffer BUF of
+   size BUFLEN.  This function is, in contrast to gpg_strerror,
+   thread-safe if a thread-safe strerror_r() function is provided by
+   the system.  If the function succeeds, 0 is returned and BUF
+   contains the string describing the error.  If the buffer was not
+   large enough, ERANGE is returned and BUF contains as much of the
+   beginning of the error string as fits into the buffer.  */
+int gpg_strerror_r (gpg_error_t err, char *buf, size_t buflen);
+
+/* Return a pointer to a string containing a description of the error
+   source in the error value ERR.  */
+const char *gpg_strsource (gpg_error_t err);
+
+
+/* Mapping of system errors (errno).  */
+
+/* Retrieve the error code for the system error ERR.  This returns
+   GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped (report
+   this). */
+gpg_err_code_t gpg_err_code_from_errno (int err);
+
+
+/* Retrieve the system error for the error code CODE.  This returns 0
+   if CODE is not a system error code.  */
+int gpg_err_code_to_errno (gpg_err_code_t code);
+
+
+/* Retrieve the error code directly from the ERRNO variable.  This
+   returns GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped
+   (report this) and GPG_ERR_MISSING_ERRNO if ERRNO has the value 0. */
+gpg_err_code_t gpg_err_code_from_syserror (void);
+
+
+/* Set the ERRNO variable.  This function is the preferred way to set
+   ERRNO due to peculiarities on WindowsCE.  */
+void gpg_err_set_errno (int err);
+
+/* Return or check the version.  Both functions are identical.  */
+const char *gpgrt_check_version (const char *req_version);
+const char *gpg_error_check_version (const char *req_version);
+
+/* System specific type definitions.  */
+#include <sys/types.h>
+typedef ssize_t gpgrt_ssize_t;
+
+typedef long gpgrt_off_t;
+
+
+
+
+/* Self-documenting convenience functions.  */
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_err_make_from_errno (gpg_err_source_t source, int err)
+{
+  return gpg_err_make (source, gpg_err_code_from_errno (err));
+}
+
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error_from_errno (int err)
+{
+  return gpg_error (gpg_err_code_from_errno (err));
+}
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error_from_syserror (void)
+{
+  return gpg_error (gpg_err_code_from_syserror ());
+}
+
+
+
+/* Lock functions.  */
+
+
+typedef struct
+{
+  long _vers;
+  union {
+    volatile char _priv[40];
+    long _x_align;
+    long *_xp_align;
+  } u;
+} gpgrt_lock_t;
+
+#define GPGRT_LOCK_INITIALIZER {1,{{0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0}}}
+
+
+#define GPGRT_LOCK_DEFINE(name) \
+  static gpgrt_lock_t name  = GPGRT_LOCK_INITIALIZER
+
+/* NB: If GPGRT_LOCK_DEFINE is not used, zero out the lock variable
+   before passing it to gpgrt_lock_init.  */
+gpg_err_code_t gpgrt_lock_init (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_lock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_trylock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_unlock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_destroy (gpgrt_lock_t *lockhd);
+
+
+
+/* Thread functions.  */
+
+gpg_err_code_t gpgrt_yield (void);
+
+
+
+
+/* Estream */
+
+/* The definition of this struct is entirely private.  You must not
+   use it for anything.  It is only here so some functions can be
+   implemented as macros.  */
+struct _gpgrt_stream_internal;
+struct _gpgrt__stream
+{
+  /* The layout of this struct must never change.  It may be grown,
+     but only if all functions which access the new members are
+     versioned.  */
+
+  /* Various flags.  */
+  struct {
+    unsigned int magic: 16;
+    unsigned int writing: 1;
+    unsigned int reserved: 15;
+  } flags;
+
+  /* A pointer to the stream buffer.  */
+  unsigned char *buffer;
+
+  /* The size of the buffer in bytes.  */
+  size_t buffer_size;
+
+  /* The length of the usable data in the buffer, only valid when in
+     read mode (see flags).  */
+  size_t data_len;
+
+  /* The current position of the offset pointer, valid in read and
+     write mode.  */
+  size_t data_offset;
+
+  size_t data_flushed;
+  unsigned char *unread_buffer;
+  size_t unread_buffer_size;
+
+  /* The number of unread bytes.  */
+  size_t unread_data_len;
+
+  /* A pointer to our internal data for this stream.  */
+  struct _gpgrt_stream_internal *intern;
+};
+
+/* The opaque type for an estream.  */
+typedef struct _gpgrt__stream *gpgrt_stream_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt__stream *estream_t;
+#endif
+
+typedef ssize_t (*gpgrt_cookie_read_function_t) (void *cookie,
+                                                 void *buffer, size_t size);
+typedef ssize_t (*gpgrt_cookie_write_function_t) (void *cookie,
+                                                  const void *buffer,
+                                                  size_t size);
+typedef int (*gpgrt_cookie_seek_function_t) (void *cookie,
+                                             gpgrt_off_t *pos, int whence);
+typedef int (*gpgrt_cookie_close_function_t) (void *cookie);
+
+struct _gpgrt_cookie_io_functions
+{
+  gpgrt_cookie_read_function_t func_read;
+  gpgrt_cookie_write_function_t func_write;
+  gpgrt_cookie_seek_function_t func_seek;
+  gpgrt_cookie_close_function_t func_close;
+};
+typedef struct _gpgrt_cookie_io_functions gpgrt_cookie_io_functions_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_cookie_io_functions  es_cookie_io_functions_t;
+#define es_cookie_read_function_t  gpgrt_cookie_read_function_t
+#define es_cookie_write_function_t gpgrt_cookie_read_function_t
+#define es_cookie_seek_function_t  gpgrt_cookie_read_function_t
+#define es_cookie_close_function_t gpgrt_cookie_read_function_t
+#endif
+
+enum gpgrt_syshd_types
+  {
+    GPGRT_SYSHD_NONE = 0,  /* No system handle available.                   */
+    GPGRT_SYSHD_FD = 1,    /* A file descriptor as returned by open().      */
+    GPGRT_SYSHD_SOCK = 2,  /* A socket as returned by socket().             */
+    GPGRT_SYSHD_RVID = 3,  /* A rendezvous id (see libassuan's gpgcedev.c).  */
+    GPGRT_SYSHD_HANDLE = 4 /* A HANDLE object (Windows).                    */
+  };
+
+struct _gpgrt_syshd
+{
+  enum gpgrt_syshd_types type;
+  union {
+    int fd;
+    int sock;
+    int rvid;
+    void *handle;
+  } u;
+};
+typedef struct _gpgrt_syshd gpgrt_syshd_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_syshd es_syshd_t;
+#define ES_SYSHD_NONE   GPGRT_SYSHD_NONE
+#define ES_SYSHD_FD     GPGRT_SYSHD_FD
+#define ES_SYSHD_SOCK   GPGRT_SYSHD_SOCK
+#define ES_SYSHD_RVID   GPGRT_SYSHD_RVID
+#define ES_SYSHD_HANDLE GPGRT_SYSHD_HANDLE
+#endif
+
+/* The object used with gpgrt_poll.  */
+struct _gpgrt_poll_s
+{
+  gpgrt_stream_t stream;
+  unsigned int want_read:1;
+  unsigned int want_write:1;
+  unsigned int want_oob:1;
+  unsigned int want_rdhup:1;
+  unsigned int _reserv1:4;
+  unsigned int got_read:1;
+  unsigned int got_write:1;
+  unsigned int got_oob:1;
+  unsigned int got_rdhup:1;
+  unsigned int _reserv2:4;
+  unsigned int got_err:1;
+  unsigned int got_hup:1;
+  unsigned int got_nval:1;
+  unsigned int _reserv3:4;
+  unsigned int ignore:1;
+  unsigned int user:8;       /* For application use.  */
+};
+typedef struct _gpgrt_poll_s gpgrt_poll_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_poll_s es_poll_t;
+#endif
+
+gpgrt_stream_t gpgrt_fopen (const char *_GPGRT__RESTRICT path,
+                            const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_mopen (void *_GPGRT__RESTRICT data,
+                            size_t data_n, size_t data_len,
+                            unsigned int grow,
+                            void *(*func_realloc) (void *mem, size_t size),
+                            void (*func_free) (void *mem),
+                            const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_fopenmem (size_t memlimit,
+                               const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_fopenmem_init (size_t memlimit,
+                                    const char *_GPGRT__RESTRICT mode,
+                                    const void *data, size_t datalen);
+gpgrt_stream_t gpgrt_fdopen    (int filedes, const char *mode);
+gpgrt_stream_t gpgrt_fdopen_nc (int filedes, const char *mode);
+gpgrt_stream_t gpgrt_sysopen    (gpgrt_syshd_t *syshd, const char *mode);
+gpgrt_stream_t gpgrt_sysopen_nc (gpgrt_syshd_t *syshd, const char *mode);
+gpgrt_stream_t gpgrt_fpopen    (FILE *fp, const char *mode);
+gpgrt_stream_t gpgrt_fpopen_nc (FILE *fp, const char *mode);
+gpgrt_stream_t gpgrt_freopen (const char *_GPGRT__RESTRICT path,
+                              const char *_GPGRT__RESTRICT mode,
+                              gpgrt_stream_t _GPGRT__RESTRICT stream);
+gpgrt_stream_t gpgrt_fopencookie (void *_GPGRT__RESTRICT cookie,
+                                  const char *_GPGRT__RESTRICT mode,
+                                  gpgrt_cookie_io_functions_t functions);
+int gpgrt_fclose (gpgrt_stream_t stream);
+int gpgrt_fclose_snatch (gpgrt_stream_t stream,
+                         void **r_buffer, size_t *r_buflen);
+int gpgrt_onclose (gpgrt_stream_t stream, int mode,
+                   void (*fnc) (gpgrt_stream_t, void*), void *fnc_value);
+int gpgrt_fileno (gpgrt_stream_t stream);
+int gpgrt_fileno_unlocked (gpgrt_stream_t stream);
+int gpgrt_syshd (gpgrt_stream_t stream, gpgrt_syshd_t *syshd);
+int gpgrt_syshd_unlocked (gpgrt_stream_t stream, gpgrt_syshd_t *syshd);
+
+void _gpgrt_set_std_fd (int no, int fd);
+gpgrt_stream_t _gpgrt_get_std_stream (int fd);
+
+#define gpgrt_stdin  _gpgrt_get_std_stream (0)
+#define gpgrt_stdout _gpgrt_get_std_stream (1)
+#define gpgrt_stderr _gpgrt_get_std_stream (2)
+
+
+void gpgrt_flockfile (gpgrt_stream_t stream);
+int  gpgrt_ftrylockfile (gpgrt_stream_t stream);
+void gpgrt_funlockfile (gpgrt_stream_t stream);
+
+int gpgrt_feof (gpgrt_stream_t stream);
+int gpgrt_feof_unlocked (gpgrt_stream_t stream);
+int gpgrt_ferror (gpgrt_stream_t stream);
+int gpgrt_ferror_unlocked (gpgrt_stream_t stream);
+void gpgrt_clearerr (gpgrt_stream_t stream);
+void gpgrt_clearerr_unlocked (gpgrt_stream_t stream);
+
+int _gpgrt_pending (gpgrt_stream_t stream);          /* (private) */
+int _gpgrt_pending_unlocked (gpgrt_stream_t stream); /* (private) */
+
+#define gpgrt_pending(stream) _gpgrt_pending (stream)
+
+#define gpgrt_pending_unlocked(stream)				\
+  (((!(stream)->flags.writing)					\
+    && (((stream)->data_offset < (stream)->data_len)		\
+        || ((stream)->unread_data_len)))                        \
+   ? 1 : _gpgrt_pending_unlocked ((stream)))
+
+int gpgrt_fflush (gpgrt_stream_t stream);
+int gpgrt_fseek (gpgrt_stream_t stream, long int offset, int whence);
+int gpgrt_fseeko (gpgrt_stream_t stream, gpgrt_off_t offset, int whence);
+long int gpgrt_ftell (gpgrt_stream_t stream);
+gpgrt_off_t gpgrt_ftello (gpgrt_stream_t stream);
+void gpgrt_rewind (gpgrt_stream_t stream);
+
+int gpgrt_fgetc (gpgrt_stream_t stream);
+int gpgrt_fputc (int c, gpgrt_stream_t stream);
+
+int _gpgrt_getc_underflow (gpgrt_stream_t stream);       /* (private) */
+int _gpgrt_putc_overflow (int c, gpgrt_stream_t stream); /* (private) */
+
+#define gpgrt_getc_unlocked(stream)				\
+  (((!(stream)->flags.writing)					\
+    && ((stream)->data_offset < (stream)->data_len)		\
+    && (! (stream)->unread_data_len))				\
+  ? ((int) (stream)->buffer[((stream)->data_offset)++])		\
+  : _gpgrt_getc_underflow ((stream)))
+
+#define gpgrt_putc_unlocked(c, stream)				\
+  (((stream)->flags.writing					\
+    && ((stream)->data_offset < (stream)->buffer_size)		\
+    && (c != '\n'))						\
+  ? ((int) ((stream)->buffer[((stream)->data_offset)++] = (c)))	\
+  : _gpgrt_putc_overflow ((c), (stream)))
+
+#define gpgrt_getc(stream)    gpgrt_fgetc (stream)
+#define gpgrt_putc(c, stream) gpgrt_fputc (c, stream)
+
+int gpgrt_ungetc (int c, gpgrt_stream_t stream);
+
+int gpgrt_read (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                void *_GPGRT__RESTRICT buffer, size_t bytes_to_read,
+                size_t *_GPGRT__RESTRICT bytes_read);
+int gpgrt_write (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                 const void *_GPGRT__RESTRICT buffer, size_t bytes_to_write,
+                 size_t *_GPGRT__RESTRICT bytes_written);
+int gpgrt_write_sanitized (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                           const void *_GPGRT__RESTRICT buffer, size_t length,
+                           const char *delimiters,
+                           size_t *_GPGRT__RESTRICT bytes_written);
+int gpgrt_write_hexstring (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                           const void *_GPGRT__RESTRICT buffer, size_t length,
+                           int reserved,
+                           size_t *_GPGRT__RESTRICT bytes_written);
+
+size_t gpgrt_fread (void *_GPGRT__RESTRICT ptr, size_t size, size_t nitems,
+                    gpgrt_stream_t _GPGRT__RESTRICT stream);
+size_t gpgrt_fwrite (const void *_GPGRT__RESTRICT ptr, size_t size, size_t memb,
+                     gpgrt_stream_t _GPGRT__RESTRICT stream);
+
+char *gpgrt_fgets (char *_GPGRT__RESTRICT s, int n,
+                   gpgrt_stream_t _GPGRT__RESTRICT stream);
+int gpgrt_fputs (const char *_GPGRT__RESTRICT s,
+                 gpgrt_stream_t _GPGRT__RESTRICT stream);
+int gpgrt_fputs_unlocked (const char *_GPGRT__RESTRICT s,
+                          gpgrt_stream_t _GPGRT__RESTRICT stream);
+
+ssize_t gpgrt_getline (char *_GPGRT__RESTRICT *_GPGRT__RESTRICT lineptr,
+                       size_t *_GPGRT__RESTRICT n,
+                       gpgrt_stream_t stream);
+ssize_t gpgrt_read_line (gpgrt_stream_t stream,
+                         char **addr_of_buffer, size_t *length_of_buffer,
+                         size_t *max_length);
+void gpgrt_free (void *a);
+
+int gpgrt_fprintf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   const char *_GPGRT__RESTRICT format, ...)
+                   GPGRT_ATTR_PRINTF(2,3);
+int gpgrt_fprintf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                            const char *_GPGRT__RESTRICT format, ...)
+                            GPGRT_ATTR_PRINTF(2,3);
+
+int gpgrt_printf (const char *_GPGRT__RESTRICT format, ...)
+                  GPGRT_ATTR_PRINTF(1,2);
+int gpgrt_printf_unlocked (const char *_GPGRT__RESTRICT format, ...)
+                           GPGRT_ATTR_PRINTF(1,2);
+
+int gpgrt_vfprintf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                    const char *_GPGRT__RESTRICT format, va_list ap)
+                    GPGRT_ATTR_PRINTF(2,0);
+int gpgrt_vfprintf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                             const char *_GPGRT__RESTRICT format, va_list ap)
+                             GPGRT_ATTR_PRINTF(2,0);
+
+int gpgrt_setvbuf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   char *_GPGRT__RESTRICT buf, int mode, size_t size);
+void gpgrt_setbuf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   char *_GPGRT__RESTRICT buf);
+
+void gpgrt_set_binary (gpgrt_stream_t stream);
+int  gpgrt_set_nonblock (gpgrt_stream_t stream, int onoff);
+int  gpgrt_get_nonblock (gpgrt_stream_t stream);
+
+int gpgrt_poll (gpgrt_poll_t *fdlist, unsigned int nfds, int timeout);
+
+gpgrt_stream_t gpgrt_tmpfile (void);
+
+void gpgrt_opaque_set (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                       void *_GPGRT__RESTRICT opaque);
+void *gpgrt_opaque_get (gpgrt_stream_t stream);
+
+void gpgrt_fname_set (gpgrt_stream_t stream, const char *fname);
+const char *gpgrt_fname_get (gpgrt_stream_t stream);
+
+int gpgrt_asprintf (char **r_buf, const char * _GPGRT__RESTRICT format, ...)
+                    GPGRT_ATTR_PRINTF(2,3);
+int gpgrt_vasprintf (char **r_buf, const char * _GPGRT__RESTRICT format,
+                     va_list ap)
+                     GPGRT_ATTR_PRINTF(2,0);
+char *gpgrt_bsprintf (const char * _GPGRT__RESTRICT format, ...)
+                      GPGRT_ATTR_PRINTF(1,2);
+char *gpgrt_vbsprintf (const char * _GPGRT__RESTRICT format, va_list ap)
+                       GPGRT_ATTR_PRINTF(1,0);
+int gpgrt_snprintf (char *buf, size_t bufsize,
+                    const char * _GPGRT__RESTRICT format, ...)
+                    GPGRT_ATTR_PRINTF(3,4);
+int gpgrt_vsnprintf (char *buf,size_t bufsize,
+                     const char * _GPGRT__RESTRICT format, va_list arg_ptr)
+                     GPGRT_ATTR_PRINTF(3,0);
+
+
+#ifdef GPGRT_ENABLE_ES_MACROS
+# define es_fopen             gpgrt_fopen
+# define es_mopen             gpgrt_mopen
+# define es_fopenmem          gpgrt_fopenmem
+# define es_fopenmem_init     gpgrt_fopenmem_init
+# define es_fdopen            gpgrt_fdopen
+# define es_fdopen_nc         gpgrt_fdopen_nc
+# define es_sysopen           gpgrt_sysopen
+# define es_sysopen_nc        gpgrt_sysopen_nc
+# define es_fpopen            gpgrt_fpopen
+# define es_fpopen_nc         gpgrt_fpopen_nc
+# define es_freopen           gpgrt_freopen
+# define es_fopencookie       gpgrt_fopencookie
+# define es_fclose            gpgrt_fclose
+# define es_fclose_snatch     gpgrt_fclose_snatch
+# define es_onclose           gpgrt_onclose
+# define es_fileno            gpgrt_fileno
+# define es_fileno_unlocked   gpgrt_fileno_unlocked
+# define es_syshd             gpgrt_syshd
+# define es_syshd_unlocked    gpgrt_syshd_unlocked
+# define es_stdin             _gpgrt_get_std_stream (0)
+# define es_stdout            _gpgrt_get_std_stream (1)
+# define es_stderr            _gpgrt_get_std_stream (2)
+# define es_flockfile         gpgrt_flockfile
+# define es_ftrylockfile      gpgrt_ftrylockfile
+# define es_funlockfile       gpgrt_funlockfile
+# define es_feof              gpgrt_feof
+# define es_feof_unlocked     gpgrt_feof_unlocked
+# define es_ferror            gpgrt_ferror
+# define es_ferror_unlocked   gpgrt_ferror_unlocked
+# define es_clearerr          gpgrt_clearerr
+# define es_clearerr_unlocked gpgrt_clearerr_unlocked
+# define es_pending           gpgrt_pending
+# define es_pending_unlocked  gpgrt_pending_unlocked
+# define es_fflush            gpgrt_fflush
+# define es_fseek             gpgrt_fseek
+# define es_fseeko            gpgrt_fseeko
+# define es_ftell             gpgrt_ftell
+# define es_ftello            gpgrt_ftello
+# define es_rewind            gpgrt_rewind
+# define es_fgetc             gpgrt_fgetc
+# define es_fputc             gpgrt_fputc
+# define es_getc_unlocked     gpgrt_getc_unlocked
+# define es_putc_unlocked     gpgrt_putc_unlocked
+# define es_getc              gpgrt_getc
+# define es_putc              gpgrt_putc
+# define es_ungetc            gpgrt_ungetc
+# define es_read              gpgrt_read
+# define es_write             gpgrt_write
+# define es_write_sanitized   gpgrt_write_sanitized
+# define es_write_hexstring   gpgrt_write_hexstring
+# define es_fread             gpgrt_fread
+# define es_fwrite            gpgrt_fwrite
+# define es_fgets             gpgrt_fgets
+# define es_fputs             gpgrt_fputs
+# define es_fputs_unlocked    gpgrt_fputs_unlocked
+# define es_getline           gpgrt_getline
+# define es_read_line         gpgrt_read_line
+# define es_free              gpgrt_free
+# define es_fprintf           gpgrt_fprintf
+# define es_fprintf_unlocked  gpgrt_fprintf_unlocked
+# define es_printf            gpgrt_printf
+# define es_printf_unlocked   gpgrt_printf_unlocked
+# define es_vfprintf          gpgrt_vfprintf
+# define es_vfprintf_unlocked gpgrt_vfprintf_unlocked
+# define es_setvbuf           gpgrt_setvbuf
+# define es_setbuf            gpgrt_setbuf
+# define es_set_binary        gpgrt_set_binary
+# define es_set_nonblock      gpgrt_set_nonblock
+# define es_get_nonblock      gpgrt_get_nonblock
+# define es_poll              gpgrt_poll
+# define es_tmpfile           gpgrt_tmpfile
+# define es_opaque_set        gpgrt_opaque_set
+# define es_opaque_get        gpgrt_opaque_get
+# define es_fname_set         gpgrt_fname_set
+# define es_fname_get         gpgrt_fname_get
+# define es_asprintf          gpgrt_asprintf
+# define es_vasprintf         gpgrt_vasprintf
+# define es_bsprintf          gpgrt_bsprintf
+# define es_vbsprintf         gpgrt_vbsprintf
+#endif /*GPGRT_ENABLE_ES_MACROS*/
+
+/* Base64 decode functions.  */
+
+struct _gpgrt_b64state;
+typedef struct _gpgrt_b64state *gpgrt_b64state_t;
+
+gpgrt_b64state_t gpgrt_b64dec_start (const char *title);
+gpg_error_t gpgrt_b64dec_proc (gpgrt_b64state_t state,
+                               void *buffer, size_t length, size_t *r_nbytes);
+gpg_error_t gpgrt_b64dec_finish (gpgrt_b64state_t state);
+
+#ifdef __cplusplus
+}
+#endif
+#endif	/* GPGRT_H */
+#endif	/* GPG_ERROR_H */
+/*
+Local Variables:
+buffer-read-only: t
+End:
+*/
diff --git a/libraries/cmake/source/libgpg-error/generated/ppc64le/mkerrcodes.h b/libraries/cmake/source/libgpg-error/generated/ppc64le/mkerrcodes.h
new file mode 100644
index 000000000..715560895
--- /dev/null
+++ b/libraries/cmake/source/libgpg-error/generated/ppc64le/mkerrcodes.h
@@ -0,0 +1,135 @@
+/* Output of mkerrcodes.awk.  DO NOT EDIT.  */
+
+static struct
+  {
+    int err;
+    const char *err_sym;
+  } err_table[] = 
+{
+  { 7, "GPG_ERR_E2BIG" },
+  { 13, "GPG_ERR_EACCES" },
+  { 98, "GPG_ERR_EADDRINUSE" },
+  { 99, "GPG_ERR_EADDRNOTAVAIL" },
+  { 68, "GPG_ERR_EADV" },
+  { 97, "GPG_ERR_EAFNOSUPPORT" },
+  { 11, "GPG_ERR_EAGAIN" },
+  { 114, "GPG_ERR_EALREADY" },
+  { 52, "GPG_ERR_EBADE" },
+  { 9, "GPG_ERR_EBADF" },
+  { 77, "GPG_ERR_EBADFD" },
+  { 74, "GPG_ERR_EBADMSG" },
+  { 53, "GPG_ERR_EBADR" },
+  { 56, "GPG_ERR_EBADRQC" },
+  { 57, "GPG_ERR_EBADSLT" },
+  { 59, "GPG_ERR_EBFONT" },
+  { 16, "GPG_ERR_EBUSY" },
+  { 125, "GPG_ERR_ECANCELED" },
+  { 10, "GPG_ERR_ECHILD" },
+  { 44, "GPG_ERR_ECHRNG" },
+  { 70, "GPG_ERR_ECOMM" },
+  { 103, "GPG_ERR_ECONNABORTED" },
+  { 111, "GPG_ERR_ECONNREFUSED" },
+  { 104, "GPG_ERR_ECONNRESET" },
+  { 35, "GPG_ERR_EDEADLK" },
+  { 58, "GPG_ERR_EDEADLOCK" },
+  { 89, "GPG_ERR_EDESTADDRREQ" },
+  { 33, "GPG_ERR_EDOM" },
+  { 73, "GPG_ERR_EDOTDOT" },
+  { 122, "GPG_ERR_EDQUOT" },
+  { 17, "GPG_ERR_EEXIST" },
+  { 14, "GPG_ERR_EFAULT" },
+  { 27, "GPG_ERR_EFBIG" },
+  { 112, "GPG_ERR_EHOSTDOWN" },
+  { 113, "GPG_ERR_EHOSTUNREACH" },
+  { 43, "GPG_ERR_EIDRM" },
+  { 84, "GPG_ERR_EILSEQ" },
+  { 115, "GPG_ERR_EINPROGRESS" },
+  { 4, "GPG_ERR_EINTR" },
+  { 22, "GPG_ERR_EINVAL" },
+  { 5, "GPG_ERR_EIO" },
+  { 106, "GPG_ERR_EISCONN" },
+  { 21, "GPG_ERR_EISDIR" },
+  { 120, "GPG_ERR_EISNAM" },
+  { 51, "GPG_ERR_EL2HLT" },
+  { 45, "GPG_ERR_EL2NSYNC" },
+  { 46, "GPG_ERR_EL3HLT" },
+  { 47, "GPG_ERR_EL3RST" },
+  { 79, "GPG_ERR_ELIBACC" },
+  { 80, "GPG_ERR_ELIBBAD" },
+  { 83, "GPG_ERR_ELIBEXEC" },
+  { 82, "GPG_ERR_ELIBMAX" },
+  { 81, "GPG_ERR_ELIBSCN" },
+  { 48, "GPG_ERR_ELNRNG" },
+  { 40, "GPG_ERR_ELOOP" },
+  { 124, "GPG_ERR_EMEDIUMTYPE" },
+  { 24, "GPG_ERR_EMFILE" },
+  { 31, "GPG_ERR_EMLINK" },
+  { 90, "GPG_ERR_EMSGSIZE" },
+  { 72, "GPG_ERR_EMULTIHOP" },
+  { 36, "GPG_ERR_ENAMETOOLONG" },
+  { 119, "GPG_ERR_ENAVAIL" },
+  { 100, "GPG_ERR_ENETDOWN" },
+  { 102, "GPG_ERR_ENETRESET" },
+  { 101, "GPG_ERR_ENETUNREACH" },
+  { 23, "GPG_ERR_ENFILE" },
+  { 55, "GPG_ERR_ENOANO" },
+  { 105, "GPG_ERR_ENOBUFS" },
+  { 50, "GPG_ERR_ENOCSI" },
+  { 61, "GPG_ERR_ENODATA" },
+  { 19, "GPG_ERR_ENODEV" },
+  { 2, "GPG_ERR_ENOENT" },
+  { 8, "GPG_ERR_ENOEXEC" },
+  { 37, "GPG_ERR_ENOLCK" },
+  { 67, "GPG_ERR_ENOLINK" },
+  { 123, "GPG_ERR_ENOMEDIUM" },
+  { 12, "GPG_ERR_ENOMEM" },
+  { 42, "GPG_ERR_ENOMSG" },
+  { 64, "GPG_ERR_ENONET" },
+  { 65, "GPG_ERR_ENOPKG" },
+  { 92, "GPG_ERR_ENOPROTOOPT" },
+  { 28, "GPG_ERR_ENOSPC" },
+  { 63, "GPG_ERR_ENOSR" },
+  { 60, "GPG_ERR_ENOSTR" },
+  { 38, "GPG_ERR_ENOSYS" },
+  { 15, "GPG_ERR_ENOTBLK" },
+  { 107, "GPG_ERR_ENOTCONN" },
+  { 20, "GPG_ERR_ENOTDIR" },
+  { 39, "GPG_ERR_ENOTEMPTY" },
+  { 118, "GPG_ERR_ENOTNAM" },
+  { 88, "GPG_ERR_ENOTSOCK" },
+  { 95, "GPG_ERR_ENOTSUP" },
+  { 25, "GPG_ERR_ENOTTY" },
+  { 76, "GPG_ERR_ENOTUNIQ" },
+  { 6, "GPG_ERR_ENXIO" },
+  { 95, "GPG_ERR_EOPNOTSUPP" },
+  { 75, "GPG_ERR_EOVERFLOW" },
+  { 1, "GPG_ERR_EPERM" },
+  { 96, "GPG_ERR_EPFNOSUPPORT" },
+  { 32, "GPG_ERR_EPIPE" },
+  { 71, "GPG_ERR_EPROTO" },
+  { 93, "GPG_ERR_EPROTONOSUPPORT" },
+  { 91, "GPG_ERR_EPROTOTYPE" },
+  { 34, "GPG_ERR_ERANGE" },
+  { 78, "GPG_ERR_EREMCHG" },
+  { 66, "GPG_ERR_EREMOTE" },
+  { 121, "GPG_ERR_EREMOTEIO" },
+  { 85, "GPG_ERR_ERESTART" },
+  { 30, "GPG_ERR_EROFS" },
+  { 108, "GPG_ERR_ESHUTDOWN" },
+  { 94, "GPG_ERR_ESOCKTNOSUPPORT" },
+  { 29, "GPG_ERR_ESPIPE" },
+  { 3, "GPG_ERR_ESRCH" },
+  { 69, "GPG_ERR_ESRMNT" },
+  { 116, "GPG_ERR_ESTALE" },
+  { 86, "GPG_ERR_ESTRPIPE" },
+  { 62, "GPG_ERR_ETIME" },
+  { 110, "GPG_ERR_ETIMEDOUT" },
+  { 109, "GPG_ERR_ETOOMANYREFS" },
+  { 26, "GPG_ERR_ETXTBSY" },
+  { 117, "GPG_ERR_EUCLEAN" },
+  { 49, "GPG_ERR_EUNATCH" },
+  { 87, "GPG_ERR_EUSERS" },
+  { 11, "GPG_ERR_EWOULDBLOCK" },
+  { 18, "GPG_ERR_EXDEV" },
+  { 54, "GPG_ERR_EXFULL" },
+};
diff --git a/libraries/cmake/source/libmagic/config/linux/ppc64le/config.h b/libraries/cmake/source/libmagic/config/linux/ppc64le/config.h
new file mode 100644
index 000000000..66f023497
--- /dev/null
+++ b/libraries/cmake/source/libmagic/config/linux/ppc64le/config.h
@@ -0,0 +1,463 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Define in built-in ELF support is used */
+#define BUILTIN_ELF 1
+
+/* Enable bzlib compression support */
+/* #undef BZLIBSUPPORT */
+
+/* Define for ELF core file support */
+#define ELFCORE 1
+
+/* Define to 1 if you have the `asctime_r' function. */
+#define HAVE_ASCTIME_R 1
+
+/* Define to 1 if you have the `asprintf' function. */
+#define HAVE_ASPRINTF 1
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+#define HAVE_BYTESWAP_H 1
+
+/* Define to 1 if you have the <bzlib.h> header file. */
+/* #undef HAVE_BZLIB_H */
+
+/* Define to 1 if you have the `ctime_r' function. */
+#define HAVE_CTIME_R 1
+
+/* HAVE_DAYLIGHT */
+#define HAVE_DAYLIGHT 1
+
+/* Define to 1 if you have the declaration of `daylight', and to 0 if you
+   don't. */
+#define HAVE_DECL_DAYLIGHT 1
+
+/* Define to 1 if you have the declaration of `tzname', and to 0 if you don't.
+   */
+#define HAVE_DECL_TZNAME 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `dprintf' function. */
+#define HAVE_DPRINTF 1
+
+/* Define to 1 if you have the <err.h> header file. */
+#define HAVE_ERR_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fmtcheck' function. */
+/* #undef HAVE_FMTCHECK */
+
+/* Define to 1 if you have the `fork' function. */
+#define HAVE_FORK 1
+
+/* Define to 1 if you have the `freelocale' function. */
+#define HAVE_FREELOCALE 1
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `getline' function. */
+#define HAVE_GETLINE 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getopt_long' function. */
+#define HAVE_GETOPT_LONG 1
+
+/* Define to 1 if you have the `getpagesize' function. */
+#define HAVE_GETPAGESIZE 1
+
+/* Define to 1 if you have the `gmtime_r' function. */
+#define HAVE_GMTIME_R 1
+
+/* Define to 1 if the system has the type `intptr_t'. */
+#define HAVE_INTPTR_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `bz2' library (-lbz2). */
+/* #undef HAVE_LIBBZ2 */
+
+/* Define to 1 if you have the `gnurx' library (-lgnurx). */
+/* #undef HAVE_LIBGNURX */
+
+/* Define to 1 if you have the `lz' library (-llz). */
+/* #undef HAVE_LIBLZ */
+
+/* Define to 1 if you have the `lzma' library (-llzma). */
+/* #undef HAVE_LIBLZMA */
+
+/* Define to 1 if you have the `seccomp' library (-lseccomp). */
+/* #undef HAVE_LIBSECCOMP */
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define HAVE_LIBZ 1
+
+/* Define to 1 if you have the `zstd' library (-lzstd). */
+/* #undef HAVE_LIBZSTD */
+
+/* Define to 1 if you have the `localtime_r' function. */
+#define HAVE_LOCALTIME_R 1
+
+/* Define to 1 if you have the <lzlib.h> header file. */
+/* #undef HAVE_LZLIB_H */
+
+/* Define to 1 if you have the <lzma.h> header file. */
+#define HAVE_LZMA_H 1
+
+/* Define to 1 if mbrtowc and mbstate_t are properly declared. */
+#define HAVE_MBRTOWC 1
+
+/* Define to 1 if <wchar.h> declares mbstate_t. */
+#define HAVE_MBSTATE_T 1
+
+/* Define to 1 if you have the `memmem' function. */
+#define HAVE_MEMMEM 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mkostemp' function. */
+#define HAVE_MKOSTEMP 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have a working `mmap' system call. */
+#define HAVE_MMAP 1
+
+/* Define to 1 if you have the `newlocale' function. */
+#define HAVE_NEWLOCALE 1
+
+/* Define to 1 if you have the `pipe2' function. */
+#define HAVE_PIPE2 1
+
+/* Define to 1 if you have the `posix_spawnp' function. */
+#define HAVE_POSIX_SPAWNP 1
+
+/* Define to 1 if you have the `pread' function. */
+#define HAVE_PREAD 1
+
+/* Have sig_t type */
+#define HAVE_SIG_T 1
+
+/* Define to 1 if you have the <spawn.h> header file. */
+#define HAVE_SPAWN_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strcasestr' function. */
+#define HAVE_STRCASESTR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strtof' function. */
+#define HAVE_STRTOF 1
+
+/* HAVE_STRUCT_OPTION */
+#define HAVE_STRUCT_OPTION 1
+
+/* Define to 1 if `st_rdev' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_RDEV 1
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_GMTOFF 1
+
+/* Define to 1 if `tm_zone' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_ZONE 1
+
+/* Define to 1 if you have the <sys/bswap.h> header file. */
+/* #undef HAVE_SYS_BSWAP_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#define HAVE_SYS_MMAN_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/sysmacros.h> header file. */
+#define HAVE_SYS_SYSMACROS_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/utime.h> header file. */
+/* #undef HAVE_SYS_UTIME_H */
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#define HAVE_SYS_WAIT_H 1
+
+/* HAVE_TM_ISDST */
+#define HAVE_TM_ISDST 1
+
+/* HAVE_TM_ZONE */
+#define HAVE_TM_ZONE 1
+
+/* HAVE_TZNAME */
+#define HAVE_TZNAME 1
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `uselocale' function. */
+#define HAVE_USELOCALE 1
+
+/* Define to 1 if you have the `utime' function. */
+#define HAVE_UTIME 1
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+#define HAVE_UTIME_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the `vfork' function. */
+#define HAVE_VFORK 1
+
+/* Define to 1 if you have the <vfork.h> header file. */
+/* #undef HAVE_VFORK_H */
+
+/* Define to 1 or 0, depending whether the compiler supports simple visibility
+   declarations. */
+#define HAVE_VISIBILITY 1
+
+/* Define to 1 if you have the <wchar.h> header file. */
+#define HAVE_WCHAR_H 1
+
+/* Define to 1 if you have the <wctype.h> header file. */
+#define HAVE_WCTYPE_H 1
+
+/* Define to 1 if you have the `wcwidth' function. */
+#define HAVE_WCWIDTH 1
+
+/* Define to 1 if `fork' works. */
+#define HAVE_WORKING_FORK 1
+
+/* Define to 1 if `vfork' works. */
+#define HAVE_WORKING_VFORK 1
+
+/* Define to 1 if you have the <xlocale.h> header file. */
+/* #undef HAVE_XLOCALE_H */
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define HAVE_ZLIB_H 1
+
+/* Define to 1 if you have the <zstd_errors.h> header file. */
+/* #undef HAVE_ZSTD_ERRORS_H */
+
+/* Define to 1 if you have the <zstd.h> header file. */
+/* #undef HAVE_ZSTD_H */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Enable lzlib compression support */
+/* #undef LZLIBSUPPORT */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
+   */
+/* #undef MAJOR_IN_MKDEV */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in
+   <sysmacros.h>. */
+#define MAJOR_IN_SYSMACROS 1
+
+/* Name of package */
+#define PACKAGE "file"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "christos@astron.com"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "file"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "file 5.45"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "file"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "5.45"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "5.45"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Enable xzlib compression support */
+#define XZLIBSUPPORT 1
+
+/* Enable zlib compression support */
+#define ZLIBSUPPORT 1
+
+/* Enable zstdlib compression support */
+/* #undef ZSTDLIBSUPPORT */
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT32_T */
+
+/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT64_T */
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT8_T */
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef int32_t */
+
+/* Define to the type of a signed integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef int64_t */
+
+/* Define to the type of a signed integer type wide enough to hold a pointer,
+   if such a type exists, and if the system does not define it. */
+/* #undef intptr_t */
+
+/* Define to a type if <wchar.h> does not define. */
+/* #undef mbstate_t */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint16_t */
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint32_t */
+
+/* Define to the type of an unsigned integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint64_t */
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint8_t */
+
+/* Define to the type of an unsigned integer type wide enough to hold a
+   pointer, if such a type exists, and if the system does not define it. */
+/* #undef uintptr_t */
+
+/* Define as `fork' if `vfork' does not work. */
+/* #undef vfork */
diff --git a/libraries/cmake/source/librdkafka/config/linux/ppc64le/config.h b/libraries/cmake/source/librdkafka/config/linux/ppc64le/config.h
new file mode 100644
index 000000000..49bda38a5
--- /dev/null
+++ b/libraries/cmake/source/librdkafka/config/linux/ppc64le/config.h
@@ -0,0 +1,50 @@
+#define WITHOUT_OPTIMIZATION 0
+#define ENABLE_DEVEL 0
+#define ENABLE_REFCNT_DEBUG 0
+
+#define HAVE_ATOMICS_32 1
+#define HAVE_ATOMICS_32_SYNC 0
+
+#if (HAVE_ATOMICS_32)
+# if (HAVE_ATOMICS_32_SYNC)
+#  define ATOMIC_OP32(OP1,OP2,PTR,VAL) __sync_ ## OP1 ## _and_ ## OP2(PTR, VAL)
+# else
+#  define ATOMIC_OP32(OP1,OP2,PTR,VAL) __atomic_ ## OP1 ## _ ## OP2(PTR, VAL, __ATOMIC_SEQ_CST)
+# endif
+#endif
+
+#define HAVE_ATOMICS_64 1
+#define HAVE_ATOMICS_64_SYNC 0
+
+#if (HAVE_ATOMICS_64)
+# if (HAVE_ATOMICS_64_SYNC)
+#  define ATOMIC_OP64(OP1,OP2,PTR,VAL) __sync_ ## OP1 ## _and_ ## OP2(PTR, VAL)
+# else
+#  define ATOMIC_OP64(OP1,OP2,PTR,VAL) __atomic_ ## OP1 ## _ ## OP2(PTR, VAL, __ATOMIC_SEQ_CST)
+# endif
+#endif
+
+#define WITH_PKGCONFIG 1
+#define WITH_HDRHISTOGRAM 1
+#define WITH_ZLIB 1
+#define WITH_ZSTD 1
+#define WITH_LIBDL 1
+#define WITH_PLUGINS 1
+#define WITH_SNAPPY 1
+#define WITH_SOCKEM 1
+#define WITH_SSL 1
+#define WITH_SASL 1
+#define WITH_SASL_SCRAM 1
+#define WITH_SASL_OAUTHBEARER 1
+#define WITH_SASL_CYRUS 0
+#define WITH_LZ4_EXT 0
+#define HAVE_REGEX 1
+#define HAVE_STRNDUP 1
+#define HAVE_RAND_R 1
+#define HAVE_PTHREAD_SETNAME_GNU 1
+#define HAVE_PTHREAD_SETNAME_DARWIN 1
+#define HAVE_PTHREAD_SETNAME_FREEBSD 0
+#define WITH_C11THREADS 1
+#define WITH_CRC32C_HW 0
+#define SOLIB_EXT ".so"
+#define BUILT_WITH  "CMAKE Clang Clang PKGCONFIG HDRHISTOGRAM ZLIB LIBDL PLUGINS SSL C11THREADS SNAPPY SOCKEM"
diff --git a/libraries/cmake/source/librdkafka/config/linux/ppc64le/dummy/README.md b/libraries/cmake/source/librdkafka/config/linux/ppc64le/dummy/README.md
new file mode 100644
index 000000000..8db433b26
--- /dev/null
+++ b/libraries/cmake/source/librdkafka/config/linux/ppc64le/dummy/README.md
@@ -0,0 +1 @@
+This folder is used by the `tinycthread.h` header: `#include "../config.h"`
diff --git a/libraries/cmake/source/librpm/config/ppc64le/config.h b/libraries/cmake/source/librpm/config/ppc64le/config.h
new file mode 100644
index 000000000..030385623
--- /dev/null
+++ b/libraries/cmake/source/librpm/config/ppc64le/config.h
@@ -0,0 +1,462 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Build with dbus support? */
+/* #undef DBUS */
+
+/* Build with systemd inhibit plugin? */
+#define ENABLE_INHIBIT_PLUGIN 1
+
+/* Enable new rpm database format? */
+#define ENABLE_NDB 1
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#define ENABLE_NLS 1
+
+/* Enable multithreading support? */
+/* #undef ENABLE_OPENMP */
+
+/* Build with plugin support? */
+/* #undef ENABLE_PLUGINS */
+
+/* Get the group name having groupid 0 */
+#define GID_0_GROUP "root"
+
+/* Define to 1 if you have the `basename' function. */
+#define HAVE_BASENAME 1
+
+/* Define to 1 if OpenSSL has BN_bn2binpad */
+#define HAVE_BN2BINPAD 1
+
+/* Define to 1 if you have the <bzlib.h> header file. */
+/* #undef HAVE_BZLIB_H */
+
+/* Have cap_compare function? */
+/* #undef HAVE_CAP_COMPARE */
+
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the declaration of `fdatasync', and to 0 if you
+   don't. */
+#define HAVE_DECL_FDATASYNC 1
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#define HAVE_DIRENT_H 1
+
+/* Define to 1 if you have the `dirname' function. */
+#define HAVE_DIRNAME 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if OpenSSL has DSA_set0_key */
+#define HAVE_DSA_SET0_KEY 1
+
+/* Define to 1 if OpenSSL has DSA_set0_pqg */
+#define HAVE_DSA_SET0_PQG 1
+
+/* Define to 1 if OpenSSL has DSA_SIG_set0 */
+#define HAVE_DSA_SIG_SET0 1
+
+/* Have dwelf_elf_begin? */
+/* #undef HAVE_DWELF_ELF_BEGIN */
+
+/* Define to 1 if you have the <elfutils/libdwelf.h> header file. */
+/* #undef HAVE_ELFUTILS_LIBDWELF_H */
+
+/* Define to 1 if OpenSSL has EVP_MD_CTX_new */
+#define HAVE_EVP_MD_CTX_NEW 1
+
+/* Define to 1 if you have the `fchmodat' function. */
+#define HAVE_FCHMODAT 1
+
+/* Define to 1 if you have the `fchownat' function. */
+#define HAVE_FCHOWNAT 1
+
+/* Define to 1 if you have the `fdatasync' function. */
+#define HAVE_FDATASYNC 1
+
+/* Define to 1 if you have the `fstatat' function. */
+#define HAVE_FSTATAT 1
+
+/* Define to 1 if you have the <gelf.h> header file. */
+/* #undef HAVE_GELF_H */
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#define HAVE_GETADDRINFO 1
+
+/* Define to 1 if you have the `getauxval' function. */
+/* #undef HAVE_GETAUXVAL */
+
+/* Define to 1 if you have the `getcwd' function. */
+#define HAVE_GETCWD 1
+
+/* Define to 1 if you have the `getline' function. */
+#define HAVE_GETLINE 1
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define as 1 if your zlib has gzseek() */
+#define HAVE_GZSEEK 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `lchown' function. */
+#define HAVE_LCHOWN 1
+
+/* Define to 1 if you have the `crypto' library (-lcrypto). */
+#define HAVE_LIBCRYPTO 1
+
+/* Define to 1 if you have elfutils libdw library */
+/* #undef HAVE_LIBDW */
+
+/* Define to 1 if you have the 'elf' library (-lelf). */
+/* #undef HAVE_LIBELF */
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+/* #undef HAVE_LIBNSL */
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#define HAVE_LIBPTHREAD 1
+
+/* Define to 1 if you have the `selinux' library (-lselinux). */
+/* #undef HAVE_LIBSELINUX */
+
+/* Define to 1 if you have the `thread' library (-lthread). */
+/* #undef HAVE_LIBTHREAD */
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if you have the `linkat' function. */
+#define HAVE_LINKAT 1
+
+/* Define to 1 if you have the <linux/fsverity.h> header file. */
+/* #undef HAVE_LINUX_FSVERITY_H */
+
+/* Define to 1 if you have the `localtime_r' function. */
+#define HAVE_LOCALTIME_R 1
+
+/* Define to 1 if you have the `lsetxattr' function. */
+/* #undef HAVE_LSETXATTR */
+
+/* Define to 1 if you have the `lutimes' function. */
+#define HAVE_LUTIMES 1
+
+/* Define to 1 if you have the <lzma.h> header file. */
+#define HAVE_LZMA_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mempcpy' function. */
+#define HAVE_MEMPCPY 1
+
+/* Define to 1 if you have the `mergesort' function. */
+/* #undef HAVE_MERGESORT */
+
+/* Define to 1 if you have the `mkdirat' function. */
+#define HAVE_MKDIRAT 1
+
+/* Define to 1 if you have the `mkfifoat' function. */
+#define HAVE_MKFIFOAT 1
+
+/* Define to 1 if you have the `mknodat' function. */
+#define HAVE_MKNODAT 1
+
+/* Define to 1 if you have the `mkstemp' function. */
+#define HAVE_MKSTEMP 1
+
+/* Define to 1 if you have the `mremap' function. */
+#define HAVE_MREMAP 1
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+/* #undef HAVE_NDIR_H */
+
+/* Define to 1 if you have the `openat' function. */
+#define HAVE_OPENAT 1
+
+/* Define to 1 if you have the <openssl/dsa.h> header file. */
+#define HAVE_OPENSSL_DSA_H 1
+
+/* Define to 1 if you have the <openssl/evp.h> header file. */
+#define HAVE_OPENSSL_EVP_H 1
+
+/* Define to 1 if you have the <openssl/rsa.h> header file. */
+#define HAVE_OPENSSL_RSA_H 1
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the `putenv' function. */
+#define HAVE_PUTENV 1
+
+/* Define if readline is available */
+/* #undef HAVE_READLINE */
+
+/* Define to 1 if you have the `realpath' function. */
+#define HAVE_REALPATH 1
+
+/* Define to 1 if you have the `regcomp' function. */
+#define HAVE_REGCOMP 1
+
+/* Define to 1 if you have the `renameat' function. */
+#define HAVE_RENAMEAT 1
+
+/* Define to 1 if OpenSSL has RSA_set0_key */
+#define HAVE_RSA_SET0_KEY 1
+
+/* Define to 1 if you have the `sched_getaffinity' function. */
+#define HAVE_SCHED_GETAFFINITY 1
+
+/* Define to 1 if you have the `secure_getenv' function. */
+/* #undef HAVE_SECURE_GETENV */
+
+/* Define to 1 if you have the `setenv' function. */
+#define HAVE_SETENV 1
+
+/* Define to 1 if SELinux setexecfilecon is present */
+/* #undef HAVE_SETEXECFILECON */
+
+/* Define to 1 if you have the `setprogname' function. */
+/* #undef HAVE_SETPROGNAME */
+
+/* Define to 1 if you have the `statvfs' function. */
+#define HAVE_STATVFS 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define to 1 if you have the `stpncpy' function. */
+#define HAVE_STPNCPY 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if `d_type' is a member of `struct dirent'. */
+#define HAVE_STRUCT_DIRENT_D_TYPE 1
+
+/* Define to 1 if you have the `symlinkat' function. */
+#define HAVE_SYMLINKAT 1
+
+/* Define to 1 if you have the `syncfs' function. */
+/* #undef HAVE_SYNCFS */
+
+/* Define to 1 if you have the <sys/auxv.h> header file. */
+/* #undef HAVE_SYS_AUXV_H */
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_DIR_H */
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+/* #undef HAVE_SYS_NDIR_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/systemcfg.h> header file. */
+/* #undef HAVE_SYS_SYSTEMCFG_H */
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/utsname.h> header file. */
+#define HAVE_SYS_UTSNAME_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unlinkat' function. */
+#define HAVE_UNLINKAT 1
+
+/* Define to 1 if you have the `unsetenv' function. */
+#define HAVE_UNSETENV 1
+
+/* Define to 1 if you have the `unshare' function. */
+#define HAVE_UNSHARE 1
+
+/* Define to 1 if you have the `utimensat' function. */
+#define HAVE_UTIMENSAT 1
+
+/* Define to 1 if you have the `utimes' function. */
+#define HAVE_UTIMES 1
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define HAVE_ZLIB_H 1
+
+/* Define if libzstd is available */
+#define HAVE_ZSTD 1
+
+/* Define if __progname is defined */
+#define HAVE___PROGNAME 1
+
+/* Define to 1 if you have the `__secure_getenv' function. */
+#define HAVE___SECURE_GETENV 1
+
+/* Define as const if the declaration of iconv() needs const. */
+#define ICONV_CONST 
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#define LT_OBJDIR ".libs/"
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
+   */
+/* #undef MAJOR_IN_MKDEV */
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in
+   <sysmacros.h>. */
+/* #undef MAJOR_IN_SYSMACROS */
+
+/* Name of package */
+#define PACKAGE "rpm"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "rpm-maint@lists.rpm.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "rpm"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "rpm 4.18.2"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "rpm"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "4.18.2"
+
+/* canonical vendor */
+#define RPMCANONVENDOR "unknown"
+
+/* run-time variable directory */
+#define RUNDIR "/run"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Get the user name having userid 0 */
+#define UID_0_USER "root"
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "4.18.2"
+
+/* Build with acl support? */
+/* #undef WITH_ACL */
+
+/* libaudit support */
+/* #undef WITH_AUDIT */
+
+/* Build with read-only Berkeley DB */
+#define WITH_BDB_RO 1
+
+/* Build with capability support? */
+/* #undef WITH_CAP */
+
+/* Build with fsverity support? */
+/* #undef WITH_FSVERITY */
+
+/* Build with imaevm support? */
+/* #undef WITH_IMAEVM */
+
+/* Build with selinux support? */
+/* #undef WITH_SELINUX */
+
+/* Define if SQLITE is available */
+#define WITH_SQLITE 1
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* A full path to a program, possibly with arguments, that will create a
+   directory and all necessary parent directories, ala 'mkdir -p' */
+#define __MKDIR_P "/usr/bin/mkdir -p"
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef pid_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
diff --git a/libraries/cmake/source/librpm/generated/ppc64le/lib/rpmhash.C b/libraries/cmake/source/librpm/generated/ppc64le/lib/rpmhash.C
new file mode 100644
index 000000000..6875397aa
--- /dev/null
+++ b/libraries/cmake/source/librpm/generated/ppc64le/lib/rpmhash.C
@@ -0,0 +1,309 @@
+/**
+ * \file lib/rpmhash.c
+ * Hash table implemenation
+ */
+
+#include "system.h"
+#include <stdio.h>
+#include "debug.h"
+
+#define Bucket JOIN(HASHTYPE,Buket)
+#define Bucket_s JOIN(HASHTYPE,Buket_s)
+
+typedef	struct  Bucket_s * Bucket;
+
+/**
+ */
+struct  Bucket_s {
+    Bucket next;	/*!< pointer to next item in bucket */
+    HTKEYTYPE key;      /*!< hash key */
+#ifdef HTDATATYPE
+    int dataCount;	/*!< data entries */
+    HTDATATYPE data[1];	/*!< data - grows by resizing whole bucket */
+#endif
+};
+
+/**
+ */
+struct HASHSTRUCT {
+    int numBuckets;			/*!< number of hash buckets */
+    Bucket * buckets;			/*!< hash bucket array */
+    hashFunctionType fn;		/*!< generate hash value for key */
+    hashEqualityType eq;		/*!< compare hash keys for equality */
+    hashFreeKey freeKey;
+    int bucketCount;			/*!< number of used buckets */
+    int keyCount;			/*!< number of keys */
+#ifdef HTDATATYPE
+    int dataCount;			/*!< number of data entries */
+    hashFreeData freeData;
+#endif
+};
+
+/**
+ * Find entry in hash table.
+ * @param ht            pointer to hash table
+ * @param key           pointer to key value
+ * @param keyHash	key hash
+ * @return pointer to hash bucket of key (or NULL)
+ */
+static
+Bucket HASHPREFIX(findEntry)(HASHTYPE ht, HTKEYTYPE key, unsigned int keyHash)
+{
+    unsigned int hash = keyHash % ht->numBuckets;
+    Bucket b = ht->buckets[hash];
+
+    while (b && ht->eq(b->key, key))
+	b = b->next;
+
+    return b;
+}
+
+HASHTYPE HASHPREFIX(Create)(int numBuckets,
+			    hashFunctionType fn, hashEqualityType eq,
+			    hashFreeKey freeKey
+#ifdef HTDATATYPE
+, hashFreeData freeData
+#endif
+)
+{
+    HASHTYPE ht;
+
+    ht = xmalloc(sizeof(*ht));
+    ht->numBuckets = numBuckets > 11 ? numBuckets : 11;
+    ht->buckets = xcalloc(ht->numBuckets, sizeof(*ht->buckets));
+    ht->freeKey = freeKey;
+#ifdef HTDATATYPE
+    ht->freeData = freeData;
+    ht->dataCount = 0;
+#endif
+    ht->fn = fn;
+    ht->eq = eq;
+    ht->bucketCount = ht->keyCount = 0;
+    return ht;
+}
+
+static void HASHPREFIX(Resize)(HASHTYPE ht, int numBuckets) {
+    Bucket * buckets = xcalloc(numBuckets, sizeof(*ht->buckets));
+
+    for (int i=0; i<ht->numBuckets; i++) {
+	Bucket b = ht->buckets[i];
+	Bucket nextB;
+	while (b != NULL) {
+	    unsigned int hash = ht->fn(b->key) % numBuckets;
+	    nextB = b->next;
+	    b->next = buckets[hash];
+	    buckets[hash] = b;
+	    b = nextB;
+	}
+    }
+    free(ht->buckets);
+    ht->buckets = buckets;
+    ht->numBuckets = numBuckets;
+}
+
+unsigned int HASHPREFIX(KeyHash)(HASHTYPE ht, HTKEYTYPE key)
+{
+    return ht->fn(key);
+}
+
+void HASHPREFIX(AddHEntry)(HASHTYPE ht, HTKEYTYPE key, unsigned int keyHash
+#ifdef HTDATATYPE
+, HTDATATYPE data
+#endif
+)
+{
+    unsigned int hash = keyHash % ht->numBuckets;
+    Bucket b = ht->buckets[hash];
+#ifdef HTDATATYPE
+    Bucket * b_addr = ht->buckets + hash;
+#endif
+
+    if (b == NULL) {
+	ht->bucketCount += 1;
+    }
+
+    while (b && ht->eq(b->key, key)) {
+#ifdef HTDATATYPE
+	b_addr = &(b->next);
+#endif
+	b = b->next;
+    }
+
+    if (b == NULL) {
+	ht->keyCount += 1;
+	b = xmalloc(sizeof(*b));
+	b->key = key;
+#ifdef HTDATATYPE
+	b->dataCount = 1;
+	b->data[0] = data;
+#endif
+	b->next = ht->buckets[hash];
+	ht->buckets[hash] = b;
+    }
+#ifdef HTDATATYPE
+    else {
+	if (ht->freeKey)
+	    ht->freeKey(key);
+	// resizing bucket TODO: increase exponentially
+	// Bucket_s already contains space for one dataset
+	b = *b_addr = xrealloc(
+	    b, sizeof(*b) + sizeof(b->data[0]) * (b->dataCount));
+	// though increasing dataCount after the resize
+	b->data[b->dataCount++] = data;
+    }
+    ht->dataCount += 1;
+#endif
+    if (ht->keyCount > ht->numBuckets) {
+	HASHPREFIX(Resize)(ht, ht->numBuckets * 2);
+    }
+}
+
+void HASHPREFIX(AddEntry)(HASHTYPE ht, HTKEYTYPE key
+#ifdef HTDATATYPE
+, HTDATATYPE data
+#endif
+)
+{
+#ifdef HTDATATYPE
+    HASHPREFIX(AddHEntry)(ht, key, ht->fn(key), data);
+#else
+    HASHPREFIX(AddHEntry)(ht, key, ht->fn(key));
+#endif
+}
+
+void HASHPREFIX(Empty)( HASHTYPE ht)
+{
+    Bucket b, n;
+    int i;
+
+    if (ht->bucketCount == 0) return;
+
+    for (i = 0; i < ht->numBuckets; i++) {
+	b = ht->buckets[i];
+	if (b == NULL)
+	    continue;
+	ht->buckets[i] = NULL;
+
+	do {
+	    n = b->next;
+	    if (ht->freeKey)
+		b->key = ht->freeKey(b->key);
+#ifdef HTDATATYPE
+	    if (ht->freeData) {
+		int j;
+		for (j=0; j < b->dataCount; j++ ) {
+		    b->data[j] = ht->freeData(b->data[j]);
+		}
+	    }
+#endif
+	    b = _free(b);
+	} while ((b = n) != NULL);
+    }
+    ht->bucketCount = 0;
+    ht->keyCount = 0;
+#ifdef HTDATATYPE
+    ht->dataCount = 0;
+#endif
+}
+
+HASHTYPE HASHPREFIX(Free)(HASHTYPE ht)
+{
+    if (ht==NULL)
+        return ht;
+    HASHPREFIX(Empty)(ht);
+    ht->buckets = _free(ht->buckets);
+    ht = _free(ht);
+
+    return NULL;
+}
+
+int HASHPREFIX(HasHEntry)(HASHTYPE ht, HTKEYTYPE key, unsigned int keyHash)
+{
+    Bucket b;
+
+    if (!(b = HASHPREFIX(findEntry)(ht, key, keyHash))) return 0; else return 1;
+}
+
+int HASHPREFIX(HasEntry)(HASHTYPE ht, HTKEYTYPE key)
+{
+    return HASHPREFIX(HasHEntry)(ht, key, ht->fn(key));
+}
+
+int HASHPREFIX(GetHEntry)(HASHTYPE ht, HTKEYTYPE key, unsigned int keyHash,
+#ifdef HTDATATYPE
+			 HTDATATYPE** data, int * dataCount,
+#endif
+			 HTKEYTYPE* tableKey)
+{
+    Bucket b;
+    int rc = ((b = HASHPREFIX(findEntry)(ht, key, keyHash)) != NULL);
+
+#ifdef HTDATATYPE
+    if (data)
+	*data = rc ? b->data : NULL;
+    if (dataCount)
+	*dataCount = rc ? b->dataCount : 0;
+#endif
+    if (tableKey && rc)
+	*tableKey = b->key;
+
+    return rc;
+}
+
+int HASHPREFIX(GetEntry)(HASHTYPE ht, HTKEYTYPE key,
+#ifdef HTDATATYPE
+			 HTDATATYPE** data, int * dataCount,
+#endif
+			 HTKEYTYPE* tableKey)
+{
+    return HASHPREFIX(GetHEntry)(ht, key, ht->fn(key),
+#ifdef HTDATATYPE
+				 data, dataCount,
+#endif
+				 tableKey);
+}
+
+unsigned int HASHPREFIX(NumBuckets)(HASHTYPE ht) {
+    return ht->numBuckets;
+}
+
+unsigned int HASHPREFIX(UsedBuckets)(HASHTYPE ht) {
+    return ht->bucketCount;
+}
+
+unsigned int HASHPREFIX(NumKeys)(HASHTYPE ht) {
+    return ht->keyCount;
+}
+
+#ifdef HTDATATYPE
+unsigned int HASHPREFIX(NumData)(HASHTYPE ht) {
+    return ht->dataCount;
+}
+#endif
+
+
+void HASHPREFIX(PrintStats)(HASHTYPE ht) {
+    int i;
+    Bucket bucket;
+
+    int hashcnt=0, bucketcnt=0, datacnt=0;
+    int maxbuckets=0;
+
+    for (i=0; i<ht->numBuckets; i++) {
+        int buckets = 0;
+        for (bucket=ht->buckets[i]; bucket; bucket=bucket->next){
+	    buckets++;
+#ifdef HTDATATYPE
+	    datacnt += bucket->dataCount;
+#endif
+	}
+	if (maxbuckets < buckets) maxbuckets = buckets;
+	if (buckets) hashcnt++;
+	bucketcnt += buckets;
+    }
+    fprintf(stderr, "Hashsize: %i\n", ht->numBuckets);
+    fprintf(stderr, "Hashbuckets: %i\n", hashcnt);
+    fprintf(stderr, "Keys: %i\n", bucketcnt);
+    fprintf(stderr, "Values: %i\n", datacnt);
+    fprintf(stderr, "Max Keys/Bucket: %i\n", maxbuckets);
+}
diff --git a/libraries/cmake/source/librpm/generated/ppc64le/lib/tagtbl.C b/libraries/cmake/source/librpm/generated/ppc64le/lib/tagtbl.C
new file mode 100644
index 000000000..fd5525f7a
--- /dev/null
+++ b/libraries/cmake/source/librpm/generated/ppc64le/lib/tagtbl.C
@@ -0,0 +1,253 @@
+static const struct headerTagTableEntry_s rpmTagTable[] = {
+    { "RPMTAG_ARCH", "Arch", RPMTAG_ARCH, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_ARCHIVESIZE", "Archivesize", RPMTAG_ARCHIVESIZE, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_ARCHSUFFIX", "Archsuffix", RPMTAG_ARCHSUFFIX, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_BASENAMES", "Basenames", RPMTAG_BASENAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_BUGURL", "Bugurl", RPMTAG_BUGURL, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_BUILDARCHS", "Buildarchs", RPMTAG_BUILDARCHS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_BUILDHOST", "Buildhost", RPMTAG_BUILDHOST, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_BUILDTIME", "Buildtime", RPMTAG_BUILDTIME, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_C", "C", RPMTAG_CONFLICTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CHANGELOGNAME", "Changelogname", RPMTAG_CHANGELOGNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CHANGELOGTEXT", "Changelogtext", RPMTAG_CHANGELOGTEXT, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CHANGELOGTIME", "Changelogtime", RPMTAG_CHANGELOGTIME, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CLASSDICT", "Classdict", RPMTAG_CLASSDICT, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CONFLICTFLAGS", "Conflictflags", RPMTAG_CONFLICTFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CONFLICTNAME", "Conflictname", RPMTAG_CONFLICTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CONFLICTNEVRS", "Conflictnevrs", RPMTAG_CONFLICTNEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_CONFLICTS", "Conflicts", RPMTAG_CONFLICTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_CONFLICTVERSION", "Conflictversion", RPMTAG_CONFLICTVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_COOKIE", "Cookie", RPMTAG_COOKIE, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_DBINSTANCE", "Dbinstance", RPMTAG_DBINSTANCE, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_DEPENDSDICT", "Dependsdict", RPMTAG_DEPENDSDICT, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_DESCRIPTION", "Description", RPMTAG_DESCRIPTION, RPM_I18NSTRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_DIRINDEXES", "Dirindexes", RPMTAG_DIRINDEXES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_DIRNAMES", "Dirnames", RPMTAG_DIRNAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_DISTRIBUTION", "Distribution", RPMTAG_DISTRIBUTION, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_DISTTAG", "Disttag", RPMTAG_DISTTAG, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_DISTURL", "Disturl", RPMTAG_DISTURL, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_DSAHEADER", "Dsaheader", RPMTAG_DSAHEADER, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_E", "E", RPMTAG_EPOCH, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_ENCODING", "Encoding", RPMTAG_ENCODING, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_ENHANCEFLAGS", "Enhanceflags", RPMTAG_ENHANCEFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ENHANCENAME", "Enhancename", RPMTAG_ENHANCENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ENHANCENEVRS", "Enhancenevrs", RPMTAG_ENHANCENEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_ENHANCES", "Enhances", RPMTAG_ENHANCENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ENHANCEVERSION", "Enhanceversion", RPMTAG_ENHANCEVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_EPOCH", "Epoch", RPMTAG_EPOCH, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_EPOCHNUM", "Epochnum", RPMTAG_EPOCHNUM, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_EVR", "Evr", RPMTAG_EVR, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_EXCLUDEARCH", "Excludearch", RPMTAG_EXCLUDEARCH, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_EXCLUDEOS", "Excludeos", RPMTAG_EXCLUDEOS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_EXCLUSIVEARCH", "Exclusivearch", RPMTAG_EXCLUSIVEARCH, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_EXCLUSIVEOS", "Exclusiveos", RPMTAG_EXCLUSIVEOS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILECAPS", "Filecaps", RPMTAG_FILECAPS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILECLASS", "Fileclass", RPMTAG_FILECLASS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILECOLORS", "Filecolors", RPMTAG_FILECOLORS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILECONTEXTS", "Filecontexts", RPMTAG_FILECONTEXTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEDEPENDSN", "Filedependsn", RPMTAG_FILEDEPENDSN, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEDEPENDSX", "Filedependsx", RPMTAG_FILEDEPENDSX, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEDEVICES", "Filedevices", RPMTAG_FILEDEVICES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEDIGESTALGO", "Filedigestalgo", RPMTAG_FILEDIGESTALGO, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEDIGESTS", "Filedigests", RPMTAG_FILEDIGESTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEFLAGS", "Fileflags", RPMTAG_FILEFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEGROUPNAME", "Filegroupname", RPMTAG_FILEGROUPNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEINODES", "Fileinodes", RPMTAG_FILEINODES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILELANGS", "Filelangs", RPMTAG_FILELANGS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILELINKTOS", "Filelinktos", RPMTAG_FILELINKTOS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEMD5S", "Filemd5s", RPMTAG_FILEDIGESTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEMODES", "Filemodes", RPMTAG_FILEMODES, RPM_INT16_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEMTIMES", "Filemtimes", RPMTAG_FILEMTIMES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILENAMES", "Filenames", RPMTAG_FILENAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_FILENLINKS", "Filenlinks", RPMTAG_FILENLINKS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_FILEPROVIDE", "Fileprovide", RPMTAG_FILEPROVIDE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_FILERDEVS", "Filerdevs", RPMTAG_FILERDEVS, RPM_INT16_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEREQUIRE", "Filerequire", RPMTAG_FILEREQUIRE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_FILESIGNATURELENGTH", "Filesignaturelength", RPMTAG_FILESIGNATURELENGTH, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_FILESIGNATURES", "Filesignatures", RPMTAG_FILESIGNATURES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILESIZES", "Filesizes", RPMTAG_FILESIZES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILESTATES", "Filestates", RPMTAG_FILESTATES, RPM_CHAR_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERCONDS", "Filetriggerconds", RPMTAG_FILETRIGGERCONDS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_FILETRIGGERFLAGS", "Filetriggerflags", RPMTAG_FILETRIGGERFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERINDEX", "Filetriggerindex", RPMTAG_FILETRIGGERINDEX, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERNAME", "Filetriggername", RPMTAG_FILETRIGGERNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERPRIORITIES", "Filetriggerpriorities", RPMTAG_FILETRIGGERPRIORITIES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERSCRIPTFLAGS", "Filetriggerscriptflags", RPMTAG_FILETRIGGERSCRIPTFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERSCRIPTPROG", "Filetriggerscriptprog", RPMTAG_FILETRIGGERSCRIPTPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERSCRIPTS", "Filetriggerscripts", RPMTAG_FILETRIGGERSCRIPTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILETRIGGERTYPE", "Filetriggertype", RPMTAG_FILETRIGGERTYPE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_FILETRIGGERVERSION", "Filetriggerversion", RPMTAG_FILETRIGGERVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEUSERNAME", "Fileusername", RPMTAG_FILEUSERNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FILEVERIFYFLAGS", "Fileverifyflags", RPMTAG_FILEVERIFYFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_FSCONTEXTS", "Fscontexts", RPMTAG_FSCONTEXTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_GIF", "Gif", RPMTAG_GIF, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_GROUP", "Group", RPMTAG_GROUP, RPM_I18NSTRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_HDRID", "Hdrid", RPMTAG_SHA1HEADER, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_HEADERCOLOR", "Headercolor", RPMTAG_HEADERCOLOR, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_HEADERI18NTABLE", "Headeri18ntable", RPMTAG_HEADERI18NTABLE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_HEADERIMAGE", "Headerimage", RPMTAG_HEADERIMAGE, RPM_NULL_TYPE, RPM_ANY_RETURN_TYPE, 0 },
+    { "RPMTAG_HEADERIMMUTABLE", "Headerimmutable", RPMTAG_HEADERIMMUTABLE, RPM_NULL_TYPE, RPM_ANY_RETURN_TYPE, 0 },
+    { "RPMTAG_HEADERREGIONS", "Headerregions", RPMTAG_HEADERREGIONS, RPM_NULL_TYPE, RPM_ANY_RETURN_TYPE, 0 },
+    { "RPMTAG_HEADERSIGNATURES", "Headersignatures", RPMTAG_HEADERSIGNATURES, RPM_NULL_TYPE, RPM_ANY_RETURN_TYPE, 0 },
+    { "RPMTAG_ICON", "Icon", RPMTAG_ICON, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_INSTALLCOLOR", "Installcolor", RPMTAG_INSTALLCOLOR, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_INSTALLTID", "Installtid", RPMTAG_INSTALLTID, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_INSTALLTIME", "Installtime", RPMTAG_INSTALLTIME, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_INSTFILENAMES", "Instfilenames", RPMTAG_INSTFILENAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_INSTPREFIXES", "Instprefixes", RPMTAG_INSTPREFIXES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_LICENSE", "License", RPMTAG_LICENSE, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_LONGARCHIVESIZE", "Longarchivesize", RPMTAG_LONGARCHIVESIZE, RPM_INT64_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_LONGFILESIZES", "Longfilesizes", RPMTAG_LONGFILESIZES, RPM_INT64_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_LONGSIGSIZE", "Longsigsize", RPMTAG_LONGSIGSIZE, RPM_INT64_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_LONGSIZE", "Longsize", RPMTAG_LONGSIZE, RPM_INT64_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_MODULARITYLABEL", "Modularitylabel", RPMTAG_MODULARITYLABEL, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_NAME", "Name", RPMTAG_NAME, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_NEVRA", "Nevra", RPMTAG_NEVRA, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_NEVR", "Nevr", RPMTAG_NEVR, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_N", "N", RPMTAG_NAME, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_NOPATCH", "Nopatch", RPMTAG_NOPATCH, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_NOSOURCE", "Nosource", RPMTAG_NOSOURCE, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_NVRA", "Nvra", RPMTAG_NVRA, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_NVR", "Nvr", RPMTAG_NVR, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_OBSOLETEFLAGS", "Obsoleteflags", RPMTAG_OBSOLETEFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OBSOLETENAME", "Obsoletename", RPMTAG_OBSOLETENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OBSOLETENEVRS", "Obsoletenevrs", RPMTAG_OBSOLETENEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_OBSOLETES", "Obsoletes", RPMTAG_OBSOLETENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OBSOLETEVERSION", "Obsoleteversion", RPMTAG_OBSOLETEVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDENHANCESFLAGS", "Oldenhancesflags", RPMTAG_OLDENHANCESFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDENHANCESNAME", "Oldenhancesname", RPMTAG_OLDENHANCESNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDENHANCES", "Oldenhances", RPMTAG_OLDENHANCESNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDENHANCESVERSION", "Oldenhancesversion", RPMTAG_OLDENHANCESVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDFILENAMES", "Oldfilenames", RPMTAG_OLDFILENAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDSUGGESTSFLAGS", "Oldsuggestsflags", RPMTAG_OLDSUGGESTSFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDSUGGESTSNAME", "Oldsuggestsname", RPMTAG_OLDSUGGESTSNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDSUGGESTS", "Oldsuggests", RPMTAG_OLDSUGGESTSNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OLDSUGGESTSVERSION", "Oldsuggestsversion", RPMTAG_OLDSUGGESTSVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_O", "O", RPMTAG_OBSOLETENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_OPTFLAGS", "Optflags", RPMTAG_OPTFLAGS, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_ORDERFLAGS", "Orderflags", RPMTAG_ORDERFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ORDERNAME", "Ordername", RPMTAG_ORDERNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ORDERVERSION", "Orderversion", RPMTAG_ORDERVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ORIGBASENAMES", "Origbasenames", RPMTAG_ORIGBASENAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ORIGDIRINDEXES", "Origdirindexes", RPMTAG_ORIGDIRINDEXES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ORIGDIRNAMES", "Origdirnames", RPMTAG_ORIGDIRNAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_ORIGFILENAMES", "Origfilenames", RPMTAG_ORIGFILENAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_OS", "Os", RPMTAG_OS, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PACKAGER", "Packager", RPMTAG_PACKAGER, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PATCHESFLAGS", "Patchesflags", RPMTAG_PATCHESFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PATCHESNAME", "Patchesname", RPMTAG_PATCHESNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PATCHESVERSION", "Patchesversion", RPMTAG_PATCHESVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PATCH", "Patch", RPMTAG_PATCH, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PAYLOADCOMPRESSOR", "Payloadcompressor", RPMTAG_PAYLOADCOMPRESSOR, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PAYLOADDIGESTALGO", "Payloaddigestalgo", RPMTAG_PAYLOADDIGESTALGO, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PAYLOADDIGESTALT", "Payloaddigestalt", RPMTAG_PAYLOADDIGESTALT, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PAYLOADDIGEST", "Payloaddigest", RPMTAG_PAYLOADDIGEST, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PAYLOADFLAGS", "Payloadflags", RPMTAG_PAYLOADFLAGS, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PAYLOADFORMAT", "Payloadformat", RPMTAG_PAYLOADFORMAT, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PKGID", "Pkgid", RPMTAG_SIGMD5, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PLATFORM", "Platform", RPMTAG_PLATFORM, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POLICIES", "Policies", RPMTAG_POLICIES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POLICYFLAGS", "Policyflags", RPMTAG_POLICYFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POLICYNAMES", "Policynames", RPMTAG_POLICYNAMES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POLICYTYPESINDEXES", "Policytypesindexes", RPMTAG_POLICYTYPESINDEXES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POLICYTYPES", "Policytypes", RPMTAG_POLICYTYPES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTINFLAGS", "Postinflags", RPMTAG_POSTINFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTIN", "Postin", RPMTAG_POSTIN, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTINPROG", "Postinprog", RPMTAG_POSTINPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTTRANSFLAGS", "Posttransflags", RPMTAG_POSTTRANSFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTTRANS", "Posttrans", RPMTAG_POSTTRANS, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTTRANSPROG", "Posttransprog", RPMTAG_POSTTRANSPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTUNFLAGS", "Postunflags", RPMTAG_POSTUNFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTUN", "Postun", RPMTAG_POSTUN, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_POSTUNPROG", "Postunprog", RPMTAG_POSTUNPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_P", "P", RPMTAG_PROVIDENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PREFIXES", "Prefixes", RPMTAG_PREFIXES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PREINFLAGS", "Preinflags", RPMTAG_PREINFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PREIN", "Prein", RPMTAG_PREIN, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PREINPROG", "Preinprog", RPMTAG_PREINPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PRETRANSFLAGS", "Pretransflags", RPMTAG_PRETRANSFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PRETRANS", "Pretrans", RPMTAG_PRETRANS, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PRETRANSPROG", "Pretransprog", RPMTAG_PRETRANSPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PREUNFLAGS", "Preunflags", RPMTAG_PREUNFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PREUN", "Preun", RPMTAG_PREUN, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_PREUNPROG", "Preunprog", RPMTAG_PREUNPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PROVIDEFLAGS", "Provideflags", RPMTAG_PROVIDEFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PROVIDENAME", "Providename", RPMTAG_PROVIDENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PROVIDENEVRS", "Providenevrs", RPMTAG_PROVIDENEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_PROVIDES", "Provides", RPMTAG_PROVIDENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PROVIDEVERSION", "Provideversion", RPMTAG_PROVIDEVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_PUBKEYS", "Pubkeys", RPMTAG_PUBKEYS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_RECOMMENDFLAGS", "Recommendflags", RPMTAG_RECOMMENDFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_RECOMMENDNAME", "Recommendname", RPMTAG_RECOMMENDNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_RECOMMENDNEVRS", "Recommendnevrs", RPMTAG_RECOMMENDNEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_RECOMMENDS", "Recommends", RPMTAG_RECOMMENDNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_RECOMMENDVERSION", "Recommendversion", RPMTAG_RECOMMENDVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_RECONTEXTS", "Recontexts", RPMTAG_RECONTEXTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_RELEASE", "Release", RPMTAG_RELEASE, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_REMOVETID", "Removetid", RPMTAG_REMOVETID, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_REQUIREFLAGS", "Requireflags", RPMTAG_REQUIREFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_REQUIRENAME", "Requirename", RPMTAG_REQUIRENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_REQUIRENEVRS", "Requirenevrs", RPMTAG_REQUIRENEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_REQUIRES", "Requires", RPMTAG_REQUIRENAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_REQUIREVERSION", "Requireversion", RPMTAG_REQUIREVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_RPMVERSION", "Rpmversion", RPMTAG_RPMVERSION, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_R", "R", RPMTAG_RELEASE, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_RSAHEADER", "Rsaheader", RPMTAG_RSAHEADER, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SHA1HEADER", "Sha1header", RPMTAG_SHA1HEADER, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SHA256HEADER", "Sha256header", RPMTAG_SHA256HEADER, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SIGGPG", "Siggpg", RPMTAG_SIGGPG, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SIGMD5", "Sigmd5", RPMTAG_SIGMD5, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SIGPGP", "Sigpgp", RPMTAG_SIGPGP, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SIGSIZE", "Sigsize", RPMTAG_SIGSIZE, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SIZE", "Size", RPMTAG_SIZE, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SOURCEPACKAGE", "Sourcepackage", RPMTAG_SOURCEPACKAGE, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SOURCEPKGID", "Sourcepkgid", RPMTAG_SOURCEPKGID, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SOURCERPM", "Sourcerpm", RPMTAG_SOURCERPM, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SOURCE", "Source", RPMTAG_SOURCE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SPEC", "Spec", RPMTAG_SPEC, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SUGGESTFLAGS", "Suggestflags", RPMTAG_SUGGESTFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUGGESTNAME", "Suggestname", RPMTAG_SUGGESTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUGGESTNEVRS", "Suggestnevrs", RPMTAG_SUGGESTNEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_SUGGESTS", "Suggests", RPMTAG_SUGGESTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUGGESTVERSION", "Suggestversion", RPMTAG_SUGGESTVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUMMARY", "Summary", RPMTAG_SUMMARY, RPM_I18NSTRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_SUPPLEMENTFLAGS", "Supplementflags", RPMTAG_SUPPLEMENTFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUPPLEMENTNAME", "Supplementname", RPMTAG_SUPPLEMENTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUPPLEMENTNEVRS", "Supplementnevrs", RPMTAG_SUPPLEMENTNEVRS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_SUPPLEMENTS", "Supplements", RPMTAG_SUPPLEMENTNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_SUPPLEMENTVERSION", "Supplementversion", RPMTAG_SUPPLEMENTVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERCONDS", "Transfiletriggerconds", RPMTAG_TRANSFILETRIGGERCONDS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_TRANSFILETRIGGERFLAGS", "Transfiletriggerflags", RPMTAG_TRANSFILETRIGGERFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERINDEX", "Transfiletriggerindex", RPMTAG_TRANSFILETRIGGERINDEX, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERNAME", "Transfiletriggername", RPMTAG_TRANSFILETRIGGERNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERPRIORITIES", "Transfiletriggerpriorities", RPMTAG_TRANSFILETRIGGERPRIORITIES, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERSCRIPTFLAGS", "Transfiletriggerscriptflags", RPMTAG_TRANSFILETRIGGERSCRIPTFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERSCRIPTPROG", "Transfiletriggerscriptprog", RPMTAG_TRANSFILETRIGGERSCRIPTPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERSCRIPTS", "Transfiletriggerscripts", RPMTAG_TRANSFILETRIGGERSCRIPTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSFILETRIGGERTYPE", "Transfiletriggertype", RPMTAG_TRANSFILETRIGGERTYPE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_TRANSFILETRIGGERVERSION", "Transfiletriggerversion", RPMTAG_TRANSFILETRIGGERVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRANSLATIONURL", "Translationurl", RPMTAG_TRANSLATIONURL, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERCONDS", "Triggerconds", RPMTAG_TRIGGERCONDS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_TRIGGERFLAGS", "Triggerflags", RPMTAG_TRIGGERFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERINDEX", "Triggerindex", RPMTAG_TRIGGERINDEX, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERNAME", "Triggername", RPMTAG_TRIGGERNAME, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERSCRIPTFLAGS", "Triggerscriptflags", RPMTAG_TRIGGERSCRIPTFLAGS, RPM_INT32_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERSCRIPTPROG", "Triggerscriptprog", RPMTAG_TRIGGERSCRIPTPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERSCRIPTS", "Triggerscripts", RPMTAG_TRIGGERSCRIPTS, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_TRIGGERTYPE", "Triggertype", RPMTAG_TRIGGERTYPE, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 1 },
+    { "RPMTAG_TRIGGERVERSION", "Triggerversion", RPMTAG_TRIGGERVERSION, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_UPSTREAMRELEASES", "Upstreamreleases", RPMTAG_UPSTREAMRELEASES, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_URL", "Url", RPMTAG_URL, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_VCS", "Vcs", RPMTAG_VCS, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_VENDOR", "Vendor", RPMTAG_VENDOR, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_VERBOSE", "Verbose", RPMTAG_VERBOSE, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 1 },
+    { "RPMTAG_VERIFYSCRIPTFLAGS", "Verifyscriptflags", RPMTAG_VERIFYSCRIPTFLAGS, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_VERIFYSCRIPTPROG", "Verifyscriptprog", RPMTAG_VERIFYSCRIPTPROG, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_VERIFYSCRIPT", "Verifyscript", RPMTAG_VERIFYSCRIPT, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_VERITYSIGNATUREALGO", "Veritysignaturealgo", RPMTAG_VERITYSIGNATUREALGO, RPM_INT32_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_VERITYSIGNATURES", "Veritysignatures", RPMTAG_VERITYSIGNATURES, RPM_STRING_ARRAY_TYPE, RPM_ARRAY_RETURN_TYPE, 0 },
+    { "RPMTAG_VERSION", "Version", RPMTAG_VERSION, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_V", "V", RPMTAG_VERSION, RPM_STRING_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { "RPMTAG_XPM", "Xpm", RPMTAG_XPM, RPM_BIN_TYPE, RPM_SCALAR_RETURN_TYPE, 0 },
+    { NULL, NULL, RPMTAG_NOT_FOUND, RPM_NULL_TYPE, 0 }
+};
diff --git a/libraries/cmake/source/lzma/CMakeLists.txt b/libraries/cmake/source/lzma/CMakeLists.txt
index 86af927e7..87e69f2a1 100644
--- a/libraries/cmake/source/lzma/CMakeLists.txt
+++ b/libraries/cmake/source/lzma/CMakeLists.txt
@@ -88,6 +88,7 @@ function(lzmaMain)
     "${library_root}/src/liblzma/simple/simple_decoder.c"
     "${library_root}/src/liblzma/simple/simple_encoder.c"
     "${library_root}/src/liblzma/simple/x86.c"
+    "${library_root}/src/liblzma/simple/powerpc.c"
   )
 
   target_compile_definitions(thirdparty_lzma PRIVATE
diff --git a/libraries/cmake/source/lzma/config/linux/ppc64le/config.h b/libraries/cmake/source/lzma/config/linux/ppc64le/config.h
new file mode 100644
index 000000000..26881f587
--- /dev/null
+++ b/libraries/cmake/source/lzma/config/linux/ppc64le/config.h
@@ -0,0 +1,543 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* How many MiB of RAM to assume if the real amount cannot be determined. */
+#define ASSUME_RAM 128
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+/* #undef ENABLE_NLS */
+
+/* Define to 1 if bswap_16 is available. */
+/* #undef HAVE_BSWAP_16 */
+
+/* Define to 1 if bswap_32 is available. */
+/* #undef HAVE_BSWAP_32 */
+
+/* Define to 1 if bswap_64 is available. */
+/* #undef HAVE_BSWAP_64 */
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+/* #undef HAVE_BYTESWAP_H */
+
+/* Define to 1 if Capsicum is available. */
+/* #undef HAVE_CAPSICUM */
+
+/* Define to 1 if the system has the type `CC_SHA256_CTX'. */
+/* #undef HAVE_CC_SHA256_CTX */
+
+/* Define to 1 if you have the `CC_SHA256_Init' function. */
+/* #undef HAVE_CC_SHA256_INIT */
+
+/* Define to 1 if you have the Mac OS X function
+   CFLocaleCopyPreferredLanguages in the CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYPREFERREDLANGUAGES */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if crc32 integrity check is enabled. */
+#define HAVE_CHECK_CRC32 1
+
+/* Define to 1 if crc64 integrity check is enabled. */
+#define HAVE_CHECK_CRC64 1
+
+/* Define to 1 if sha256 integrity check is enabled. */
+#define HAVE_CHECK_SHA256 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Define to 1 if `CLOCK_MONOTONIC' is declared in <time.h>. */
+#define HAVE_CLOCK_MONOTONIC 1
+
+/* Define to 1 if you have the <CommonCrypto/CommonDigest.h> header file. */
+/* #undef HAVE_COMMONCRYPTO_COMMONDIGEST_H */
+
+/* Define to 1 if you have the <cpuid.h> header file. */
+/* #undef HAVE_CPUID_H */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+/* #undef HAVE_DCGETTEXT */
+
+/* Define to 1 if any of HAVE_DECODER_foo have been defined. */
+#define HAVE_DECODERS 1
+
+/* Define to 1 if arm decoder is enabled. */
+#define HAVE_DECODER_ARM 1
+
+/* Define to 1 if arm64 decoder is enabled. */
+#define HAVE_DECODER_ARM64 1
+
+/* Define to 1 if armthumb decoder is enabled. */
+#define HAVE_DECODER_ARMTHUMB 1
+
+/* Define to 1 if delta decoder is enabled. */
+#define HAVE_DECODER_DELTA 1
+
+/* Define to 1 if ia64 decoder is enabled. */
+/* #undef HAVE_DECODER_IA64 */
+
+/* Define to 1 if lzma1 decoder is enabled. */
+#define HAVE_DECODER_LZMA1 1
+
+/* Define to 1 if lzma2 decoder is enabled. */
+#define HAVE_DECODER_LZMA2 1
+
+/* Define to 1 if powerpc decoder is enabled. */
+#define HAVE_DECODER_POWERPC 1
+
+/* Define to 1 if sparc decoder is enabled. */
+/* #undef HAVE_DECODER_SPARC */
+
+/* Define to 1 if x86 decoder is enabled. */
+#define HAVE_DECODER_X86 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if any of HAVE_ENCODER_foo have been defined. */
+#define HAVE_ENCODERS 1
+
+/* Define to 1 if arm encoder is enabled. */
+#define HAVE_ENCODER_ARM 1
+
+/* Define to 1 if arm64 encoder is enabled. */
+#define HAVE_ENCODER_ARM64 1
+
+/* Define to 1 if armthumb encoder is enabled. */
+#define HAVE_ENCODER_ARMTHUMB 1
+
+/* Define to 1 if delta encoder is enabled. */
+#define HAVE_ENCODER_DELTA 1
+
+/* Define to 1 if ia64 encoder is enabled. */
+/* #undef HAVE_ENCODER_IA64 */
+
+/* Define to 1 if lzma1 encoder is enabled. */
+#define HAVE_ENCODER_LZMA1 1
+
+/* Define to 1 if lzma2 encoder is enabled. */
+#define HAVE_ENCODER_LZMA2 1
+
+/* Define to 1 if powerpc encoder is enabled. */
+#define HAVE_ENCODER_POWERPC 1
+
+/* Define to 1 if sparc encoder is enabled. */
+/* #undef HAVE_ENCODER_SPARC */
+
+/* Define to 1 if x86 encoder is enabled. */
+#define HAVE_ENCODER_X86 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if __attribute__((__constructor__)) is supported for functions.
+   */
+#define HAVE_FUNC_ATTRIBUTE_CONSTRUCTOR 1
+
+/* Define to 1 if you have the `futimens' function. */
+#define HAVE_FUTIMENS 1
+
+/* Define to 1 if you have the `futimes' function. */
+/* #undef HAVE_FUTIMES */
+
+/* Define to 1 if you have the `futimesat' function. */
+/* #undef HAVE_FUTIMESAT */
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getopt_long' function. */
+#define HAVE_GETOPT_LONG 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+/* #undef HAVE_GETTEXT */
+
+/* Define if you have the iconv() function and it works. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the <immintrin.h> header file. */
+/* #undef HAVE_IMMINTRIN_H */
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <limits.h> header file. */
+#define HAVE_LIMITS_H 1
+
+/* Define to 1 if .lz (lzip) decompression support is enabled. */
+#define HAVE_LZIP_DECODER 1
+
+/* Define to 1 if mbrtowc and mbstate_t are properly declared. */
+#define HAVE_MBRTOWC 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 to enable bt2 match finder. */
+#define HAVE_MF_BT2 1
+
+/* Define to 1 to enable bt3 match finder. */
+#define HAVE_MF_BT3 1
+
+/* Define to 1 to enable bt4 match finder. */
+#define HAVE_MF_BT4 1
+
+/* Define to 1 to enable hc3 match finder. */
+#define HAVE_MF_HC3 1
+
+/* Define to 1 to enable hc4 match finder. */
+#define HAVE_MF_HC4 1
+
+/* Define to 1 if getopt.h declares extern int optreset. */
+/* #undef HAVE_OPTRESET */
+
+/* Define to 1 if you have the `pledge' function. */
+/* #undef HAVE_PLEDGE */
+
+/* Define to 1 if you have the `posix_fadvise' function. */
+#define HAVE_POSIX_FADVISE 1
+
+/* Define to 1 if `program_invocation_name' is declared in <errno.h>. */
+#define HAVE_PROGRAM_INVOCATION_NAME 1
+
+/* Define to 1 if you have the `pthread_condattr_setclock' function. */
+#define HAVE_PTHREAD_CONDATTR_SETCLOCK 1
+
+/* Have PTHREAD_PRIO_INHERIT. */
+#define HAVE_PTHREAD_PRIO_INHERIT 1
+
+/* Define to 1 if you have the `SHA256Init' function. */
+/* #undef HAVE_SHA256INIT */
+
+/* Define to 1 if the system has the type `SHA256_CTX'. */
+/* #undef HAVE_SHA256_CTX */
+
+/* Define to 1 if you have the <sha256.h> header file. */
+/* #undef HAVE_SHA256_H */
+
+/* Define to 1 if you have the `SHA256_Init' function. */
+/* #undef HAVE_SHA256_INIT */
+
+/* Define to 1 if the system has the type `SHA2_CTX'. */
+/* #undef HAVE_SHA2_CTX */
+
+/* Define to 1 if you have the <sha2.h> header file. */
+/* #undef HAVE_SHA2_H */
+
+/* Define to 1 if optimizing for size. */
+/* #undef HAVE_SMALL */
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#define HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if `st_atimensec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMENSEC */
+
+/* Define to 1 if `st_atimespec.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIMESPEC_TV_NSEC */
+
+/* Define to 1 if `st_atim.st__tim.tv_nsec' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_ATIM_ST__TIM_TV_NSEC */
+
+/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC 1
+
+/* Define to 1 if `st_uatime' is a member of `struct stat'. */
+/* #undef HAVE_STRUCT_STAT_ST_UATIME */
+
+/* Define to 1 to if GNU/Linux-specific details are unconditionally wanted for
+   symbol versioning. Define to 2 to if these are wanted only if also PIC is
+   defined (allows building both shared and static liblzma at the same time
+   with Libtool if neither --with-pic nor --without-pic is used). This define
+   must be used together with liblzma_linux.map. */
+#define HAVE_SYMBOL_VERSIONS_LINUX 2
+
+/* Define to 1 if you have the <sys/byteorder.h> header file. */
+/* #undef HAVE_SYS_BYTEORDER_H */
+
+/* Define to 1 if you have the <sys/capsicum.h> header file. */
+/* #undef HAVE_SYS_CAPSICUM_H */
+
+/* Define to 1 if you have the <sys/endian.h> header file. */
+/* #undef HAVE_SYS_ENDIAN_H */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#define HAVE_UINTPTR_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if _mm_set_epi64x and _mm_clmulepi64_si128 are usable. See
+   configure.ac for details. */
+/* #undef HAVE_USABLE_CLMUL */
+
+/* Define to 1 if you have the `utime' function. */
+/* #undef HAVE_UTIME */
+
+/* Define to 1 if you have the `utimes' function. */
+/* #undef HAVE_UTIMES */
+
+/* Define to 1 or 0, depending whether the compiler supports simple visibility
+   declarations. */
+#define HAVE_VISIBILITY 1
+
+/* Define to 1 if you have the `wcwidth' function. */
+#define HAVE_WCWIDTH 1
+
+/* Define to 1 if the system has the type `_Bool'. */
+#define HAVE__BOOL 1
+
+/* Define to 1 if you have the `_futime' function. */
+/* #undef HAVE__FUTIME */
+
+/* Define to 1 if _mm_movemask_epi8 is available. */
+/* #undef HAVE__MM_MOVEMASK_EPI8 */
+
+/* Define to 1 if the GNU C extension __builtin_assume_aligned is supported.
+   */
+#define HAVE___BUILTIN_ASSUME_ALIGNED 1
+
+/* Define to 1 if the GNU C extensions __builtin_bswap16/32/64 are supported.
+   */
+#define HAVE___BUILTIN_BSWAPXX 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Define to 1 when using POSIX threads (pthreads). */
+#define MYTHREAD_POSIX 1
+
+/* Define to 1 when using Windows Vista compatible threads. This uses features
+   that are not available on Windows XP. */
+/* #undef MYTHREAD_VISTA */
+
+/* Define to 1 when using Windows 95 (and thus XP) compatible threads. This
+   avoids use of features that were added in Windows Vista. */
+/* #undef MYTHREAD_WIN95 */
+
+/* Define to 1 to disable debugging code. */
+#define NDEBUG 1
+
+/* Name of package */
+#define PACKAGE "xz"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "xz@tukaani.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "XZ Utils"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "XZ Utils 5.4.4"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "xz"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "https://tukaani.org/xz/"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "5.4.4"
+
+/* Define to necessary symbol if this constant uses a non-standard name on
+   your system. */
+/* #undef PTHREAD_CREATE_JOINABLE */
+
+/* The size of `size_t', as computed by sizeof. */
+#define SIZEOF_SIZE_T 8
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if the number of available CPU cores can be detected with
+   cpuset(2). */
+/* #undef TUKLIB_CPUCORES_CPUSET */
+
+/* Define to 1 if the number of available CPU cores can be detected with
+   pstat_getdynamic(). */
+/* #undef TUKLIB_CPUCORES_PSTAT_GETDYNAMIC */
+
+/* Define to 1 if the number of available CPU cores can be detected with
+   sched_getaffinity() */
+#define TUKLIB_CPUCORES_SCHED_GETAFFINITY 1
+
+/* Define to 1 if the number of available CPU cores can be detected with
+   sysconf(_SC_NPROCESSORS_ONLN) or sysconf(_SC_NPROC_ONLN). */
+/* #undef TUKLIB_CPUCORES_SYSCONF */
+
+/* Define to 1 if the number of available CPU cores can be detected with
+   sysctl(). */
+/* #undef TUKLIB_CPUCORES_SYSCTL */
+
+/* Define to 1 if the system supports fast unaligned access to 16-bit, 32-bit,
+   and 64-bit integers. */
+/* #undef TUKLIB_FAST_UNALIGNED_ACCESS */
+
+/* Define to 1 if the amount of physical memory can be detected with
+   _system_configuration.physmem. */
+/* #undef TUKLIB_PHYSMEM_AIX */
+
+/* Define to 1 if the amount of physical memory can be detected with
+   getinvent_r(). */
+/* #undef TUKLIB_PHYSMEM_GETINVENT_R */
+
+/* Define to 1 if the amount of physical memory can be detected with
+   getsysinfo(). */
+/* #undef TUKLIB_PHYSMEM_GETSYSINFO */
+
+/* Define to 1 if the amount of physical memory can be detected with
+   pstat_getstatic(). */
+/* #undef TUKLIB_PHYSMEM_PSTAT_GETSTATIC */
+
+/* Define to 1 if the amount of physical memory can be detected with
+   sysconf(_SC_PAGESIZE) and sysconf(_SC_PHYS_PAGES). */
+#define TUKLIB_PHYSMEM_SYSCONF 1
+
+/* Define to 1 if the amount of physical memory can be detected with sysctl().
+   */
+/* #undef TUKLIB_PHYSMEM_SYSCTL */
+
+/* Define to 1 if the amount of physical memory can be detected with Linux
+   sysinfo(). */
+/* #undef TUKLIB_PHYSMEM_SYSINFO */
+
+/* Define to 1 to use unsafe type punning, e.g. char *x = ...; *(int *)x =
+   123; which violates strict aliasing rules and thus is undefined behavior
+   and might result in broken code. */
+/* #undef TUKLIB_USE_UNSAFE_TYPE_PUNNING */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "5.4.4"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT32_T */
+
+/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT64_T */
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+/* #undef _UINT8_T */
+
+/* Define to rpl_ if the getopt replacement functions and variables should be
+   used. */
+/* #undef __GETOPT_PREFIX */
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef int32_t */
+
+/* Define to the type of a signed integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef int64_t */
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint16_t */
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint32_t */
+
+/* Define to the type of an unsigned integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint64_t */
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+/* #undef uint8_t */
+
+/* Define to the type of an unsigned integer type wide enough to hold a
+   pointer, if such a type exists, and if the system does not define it. */
+/* #undef uintptr_t */
diff --git a/libraries/cmake/source/popt/config/linux/ppc64le/config.h b/libraries/cmake/source/popt/config/linux/ppc64le/config.h
new file mode 100644
index 000000000..4067bee15
--- /dev/null
+++ b/libraries/cmake/source/popt/config/linux/ppc64le/config.h
@@ -0,0 +1,184 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#define ENABLE_NLS 1
+
+/* Define to 1 if you have the MacOS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the MacOS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the <fnmatch.h> header file. */
+#define HAVE_FNMATCH_H 1
+
+/* Define to 1 if you have the `geteuid' function. */
+#define HAVE_GETEUID 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define to 1 if you have the `getuid' function. */
+#define HAVE_GETUID 1
+
+/* Define to 1 if you have the <glob.h> header file. */
+#define HAVE_GLOB_H 1
+
+/* Define to 1 if you have the `glob_pattern_p' function. */
+#define HAVE_GLOB_PATTERN_P 1
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#define HAVE_LIBINTL_H 1
+
+/* Define to 1 if you have the `mbsrtowcs' function. */
+#define HAVE_MBSRTOWCS 1
+
+/* Define to 1 if you have the <mcheck.h> header file. */
+#define HAVE_MCHECK_H 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mtrace' function. */
+#define HAVE_MTRACE 1
+
+/* Define to 1 if you have the `secure_getenv' function. */
+#define HAVE_SECURE_GETENV 1
+
+/* Define to 1 if you have the `setreuid' function. */
+#define HAVE_SETREUID 1
+
+/* Define to 1 if you have the `setuid' function. */
+#define HAVE_SETUID 1
+
+/* Define to 1 if you have the `srandom' function. */
+#define HAVE_SRANDOM 1
+
+/* Define to 1 if you have the <stdalign.h> header file. */
+#define HAVE_STDALIGN_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `stpcpy' function. */
+#define HAVE_STPCPY 1
+
+/* Define to 1 if you have the `strerror' function. */
+#define HAVE_STRERROR 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the `__secure_getenv' function. */
+/* #undef HAVE___SECURE_GETENV */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "popt"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "rpm-maint@lists.rpm.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "popt"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "popt 1.19"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "popt"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.19"
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Version number of package */
+#define VERSION "1.19"
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
diff --git a/libraries/cmake/source/rocksdb/CMakeLists.txt b/libraries/cmake/source/rocksdb/CMakeLists.txt
index 9f2dd12e1..d22f27bef 100644
--- a/libraries/cmake/source/rocksdb/CMakeLists.txt
+++ b/libraries/cmake/source/rocksdb/CMakeLists.txt
@@ -351,6 +351,10 @@ function(rocksdbMain)
     target_sources(thirdparty_rocksdb PRIVATE
       "${library_root}/util/crc32c_arm64.cc"
     )
+  elseif(TARGET_PROCESSOR STREQUAL "ppc64le")
+    target_sources(thirdparty_rocksdb PRIVATE
+      "${library_root}/util/crc32c_ppc.c"
+    )
   endif()
 
   if(PLATFORM_LINUX)
@@ -372,6 +376,24 @@ function(rocksdbMain)
           ROCKSDB_SCHED_GETCPU_PRESENT
       )
 
+    elseif(TARGET_PROCESSOR STREQUAL "ppc64le")
+      target_compile_definitions(thirdparty_rocksdb
+        PUBLIC
+          ROCKSDB_SUPPORT_THREAD_LOCAL
+
+        PRIVATE
+          NPERF_CONTEXT
+          OS_LINUX
+          ROCKSDB_FALLOCATE_PRESENT
+          ROCKSDB_LIB_IO_POSIX
+          ROCKSDB_MALLOC_USABLE_SIZE
+          ROCKSDB_NO_DYNAMIC_EXTENSION
+          ROCKSDB_PLATFORM_POSIX
+          ROCKSDB_PTHREAD_ADAPTIVE_MUTEX
+          ROCKSDB_RANGESYNC_PRESENT
+          ROCKSDB_SCHED_GETCPU_PRESENT
+      )
+
     elseif(TARGET_PROCESSOR STREQUAL "aarch64")
       target_compile_definitions(thirdparty_rocksdb PRIVATE
         NIOSTATS_CONTEXT
diff --git a/libraries/cmake/source/sleuthkit/config/linux/ppc64le/tsk/tsk_config.h b/libraries/cmake/source/sleuthkit/config/linux/ppc64le/tsk/tsk_config.h
new file mode 100644
index 000000000..1e861e514
--- /dev/null
+++ b/libraries/cmake/source/sleuthkit/config/linux/ppc64le/tsk/tsk_config.h
@@ -0,0 +1,279 @@
+/* tsk/tsk_config.h.  Generated from tsk_config.h.in by configure.  */
+/* tsk/tsk_config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+/* #undef CRAY_STACKSEG_END */
+
+/* Define to 1 if using `alloca.c'. */
+/* #undef C_ALLOCA */
+
+/* Define to 1 if you have the <afflib/afflib.h> header file. */
+/* #undef HAVE_AFFLIB_AFFLIB_H */
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#define HAVE_ALLOCA 1
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#define HAVE_ALLOCA_H 1
+
+/* define if the compiler supports basic C++14 syntax */
+#define HAVE_CXX14 1
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+/* #undef HAVE_DOPRNT */
+
+/* Define to 1 if you have the `err' function. */
+#define HAVE_ERR 1
+
+/* Define to 1 if you have the `errx' function. */
+#define HAVE_ERRX 1
+
+/* Define to 1 if you have the <err.h> header file. */
+#define HAVE_ERR_H 1
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `getline' function. */
+#define HAVE_GETLINE 1
+
+/* Define to 1 if you have the `getrusage' function. */
+#define HAVE_GETRUSAGE 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `ishexnumber' function. */
+/* #undef HAVE_ISHEXNUMBER */
+
+/* Define to 1 if you have the `afflib' library (-lafflib). */
+/* #undef HAVE_LIBAFFLIB */
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+#define HAVE_LIBDL 1
+
+/* Define to 1 if you have the `ewf' library (-lewf). */
+/* #undef HAVE_LIBEWF */
+
+/* Define to 1 if you have the <libewf.h> header file. */
+/* #undef HAVE_LIBEWF_H */
+
+/* Define if using opensll */
+/* #undef HAVE_LIBOPENSSL */
+
+/* Define to 1 if you have the `sqlite3' library (-lsqlite3). */
+/* #undef HAVE_LIBSQLITE3 */
+
+/* Define to 1 if you have the `stdc++' library (-lstdc++). */
+#define HAVE_LIBSTDC__ 1
+
+/* Define to 1 if you have the `vhdi' library (-lvhdi). */
+/* #undef HAVE_LIBVHDI */
+
+/* Define to 1 if you have the <libvhdi.h> header file. */
+/* #undef HAVE_LIBVHDI_H */
+
+/* Define to 1 if you have the `vmdk' library (-lvmdk). */
+/* #undef HAVE_LIBVMDK */
+
+/* Define to 1 if you have the <libvmdk.h> header file. */
+/* #undef HAVE_LIBVMDK_H */
+
+/* Define to 1 if you have the `z' library (-lz). */
+#define HAVE_LIBZ 1
+
+/* Define to 1 if you have the <list> header file. */
+/* #undef HAVE_LIST */
+
+/* Define to 1 if `lstat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+/* #undef HAVE_LSTAT_EMPTY_STRING_BUG */
+
+/* Define to 1 if you have the <map> header file. */
+/* #undef HAVE_MAP */
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define if you have POSIX threads libraries and header files. */
+#define HAVE_PTHREAD 1
+
+/* Define to 1 if you have the <queue> header file. */
+/* #undef HAVE_QUEUE */
+
+/* Define to 1 if you have the <set> header file. */
+/* #undef HAVE_SET */
+
+/* Define to 1 if you have the <sqlite3.h> header file. */
+/* #undef HAVE_SQLITE3_H */
+
+/* Define to 1 if you have the <stack> header file. */
+/* #undef HAVE_STACK */
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#define HAVE_STDBOOL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <streambuf> header file. */
+/* #undef HAVE_STREAMBUF */
+
+/* Define to 1 if you have the <string> header file. */
+/* #undef HAVE_STRING */
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strlcat' function. */
+/* #undef HAVE_STRLCAT */
+
+/* Define to 1 if you have the `strlcpy' function. */
+/* #undef HAVE_STRLCPY */
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <utime.h> header file. */
+#define HAVE_UTIME_H 1
+
+/* Define to 1 if `utime(file, NULL)' sets file's timestamp to the present. */
+#define HAVE_UTIME_NULL 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Define to 1 if you have the <vector> header file. */
+/* #undef HAVE_VECTOR */
+
+/* Define to 1 if you have the `vprintf' function. */
+#define HAVE_VPRINTF 1
+
+/* Define to 1 if you have the `warn' function. */
+#define HAVE_WARN 1
+
+/* Define to 1 if you have the `warnx' function. */
+#define HAVE_WARNX 1
+
+/* Define to 1 if you have the <zlib.h> header file. */
+#define HAVE_ZLIB_H 1
+
+/* Define to 1 if the system has the type `_Bool'. */
+#define HAVE__BOOL 1
+
+/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
+   slash. */
+#define LSTAT_FOLLOWS_SLASHED_SYMLINK 1
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* Name of package */
+#define PACKAGE "sleuthkit"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT ""
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "sleuthkit"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "sleuthkit 4.11.0"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "sleuthkit"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL ""
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "4.11.0"
+
+/* Define to necessary symbol if this constant uses a non-standard name on
+   your system. */
+/* #undef PTHREAD_CREATE_JOINABLE */
+
+/* Define to the type of arg 1 for `select'. */
+#define SELECT_TYPE_ARG1 int
+
+/* Define to the type of args 2, 3 and 4 for `select'. */
+#define SELECT_TYPE_ARG234 (fd_set *)
+
+/* Define to the type of arg 5 for `select'. */
+#define SELECT_TYPE_ARG5 (struct timeval *)
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+/* #undef STACK_DIRECTION */
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Version number of package */
+#define VERSION "4.11.0"
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef gid_t */
+
+/* Define to `int' if <sys/types.h> does not define. */
+/* #undef mode_t */
+
+/* Define to `long int' if <sys/types.h> does not define. */
+/* #undef off_t */
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+/* #undef size_t */
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+/* #undef uid_t */
diff --git a/libraries/cmake/source/sleuthkit/config/linux/ppc64le/tsk/tsk_incs.h b/libraries/cmake/source/sleuthkit/config/linux/ppc64le/tsk/tsk_incs.h
new file mode 100644
index 000000000..54976871b
--- /dev/null
+++ b/libraries/cmake/source/sleuthkit/config/linux/ppc64le/tsk/tsk_incs.h
@@ -0,0 +1,14 @@
+#ifndef _TSK_INCS_H
+#define _TSK_INCS_H
+// automatically by ./configure
+// Contains the config.h data needed by programs that use libtsk
+
+#include <unistd.h>
+#ifndef __STDC_FORMAT_MACROS
+#define  __STDC_FORMAT_MACROS
+#endif
+#include <inttypes.h>
+#include <sys/param.h>
+#define TSK_MULTITHREAD_LIB // enable multithreading
+
+#endif
diff --git a/libraries/cmake/source/thrift/config/linux/ppc64le/thrift/config.h b/libraries/cmake/source/thrift/config/linux/ppc64le/thrift/config.h
new file mode 100644
index 000000000..8fd926fd4
--- /dev/null
+++ b/libraries/cmake/source/thrift/config/linux/ppc64le/thrift/config.h
@@ -0,0 +1,160 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/* config.h generated by CMake from config.h.in */
+
+#ifndef CONFIG_H
+#define CONFIG_H
+
+
+/* Name of package */
+/* #undef PACKAGE */
+
+/* Define to the address where bug reports for this package should be sent. */
+/* #undef PACKAGE_BUGREPORT */
+
+/* Define to the full name of this package. */
+/* #undef PACKAGE_NAME */
+
+/* Define to the one symbol short name of this package. */
+/* #undef PACKAGE_TARNAME */
+
+/* Define to the home page for this package. */
+/* #undef PACKAGE_URL */
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "0.17.0"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING " 0.17.0"
+
+/************************** DEFINES *************************/
+
+/* Define if the AI_ADDRCONFIG symbol is unavailable */
+/* #undef AI_ADDRCONFIG */
+
+/* Possible value for SIGNED_RIGHT_SHIFT_IS */
+/* TODO: This is just set to 1 for the moment
+   port the macro aclocal/ax_signed_right_shift.m4 to CMake to make this work */
+#define ARITHMETIC_RIGHT_SHIFT 1
+
+/* Indicates the effect of the right shift operator on negative signed
+   integers */
+/* TODO: This is just set to 1 for the moment */
+#define SIGNED_RIGHT_SHIFT_IS 1
+
+/* Use *.h extension for parser header file */
+/* TODO: This might now be necessary anymore as it is set only for automake < 1.11
+   see: aclocal/ac_prog_bison.m4 */
+/* #undef BISON_USE_PARSER_H_EXTENSION */
+
+/* Define to 1 if strerror_r returns char *. */
+#define STRERROR_R_CHAR_P 1
+
+
+/************************** HEADER FILES *************************/
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#define HAVE_ARPA_INET_H 1
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#define HAVE_NETDB_H 1
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <signal.h> header file. */
+#define HAVE_SIGNAL_H 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#define HAVE_PTHREAD_H 1
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <poll.h> header file. */
+#define HAVE_POLL_H 1
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#define HAVE_SYS_POLL_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#define HAVE_SYS_SELECT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sched.h> header file. */
+#define HAVE_SCHED_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <afunix.h> header file. */
+/* #undef HAVE_AF_UNIX_H */
+
+/*************************** FUNCTIONS ***************************/
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define to 1 if you have the `gethostbyname_r' function. */
+#define HAVE_GETHOSTBYNAME_R 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+#define HAVE_STRERROR_R 1
+
+/* Define to 1 if you have the `sched_get_priority_max' function. */
+#define HAVE_SCHED_GET_PRIORITY_MAX 1
+
+/* Define to 1 if you have the `sched_get_priority_min' function. */
+#define HAVE_SCHED_GET_PRIORITY_MIN 1
+
+
+/* Define to 1 if strerror_r returns char *. */
+#define STRERROR_R_CHAR_P 1
+
+#endif
diff --git a/libraries/cmake/source/util-linux/config/ppc64le/config.h b/libraries/cmake/source/util-linux/config/ppc64le/config.h
new file mode 100644
index 000000000..8e8d8bddd
--- /dev/null
+++ b/libraries/cmake/source/util-linux/config/ppc64le/config.h
@@ -0,0 +1,896 @@
+/* config.h.  Generated from config.h.in by configure.  */
+/* config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+/* #undef AC_APPLE_UNIVERSAL_BUILD */
+
+/* Enable agetty --reload feature */
+#define AGETTY_RELOAD 1
+
+/* Should chfn and chsh require the user to enter the password? */
+#define CHFN_CHSH_PASSWORD 1
+
+/* Path to hwclock adjtime file */
+#define CONFIG_ADJTIME_PATH "/etc/adjtime"
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#define ENABLE_NLS 1
+
+/* search path for fs helpers */
+#define FS_SEARCH_PATH "/sbin:/sbin/fs.d:/sbin/fs"
+
+/* Define to 1 if you have the <asm/io.h> header file. */
+/* #undef HAVE_ASM_IO_H */
+
+/* Define if btrfs stuff is available */
+#define HAVE_BTRFS_SUPPORT 1
+
+/* Define to 1 if you have the <byteswap.h> header file. */
+#define HAVE_BYTESWAP_H 1
+
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define to 1 if you have the `clearenv' function. */
+#define HAVE_CLEARENV 1
+
+/* Define to 1 if you have the `clock_gettime' function. */
+#define HAVE_CLOCK_GETTIME 1
+
+/* Define to 1 if the system has the type `cpu_set_t'. */
+#define HAVE_CPU_SET_T 1
+
+/* Define if cryptsetup is available */
+/* #undef HAVE_CRYPTSETUP */
+
+/* Define to 1 if you have the <crypt.h> header file. */
+#define HAVE_CRYPT_H 1
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#define HAVE_DCGETTEXT 1
+
+/* Define to 1 if you have the declaration of `CPU_ALLOC', and to 0 if you
+   don't. */
+#define HAVE_DECL_CPU_ALLOC 1
+
+/* Define to 1 if you have the declaration of `dirfd', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_DIRFD */
+
+/* Define to 1 if you have the declaration of `tzname', and to 0 if you don't.
+   */
+/* #undef HAVE_DECL_TZNAME */
+
+/* Define to 1 if you have the declaration of `_NL_TIME_WEEK_1STDAY', and to 0
+   if you don't. */
+#define HAVE_DECL__NL_TIME_WEEK_1STDAY 1
+
+/* Define to 1 if you have the `dirfd' function. */
+#define HAVE_DIRFD 1
+
+/* Define to 1 if `dd_fd' is a member of `DIR'. */
+/* #undef HAVE_DIR_DD_FD */
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#define HAVE_DLFCN_H 1
+
+/* Define to 1 if you have the `eaccess' function. */
+#define HAVE_EACCESS 1
+
+/* Define to 1 if you have the <endian.h> header file. */
+#define HAVE_ENDIAN_H 1
+
+/* Define to 1 if have **environ prototype */
+#define HAVE_ENVIRON_DECL 1
+
+/* Define to 1 if you have the `err' function. */
+#define HAVE_ERR 1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#define HAVE_ERRNO_H 1
+
+/* Define to 1 if you have the `errx' function. */
+#define HAVE_ERRX 1
+
+/* Define to 1 if you have the <err.h> header file. */
+#define HAVE_ERR_H 1
+
+/* Define to 1 if you have the `explicit_bzero' function. */
+#define HAVE_EXPLICIT_BZERO 1
+
+/* Have valid fallocate() function */
+/* #undef HAVE_FALLOCATE */
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#define HAVE_FCNTL_H 1
+
+/* Define to 1 if you have the `fmemopen' function. */
+#define HAVE_FMEMOPEN 1
+
+/* Define to 1 if you have the `fpurge' function. */
+/* #undef HAVE_FPURGE */
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#define HAVE_FSEEKO 1
+
+/* Define to 1 if you have the `fstatat' function. */
+#define HAVE_FSTATAT 1
+
+/* Define to 1 if you have the `fsync' function. */
+#define HAVE_FSYNC 1
+
+/* Define to 1 if you have the `futimens' function. */
+#define HAVE_FUTIMENS 1
+
+/* Define to 1 if you have the `getdomainname' function. */
+#define HAVE_GETDOMAINNAME 1
+
+/* Define to 1 if you have the `getdtablesize' function. */
+#define HAVE_GETDTABLESIZE 1
+
+/* Define to 1 if you have the `getexecname' function. */
+/* #undef HAVE_GETEXECNAME */
+
+/* Define to 1 if you have the `getmntinfo' function. */
+/* #undef HAVE_GETMNTINFO */
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#define HAVE_GETOPT_H 1
+
+/* Define to 1 if you have the `getrandom' function. */
+#define HAVE_GETRANDOM 1
+
+/* Define to 1 if you have the `getrlimit' function. */
+#define HAVE_GETRLIMIT 1
+
+/* Define to 1 if you have the `getsgnam' function. */
+#define HAVE_GETSGNAM 1
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#define HAVE_GETTEXT 1
+
+/* Define to 1 if you have the `getusershell' function. */
+#define HAVE_GETUSERSHELL 1
+
+/* Define if you have the iconv() function and it works. */
+/* #undef HAVE_ICONV */
+
+/* Define to 1 if you have the `inotify_init' function. */
+#define HAVE_INOTIFY_INIT 1
+
+/* Define to 1 if you have the `inotify_init1' function. */
+#define HAVE_INOTIFY_INIT1 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `ioperm' function. */
+/* #undef HAVE_IOPERM */
+
+/* Define to 1 if you have the `iopl' function. */
+/* #undef HAVE_IOPL */
+
+/* Define to 1 if you have the `isnan' function. */
+#define HAVE_ISNAN 1
+
+/* Define to 1 if you have the `jrand48' function. */
+#define HAVE_JRAND48 1
+
+/* Define if langinfo.h defines ALTMON_x constants */
+#define HAVE_LANGINFO_ALTMON 1
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#define HAVE_LANGINFO_H 1
+
+/* Define if langinfo.h defines _NL_ABALTMON_x constants */
+#define HAVE_LANGINFO_NL_ABALTMON 1
+
+/* Define to 1 if you have the <lastlog.h> header file. */
+#define HAVE_LASTLOG_H 1
+
+/* Define to 1 if you have the `lchown' function. */
+#define HAVE_LCHOWN 1
+
+/* Define to 1 if you have the `audit' library (-laudit). */
+/* #undef HAVE_LIBAUDIT */
+
+/* Define to 1 if you have the -lblkid. */
+#define HAVE_LIBBLKID 1
+
+/* Define to 1 if you have the `cap-ng' library (-lcap-ng). */
+/* #undef HAVE_LIBCAP_NG */
+
+/* Do we need -lcrypt? */
+#define HAVE_LIBCRYPT 1
+
+/* Define if libmount available. */
+/* #undef HAVE_LIBMOUNT */
+
+/* Define if ncurses library available */
+#define HAVE_LIBNCURSES 1
+
+/* Define if ncursesw library available */
+/* #undef HAVE_LIBNCURSESW */
+
+/* Define to 1 if you have the `readline' library (-lreadline). */
+/* #undef HAVE_LIBREADLINE */
+
+/* Define if librtas exists */
+/* #undef HAVE_LIBRTAS */
+
+/* Define if SELinux is available */
+/* #undef HAVE_LIBSELINUX */
+
+/* Define if libsystemd is available */
+/* #undef HAVE_LIBSYSTEMD */
+
+/* Define if libtinfo or libtinfow available. */
+/* #undef HAVE_LIBTINFO */
+
+/* Define to 1 if you have the `udev' library (-ludev). */
+/* #undef HAVE_LIBUDEV */
+
+/* Define if libuser is available */
+/* #undef HAVE_LIBUSER */
+
+/* Define to 1 if you have the `utempter' library (-lutempter). */
+/* #undef HAVE_LIBUTEMPTER */
+
+/* Define to 1 if you have the `util' library (-lutil). */
+#define HAVE_LIBUTIL 1
+
+/* Define to 1 if you have the <libutil.h> header file. */
+/* #undef HAVE_LIBUTIL_H */
+
+/* Define to 1 if you have the -luuid. */
+#define HAVE_LIBUUID 1
+
+/* Define to 1 if you have the <linux/blkpg.h> header file. */
+#define HAVE_LINUX_BLKPG_H 1
+
+/* Define to 1 if you have the <linux/blkzoned.h> header file. */
+#define HAVE_LINUX_BLKZONED_H 1
+
+/* Define to 1 if you have the <linux/btrfs.h> header file. */
+#define HAVE_LINUX_BTRFS_H 1
+
+/* Define to 1 if you have the <linux/capability.h> header file. */
+#define HAVE_LINUX_CAPABILITY_H 1
+
+/* Define to 1 if you have the <linux/cdrom.h> header file. */
+#define HAVE_LINUX_CDROM_H 1
+
+/* Define to 1 if you have the <linux/compiler.h> header file. */
+/* #undef HAVE_LINUX_COMPILER_H */
+
+/* Define to 1 if you have the <linux/falloc.h> header file. */
+#define HAVE_LINUX_FALLOC_H 1
+
+/* Define to 1 if you have the <linux/fd.h> header file. */
+#define HAVE_LINUX_FD_H 1
+
+/* Define to 1 if you have the <linux/fs.h> header file. */
+/* #undef HAVE_LINUX_FS_H */
+
+/* Define to 1 if you have the <linux/gsmmux.h> header file. */
+#define HAVE_LINUX_GSMMUX_H 1
+
+/* Define to 1 if you have the <linux/major.h> header file. */
+#define HAVE_LINUX_MAJOR_H 1
+
+/* Define to 1 if you have the <linux/net_namespace.h> header file. */
+#define HAVE_LINUX_NET_NAMESPACE_H 1
+
+/* Define to 1 if you have the <linux/raw.h> header file. */
+#define HAVE_LINUX_RAW_H 1
+
+/* Define to 1 if you have the <linux/securebits.h> header file. */
+#define HAVE_LINUX_SECUREBITS_H 1
+
+/* Define to 1 if you have the <linux/tiocl.h> header file. */
+#define HAVE_LINUX_TIOCL_H 1
+
+/* Define to 1 if you have the <linux/version.h> header file. */
+#define HAVE_LINUX_VERSION_H 1
+
+/* Define to 1 if you have the <linux/watchdog.h> header file. */
+#define HAVE_LINUX_WATCHDOG_H 1
+
+/* Define to 1 if you have the `llseek' function. */
+/* #undef HAVE_LLSEEK */
+
+/* Define to 1 if have llseek prototype */
+/* #undef HAVE_LLSEEK_PROTOTYPE */
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if the system has the type `loff_t'. */
+#define HAVE_LOFF_T 1
+
+/* Define to 1 if you have the `lseek64' function. */
+#define HAVE_LSEEK64 1
+
+/* Define to 1 if have lseek64 prototype */
+#define HAVE_LSEEK64_PROTOTYPE 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `mempcpy' function. */
+#define HAVE_MEMPCPY 1
+
+/* Define to 1 if you have the `mkostemp' function. */
+#define HAVE_MKOSTEMP 1
+
+/* Define to 1 if you have the <mntent.h> header file. */
+#define HAVE_MNTENT_H 1
+
+/* Define to 1 if you have the `nanosleep' function. */
+#define HAVE_NANOSLEEP 1
+
+/* Define to 1 if you have the <ncursesw/ncurses.h> header file. */
+/* #undef HAVE_NCURSESW_NCURSES_H */
+
+/* Define to 1 if you have the <ncursesw/term.h> header file. */
+/* #undef HAVE_NCURSESW_TERM_H */
+
+/* Define to 1 if you have the <ncurses.h> header file. */
+#define HAVE_NCURSES_H 1
+
+/* Define to 1 if you have the <ncurses/ncurses.h> header file. */
+/* #undef HAVE_NCURSES_NCURSES_H */
+
+/* Define to 1 if you have the <ncurses/term.h> header file. */
+/* #undef HAVE_NCURSES_TERM_H */
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#define HAVE_NETINET_IN_H 1
+
+/* Define to 1 if you have the <net/if_dl.h> header file. */
+/* #undef HAVE_NET_IF_DL_H */
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#define HAVE_NET_IF_H 1
+
+/* Define to 1 if you have the `ntp_gettime' function. */
+#define HAVE_NTP_GETTIME 1
+
+/* Define to 1 if you have the `openat' function. */
+#define HAVE_OPENAT 1
+
+/* Define to 1 if you have the `open_memstream' function. */
+#define HAVE_OPEN_MEMSTREAM 1
+
+/* Define to 1 if you have the <paths.h> header file. */
+#define HAVE_PATHS_H 1
+
+/* Define if libpcre2 is available */
+/* #undef HAVE_PCRE */
+
+/* Define to 1 if you have the `personality' function. */
+#define HAVE_PERSONALITY 1
+
+/* Define to 1 if you have the `pidfd_open' function. */
+/* #undef HAVE_PIDFD_OPEN */
+
+/* Define to 1 if you have the `pidfd_send_signal' function. */
+/* #undef HAVE_PIDFD_SEND_SIGNAL */
+
+/* Define to 1 if you have the `posix_fadvise' function. */
+#define HAVE_POSIX_FADVISE 1
+
+/* Have valid posix_fallocate() function */
+/* #undef HAVE_POSIX_FALLOCATE */
+
+/* Define to 1 if you have the `prctl' function. */
+#define HAVE_PRCTL 1
+
+/* Define to 1 if you have the `prlimit' function. */
+/* #undef HAVE_PRLIMIT */
+
+/* Define if program_invocation_short_name is defined */
+#define HAVE_PROGRAM_INVOCATION_SHORT_NAME 1
+
+/* have PTY support */
+#define HAVE_PTY 1
+
+/* Define to 1 if you have the <pty.h> header file. */
+#define HAVE_PTY_H 1
+
+/* Define to 1 if you have the `qsort_r' function. */
+#define HAVE_QSORT_R 1
+
+/* Define to 1 if you have the `reboot' function. */
+#define HAVE_REBOOT 1
+
+/* Define if curses library has the resizeterm(). */
+#define HAVE_RESIZETERM 1
+
+/* Define to 1 if you have the `rpmatch' function. */
+#define HAVE_RPMATCH 1
+
+/* Define if struct sockaddr contains sa_len */
+/* #undef HAVE_SA_LEN */
+
+/* Define to 1 if you have the `scandirat' function. */
+#define HAVE_SCANDIRAT 1
+
+/* scanf %as modifier */
+/* #undef HAVE_SCANF_AS_MODIFIER */
+
+/* scanf %ms modifier */
+#define HAVE_SCANF_MS_MODIFIER 1
+
+/* Define to 1 if you have the `sched_setattr' function. */
+/* #undef HAVE_SCHED_SETATTR */
+
+/* Define to 1 if you have the `sched_setscheduler' function. */
+#define HAVE_SCHED_SETSCHEDULER 1
+
+/* Define to 1 if you have the `secure_getenv' function. */
+#define HAVE_SECURE_GETENV 1
+
+/* Define to 1 if you have the `security_get_initial_context' function. */
+/* #undef HAVE_SECURITY_GET_INITIAL_CONTEXT */
+
+/* Define to 1 if you have the <security/openpam.h> header file. */
+/* #undef HAVE_SECURITY_OPENPAM_H */
+
+/* Define to 1 if you have the <security/pam_appl.h> header file. */
+/* #undef HAVE_SECURITY_PAM_APPL_H */
+
+/* Define to 1 if you have the <security/pam_misc.h> header file. */
+/* #undef HAVE_SECURITY_PAM_MISC_H */
+
+/* Define to 1 if you have the `setitimer' function. */
+/* #undef HAVE_SETITIMER */
+
+/* Define to 1 if you have the `setns' function. */
+#define HAVE_SETNS 1
+
+/* Define to 1 if you have the `setprogname' function. */
+/* #undef HAVE_SETPROGNAME */
+
+/* Define to 1 if you have the `setresgid' function. */
+#define HAVE_SETRESGID 1
+
+/* Define to 1 if you have the `setresuid' function. */
+#define HAVE_SETRESUID 1
+
+/* Define to 1 if you have the <shadow.h> header file. */
+#define HAVE_SHADOW_H 1
+
+/* Define to 1 if the system has the type `sighandler_t'. */
+#define HAVE_SIGHANDLER_T 1
+
+/* Define to 1 if you have the `sigqueue' function. */
+#define HAVE_SIGQUEUE 1
+
+/* Define to 1 if you have the <slang.h> header file. */
+/* #undef HAVE_SLANG_H */
+
+/* Define to 1 if you have the <slang/slang.h> header file. */
+/* #undef HAVE_SLANG_SLANG_H */
+
+/* Define to 1 if you have the <slang/slcurses.h> header file. */
+/* #undef HAVE_SLANG_SLCURSES_H */
+
+/* Define to 1 if you have the <slcurses.h> header file. */
+/* #undef HAVE_SLCURSES_H */
+
+/* Add SMACK support */
+/* #undef HAVE_SMACK */
+
+/* Define to 1 if you have the `srandom' function. */
+#define HAVE_SRANDOM 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdio_ext.h> header file. */
+#define HAVE_STDIO_EXT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#define HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the `strnchr' function. */
+/* #undef HAVE_STRNCHR */
+
+/* Define to 1 if you have the `strndup' function. */
+#define HAVE_STRNDUP 1
+
+/* Define to 1 if you have the `strnlen' function. */
+#define HAVE_STRNLEN 1
+
+/* Define to 1 if have strsignal function prototype */
+#define HAVE_STRSIGNAL_DECL 1
+
+/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+
+/* Define to 1 if `c_line' is a member of `struct termios'. */
+#define HAVE_STRUCT_TERMIOS_C_LINE 1
+
+/* Define to 1 if `tm_zone' is a member of `struct tm'. */
+#define HAVE_STRUCT_TM_TM_ZONE 1
+
+/* Define to 1 if you have the `swapoff' function. */
+#define HAVE_SWAPOFF 1
+
+/* Define to 1 if you have the `swapon' function. */
+#define HAVE_SWAPON 1
+
+/* Define to 1 if you have the `sysconf' function. */
+#define HAVE_SYSCONF 1
+
+/* Define to 1 if you have the `sysinfo' function. */
+#define HAVE_SYSINFO 1
+
+/* Define to 1 if you have the <sys/disklabel.h> header file. */
+/* #undef HAVE_SYS_DISKLABEL_H */
+
+/* Define to 1 if you have the <sys/disk.h> header file. */
+/* #undef HAVE_SYS_DISK_H */
+
+/* Define to 1 if you have the <sys/endian.h> header file. */
+/* #undef HAVE_SYS_ENDIAN_H */
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#define HAVE_SYS_FILE_H 1
+
+/* Define to 1 if you have the <sys/ioccom.h> header file. */
+/* #undef HAVE_SYS_IOCCOM_H */
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#define HAVE_SYS_IOCTL_H 1
+
+/* Define to 1 if you have the <sys/io.h> header file. */
+/* #undef HAVE_SYS_IO_H */
+
+/* Define to 1 if you have the <sys/mkdev.h> header file. */
+/* #undef HAVE_SYS_MKDEV_H */
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+#define HAVE_SYS_MOUNT_H 1
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#define HAVE_SYS_PARAM_H 1
+
+/* Define to 1 if you have the <sys/prctl.h> header file. */
+#define HAVE_SYS_PRCTL_H 1
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#define HAVE_SYS_RESOURCE_H 1
+
+/* Define to 1 if you have the <sys/signalfd.h> header file. */
+#define HAVE_SYS_SIGNALFD_H 1
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#define HAVE_SYS_SOCKET_H 1
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+/* #undef HAVE_SYS_SOCKIO_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/swap.h> header file. */
+#define HAVE_SYS_SWAP_H 1
+
+/* Define to 1 if you have the <sys/syscall.h> header file. */
+#define HAVE_SYS_SYSCALL_H 1
+
+/* Define to 1 if you have the <sys/sysmacros.h> header file. */
+#define HAVE_SYS_SYSMACROS_H 1
+
+/* Define to 1 if you have the <sys/timex.h> header file. */
+#define HAVE_SYS_TIMEX_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#define HAVE_SYS_TIME_H 1
+
+/* Define to 1 if you have the <sys/ttydefaults.h> header file. */
+#define HAVE_SYS_TTYDEFAULTS_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <sys/ucred.h> header file. */
+/* #undef HAVE_SYS_UCRED_H */
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <term.h> header file. */
+#define HAVE_TERM_H 1
+
+/* Define to 1 if you have the `timegm' function. */
+#define HAVE_TIMEGM 1
+
+/* Define if timer_create exist in -lrt -lpthread */
+#define HAVE_TIMER_CREATE 1
+
+/* Define to 1 if the target supports thread-local storage. */
+#define HAVE_TLS 1
+
+/* Does struct tm have a field tm_gmtoff? */
+#define HAVE_TM_GMTOFF 1
+
+/* Define to 1 if your `struct tm' has `tm_zone'. Deprecated, use
+   `HAVE_STRUCT_TM_TM_ZONE' instead. */
+#define HAVE_TM_ZONE 1
+
+/* Define to 1 if you don't have `tm_zone' but do have the external array
+   `tzname'. */
+/* #undef HAVE_TZNAME */
+
+/* Define to 1 if the system has the type `union semun'. */
+/* #undef HAVE_UNION_SEMUN */
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if you have the `unlinkat' function. */
+#define HAVE_UNLINKAT 1
+
+/* Define to 1 if you have the `unshare' function. */
+#define HAVE_UNSHARE 1
+
+/* Define to 1 if you have the `updwtmpx' function. */
+#define HAVE_UPDWTMPX 1
+
+/* Define if curses library has the use_default_colors(). */
+#define HAVE_USE_DEFAULT_COLORS 1
+
+/* Define to 1 if you have the `usleep' function. */
+#define HAVE_USLEEP 1
+
+/* Define to 1 if you have the `utimensat' function. */
+#define HAVE_UTIMENSAT 1
+
+/* Define to 1 if you have the <utmpx.h> header file. */
+#define HAVE_UTMPX_H 1
+
+/* Define to 1 if you have the <utmp.h> header file. */
+#define HAVE_UTMP_H 1
+
+/* Define to 1 if you want to use uuid daemon. */
+/* #undef HAVE_UUIDD */
+
+/* Define to 1 if you have the `vwarnx' function. */
+#define HAVE_VWARNX 1
+
+/* Define to 1 if you have the `warn' function. */
+#define HAVE_WARN 1
+
+/* Define to 1 if you have the `warnx' function. */
+#define HAVE_WARNX 1
+
+/* Do we have wide character support? */
+#define HAVE_WIDECHAR 1
+
+/* Define to 1 if you have the `__fpending' function. */
+#define HAVE___FPENDING 1
+
+/* Define to 1 if you have the `__fpurge' function. */
+#define HAVE___FPURGE 1
+
+/* Define if __progname is defined */
+#define HAVE___PROGNAME 1
+
+/* Define to 1 if you have the `__secure_getenv' function. */
+/* #undef HAVE___SECURE_GETENV */
+
+/* libblkid date string */
+#define LIBBLKID_DATE "20-May-2020"
+
+/* libblkid version string */
+#define LIBBLKID_VERSION "2.35.2"
+
+/* libfdisk version string */
+#define LIBFDISK_VERSION "2.35.2"
+
+/* libmount version string */
+#define LIBMOUNT_VERSION "2.35.2"
+
+/* libsmartcols version string */
+#define LIBSMARTCOLS_VERSION "2.35.2"
+
+/* Should login chown /dev/vcsN? */
+/* #undef LOGIN_CHOWN_VCS */
+
+/* Should login stat() the mailbox? */
+/* #undef LOGIN_STAT_MAIL */
+
+/* Define to the sub-directory where libtool stores uninstalled libraries. */
+#define LT_OBJDIR ".libs/"
+
+/* "Multi-arch triplet for whereis library search path" */
+/* #undef MULTIARCHTRIPLET */
+
+/* Define to 1 if assertions should be disabled. */
+/* #undef NDEBUG */
+
+/* Should chsh allow only shells in /etc/shells? */
+#define ONLY_LISTED_SHELLS 1
+
+/* Name of package */
+#define PACKAGE "util-linux"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "kzak@redhat.com"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "util-linux"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "util-linux 2.35.2"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "util-linux"
+
+/* Define to the home page for this package. */
+#define PACKAGE_URL "http://www.kernel.org/pub/linux/utils/util-linux/"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "2.35.2"
+
+/* Should pg ring the bell on invalid keys? */
+#define PG_BELL 1
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Fallback syscall number for fallocate */
+/* #undef SYS_fallocate */
+
+/* Fallback syscall number for ioprio_get */
+/* #undef SYS_ioprio_get */
+
+/* Fallback syscall number for ioprio_set */
+/* #undef SYS_ioprio_set */
+
+/* Fallback syscall number for pidfd_open */
+/* #undef SYS_pidfd_open */
+
+/* Fallback syscall number for pidfd_send_signal */
+/* #undef SYS_pidfd_send_signal */
+
+/* Fallback syscall number for pivot_root */
+/* #undef SYS_pivot_root */
+
+/* Fallback syscall number for prlimit64 */
+/* #undef SYS_prlimit64 */
+
+/* Fallback syscall number for sched_getaffinity */
+/* #undef SYS_sched_getaffinity */
+
+/* Fallback syscall number for sched_setattr */
+/* #undef SYS_sched_setattr */
+
+/* Fallback syscall number for setns */
+/* #undef SYS_setns */
+
+/* Fallback syscall number for swapoff */
+/* #undef SYS_swapoff */
+
+/* Fallback syscall number for swapon */
+/* #undef SYS_swapon */
+
+/* Fallback syscall number for unshare */
+/* #undef SYS_unshare */
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+/* #undef TM_IN_SYS_TIME */
+
+/* Enables colorized output from utils by default */
+#define USE_COLORS_BY_DEFAULT 1
+
+/* Define to 1 if want to use CMOS clock. */
+/* #undef USE_HWCLOCK_CMOS */
+
+/* use datetime parsing GPLv3 code to hwclock */
+#define USE_HWCLOCK_GPLv3_DATETIME 1
+
+/* Define to 1 if want to support mtab. */
+/* #undef USE_LIBMOUNT_SUPPORT_MTAB */
+
+/* Define to 1 if want to support namepaces. */
+/* #undef USE_LIBMOUNT_SUPPORT_NAMESPACES */
+
+/* Enable plymouth support feature for sulogin and aggety */
+#define USE_PLYMOUTH_SUPPORT 1
+
+/* Should sulogin use a emergency mount of /dev and /proc? */
+/* #undef USE_SULOGIN_EMERGENCY_MOUNT */
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
+#endif
+
+
+/* Should wall and write be installed setgid tty? */
+#define USE_TTY_GROUP 1
+
+/* Define to 1 to remove /bin and /sbin from PATH env.variable */
+/* #undef USE_USRDIR_PATHS_ONLY */
+
+/* Version number of package */
+#define VERSION "2.35.2"
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+/* #  undef WORDS_BIGENDIAN */
+# endif
+#endif
+
+/* Enable MAP_ANON in sys/mman.h on Mac OS X */
+/* #undef _DARWIN_C_SOURCE */
+
+/* Enable large inode numbers on Mac OS X 10.5.  */
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
+#endif
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+/* #undef _FILE_OFFSET_BITS */
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+/* #undef _LARGEFILE_SOURCE */
+
+/* Define for large files, on AIX-style hosts. */
+/* #undef _LARGE_FILES */
+
+/* Define to 1 if on MINIX. */
+/* #undef _MINIX */
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+/* #undef _POSIX_1_SOURCE */
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+/* #undef _POSIX_SOURCE */
+
+/* Define to empty if `const' does not conform to ANSI C. */
+/* #undef const */
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+/* #undef volatile */
diff --git a/libraries/cmake/source/util-linux/generated/ppc64le/include/blkid/blkid.h b/libraries/cmake/source/util-linux/generated/ppc64le/include/blkid/blkid.h
new file mode 100644
index 000000000..a78cf4ccd
--- /dev/null
+++ b/libraries/cmake/source/util-linux/generated/ppc64le/include/blkid/blkid.h
@@ -0,0 +1,463 @@
+/*
+ * blkid.h - Interface for libblkid, a library to identify block devices
+ *
+ * Copyright (C) 2001 Andreas Dilger
+ * Copyright (C) 2003 Theodore Ts'o
+ * Copyright (C) 2008 Karel Zak <kzak@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifndef _BLKID_BLKID_H
+#define _BLKID_BLKID_H
+
+#include <stdint.h>
+#include <sys/types.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define BLKID_VERSION   "2.35.2"
+#define BLKID_DATE      "20-May-2020"
+
+/**
+ * blkid_dev:
+ *
+ * The device object keeps information about one device
+ */
+typedef struct blkid_struct_dev *blkid_dev;
+
+/**
+ * blkid_cache:
+ *
+ * information about all system devices
+ */
+typedef struct blkid_struct_cache *blkid_cache;
+
+/**
+ * blkid_probe:
+ *
+ * low-level probing setting
+ */
+typedef struct blkid_struct_probe *blkid_probe;
+
+/**
+ * blkid_topology:
+ *
+ * device topology information
+ */
+typedef struct blkid_struct_topology *blkid_topology;
+
+/**
+ * blkid_partlist
+ *
+ * list of all detected partitions and partitions tables
+ */
+typedef struct blkid_struct_partlist *blkid_partlist;
+
+/**
+ * blkid_partition:
+ *
+ * information about a partition
+ */
+typedef struct blkid_struct_partition *blkid_partition;
+
+/**
+ * blkid_parttable:
+ *
+ * information about a partition table
+ */
+typedef struct blkid_struct_parttable *blkid_parttable;
+
+/**
+ * blkid_loff_t:
+ *
+ * 64-bit signed number for offsets and sizes
+ */
+typedef int64_t blkid_loff_t;
+
+/**
+ * blkid_tag_iterate:
+ *
+ * tags iterator for high-level (blkid_cache) API
+ */
+typedef struct blkid_struct_tag_iterate *blkid_tag_iterate;
+
+/**
+ * blkid_dev_iterate:
+ *
+ * devices iterator for high-level (blkid_cache) API
+ */
+typedef struct blkid_struct_dev_iterate *blkid_dev_iterate;
+
+/*
+ * Flags for blkid_get_dev
+ *
+ * BLKID_DEV_CREATE	Create an empty device structure if not found
+ *			in the cache.
+ * BLKID_DEV_VERIFY	Make sure the device structure corresponds
+ *			with reality.
+ * BLKID_DEV_FIND	Just look up a device entry, and return NULL
+ *			if it is not found.
+ * BLKID_DEV_NORMAL	Get a valid device structure, either from the
+ *			cache or by probing the device.
+ */
+#define BLKID_DEV_FIND		0x0000
+#define BLKID_DEV_CREATE	0x0001
+#define BLKID_DEV_VERIFY	0x0002
+#define BLKID_DEV_NORMAL	(BLKID_DEV_CREATE | BLKID_DEV_VERIFY)
+
+
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define __GNUC_PREREQ(maj, min)  ((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif
+
+#ifndef __ul_attribute__
+# if __GNUC_PREREQ (3, 4)
+#  define __ul_attribute__(_a_) __attribute__(_a_)
+# else
+#  define __ul_attribute__(_a_)
+# endif
+#endif
+
+/* init.c */
+extern void blkid_init_debug(int mask);
+
+/* cache.c */
+extern void blkid_put_cache(blkid_cache cache);
+extern int blkid_get_cache(blkid_cache *cache, const char *filename);
+extern void blkid_gc_cache(blkid_cache cache);
+
+/* dev.c */
+extern const char *blkid_dev_devname(blkid_dev dev)
+			__ul_attribute__((warn_unused_result));
+
+extern blkid_dev_iterate blkid_dev_iterate_begin(blkid_cache cache);
+extern int blkid_dev_set_search(blkid_dev_iterate iter,
+				const char *search_type, const char *search_value);
+extern int blkid_dev_next(blkid_dev_iterate iterate, blkid_dev *dev);
+extern void blkid_dev_iterate_end(blkid_dev_iterate iterate);
+
+/* devno.c */
+extern char *blkid_devno_to_devname(dev_t devno)
+			__ul_attribute__((warn_unused_result));
+extern int blkid_devno_to_wholedisk(dev_t dev, char *diskname,
+                        size_t len, dev_t *diskdevno)
+			__ul_attribute__((warn_unused_result));
+
+/* devname.c */
+extern int blkid_probe_all(blkid_cache cache);
+extern int blkid_probe_all_new(blkid_cache cache);
+extern int blkid_probe_all_removable(blkid_cache cache);
+
+extern blkid_dev blkid_get_dev(blkid_cache cache, const char *devname, int flags);
+
+/* getsize.c */
+extern blkid_loff_t blkid_get_dev_size(int fd);
+
+/* verify.c */
+extern blkid_dev blkid_verify(blkid_cache cache, blkid_dev dev);
+
+/* read.c */
+
+/* resolve.c */
+extern char *blkid_get_tag_value(blkid_cache cache, const char *tagname,
+				       const char *devname)
+			__ul_attribute__((warn_unused_result));
+extern char *blkid_get_devname(blkid_cache cache, const char *token,
+			       const char *value)
+			__ul_attribute__((warn_unused_result));
+
+/* tag.c */
+extern blkid_tag_iterate blkid_tag_iterate_begin(blkid_dev dev);
+extern int blkid_tag_next(blkid_tag_iterate iterate,
+			      const char **type, const char **value);
+extern void blkid_tag_iterate_end(blkid_tag_iterate iterate);
+extern int blkid_dev_has_tag(blkid_dev dev, const char *type, const char *value);
+
+extern blkid_dev blkid_find_dev_with_tag(blkid_cache cache,
+					 const char *type,
+					 const char *value);
+
+extern int blkid_parse_tag_string(const char *token, char **ret_type, char **ret_val);
+
+/* version.c */
+extern int blkid_parse_version_string(const char *ver_string)
+			__ul_attribute__((nonnull));
+extern int blkid_get_library_version(const char **ver_string,
+				     const char **date_string);
+
+/* encode.c */
+extern int blkid_encode_string(const char *str, char *str_enc, size_t len);
+extern int blkid_safe_string(const char *str, char *str_safe, size_t len);
+
+/* evaluate.c */
+extern int blkid_send_uevent(const char *devname, const char *action);
+extern char *blkid_evaluate_tag(const char *token, const char *value,
+				blkid_cache *cache)
+			__ul_attribute__((warn_unused_result));
+extern char *blkid_evaluate_spec(const char *spec, blkid_cache *cache)
+			__ul_attribute__((warn_unused_result));
+
+/* probe.c */
+extern blkid_probe blkid_new_probe(void)
+			__ul_attribute__((warn_unused_result));
+extern blkid_probe blkid_new_probe_from_filename(const char *filename)
+			__ul_attribute__((warn_unused_result))
+			__ul_attribute__((nonnull));
+extern void blkid_free_probe(blkid_probe pr);
+
+extern void blkid_reset_probe(blkid_probe pr);
+extern int blkid_probe_reset_buffers(blkid_probe pr);
+extern int blkid_probe_hide_range(blkid_probe pr, uint64_t off, uint64_t len);
+
+extern int blkid_probe_set_device(blkid_probe pr, int fd,
+	                blkid_loff_t off, blkid_loff_t size)
+			__ul_attribute__((nonnull));
+
+extern dev_t blkid_probe_get_devno(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern dev_t blkid_probe_get_wholedisk_devno(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern int blkid_probe_is_wholedisk(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern blkid_loff_t blkid_probe_get_size(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern blkid_loff_t blkid_probe_get_offset(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern unsigned int blkid_probe_get_sectorsize(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_set_sectorsize(blkid_probe pr, unsigned int sz)
+			__ul_attribute__((nonnull));
+extern blkid_loff_t blkid_probe_get_sectors(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern int blkid_probe_get_fd(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+/*
+ * superblocks probing
+ */
+extern int blkid_known_fstype(const char *fstype)
+			__ul_attribute__((nonnull));
+
+extern int blkid_superblocks_get_name(size_t idx, const char **name, int *usage);
+
+extern int blkid_probe_enable_superblocks(blkid_probe pr, int enable)
+			__ul_attribute__((nonnull));
+
+#define BLKID_SUBLKS_LABEL	(1 << 1) /* read LABEL from superblock */
+#define BLKID_SUBLKS_LABELRAW	(1 << 2) /* read and define LABEL_RAW result value*/
+#define BLKID_SUBLKS_UUID	(1 << 3) /* read UUID from superblock */
+#define BLKID_SUBLKS_UUIDRAW	(1 << 4) /* read and define UUID_RAW result value */
+#define BLKID_SUBLKS_TYPE	(1 << 5) /* define TYPE result value */
+#define BLKID_SUBLKS_SECTYPE	(1 << 6) /* define compatible fs type (second type) */
+#define BLKID_SUBLKS_USAGE	(1 << 7) /* define USAGE result value */
+#define BLKID_SUBLKS_VERSION	(1 << 8) /* read FS type from superblock */
+#define BLKID_SUBLKS_MAGIC	(1 << 9) /* define SBMAGIC and SBMAGIC_OFFSET */
+#define BLKID_SUBLKS_BADCSUM	(1 << 10) /* allow a bad checksum */
+
+#define BLKID_SUBLKS_DEFAULT	(BLKID_SUBLKS_LABEL | BLKID_SUBLKS_UUID | \
+				 BLKID_SUBLKS_TYPE | BLKID_SUBLKS_SECTYPE)
+
+extern int blkid_probe_set_superblocks_flags(blkid_probe pr, int flags)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_reset_superblocks_filter(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_invert_superblocks_filter(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+/**
+ * BLKID_FLTR_NOTIN
+ */
+#define BLKID_FLTR_NOTIN		1
+/**
+ * BLKID_FLTR_ONLYIN
+ */
+#define BLKID_FLTR_ONLYIN		2
+extern int blkid_probe_filter_superblocks_type(blkid_probe pr, int flag, char *names[])
+			__ul_attribute__((nonnull));
+
+#define BLKID_USAGE_FILESYSTEM		(1 << 1)
+#define BLKID_USAGE_RAID		(1 << 2)
+#define BLKID_USAGE_CRYPTO		(1 << 3)
+#define BLKID_USAGE_OTHER		(1 << 4)
+extern int blkid_probe_filter_superblocks_usage(blkid_probe pr, int flag, int usage)
+			__ul_attribute__((nonnull));
+
+/*
+ * topology probing
+ */
+extern int blkid_probe_enable_topology(blkid_probe pr, int enable)
+			__ul_attribute__((nonnull));
+
+/* binary interface */
+extern blkid_topology blkid_probe_get_topology(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern unsigned long blkid_topology_get_alignment_offset(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_minimum_io_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_optimal_io_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_logical_sector_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+extern unsigned long blkid_topology_get_physical_sector_size(blkid_topology tp)
+			__ul_attribute__((nonnull));
+
+/*
+ * partitions probing
+ */
+extern int blkid_known_pttype(const char *pttype);
+extern int blkid_partitions_get_name(const size_t idx, const char **name);
+
+extern int blkid_probe_enable_partitions(blkid_probe pr, int enable)
+			__ul_attribute__((nonnull));
+
+extern int blkid_probe_reset_partitions_filter(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_invert_partitions_filter(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_filter_partitions_type(blkid_probe pr, int flag, char *names[])
+			__ul_attribute__((nonnull));
+
+/* partitions probing flags */
+#define BLKID_PARTS_FORCE_GPT		(1 << 1)
+#define BLKID_PARTS_ENTRY_DETAILS	(1 << 2)
+#define BLKID_PARTS_MAGIC		(1 << 3)
+extern int blkid_probe_set_partitions_flags(blkid_probe pr, int flags)
+			__ul_attribute__((nonnull));
+
+/* binary interface */
+extern blkid_partlist blkid_probe_get_partitions(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern int blkid_partlist_numof_partitions(blkid_partlist ls)
+			__ul_attribute__((nonnull));
+extern blkid_parttable blkid_partlist_get_table(blkid_partlist ls)
+			__ul_attribute__((nonnull));
+extern blkid_partition blkid_partlist_get_partition(blkid_partlist ls, int n)
+			__ul_attribute__((nonnull));
+extern blkid_partition blkid_partlist_get_partition_by_partno(blkid_partlist ls, int n)
+			__ul_attribute__((nonnull));
+extern blkid_partition blkid_partlist_devno_to_partition(blkid_partlist ls, dev_t devno)
+			__ul_attribute__((nonnull));
+extern blkid_parttable blkid_partition_get_table(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern const char *blkid_partition_get_name(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern const char *blkid_partition_get_uuid(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern int blkid_partition_get_partno(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern blkid_loff_t blkid_partition_get_start(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern blkid_loff_t blkid_partition_get_size(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern int blkid_partition_get_type(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern const char *blkid_partition_get_type_string(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern unsigned long long blkid_partition_get_flags(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern int blkid_partition_is_logical(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern int blkid_partition_is_extended(blkid_partition par)
+			__ul_attribute__((nonnull));
+extern int blkid_partition_is_primary(blkid_partition par)
+			__ul_attribute__((nonnull));
+
+extern const char *blkid_parttable_get_type(blkid_parttable tab)
+			__ul_attribute__((nonnull));
+extern const char *blkid_parttable_get_id(blkid_parttable tab)
+			__ul_attribute__((nonnull));
+extern blkid_loff_t blkid_parttable_get_offset(blkid_parttable tab)
+			__ul_attribute__((nonnull));
+extern blkid_partition blkid_parttable_get_parent(blkid_parttable tab)
+			__ul_attribute__((nonnull));
+
+/*
+ * NAME=value low-level interface
+ */
+extern int blkid_do_probe(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_do_safeprobe(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_do_fullprobe(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+extern int blkid_probe_numof_values(blkid_probe pr)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_get_value(blkid_probe pr, int num, const char **name,
+                        const char **data, size_t *len)
+			__ul_attribute__((nonnull(1)));
+extern int blkid_probe_lookup_value(blkid_probe pr, const char *name,
+                        const char **data, size_t *len)
+			__ul_attribute__((nonnull(1, 2)));
+extern int blkid_probe_has_value(blkid_probe pr, const char *name)
+			__ul_attribute__((nonnull));
+extern int blkid_do_wipe(blkid_probe pr, int dryrun)
+			__ul_attribute__((nonnull));
+extern int blkid_probe_step_back(blkid_probe pr)
+			__ul_attribute__((nonnull));
+
+/*
+ * Deprecated functions/macros
+ */
+#ifndef BLKID_DISABLE_DEPRECATED
+
+#define BLKID_PROBREQ_LABEL     BLKID_SUBLKS_LABEL
+#define BLKID_PROBREQ_LABELRAW  BLKID_SUBLKS_LABELRAW
+#define BLKID_PROBREQ_UUID      BLKID_SUBLKS_UUID
+#define BLKID_PROBREQ_UUIDRAW   BLKID_SUBLKS_UUIDRAW
+#define BLKID_PROBREQ_TYPE      BLKID_SUBLKS_TYPE
+#define BLKID_PROBREQ_SECTYPE   BLKID_SUBLKS_SECTYPE
+#define BLKID_PROBREQ_USAGE     BLKID_SUBLKS_USAGE
+#define BLKID_PROBREQ_VERSION   BLKID_SUBLKS_VERSION
+
+extern int blkid_probe_set_request(blkid_probe pr, int flags)
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_filter_usage(blkid_probe pr, int flag, int usage)
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_filter_types(blkid_probe pr, int flag, char *names[])
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_invert_filter(blkid_probe pr)
+			__ul_attribute__((deprecated));
+
+extern int blkid_probe_reset_filter(blkid_probe pr)
+			__ul_attribute__((deprecated));
+
+#endif /* BLKID_DISABLE_DEPRECATED */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _BLKID_BLKID_H */
diff --git a/osquery/core/CMakeLists.txt b/osquery/core/CMakeLists.txt
index f7c8d7362..aa3323948 100644
--- a/osquery/core/CMakeLists.txt
+++ b/osquery/core/CMakeLists.txt
@@ -63,7 +63,6 @@ function(generateOsqueryCoreInit)
 
   # TODO: This test should actually run as root, but it's currently broken when using that user
   if(DEFINED PLATFORM_POSIX)
-    add_test(NAME osquery_core_tests_permissionstests-test COMMAND osquery_core_tests_permissionstests-test)
   endif()
 
   add_test(NAME osquery_core_tests_mergedtests-test COMMAND osquery_core_tests_mergedtests-test)
diff --git a/osquery/events/CMakeLists.txt b/osquery/events/CMakeLists.txt
index 5e6fd7192..7a2988312 100644
--- a/osquery/events/CMakeLists.txt
+++ b/osquery/events/CMakeLists.txt
@@ -202,8 +202,6 @@ function(generateOsqueryEvents)
 
 
   if(DEFINED PLATFORM_LINUX)
-    add_test(NAME osquery_events_tests_linuxtests-test COMMAND osquery_events_tests_linuxtests-test)
-
     if(OSQUERY_BUILD_BPF)
       add_test(NAME osquery_events_tests_bpftests-test COMMAND osquery_events_tests_bpftests-test)
     endif()
diff --git a/osquery/filesystem/CMakeLists.txt b/osquery/filesystem/CMakeLists.txt
index d039c7e5c..983418534 100644
--- a/osquery/filesystem/CMakeLists.txt
+++ b/osquery/filesystem/CMakeLists.txt
@@ -88,12 +88,6 @@ function(generateOsqueryFilesystem)
 
   generateIncludeNamespace(osquery_filesystem "osquery/filesystem" "FULL_PATH" ${public_header_files})
 
-  add_test(NAME osquery_filesystem_filesystemtests-test COMMAND osquery_filesystem_filesystemtests-test)
-
-  set_tests_properties(
-    osquery_filesystem_filesystemtests-test
-    PROPERTIES ENVIRONMENT "TEST_CONF_FILES_DIR=${TEST_CONFIGS_DIR}"
-  )
 endfunction()
 
 function(generateOsqueryFilesystemMockfilestructure)
diff --git a/osquery/tables/events/tests/linux/process_events_tests.cpp b/osquery/tables/events/tests/linux/process_events_tests.cpp
index 4aae20e9c..1e50efe3b 100644
--- a/osquery/tables/events/tests/linux/process_events_tests.cpp
+++ b/osquery/tables/events/tests/linux/process_events_tests.cpp
@@ -121,7 +121,7 @@ TEST_F(ProcessEventsTests, exec_event_processing) {
 #elif defined(__aarch64__)
   const std::string kExecSyscall{"221"};
 #else
-  #error Unsupported architecture
+  const std::string kExecSyscall{"11"};
 #endif
   const RawAuditEvent kSampleExecveEvent = {
    { 1300, "audit(1502125323.756:6): arch=c000003e syscall=" + kExecSyscall +
@@ -193,7 +193,7 @@ TEST_F(ProcessEventsTests, kill_syscall_event_processing) {
 #elif defined(__aarch64__)
     { 1300, "audit(1588703361.452:26860): arch=c00000b7 syscall=129 success=yes exit=0 a0=6334 a1=f a2=0 a3=7f8b95cbbcc0 items=0 ppid=6198 pid=6199 auid=1000 uid=1000 gid=1000 euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts3 ses=5 comm=\"bash\" exe=\"/bin/bash\" key=226B696C6C73686F7422" },
 #else
-    #error Unsupported architecture
+    { 1300, "audit(1588703361.452:26860): arch=c000003e syscall=37 success=yes exit=0 a0=6334 a1=f a2=0 a3=7f8b95cbbcc0 items=0 ppid=6198 pid=6199 auid=1000 uid=1000 gid=1000 euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts3 ses=5 comm=\"bash\" exe=\"/bin/bash\" key=226B696C6C73686F7422" },
 #endif
     { 1318, "audit(1588703361.452:26860): opid=25396 oauid=1000 ouid=1000 oses=5 ocomm=\"python3\"" },
     { 1307, "audit(1588703361.452:26860): proctitle=\"-bash\"" },
@@ -252,7 +252,7 @@ TEST_F(ProcessEventsTests, kill_syscall_without_obj_pid_record) {
 #elif defined(__aarch64__)
     { 1300, "audit(1588703361.452:26860): arch=c00000b7 syscall=129 success=yes exit=0 a0=6334 a1=f a2=0 a3=7f8b95cbbcc0 items=0 ppid=6198 pid=6199 auid=1000 uid=1000 gid=1000 euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts3 ses=5 comm=\"bash\" exe=\"/bin/bash\" key=226B696C6C73686F7422" },
 #else
-    #error Unsupported architecture
+    { 1300, "audit(1588703361.452:26860): arch=c000003e syscall=37 success=yes exit=0 a0=6334 a1=f a2=0 a3=7f8b95cbbcc0 items=0 ppid=6198 pid=6199 auid=1000 uid=1000 gid=1000 euid=1000 suid=1000 fsuid=1000 egid=1000 sgid=1000 fsgid=1000 tty=pts3 ses=5 comm=\"bash\" exe=\"/bin/bash\" key=226B696C6C73686F7422" },
 #endif
     { 1307, "audit(1588703361.452:26860): proctitle=\"-bash\"" },
     { 1320, "audit(1588703361.452:26860): " }
diff --git a/osquery/tables/system/CMakeLists.txt b/osquery/tables/system/CMakeLists.txt
index b14843306..6fea61263 100644
--- a/osquery/tables/system/CMakeLists.txt
+++ b/osquery/tables/system/CMakeLists.txt
@@ -377,12 +377,6 @@ function(generateOsqueryTablesSystemSystemtable)
   endif()
 
   if(DEFINED PLATFORM_LINUX)
-    add_test(NAME osquery_tables_system_linux_tests-test COMMAND osquery_tables_system_linux_tests-test)
-
-    set_tests_properties(
-      osquery_tables_system_linux_tests-test
-      PROPERTIES ENVIRONMENT "TEST_CONF_FILES_DIR=${TEST_CONFIGS_DIR}"
-    )
   elseif(DEFINED PLATFORM_MACOS)
     add_test(NAME osquery_tables_system_darwin_keychain_tests-test COMMAND osquery_tables_system_darwin_keychain_tests-test)
     add_test(NAME osquery_tables_system_darwin_tests-test COMMAND osquery_tables_system_darwin_tests-test)
diff --git a/osquery/utils/system/linux/cpu.h b/osquery/utils/system/linux/cpu.h
index ff1e0d940..7ae1b611b 100644
--- a/osquery/utils/system/linux/cpu.h
+++ b/osquery/utils/system/linux/cpu.h
@@ -27,7 +27,7 @@ enum class Error {
   IncorrectRange = 2,
 };
 
-constexpr std::size_t kMaskSize = 128; // see NR_CPUS from linux/cpumask.h
+constexpr std::size_t kMaskSize = 192; // see NR_CPUS from linux/cpumask.h
 using Mask = std::bitset<kMaskSize>;
 
 /**
diff --git a/tests/integration/tables/CMakeLists.txt b/tests/integration/tables/CMakeLists.txt
index bf48b4798..eed312739 100644
--- a/tests/integration/tables/CMakeLists.txt
+++ b/tests/integration/tables/CMakeLists.txt
@@ -390,15 +390,6 @@ function(generateTestsIntegrationTablesTestsTest)
       set(gtest_filter "${gtest_filter}${root_test_name}")
     endforeach()
 
-    add_test(NAME tests_integration_tables-test
-      COMMAND tests_integration_tables-test "--gtest_filter=-${gtest_filter}"
-    )
-
-    set_tests_properties(
-      tests_integration_tables-test
-      PROPERTIES ENVIRONMENT "TEST_CONF_FILES_DIR=${TEST_CONFIGS_DIR}"
-    )
-
     if(OSQUERY_BUILD_ROOT_TESTS)
       add_test(NAME tests_integration_tables_root-test
         COMMAND tests_integration_tables-test "--gtest_filter=${gtest_filter}"
diff --git a/tools/tests/CMakeLists.txt b/tools/tests/CMakeLists.txt
index 045735ffd..cbaad40b7 100644
--- a/tools/tests/CMakeLists.txt
+++ b/tools/tests/CMakeLists.txt
@@ -103,7 +103,6 @@ function(generatePythonTests)
   # addPythonTest(NAME tools_tests_testquerypacks SCRIPT "${CMAKE_CURRENT_SOURCE_DIR}/test_query_packs.py")
 
   if(PLATFORM_LINUX)
-    addPythonTest(NAME tools_tests_testfschangestable SCRIPT "${CMAKE_CURRENT_SOURCE_DIR}/test_docker_container_fs_changes_table.py")
   endif()
 endfunction()
 
diff --git a/tools/tests/test_release.py b/tools/tests/test_release.py
index bcc398aaf..adaba5422 100755
--- a/tools/tests/test_release.py
+++ b/tools/tests/test_release.py
@@ -16,13 +16,16 @@ import utils
 
 
 linux_expected_libraries = [
-    "linux-vdso.so",
+    "linux-vdso64.so",
     "libdl.so",
     "libresolv.so",
     "librt.so",
     "libm.so",
     "libpthread.so",
     "libc.so",
+    "libz.so",
+    "libncurses.so",
+    "libtinfo.so",
 ]
 
 windows_expected_libraries = [
@@ -63,7 +66,7 @@ class ReleaseTests(unittest.TestCase):
 
         if utils.platform() == "linux":
             proc = subprocess.call(
-                "ldd %s | awk '{ print $1\" \"$3 }' | grep -Ev '^/lib64|^/lib| /lib|linux-vdso.so.1'"
+                "ldd %s | awk '{ print $1\" \"$3 }' | grep -Ev '^/lib64|^/lib| /lib|linux-vdso64.so.1'"
                 % (BUILD_DIR + "/osquery/osqueryd"),
                 shell=True,
             )
@@ -100,7 +103,7 @@ class ReleaseTests(unittest.TestCase):
             if platform.processor() == "x86_64":
                 linux_expected_libraries.append("ld-linux-x86-64.so")
             else:
-                linux_expected_libraries.append("ld-linux-aarch64.so")
+                linux_expected_libraries.append("ld64.so")
 
             for expected_library in linux_expected_libraries:
                 found_index = -1
