diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1d8272754..f44cfe7b6 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -400,6 +400,10 @@ if (FLB_SYSTEM_MACOS)
   include(cmake/macos-setup.cmake)
 endif()
 
+if (FLB_SYSTEM_LINUX)
+  include(cmake/ppc64le.cmake)
+endif ()
+
 # Build for SystemZ - s390x arch
 if (FLB_SYSTEM_LINUX)
   include(cmake/s390x.cmake)
diff --git a/cmake/libraries.cmake b/cmake/libraries.cmake
index 47325cbda..2f13e5b81 100644
--- a/cmake/libraries.cmake
+++ b/cmake/libraries.cmake
@@ -10,7 +10,7 @@ set(FLB_PATH_LIB_MSGPACK     "lib/msgpack-c")
 set(FLB_PATH_LIB_NGHTTP2     "lib/nghttp2")
 set(FLB_PATH_LIB_AVRO        "lib/avro")
 set(FLB_PATH_LIB_CHUNKIO     "lib/chunkio")
-set(FLB_PATH_LIB_LUAJIT      "lib/luajit-3065c9")
+set(FLB_PATH_LIB_LUAJIT      "lib/luajit2")
 set(FLB_PATH_LIB_MONKEY      "lib/monkey")
 set(FLB_PATH_LIB_JSMN        "lib/jsmn")
 set(FLB_PATH_LIB_SQLITE      "lib/sqlite-amalgamation-3450200")
diff --git a/cmake/luajit.cmake b/cmake/luajit.cmake
index b6774eb44..7741805a9 100644
--- a/cmake/luajit.cmake
+++ b/cmake/luajit.cmake
@@ -1,4 +1,65 @@
-# luajit cmake
-option(LUAJIT_DIR "Path of LuaJIT 2.1 source dir" ON)
-set(LUAJIT_DIR ${FLB_PATH_ROOT_SOURCE}/${FLB_PATH_LIB_LUAJIT})
-add_subdirectory("lib/luajit-cmake")
+# This file provides 'libluajit' target for both UNIX and Windows.
+#
+# To enable LuaJIT, include this file and link the build target:
+#
+#    include(cmake/luajit.cmake)
+#    target_link_libraries(fluent-bit libluajit)
+
+add_library(libluajit STATIC IMPORTED GLOBAL)
+
+# Global Settings
+set(LUAJIT_SRC ${CMAKE_CURRENT_SOURCE_DIR}/${FLB_PATH_LIB_LUAJIT})
+set(LUAJIT_DEST ${CMAKE_CURRENT_BINARY_DIR})
+
+if (CMAKE_SYSTEM_NAME MATCHES "Darwin")
+  set(CFLAGS "${CFLAGS} -isysroot ${CMAKE_OSX_SYSROOT} -fno-stack-check")
+
+  if(DEFINED ENV{MACOSX_DEPLOYMENT_TARGET})
+    # Refer MACOSX_DEPLOYMENT_TARGET if available.
+    set(DEPLOYMENT_TARGET "MACOSX_DEPLOYMENT_TARGET=$ENV{MACOSX_DEPLOYMENT_TARGET}")
+  else()
+    # Calculate MACOSX_DEPLOYMENT_TARGET from sw_vers command result.
+    execute_process(COMMAND sw_vers -productVersion OUTPUT_VARIABLE MACOSX_DEPLOYMENT_TARGET)
+    string(REGEX REPLACE "\n$" "" MACOSX_DEPLOYMENT_TARGET ${MACOSX_DEPLOYMENT_TARGET})
+    string(REPLACE "." ";" DEPLOYMENT_VERSION_LIST ${MACOSX_DEPLOYMENT_TARGET})
+    list(GET DEPLOYMENT_VERSION_LIST 0 MACOSX_DEPLOYMENT_TARGET_MAJOR)
+    list(GET DEPLOYMENT_VERSION_LIST 1 MACOSX_DEPLOYMENT_TARGET_MINOR)
+    set(DEPLOYMENT_TARGET "MACOSX_DEPLOYMENT_TARGET=${MACOSX_DEPLOYMENT_TARGET_MAJOR}.${MACOSX_DEPLOYMENT_TARGET_MINOR}")
+  endif()
+else()
+  set(DEPLOYMENT_TARGET "")
+endif()
+
+# luajit (UNIX)
+# =============
+ExternalProject_Add(luajit
+  BUILD_IN_SOURCE TRUE
+  EXCLUDE_FROM_ALL TRUE
+  SOURCE_DIR ${LUAJIT_SRC}
+  CONFIGURE_COMMAND ./configure
+  BUILD_COMMAND $(MAKE) CC=${CMAKE_C_COMPILER} ${DEPLOYMENT_TARGET} CFLAGS=${CFLAGS} BUILDMODE=static "XCFLAGS=-fPIC"
+  INSTALL_COMMAND cp src/libluajit.a "${LUAJIT_DEST}/lib/libluajit.a")
+
+# luajit (Windows)
+# ================
+if (MSVC)
+  ExternalProject_Add(luajit-windows
+    BUILD_IN_SOURCE TRUE
+    EXCLUDE_FROM_ALL TRUE
+    SOURCE_DIR ${LUAJIT_SRC}/src
+    CONFIGURE_COMMAND ""
+    BUILD_COMMAND ./msvcbuild.bat static
+    INSTALL_COMMAND ${CMAKE_COMMAND} -E copy lua51.lib "${LUAJIT_DEST}/lib/libluajit.lib")
+endif()
+
+# Hook the buld definition to 'libluajit' target
+if(MSVC)
+  add_dependencies(libluajit luajit-windows)
+  set(LUAJIT_STATIC_LIB "${LUAJIT_DEST}/lib/libluajit.lib")
+else()
+  add_dependencies(libluajit luajit)
+  set(LUAJIT_STATIC_LIB "${LUAJIT_DEST}/lib/libluajit.a")
+endif()
+
+set_target_properties(libluajit PROPERTIES IMPORTED_LOCATION "${LUAJIT_STATIC_LIB}")
+include_directories("${LUAJIT_DEST}/include/")
diff --git a/cmake/ppc64le.cmake b/cmake/ppc64le.cmake
new file mode 100644
index 000000000..3f79f2087
--- /dev/null
+++ b/cmake/ppc64le.cmake
@@ -0,0 +1,6 @@
+if(CMAKE_SYSTEM_PROCESSOR MATCHES "^(powerpc|ppc)64le")
+  message(STATUS "Forcing characters to be signed, as on x86_64.")
+  set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fsigned-char")
+  message(STATUS "This platform does not support WAMR building so disabled.")
+  set(FLB_WASM OFF)
+endif ()
diff --git a/lib/luajit-3065c9/configure b/lib/luajit-3065c9/configure
deleted file mode 100755
index e69de29bb..000000000
diff --git a/lib/luajit-3065c9/doc/faq.html b/lib/luajit-3065c9/doc/faq.html
deleted file mode 100644
index 9effeb16a..000000000
--- a/lib/luajit-3065c9/doc/faq.html
+++ /dev/null
@@ -1,199 +0,0 @@
-<!DOCTYPE html>
-<html>
-<head>
-<title>Frequently Asked Questions (FAQ)</title>
-<meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
-<meta name="Language" content="en">
-<link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
-<link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
-<style type="text/css">
-dd { margin-left: 1.5em; }
-</style>
-</head>
-<body>
-<div id="site">
-<a href="https://luajit.org"><span>Lua<span id="logo">JIT</span></span></a>
-</div>
-<div id="head">
-<h1>Frequently Asked Questions (FAQ)</h1>
-</div>
-<div id="nav">
-<ul><li>
-<a href="luajit.html">LuaJIT</a>
-<ul><li>
-<a href="https://luajit.org/download.html">Download <span class="ext">&raquo;</span></a>
-</li><li>
-<a href="install.html">Installation</a>
-</li><li>
-<a href="running.html">Running</a>
-</li></ul>
-</li><li>
-<a href="extensions.html">Extensions</a>
-<ul><li>
-<a href="ext_ffi.html">FFI Library</a>
-<ul><li>
-<a href="ext_ffi_tutorial.html">FFI Tutorial</a>
-</li><li>
-<a href="ext_ffi_api.html">ffi.* API</a>
-</li><li>
-<a href="ext_ffi_semantics.html">FFI Semantics</a>
-</li></ul>
-</li><li>
-<a href="ext_buffer.html">String Buffers</a>
-</li><li>
-<a href="ext_jit.html">jit.* Library</a>
-</li><li>
-<a href="ext_c_api.html">Lua/C API</a>
-</li><li>
-<a href="ext_profiler.html">Profiler</a>
-</li></ul>
-</li><li>
-<a href="status.html">Status</a>
-</li><li>
-<a class="current" href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
-</li><li>
-<a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
-</li></ul>
-</div>
-<div id="main">
-<dl id="info">
-<dt>Q: Where can I learn more about LuaJIT and Lua?</dt>
-<dd>
-<ul style="padding: 0;">
-<li>The <a href="https://luajit.org/list.html"><span class="ext">&raquo;</span>&nbsp;LuaJIT mailing list</a> focuses on topics
-related to LuaJIT.</li>
-<li>The <a href="http://wiki.luajit.org/"><span class="ext">&raquo;</span>&nbsp;LuaJIT wiki</a> gathers community
-resources about LuaJIT.</li>
-<li>News about Lua itself can be found at the
-<a href="https://www.lua.org/lua-l.html"><span class="ext">&raquo;</span>&nbsp;Lua mailing list</a>.
-The mailing list archives are worth checking out for older postings
-about LuaJIT.</li>
-<li>The <a href="https://lua.org"><span class="ext">&raquo;</span>&nbsp;main Lua.org site</a> has complete
-<a href="https://www.lua.org/docs.html"><span class="ext">&raquo;</span>&nbsp;documentation</a> of the language
-and links to books and papers about Lua.</li>
-<li>The community-managed <a href="http://lua-users.org/wiki/"><span class="ext">&raquo;</span>&nbsp;Lua Wiki</a>
-has information about diverse topics.</li>
-</ul></dd>
-</dl>
-
-<dl id="tech">
-<dt>Q: Where can I learn more about the compiler technology used by LuaJIT?</dt>
-<dd>
-Please use the following Google Scholar searches to find relevant papers:<br>
-Search for: <a href="https://scholar.google.com/scholar?q=Trace+Compiler"><span class="ext">&raquo;</span>&nbsp;Trace Compiler</a><br>
-Search for: <a href="https://scholar.google.com/scholar?q=JIT+Compiler"><span class="ext">&raquo;</span>&nbsp;JIT Compiler</a><br>
-Search for: <a href="https://scholar.google.com/scholar?q=Dynamic+Language+Optimizations"><span class="ext">&raquo;</span>&nbsp;Dynamic Language Optimizations</a><br>
-Search for: <a href="https://scholar.google.com/scholar?q=SSA+Form"><span class="ext">&raquo;</span>&nbsp;SSA Form</a><br>
-Search for: <a href="https://scholar.google.com/scholar?q=Linear+Scan+Register+Allocation"><span class="ext">&raquo;</span>&nbsp;Linear Scan Register Allocation</a><br>
-Here is a list of the <a href="http://lua-users.org/lists/lua-l/2009-11/msg00089.html"><span class="ext">&raquo;</span>&nbsp;innovative features in LuaJIT</a>.<br>
-And, you know, reading the source is of course the only way to enlightenment.
-</dd>
-</dl>
-
-<dl id="arg">
-<dt>Q: Why do I get this error: "attempt to index global 'arg' (a nil value)"?<br>
-Q: My vararg functions fail after switching to LuaJIT!</dt>
-<dd>LuaJIT is compatible to the Lua 5.1 language standard. It doesn't
-support the implicit <tt>arg</tt> parameter for old-style vararg
-functions from Lua 5.0.<br>Please convert your code to the
-<a href="https://www.lua.org/manual/5.1/manual.html#2.5.9"><span class="ext">&raquo;</span>&nbsp;Lua 5.1
-vararg syntax</a>.</dd>
-</dl>
-
-<dl id="x87">
-<dt>Q: Why do I get this error: "bad FPU precision"?<br>
-<dt>Q: I get weird behavior after initializing Direct3D.<br>
-<dt>Q: Some FPU operations crash after I load a Delphi DLL.<br>
-</dt>
-<dd>
-
-DirectX/Direct3D (up to version 9) sets the x87 FPU to single-precision
-mode by default. This violates the Windows ABI and interferes with the
-operation of many programs &mdash; LuaJIT is affected, too. Please make
-sure you always use the <tt>D3DCREATE_FPU_PRESERVE</tt> flag when
-initializing Direct3D.<br>
-
-Direct3D version 10 or higher do not show this behavior anymore.
-Consider testing your application with older versions, too.<br>
-
-Similarly, the Borland/Delphi runtime modifies the FPU control word and
-enables FP exceptions. Of course, this violates the Windows ABI, too.
-Please check the Delphi docs for the Set8087CW method.</dd>
-</dl>
-
-<dl id="ctrlc">
-<dt>Q: Sometimes Ctrl-C fails to stop my Lua program. Why?</dt>
-<dd>The interrupt signal handler sets a Lua debug hook. But this is
-ignored by compiled code. If your program is running in a tight loop
-and never falls back to the interpreter, the debug hook never runs and
-can't throw the "interrupted!" error.<br>
-You have to press Ctrl-C twice to stop your program. That's similar
-to when it's stuck running inside a C function under the Lua interpreter.</dd>
-</dl>
-
-<dl id="order">
-<dt>Q: Table iteration with <tt>pairs()</tt> does not result in the same order?</dt>
-<dd>The order of table iteration is explicitly <b>undefined</b> by
-the Lua language standard.<br>
-Different Lua implementations or versions may use different orders for
-otherwise identical tables. Different ways of constructing a table may
-result in different orders, too.<br>
-Due to improved VM security, LuaJIT 2.1 may even use a different order
-on separate VM invocations or when string keys are newly interned.<br><br>
-If your program relies on a deterministic order, it has a bug. Rewrite it,
-so it doesn't rely on the key order. Or sort the table keys, if you must.</dd>
-</dl>
-
-<dl id="sandbox">
-<dt>Q: Can Lua code be safely sandboxed?</dt>
-<dd>
-Maybe for an extremely restricted subset of Lua and if you relentlessly
-scrutinize every single interface function you offer to the untrusted code.<br>
-
-Although Lua provides some sandboxing functionality (<tt>setfenv()</tt>, hooks),
-it's very hard to get this right even for the Lua core libraries. Of course,
-you'll need to inspect any extension library, too. And there are libraries
-that are inherently unsafe, e.g. the <a href="ext_ffi.html">FFI library</a>.<br>
-
-More reading material at the <a href="http://lua-users.org/wiki/SandBoxes"><span class="ext">&raquo;</span>&nbsp;Lua Wiki</a> and <a href="https://en.wikipedia.org/wiki/Sandbox_(computer_security)"><span class="ext">&raquo;</span>&nbsp;Wikipedia</a>.<br><br>
-
-Relatedly, <b>loading untrusted bytecode is not safe!</b><br>
-
-It's trivial to crash the Lua or LuaJIT VM with maliciously crafted bytecode.
-This is well known and there's no bytecode verification on purpose, so please
-don't report a bug about it. Check the <tt>mode</tt> parameter for the
-<tt>load*()</tt> functions to disable loading of bytecode.<br><br>
-
-<b>In general, the only promising approach is to sandbox Lua code at the
-process level and not the VM level.</b>
-</dd>
-</dl>
-
-<dl id="arch">
-<dt>Q: Lua runs everywhere. Why doesn't LuaJIT support my CPU?</dt>
-<dd>Because it's a compiler &mdash; it needs to generate native
-machine code. This means the code generator must be ported to each
-architecture. And the fast interpreter is written in assembler and
-must be ported, too. This is quite an undertaking.<br>
-The <a href="install.html">install documentation</a> shows the supported
-architectures.<br>
-Other architectures may follow based on sufficient user demand and
-market-relevance of the architecture. Sponsoring is required to develop
-the port itself, to integrate it and to continuously maintain it in the
-actively developed branches.</dd>
-</dl>
-<br class="flush">
-</div>
-<div id="foot">
-<hr class="hide">
-Copyright &copy; 2005-2022
-<span class="noprint">
-&middot;
-<a href="contact.html">Contact</a>
-</span>
-</div>
-</body>
-</html>
diff --git a/lib/luajit-3065c9/doc/status.html b/lib/luajit-3065c9/doc/status.html
deleted file mode 100644
index 1c86c1032..000000000
--- a/lib/luajit-3065c9/doc/status.html
+++ /dev/null
@@ -1,107 +0,0 @@
-<!DOCTYPE html>
-<html>
-<head>
-<title>Status</title>
-<meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
-<meta name="Language" content="en">
-<link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
-<link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
-<style type="text/css">
-ul li { padding-bottom: 0.3em; }
-</style>
-</head>
-<body>
-<div id="site">
-<a href="https://luajit.org"><span>Lua<span id="logo">JIT</span></span></a>
-</div>
-<div id="head">
-<h1>Status</h1>
-</div>
-<div id="nav">
-<ul><li>
-<a href="luajit.html">LuaJIT</a>
-<ul><li>
-<a href="https://luajit.org/download.html">Download <span class="ext">&raquo;</span></a>
-</li><li>
-<a href="install.html">Installation</a>
-</li><li>
-<a href="running.html">Running</a>
-</li></ul>
-</li><li>
-<a href="extensions.html">Extensions</a>
-<ul><li>
-<a href="ext_ffi.html">FFI Library</a>
-<ul><li>
-<a href="ext_ffi_tutorial.html">FFI Tutorial</a>
-</li><li>
-<a href="ext_ffi_api.html">ffi.* API</a>
-</li><li>
-<a href="ext_ffi_semantics.html">FFI Semantics</a>
-</li></ul>
-</li><li>
-<a href="ext_buffer.html">String Buffers</a>
-</li><li>
-<a href="ext_jit.html">jit.* Library</a>
-</li><li>
-<a href="ext_c_api.html">Lua/C API</a>
-</li><li>
-<a href="ext_profiler.html">Profiler</a>
-</li></ul>
-</li><li>
-<a class="current" href="status.html">Status</a>
-</li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
-</li><li>
-<a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
-</li></ul>
-</div>
-<div id="main">
-<p>
-This documentation is for LuaJIT 2.1.0-beta3. Please check the <tt>doc</tt>
-directory in each git branch for the version-specific documentation.
-</p>
-<p>
-The currently developed branches are LuaJIT&nbsp;2.1 and LuaJIT&nbsp;2.0.
-</p>
-<p>
-LuaJIT&nbsp;2.0 is in feature-freeze &mdash; new features will only
-be added to LuaJIT&nbsp;2.1.
-</p>
-
-<h2>Current Status</h2>
-<p>
-LuaJIT ought to run all Lua&nbsp;5.1-compatible source code just fine.
-It's considered a serious bug if the VM crashes or produces unexpected
-results &mdash; please report this.
-</p>
-<p>
-Known incompatibilities and issues in LuaJIT&nbsp;2.0:
-</p>
-<ul>
-<li>
-There are some differences in <b>implementation-defined</b> behavior.
-These either have a good reason, are arbitrary design choices,
-or are due to quirks in the VM. The latter cases may get fixed if a
-demonstrable need is shown.
-</li>
-<li>
-The Lua <b>debug API</b> is missing a couple of features (return
-hooks for non-Lua functions) and shows slightly different behavior
-in LuaJIT (no per-coroutine hooks, no tail call counting).
-</li>
-</ul>
-<br class="flush">
-</div>
-<div id="foot">
-<hr class="hide">
-Copyright &copy; 2005-2022
-<span class="noprint">
-&middot;
-<a href="contact.html">Contact</a>
-</span>
-</div>
-</body>
-</html>
diff --git a/lib/luajit2/.gitattributes b/lib/luajit2/.gitattributes
new file mode 100644
index 000000000..c048531e2
--- /dev/null
+++ b/lib/luajit2/.gitattributes
@@ -0,0 +1 @@
+/.relver export-subst
diff --git a/lib/luajit-3065c9/.gitignore b/lib/luajit2/.gitignore
similarity index 83%
rename from lib/luajit-3065c9/.gitignore
rename to lib/luajit2/.gitignore
index 1a07bf75b..9dd51e85f 100644
--- a/lib/luajit-3065c9/.gitignore
+++ b/lib/luajit2/.gitignore
@@ -9,3 +9,6 @@
 *.dmp
 *.swp
 .tags
+*~
+tags
+*.swo
diff --git a/lib/luajit2/.relver b/lib/luajit2/.relver
new file mode 100644
index 000000000..2707647aa
--- /dev/null
+++ b/lib/luajit2/.relver
@@ -0,0 +1 @@
+$Format:%ct$
diff --git a/lib/luajit2/.travis.yml b/lib/luajit2/.travis.yml
new file mode 100644
index 000000000..9077c9426
--- /dev/null
+++ b/lib/luajit2/.travis.yml
@@ -0,0 +1,61 @@
+sudo: required
+dist: bionic
+
+branches:
+  only:
+    - "v2.1-agentzh"
+
+os: linux
+arch:
+  - amd64
+  - arm64
+  - s390x
+
+language: c
+
+compiler:
+  - gcc
+
+addons:
+  apt:
+    packages:
+    - axel
+    - cpanminus
+    - libtest-base-perl
+    - libtext-diff-perl
+    - libtest-longstring-perl
+    - liblist-moreutils-perl
+    - libparallel-forkmanager-perl
+    - libgd-dev
+    - libmpc-dev
+    - build-essential
+    - libgtk2.0-dev
+    - valgrind
+
+env:
+  global:
+  - JOBS=3
+  - LUAJIT_PREFIX=/opt/luajit21
+  - LUAJIT_SYSM_PREFIX=/opt/luajit21-sysm
+  - LUAJIT_COMMON_XCFLAGS="-DLUA_USE_APICHECK -DLUA_USE_ASSERT -DLUAJIT_NUMMODE=2 -O1"
+  - LUAJIT_COMMON_XCFLAGS=$( [ ${TRAVIS_CPU_ARCH} == "amd64" ] && echo "$LUAJIT_COMMON_XCFLAGS -msse4.2" || echo "$LUAJIT_COMMON_XCFLAGS" )
+
+  matrix:
+  - LUAJIT_XCFLAGS="$LUAJIT_COMMON_XCFLAGS"
+  - LUAJIT_XCFLAGS="-DLUAJIT_ENABLE_LUA52COMPAT $LUAJIT_COMMON_XCFLAGS" LUA52=1
+  - LUAJIT_XCFLAGS="-DLUAJIT_USE_VALGRIND -DLUAJIT_USE_SYSMALLOC -DLUAJIT_ENABLE_LUA52COMPAT $LUAJIT_COMMON_XCFLAGS" LUA52=1 FLAGS=$( [ ${TRAVIS_CPU_ARCH} != "s390x" ] && echo '-v' )
+  - LUAJIT_XCFLAGS="-DLUAJIT_DISABLE_GC64 -DLUAJIT_ENABLE_LUA52COMPAT $LUAJIT_COMMON_XCFLAGS" LUA52=1
+
+install:
+  - git clone https://github.com/openresty/luajit2-test-suite.git ../luajit2-test-suite
+
+script:
+  - echo ${LUAJIT_COMMON_XCFLAGS}
+  - valgrind --version
+  - /usr/bin/env perl $(command -v cpanm) --sudo --notest IPC::Run3 Test::Base Test::LongString Parallel::ForkManager  > build.log 2>&1 || (cat build.log && exit 1)
+  - cd ../luajit2
+  - make -j$JOBS CCDEBUG=-g Q= PREFIX=$LUAJIT_PREFIX CC=$CC XCFLAGS="$LUAJIT_XCFLAGS" > build.log 2>&1 || (cat build.log && exit 1)
+  - sudo make install PREFIX=$LUAJIT_PREFIX > build.log 2>&1 || (cat build.log && exit 1)
+  - if [ ${TRAVIS_CPU_ARCH} == "amd64" ]; then PATH=/opt/luajit21/bin:$PATH prove -I. t; fi
+  - cd ../luajit2-test-suite
+  - ./run-tests -j 1 $FLAGS $LUAJIT_PREFIX
diff --git a/lib/luajit-3065c9/COPYRIGHT b/lib/luajit2/COPYRIGHT
similarity index 94%
rename from lib/luajit-3065c9/COPYRIGHT
rename to lib/luajit2/COPYRIGHT
index c74216c3e..f57d0d4cf 100644
--- a/lib/luajit-3065c9/COPYRIGHT
+++ b/lib/luajit2/COPYRIGHT
@@ -1,7 +1,11 @@
 ===============================================================================
 LuaJIT -- a Just-In-Time Compiler for Lua. https://luajit.org/
 
-Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+Copyright (C) 2005-2023 Mike Pall. All rights reserved.
+
+Copyright (C) 2017-2018 Yichun Zhang. All rights reserved.
+
+Copyright (C) 2017-2018 OpenResty Inc. All rights reserved.
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
diff --git a/lib/luajit-3065c9/Makefile b/lib/luajit2/Makefile
similarity index 77%
rename from lib/luajit-3065c9/Makefile
rename to lib/luajit2/Makefile
index 10c83c733..3aed365db 100644
--- a/lib/luajit-3065c9/Makefile
+++ b/lib/luajit2/Makefile
@@ -10,16 +10,21 @@
 # For MSVC, please follow the instructions given in src/msvcbuild.bat.
 # For MinGW and Cygwin, cd to src and run make with the Makefile there.
 #
-# Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+# Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 ##############################################################################
 
 MAJVER=  2
 MINVER=  1
-RELVER=  0
-PREREL=  -beta3
-VERSION= $(MAJVER).$(MINVER).$(RELVER)$(PREREL)
 ABIVER=  5.1
 
+# LuaJIT uses rolling releases. The release version is based on the time of
+# the latest git commit. The 'git' command must be available during the build.
+RELVER= $(shell cat src/luajit_relver.txt 2>/dev/null || : )
+# Note: setting it with := doesn't work, since it will change during the build.
+
+MMVERSION= $(MAJVER).$(MINVER)
+VERSION= $(MMVERSION).$(RELVER)
+
 ##############################################################################
 #
 # Change the installation path as needed. This automatically adjusts
@@ -33,9 +38,10 @@ DPREFIX= $(DESTDIR)$(PREFIX)
 INSTALL_BIN=   $(DPREFIX)/bin
 INSTALL_LIB=   $(DPREFIX)/$(MULTILIB)
 INSTALL_SHARE= $(DPREFIX)/share
-INSTALL_INC=   $(DPREFIX)/include/luajit-$(MAJVER).$(MINVER)
+INSTALL_DEFINC= $(DPREFIX)/include/luajit-$(MMVERSION)
+INSTALL_INC=   $(INSTALL_DEFINC)
 
-INSTALL_LJLIBD= $(INSTALL_SHARE)/luajit-$(VERSION)
+INSTALL_LJLIBD= $(INSTALL_SHARE)/luajit-$(MMVERSION)
 INSTALL_JITLIB= $(INSTALL_LJLIBD)/jit
 INSTALL_LMODD= $(INSTALL_SHARE)/lua
 INSTALL_LMOD= $(INSTALL_LMODD)/$(ABIVER)
@@ -49,10 +55,10 @@ INSTALL_TSYMNAME= luajit
 INSTALL_ANAME= libluajit-$(ABIVER).a
 INSTALL_SOSHORT1= libluajit-$(ABIVER).so
 INSTALL_SOSHORT2= libluajit-$(ABIVER).so.$(MAJVER)
-INSTALL_SONAME= $(INSTALL_SOSHORT2).$(MINVER).$(RELVER)
+INSTALL_SONAME= libluajit-$(ABIVER).so.$(VERSION)
 INSTALL_DYLIBSHORT1= libluajit-$(ABIVER).dylib
 INSTALL_DYLIBSHORT2= libluajit-$(ABIVER).$(MAJVER).dylib
-INSTALL_DYLIBNAME= libluajit-$(ABIVER).$(MAJVER).$(MINVER).$(RELVER).dylib
+INSTALL_DYLIBNAME= libluajit-$(ABIVER).$(VERSION).dylib
 INSTALL_PCNAME= luajit.pc
 
 INSTALL_STATIC= $(INSTALL_LIB)/$(INSTALL_ANAME)
@@ -77,7 +83,11 @@ INSTALL_F= install -m 0644
 UNINSTALL= $(RM)
 LDCONFIG= ldconfig -n 2>/dev/null
 SED_PC= sed -e "s|^prefix=.*|prefix=$(PREFIX)|" \
-            -e "s|^multilib=.*|multilib=$(MULTILIB)|"
+	    -e "s|^multilib=.*|multilib=$(MULTILIB)|" \
+	    -e "s|^relver=.*|relver=$(RELVER)|"
+ifneq ($(INSTALL_DEFINC),$(INSTALL_INC))
+  SED_PC+= -e "s|^includedir=.*|includedir=$(INSTALL_INC)|"
+endif
 
 FILE_T= luajit
 FILE_A= libluajit.a
@@ -88,7 +98,9 @@ FILES_INC= lua.h lualib.h lauxlib.h luaconf.h lua.hpp luajit.h
 FILES_JITLIB= bc.lua bcsave.lua dump.lua p.lua v.lua zone.lua \
 	      dis_x86.lua dis_x64.lua dis_arm.lua dis_arm64.lua \
 	      dis_arm64be.lua dis_ppc.lua dis_mips.lua dis_mipsel.lua \
-	      dis_mips64.lua dis_mips64el.lua vmdef.lua
+	      dis_mips64.lua dis_mips64el.lua \
+	      dis_mips64r6.lua dis_mips64r6el.lua \
+	      vmdef.lua
 
 ifeq (,$(findstring Windows,$(OS)))
   HOST_SYS:= $(shell uname -s)
@@ -109,9 +121,9 @@ endif
 INSTALL_DEP= src/luajit
 
 default all $(INSTALL_DEP):
-	@echo "==== Building LuaJIT $(VERSION) ===="
+	@echo "==== Building LuaJIT $(MMVERSION) ===="
 	$(MAKE) -C src
-	@echo "==== Successfully built LuaJIT $(VERSION) ===="
+	@echo "==== Successfully built LuaJIT $(MMVERSION) ===="
 
 install: $(INSTALL_DEP)
 	@echo "==== Installing LuaJIT $(VERSION) to $(PREFIX) ===="
@@ -130,18 +142,12 @@ install: $(INSTALL_DEP)
 	  $(RM) $(FILE_PC).tmp
 	cd src && $(INSTALL_F) $(FILES_INC) $(INSTALL_INC)
 	cd src/jit && $(INSTALL_F) $(FILES_JITLIB) $(INSTALL_JITLIB)
+	$(SYMLINK) $(INSTALL_TNAME) $(INSTALL_TSYM)
 	@echo "==== Successfully installed LuaJIT $(VERSION) to $(PREFIX) ===="
-	@echo ""
-	@echo "Note: the development releases deliberately do NOT install a symlink for luajit"
-	@echo "You can do this now by running this command (with sudo):"
-	@echo ""
-	@echo "  $(SYMLINK) $(INSTALL_TNAME) $(INSTALL_TSYM)"
-	@echo ""
-
 
 uninstall:
 	@echo "==== Uninstalling LuaJIT $(VERSION) from $(PREFIX) ===="
-	$(UNINSTALL) $(INSTALL_T) $(INSTALL_STATIC) $(INSTALL_DYN) $(INSTALL_SHORT1) $(INSTALL_SHORT2) $(INSTALL_MAN)/$(FILE_MAN) $(INSTALL_PC)
+	$(UNINSTALL) $(INSTALL_TSYM) $(INSTALL_T) $(INSTALL_STATIC) $(INSTALL_DYN) $(INSTALL_SHORT1) $(INSTALL_SHORT2) $(INSTALL_MAN)/$(FILE_MAN) $(INSTALL_PC)
 	for file in $(FILES_JITLIB); do \
 	  $(UNINSTALL) $(INSTALL_JITLIB)/$$file; \
 	  done
@@ -155,8 +161,9 @@ uninstall:
 ##############################################################################
 
 amalg:
-	@echo "Building LuaJIT $(VERSION)"
+	@echo "==== Building LuaJIT $(MMVERSION) (amalgamation) ===="
 	$(MAKE) -C src amalg
+	@echo "==== Successfully built LuaJIT $(MMVERSION) (amalgamation) ===="
 
 clean:
 	$(MAKE) -C src clean
diff --git a/lib/luajit-3065c9/README b/lib/luajit2/README
similarity index 76%
rename from lib/luajit-3065c9/README
rename to lib/luajit2/README
index 1faef2559..e4a692654 100644
--- a/lib/luajit-3065c9/README
+++ b/lib/luajit2/README
@@ -1,11 +1,11 @@
-README for LuaJIT 2.1.0-beta3
------------------------------
+README for LuaJIT 2.1
+---------------------
 
 LuaJIT is a Just-In-Time (JIT) compiler for the Lua programming language.
 
 Project Homepage: https://luajit.org/
 
-LuaJIT is Copyright (C) 2005-2022 Mike Pall.
+LuaJIT is Copyright (C) 2005-2023 Mike Pall.
 LuaJIT is free software, released under the MIT license.
 See full Copyright Notice in the COPYRIGHT file or in luajit.h.
 
diff --git a/lib/luajit2/README.md b/lib/luajit2/README.md
new file mode 100644
index 000000000..4e6463e94
--- /dev/null
+++ b/lib/luajit2/README.md
@@ -0,0 +1,415 @@
+# Name
+
+openresty/luajit2 - OpenResty's maintained branch of LuaJIT.
+
+Table of Contents
+=================
+
+* [Name](#name)
+* [Description](#description)
+* [OpenResty extensions](#openresty-extensions)
+    * [New Lua APIs](#new-lua-apis)
+        * [table.isempty](#tableisempty)
+        * [table.isarray](#tableisarray)
+        * [table.nkeys](#tablenkeys)
+        * [table.clone](#tableclone)
+        * [jit.prngstate](#jitprngstate)
+        * [thread.exdata](#threadexdata)
+        * [thread.exdata2](#threadexdata2)
+    * [New C API](#new-c-api)
+        * [lua_setexdata](#lua_setexdata)
+        * [lua_getexdata](#lua_getexdata)
+        * [lua_setexdata2](#lua_setexdata2)
+        * [lua_getexdata2](#lua_getexdata2)
+        * [lua_resetthread](#lua_resetthread)
+    * [New macros](#new-macros)
+        * [`OPENRESTY_LUAJIT`](#openresty_luajit)
+        * [`HAVE_LUA_RESETTHREAD`](#have_lua_resetthread)
+    * [Optimizations](#optimizations)
+        * [Updated JIT default parameters](#updated-jit-default-parameters)
+        * [String hashing](#string-hashing)
+    * [Updated bytecode options](#updated-bytecode-options)
+        * [New `-bL` option](#new--bl-option)
+        * [Updated `-bl` option](#updated--bl-option)
+    * [Miscellaneous](#miscellaneous)
+* [Copyright & License](#copyright--license)
+
+# Description
+
+This is the official OpenResty branch of LuaJIT. It is not to be considered a
+fork, since we still regularly synchronize changes from the upstream LuaJIT
+project (https://github.com/LuaJIT/LuaJIT).
+
+# OpenResty extensions
+
+Additionally to synchronizing upstream changes, we introduce our own changes
+which haven't been merged yet (or never will be). This document describes those
+changes that are specific to this branch.
+
+## New Lua APIs
+
+### table.isempty
+
+**syntax:** *res = isempty(tab)*
+
+Returns `true` when the given Lua table contains neither non-nil array elements
+nor non-nil key-value pairs, or `false` otherwise.
+
+This API can be JIT compiled.
+
+Usage:
+
+```lua
+local isempty = require "table.isempty"
+
+print(isempty({}))  -- true
+print(isempty({nil, dog = nil}))  -- true
+print(isempty({"a", "b"}))  -- false
+print(isempty({nil, 3}))  -- false
+print(isempty({cat = 3}))  -- false
+```
+
+[Back to TOC](#table-of-contents)
+
+### table.isarray
+
+**syntax:** *res = isarray(tab)*
+
+Returns `true` when the given Lua table is a pure array-like Lua table, or
+`false` otherwise.
+
+Empty Lua tables are treated as arrays.
+
+This API can be JIT compiled.
+
+Usage:
+
+```lua
+local isarray = require "table.isarray"
+
+print(isarray{"a", true, 3.14})  -- true
+print(isarray{dog = 3})  -- false
+print(isarray{})  -- true
+```
+
+[Back to TOC](#table-of-contents)
+
+### table.nkeys
+
+**syntax:** *n = nkeys(tab)*
+
+Returns the total number of elements in a given Lua table (i.e. from both the
+array and hash parts combined).
+
+This API can be JIT compiled.
+
+Usage:
+
+```lua
+local nkeys = require "table.nkeys"
+
+print(nkeys({}))  -- 0
+print(nkeys({ "a", nil, "b" }))  -- 2
+print(nkeys({ dog = 3, cat = 4, bird = nil }))  -- 2
+print(nkeys({ "a", dog = 3, cat = 4 }))  -- 3
+```
+
+[Back to TOC](#table-of-contents)
+
+### table.clone
+
+**syntax:** *t = clone(tab)*
+
+Returns a shallow copy of the given Lua table.
+
+This API can be JIT compiled.
+
+Usage:
+
+```lua
+local clone = require "table.clone"
+
+local x = {x=12, y={5, 6, 7}}
+local y = clone(x)
+... use y ...
+```
+
+**Note:** We observe 7% over-all speedup in the edgelang-fan compiler's
+compiling speed whose Lua is generated by the fanlang compiler.
+
+**Note bis:** Deep cloning is planned to be supported by adding `true` as a
+second argument.
+
+[Back to TOC](#table-of-contents)
+
+### jit.prngstate
+
+**syntax:** *state = jit.prngstate(state?)*
+
+Returns (and optionally sets) the current PRNG state (an array of 8 Lua
+numbers with 32-bit integer values) currently used by the JIT compiler.
+
+When the `state` argument is non-nil, it is expected to be an array of up to 8
+unsigned Lua numbers, each with value less than 2\*\*32-1. This will set the
+current PRNG state and return the state that was overridden.
+
+**Note:** For backward compatibility, `state` argument can also be an unsigned
+Lua number less than 2\*\*32-1.
+
+**Note:** When the `state` argument is an array and less than 8 numbers, or the
+`state` is a number, the remaining positions are filled with zeros.
+
+Usage:
+
+```lua
+local state = jit.prngstate()
+local oldstate = jit.prngstate{ a, b, c, ... }
+
+jit.prngstate(32) -- {32, 0, 0, 0, 0, 0, 0, 0}
+jit.prngstate{432, 23, 50} -- {432, 23, 50, 0, 0, 0, 0, 0}
+```
+
+**Note:** This API has no effect if LuaJIT is compiled with
+`-DLUAJIT_DISABLE_JIT`, and will return a table with all `0`.
+
+[Back to TOC](#table-of-contents)
+
+### thread.exdata
+
+**syntax:** *exdata = th_exdata(data?)*
+
+This API allows for embedding user data into a thread (`lua_State`).
+
+The retrieved `exdata` value on the Lua land is represented as a cdata object
+of the ctype `void*`.
+
+As of this version, retrieving the `exdata` (i.e. `th_exdata()` without any
+argument) can be JIT compiled.
+
+Usage:
+
+```lua
+local th_exdata = require "thread.exdata"
+
+th_exdata(0xdeadbeefLL)  -- set the exdata of the current Lua thread
+local exdata = th_exdata()  -- fetch the exdata of the current Lua thread
+```
+
+Also available are the following public C API functions for manipulating
+`exdata` on the C land:
+
+```C
+void lua_setexdata(lua_State *L, void *exdata);
+void *lua_getexdata(lua_State *L);
+```
+
+The `exdata` pointer is initialized to `NULL` when the main thread is created.
+Any child Lua thread will inherit its parent's `exdata`, but still can override
+it.
+
+**Note:** This API will not be available if LuaJIT is compiled with
+`-DLUAJIT_DISABLE_FFI`.
+
+**Note bis:** This API is used internally by the OpenResty core, and it is
+strongly discouraged to use it yourself in the context of OpenResty.
+
+[Back to TOC](#table-of-contents)
+
+### thread.exdata2
+
+**syntax:** *exdata = th_exdata2(data?)*
+
+Similar to `thread.exdata` but for a 2nd separate user data as a pointer value.
+
+[Back to TOC](#table-of-contents)
+
+## New C API
+
+### lua_setexdata
+
+```C
+void lua_setexdata(lua_State *L, void *exdata);
+```
+
+Sets extra user data as a pointer value to the current Lua state or thread.
+
+[Back to TOC](#table-of-contents)
+
+### lua_getexdata
+
+```C
+void *lua_getexdata(lua_State *L);
+```
+
+Gets extra user data as a pointer value to the current Lua state or thread.
+
+[Back to TOC](#table-of-contents)
+
+### lua_setexdata2
+
+```C
+void lua_setexdata2(lua_State *L, void *exdata2);
+```
+
+Similar to `lua_setexdata` but for a 2nd user data (pointer) value.
+
+[Back to TOC](#table-of-contents)
+
+### lua_getexdata2
+
+```C
+void *lua_getexdata2(lua_State *L);
+```
+
+Similar to `lua_getexdata` but for a 2nd user data (pointer) value.
+
+[Back to TOC](#table-of-contents)
+
+### lua_resetthread
+
+```C
+void lua_resetthread(lua_State *L, lua_State *th);
+```
+
+Resets the state of `th` to the initial state of a newly created Lua thread
+object as returned by `lua_newthread()`. This is mainly for Lua thread
+recycling. Lua threads in arbitrary states (like yielded or errored) can be
+reset properly.
+
+The current implementation does not shrink the already allocated Lua stack
+though. It only clears it.
+
+[Back to TOC](#table-of-contents)
+
+## New macros
+
+The macros described in this section have been added to this branch.
+
+[Back to TOC](#table-of-contents)
+
+### `OPENRESTY_LUAJIT`
+
+In the `luajit.h` header file, a new macro `OPENRESTY_LUAJIT` was defined to
+help distinguishing this OpenResty-specific branch of LuaJIT.
+
+### `HAVE_LUA_RESETTHREAD`
+
+This macro is set when the `lua_resetthread` C API is present.
+
+[Back to TOC](#table-of-contents)
+
+## Optimizations
+
+### Updated JIT default parameters
+
+We use more appressive default JIT compiler options to help large OpenResty
+Lua applications.
+
+The following `jit.opt` options are used by default:
+
+```lua
+maxtrace=8000
+maxrecord=16000
+minstitch=3
+maxmcode=40960  -- in KB
+```
+
+[Back to TOC](#table-of-contents)
+
+### String hashing
+
+This optimization only applies to Intel CPUs supporting the SSE 4.2 instruction
+sets. For such CPUs, and when this branch is compiled with `-msse4.2`, the
+string hashing function used for strings interning will be based on an
+optimized crc32 implementation (see `lj_str_new()`).
+
+This optimization still provides constant-time hashing complexity (`O(n)`), but
+makes hash collision attacks harder for strings up to 127 bytes of size.
+
+[Back to TOC](#table-of-contents)
+
+## Updated bytecode options
+
+### New `-bL` option
+
+The bytecode option `L` was added to display Lua sources line numbers.
+
+For example, `luajit -bL -e 'print(1)'` now produces bytecode dumps like below:
+
+```
+-- BYTECODE -- "print(1)":0-1
+0001     [1]    GGET     0   0      ; "print"
+0002     [1]    KSHORT   1   1
+0003     [1]    CALL     0   1   2
+0004     [1]    RET0     0   1
+```
+
+The `[N]` column corresponds to the Lua source line number. For example, `[1]`
+means "the first source line".
+
+[Back to TOC](#table-of-contents)
+
+### Updated `-bl` option
+
+The bytecode option `l` was updated to display the constant tables of each Lua
+prototype.
+
+For example, `luajit -bl a.lua'` now produces bytecode dumps like below:
+
+```
+-- BYTECODE -- a.lua:0-48
+KGC    0    "print"
+KGC    1    "hi"
+KGC    2    table
+KGC    3    a.lua:17
+KN    1    1000000
+KN    2    1.390671161567e-309
+...
+```
+
+[Back to TOC](#table-of-contents)
+
+## Miscellaneous
+
+* Increased the maximum number of allowed upvalues from 60 to 120.
+* Various important bugfixes in the JIT compiler and Lua VM which have
+  not been merged in upstream LuaJIT.
+* Removed the GCC 4 requirement for x86 on older systems such as Solaris i386.
+* In the `Makefile` file, make sure we always install the symlink for "luajit"
+  even for alpha or beta versions.
+* Applied a patch to fix DragonFlyBSD compatibility. Note: this is not an
+  officially supported target.
+* feature: jit.dump: output Lua source location after every BC.
+* feature: added internal memory-buffer-based trace entry/exit/start-recording
+  event logging, mainly for debugging bugs in the JIT compiler. it requires
+  `-DLUA_USE_TRACE_LOGS` when building LuaJIT.
+* feature: save `g->jit_base` to `g->saved_jit_base` before `lj_err_throw`
+  clears `g->jit_base` which makes it impossible to get Lua backtrace in such
+  states.
+
+[Back to TOC](#table-of-contents)
+
+# Copyright & License
+
+LuaJIT is a Just-In-Time (JIT) compiler for the Lua programming language.
+
+Project Homepage: http://luajit.org/
+
+LuaJIT is Copyright (C) 2005-2019 Mike Pall.
+
+Additional patches for OpenResty are copyrighted by Yichun Zhang and OpenResty
+Inc.:
+
+Copyright (C) 2017-2019 Yichun Zhang. All rights reserved.
+
+Copyright (C) 2017-2019 OpenResty Inc. All rights reserved.
+
+LuaJIT is free software, released under the MIT license.
+See full Copyright Notice in the COPYRIGHT file or in luajit.h.
+
+Documentation for the official LuaJIT is available in HTML format.
+Please point your favorite browser to:
+
+    doc/luajit.html
+
+[Back to TOC](#table-of-contents)
diff --git a/lib/luajit2/configure b/lib/luajit2/configure
new file mode 100755
index 000000000..e4ec1a54e
--- /dev/null
+++ b/lib/luajit2/configure
@@ -0,0 +1 @@
+exit 0;
diff --git a/lib/luajit-3065c9/doc/bluequad-print.css b/lib/luajit2/doc/bluequad-print.css
similarity index 98%
rename from lib/luajit-3065c9/doc/bluequad-print.css
rename to lib/luajit2/doc/bluequad-print.css
index a49d309ff..4a1392789 100644
--- a/lib/luajit-3065c9/doc/bluequad-print.css
+++ b/lib/luajit2/doc/bluequad-print.css
@@ -1,4 +1,4 @@
-/* Copyright (C) 2004-2022 Mike Pall.
+/* Copyright (C) 2004-2023 Mike Pall.
  *
  * You are welcome to use the general ideas of this design for your own sites.
  * But please do not steal the stylesheet, the layout or the color scheme.
diff --git a/lib/luajit-3065c9/doc/bluequad.css b/lib/luajit2/doc/bluequad.css
similarity index 97%
rename from lib/luajit-3065c9/doc/bluequad.css
rename to lib/luajit2/doc/bluequad.css
index 4c1a9082e..7399f6251 100644
--- a/lib/luajit-3065c9/doc/bluequad.css
+++ b/lib/luajit2/doc/bluequad.css
@@ -1,4 +1,4 @@
-/* Copyright (C) 2004-2022 Mike Pall.
+/* Copyright (C) 2004-2023 Mike Pall.
  *
  * You are welcome to use the general ideas of this design for your own sites.
  * But please do not steal the stylesheet, the layout or the color scheme.
@@ -206,11 +206,9 @@ img.right {
 .ext {
   color: #ff8000;
 }
-.new {
-  font-size: 6pt;
-  vertical-align: middle;
-  background: #ff8000;
-  color: #ffffff;
+.note {
+  padding: 0.5em 1em;
+  border-left: 3px solid #bfcfff;
 }
 #site {
   clear: both;
diff --git a/lib/luajit-3065c9/doc/contact.html b/lib/luajit2/doc/contact.html
similarity index 80%
rename from lib/luajit-3065c9/doc/contact.html
rename to lib/luajit2/doc/contact.html
index 89c1af958..cc4d8c723 100644
--- a/lib/luajit-3065c9/doc/contact.html
+++ b/lib/luajit2/doc/contact.html
@@ -3,7 +3,7 @@
 <head>
 <title>Contact</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -46,11 +46,9 @@
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -86,10 +84,17 @@ xD("fyZKB8xv\"FJytmz8.KAB0u52D")
 </p>
 </noscript>
 
+<p><i>
+Note: I cannot reply to GMail, Google Workplace, Outlook or Office365
+mail addresses, since they prefer to mindlessly filter out mails sent
+from small domains using independent mail servers, such as mine. If you
+don't like that, please complain to Google or Microsoft, not me.
+</i></p>
+
 <h2>Copyright</h2>
 <p>
 All documentation is
-Copyright &copy; 2005-2022 Mike Pall.
+Copyright &copy; 2005-2023 Mike Pall.
 </p>
 
 
@@ -97,7 +102,7 @@ Copyright &copy; 2005-2022 Mike Pall.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_buffer.html b/lib/luajit2/doc/ext_buffer.html
similarity index 98%
rename from lib/luajit-3065c9/doc/ext_buffer.html
rename to lib/luajit2/doc/ext_buffer.html
index 192110a7e..bfaa24cbd 100644
--- a/lib/luajit-3065c9/doc/ext_buffer.html
+++ b/lib/luajit2/doc/ext_buffer.html
@@ -3,7 +3,7 @@
 <head>
 <title>String Buffer Library</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -57,11 +57,9 @@
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -90,12 +88,6 @@ The string buffer library also includes a high-performance
 <a href="serialize">serializer</a> for Lua objects.
 </p>
 
-<h2 id="wip" style="color:#ff0000">Work in Progress</h2>
-<p>
-<b style="color:#ff0000">This library is a work in progress. More
-functionality will be added soon.</b>
-</p>
-
 <h2 id="use">Using the String Buffer Library</h2>
 <p>
 The string buffer library is built into LuaJIT by default, but it's not
@@ -687,7 +679,7 @@ mappings of files are OK, but only if the file does not change.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_c_api.html b/lib/luajit2/doc/ext_c_api.html
similarity index 95%
rename from lib/luajit-3065c9/doc/ext_c_api.html
rename to lib/luajit2/doc/ext_c_api.html
index 21dc13101..d5e6bb60f 100644
--- a/lib/luajit-3065c9/doc/ext_c_api.html
+++ b/lib/luajit2/doc/ext_c_api.html
@@ -3,7 +3,7 @@
 <head>
 <title>Lua/C API Extensions</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -46,11 +46,9 @@
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -175,7 +173,7 @@ Also note that this mechanism is not without overhead.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_ffi.html b/lib/luajit2/doc/ext_ffi.html
similarity index 97%
rename from lib/luajit-3065c9/doc/ext_ffi.html
rename to lib/luajit2/doc/ext_ffi.html
index b39ae314d..eaa176b61 100644
--- a/lib/luajit-3065c9/doc/ext_ffi.html
+++ b/lib/luajit2/doc/ext_ffi.html
@@ -3,7 +3,7 @@
 <head>
 <title>FFI Library</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -46,11 +46,9 @@
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -318,7 +316,7 @@ without undue conversion penalties.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_ffi_api.html b/lib/luajit2/doc/ext_ffi_api.html
similarity index 98%
rename from lib/luajit-3065c9/doc/ext_ffi_api.html
rename to lib/luajit2/doc/ext_ffi_api.html
index b8da1c957..500a2143e 100644
--- a/lib/luajit-3065c9/doc/ext_ffi_api.html
+++ b/lib/luajit2/doc/ext_ffi_api.html
@@ -3,7 +3,7 @@
 <head>
 <title>ffi.* API Functions</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -51,11 +51,9 @@ td.abiparam { font-weight: bold; width: 6em; }
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -465,8 +463,10 @@ otherwise. The following parameters are currently defined:
 <tr class="odd">
 <td class="abiparam">win</td><td class="abidesc">Windows variant of the standard ABI</td></tr>
 <tr class="even">
-<td class="abiparam">uwp</td><td class="abidesc">Universal Windows Platform</td></tr>
+<td class="abiparam">pauth</td><td class="abidesc">Pointer authentication ABI</td></tr>
 <tr class="odd">
+<td class="abiparam">uwp</td><td class="abidesc">Universal Windows Platform</td></tr>
+<tr class="even">
 <td class="abiparam">gc64</td><td class="abidesc">64 bit GC references</td></tr>
 </table>
 
@@ -558,7 +558,7 @@ named <tt>i</tt>.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_ffi_semantics.html b/lib/luajit2/doc/ext_ffi_semantics.html
similarity index 99%
rename from lib/luajit-3065c9/doc/ext_ffi_semantics.html
rename to lib/luajit2/doc/ext_ffi_semantics.html
index 22f7f17c6..5ba82a1e7 100644
--- a/lib/luajit-3065c9/doc/ext_ffi_semantics.html
+++ b/lib/luajit2/doc/ext_ffi_semantics.html
@@ -3,7 +3,7 @@
 <head>
 <title>FFI Semantics</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -51,11 +51,9 @@ td.convop { font-style: italic; width: 40%; }
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -1248,7 +1246,7 @@ compiled.</li>
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_ffi_tutorial.html b/lib/luajit2/doc/ext_ffi_tutorial.html
similarity index 98%
rename from lib/luajit-3065c9/doc/ext_ffi_tutorial.html
rename to lib/luajit2/doc/ext_ffi_tutorial.html
index e0bf90405..a5236f0bd 100644
--- a/lib/luajit-3065c9/doc/ext_ffi_tutorial.html
+++ b/lib/luajit2/doc/ext_ffi_tutorial.html
@@ -3,7 +3,7 @@
 <head>
 <title>FFI Tutorial</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -53,11 +53,9 @@ td.idiomlua b { font-weight: normal; color: #2142bf; }
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -589,7 +587,7 @@ it to a local variable in the function scope is unnecessary.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_jit.html b/lib/luajit2/doc/ext_jit.html
similarity index 92%
rename from lib/luajit-3065c9/doc/ext_jit.html
rename to lib/luajit2/doc/ext_jit.html
index b8a25967e..dd136d65e 100644
--- a/lib/luajit-3065c9/doc/ext_jit.html
+++ b/lib/luajit2/doc/ext_jit.html
@@ -3,7 +3,7 @@
 <head>
 <title>jit.* Library</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -46,11 +46,9 @@
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -137,7 +135,9 @@ Contains the LuaJIT version string.
 <h3 id="jit_version_num"><tt>jit.version_num</tt></h3>
 <p>
 Contains the version number of the LuaJIT core. Version xx.yy.zz
-is represented by the decimal number xxyyzz.
+is represented by the decimal number xxyyzz.<br>
+<b>DEPRECATED after the switch to
+<a href="https://luajit.org/status.html#release"><span class="ext">&raquo;</span>&nbsp;rolling releases</a>. zz is frozen at 99.</b>
 </p>
 
 <h3 id="jit_os"><tt>jit.os</tt></h3>
@@ -187,7 +187,7 @@ if you want to know more.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/ext_profiler.html b/lib/luajit2/doc/ext_profiler.html
similarity index 98%
rename from lib/luajit-3065c9/doc/ext_profiler.html
rename to lib/luajit2/doc/ext_profiler.html
index b645a2044..81b5d7739 100644
--- a/lib/luajit-3065c9/doc/ext_profiler.html
+++ b/lib/luajit2/doc/ext_profiler.html
@@ -3,7 +3,7 @@
 <head>
 <title>Profiler</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -46,11 +46,9 @@
 <a class="current" href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -351,7 +349,7 @@ use.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/extensions.html b/lib/luajit2/doc/extensions.html
similarity index 87%
rename from lib/luajit-3065c9/doc/extensions.html
rename to lib/luajit2/doc/extensions.html
index 040fc5885..c1c9a808c 100644
--- a/lib/luajit-3065c9/doc/extensions.html
+++ b/lib/luajit2/doc/extensions.html
@@ -3,7 +3,7 @@
 <head>
 <title>Extensions</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -63,16 +63,15 @@ td.excinterop {
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
 </div>
 <div id="main">
+
 <p>
 LuaJIT is fully upwards-compatible with Lua 5.1. It supports all
 <a href="https://www.lua.org/manual/5.1/manual.html#5"><span class="ext">&raquo;</span>&nbsp;standard Lua
@@ -161,13 +160,33 @@ passes any arguments after the error function to the function
 which is called in a protected context.
 </p>
 
-<h3 id="load"><tt>loadfile()</tt> etc. handle UTF-8 source code</h3>
+<h3 id="load"><tt>load*()</tt> handle UTF-8 source code</h3>
 <p>
 Non-ASCII characters are handled transparently by the Lua source code parser.
 This allows the use of UTF-8 characters in identifiers and strings.
 A UTF-8 BOM is skipped at the start of the source code.
 </p>
 
+<h3 id="load_mode"><tt>load*()</tt> add a mode parameter</h3>
+<p>
+As an extension from Lua 5.2, the functions <tt>loadstring()</tt>,
+<tt>loadfile()</tt> and (new) <tt>load()</tt> add an optional
+<tt>mode</tt> parameter.
+</p>
+<p>
+The default mode string is <tt>"bt"</tt>, which allows loading of both
+source code and bytecode. Use <tt>"t"</tt> to allow only source code
+or <tt>"b"</tt> to allow only bytecode to be loaded.
+</p>
+<p>
+By default, the <tt>load*</tt> functions generate the native bytecode format.
+For cross-compilation purposes, add <tt>W</tt> to the mode string to
+force the 32 bit format and <tt>X</tt> to force the 64 bit format.
+Add both to force the opposite format. Note that non-native bytecode
+generated by <tt>load*</tt> cannot be run, but can still be passed
+to <tt>string.dump</tt>.
+</p>
+
 <h3 id="tostring"><tt>tostring()</tt> etc. canonicalize NaN and &plusmn;Inf</h3>
 <p>
 All number-to-string conversions consistently convert non-finite numbers
@@ -187,26 +206,33 @@ works independently of the current locale and it supports hex floating-point
 numbers (e.g. <tt>0x1.5p-3</tt>).
 </p>
 
-<h3 id="string_dump"><tt>string.dump(f [,strip])</tt> generates portable bytecode</h3>
+<h3 id="string_dump"><tt>string.dump(f [,mode])</tt> generates portable bytecode</h3>
 <p>
 An extra argument has been added to <tt>string.dump()</tt>. If set to
-<tt>true</tt>, 'stripped' bytecode without debug information is
-generated. This speeds up later bytecode loading and reduces memory
-usage. See also the
+<tt>true</tt> or to a string which contains the character <tt>s</tt>,
+'stripped' bytecode without debug information is generated. This speeds
+up later bytecode loading and reduces memory usage. See also the
 <a href="running.html#opt_b"><tt>-b</tt> command line option</a>.
 </p>
 <p>
 The generated bytecode is portable and can be loaded on any architecture
-that LuaJIT supports, independent of word size or endianess. However, the
-bytecode compatibility versions must match. Bytecode stays compatible
-for dot releases (x.y.0 &rarr; x.y.1), but may change with major or
-minor releases (2.0 &rarr; 2.1) or between any beta release. Foreign
-bytecode (e.g. from Lua 5.1) is incompatible and cannot be loaded.
+that LuaJIT supports. However, the bytecode compatibility versions must
+match. Bytecode only stays compatible within a major+minor version
+(x.y.aaa &rarr; x.y.bbb), except for development branches. Foreign bytecode
+(e.g. from Lua 5.1) is incompatible and cannot be loaded.
 </p>
 <p>
 Note: <tt>LJ_GC64</tt> mode requires a different frame layout, which implies
-a different, incompatible bytecode format for all 64 bit ports. This may be
-rectified in the future.
+a different, incompatible bytecode format between 32 bit and 64 bit ports.
+This may be rectified in the future. In the meantime, use the <tt>W</tt>
+and </tt>X</tt> <a href="#load_mode">modes of the <tt>load*</tt> functions</a>
+for cross-compilation purposes.
+</p>
+<p>
+Due to VM hardening, bytecode is not deterministic. Add <tt>d</tt> to the
+mode string to dump it in a deterministic manner: identical source code
+always gives a byte-for-byte identical bytecode dump. This feature is
+mainly useful for reproducible builds.
 </p>
 
 <h3 id="table_new"><tt>table.new(narray, nhash)</tt> allocates a pre-sized table</h3>
@@ -287,7 +313,7 @@ enabled:
 </p>
 <ul>
 <li><tt>goto</tt> and <tt>::labels::</tt>.</li>
-<li>Hex escapes <tt>'\x3F'</tt> and <tt>'\*'</tt> escape in strings.</li>
+<li>Hex escapes <tt>'\x3F'</tt> and <tt>'\z'</tt> escape in strings.</li>
 <li><tt>load(string|reader [, chunkname [,mode [,env]]])</tt>.</li>
 <li><tt>loadstring()</tt> is an alias for <tt>load()</tt>.</li>
 <li><tt>loadfile(filename [,mode [,env]])</tt>.</li>
@@ -427,9 +453,7 @@ the toolchain used to compile LuaJIT:
 on the C&nbsp;stack. The contents of the C++&nbsp;exception object
 pass through unmodified.</li>
 <li>Lua errors can be caught on the C++ side with <tt>catch(...)</tt>.
-The corresponding Lua error message can be retrieved from the Lua stack.<br>
-For MSVC for Windows 64 bit this requires compilation of your C++ code
-with <tt>/EHa</tt>.</li>
+The corresponding Lua error message can be retrieved from the Lua stack.</li>
 <li>Throwing Lua errors across C++ frames is safe. C++ destructors
 will be called.</li>
 </ul>
@@ -464,7 +488,7 @@ C++ destructors.</li>
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/img/contact.png b/lib/luajit2/doc/img/contact.png
similarity index 100%
rename from lib/luajit-3065c9/doc/img/contact.png
rename to lib/luajit2/doc/img/contact.png
diff --git a/lib/luajit-3065c9/doc/install.html b/lib/luajit2/doc/install.html
similarity index 72%
rename from lib/luajit-3065c9/doc/install.html
rename to lib/luajit2/doc/install.html
index 9fad31f43..b64814431 100644
--- a/lib/luajit-3065c9/doc/install.html
+++ b/lib/luajit2/doc/install.html
@@ -3,7 +3,7 @@
 <head>
 <title>Installation</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -20,7 +20,7 @@ table.compat tr.compathead td {
   font-weight: bold;
   border-bottom: 2px solid #bfcfff;
 }
-td.compatname, td.compatver {
+td.compatname {
   width: 10%;
 }
 td.compatbits {
@@ -69,20 +69,18 @@ td.compatx {
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
 </div>
 <div id="main">
 <p>
-LuaJIT is only distributed as a source package. This page explains
-how to build and install LuaJIT with different operating systems
-and C&nbsp;compilers.
+LuaJIT is only distributed as source code &mdash; get it from the
+<a href="https://luajit.org/download.html"><span class="ext">&raquo;</span>&nbsp;git repository</a>. This page explains how to build
+and install the LuaJIT binary and library for different operating systems.
 </p>
 <p>
 For the impatient (on POSIX systems):
@@ -92,201 +90,21 @@ make &amp;&amp; sudo make install
 </pre>
 
 <h2 id="req">Requirements</h2>
-<h3 id="systems">Systems</h3>
 <p>
-LuaJIT currently builds out-of-the box on most systems:
+LuaJIT currently builds out-of-the box on most systems. Please check the
+supported operating systems and CPU architectures on the
+<a href="https://luajit.org/status.html"><span class="ext">&raquo;</span>&nbsp;status page</a>.
 </p>
-<table class="compat">
-<tr class="compathead">
-<td class="compatname">OS</td>
-<td class="compatver">Min. Version</td>
-<td class="compatx">Requirements</td>
-<td class="compatx">LuaJIT Versions</td>
-</tr>
-<tr class="odd separate">
-<td class="compatname"><a href="#windows">Windows</a></td>
-<td class="compatver">7</td>
-<td class="compatx">x86 or x64, ARM64: TBA</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname"><a href="#posix">Linux</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname"><a href="#posix">*BSD</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname"><a href="#posix">macOS (OSX)</a></td>
-<td class="compatver">10.4</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname"><a href="#posix">POSIX</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">mmap, dlopen</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even separate">
-<td class="compatname"><a href="#android">Android</a></td>
-<td class="compatver">4.0</td>
-<td class="compatx">Recent Android NDK</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname"><a href="#ios">iOS</a></td>
-<td class="compatver">3.0</td>
-<td class="compatx">Xcode iOS SDK</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-<tr class="even separate">
-<td class="compatname"><a href="#consoles">PS3</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">PS3 SDK</td>
-<td class="compatx">v2.0 &ndash; v2.1 EOL</td>
-</tr>
-<tr class="odd">
-<td class="compatname"><a href="#consoles">PS4</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">PS4 SDK (ORBIS)</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname"><a href="#consoles">PS5</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">PS5 SDK (PROSPERO)</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname"><a href="#consoles">PS Vita</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">PS Vita SDK (PSP2)</td>
-<td class="compatx">v2.0 &ndash; v2.1 EOL</td>
-</tr>
-<tr class="even">
-<td class="compatname"><a href="#consoles">Xbox 360</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">Xbox 360 SDK (XEDK)</td>
-<td class="compatx">v2.0 &ndash; v2.1 EOL</td>
-</tr>
-<tr class="odd">
-<td class="compatname"><a href="#consoles">Xbox One</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">Xbox One SDK (DURANGO)</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname"><a href="#consoles">Nintendo Switch</a></td>
-<td class="compatver">&nbsp;</td>
-<td class="compatx">NintendoSDK + NX Addon</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-</table>
-<p>
-The codebase has compatibility defines for some more systems, but
-without official support.
-</p>
-<h3 id="toolchains">Toolchains</h3>
 <p>
 Building LuaJIT requires a recent toolchain based on GCC, Clang/LLVM or
 MSVC++.
 </p>
 <p>
 The Makefile-based build system requires GNU Make and supports
-cross-builds. Batch files are provided for MSVC++ builds and console
 cross-builds.
 </p>
-<h3 id="architectures">CPU Architectures</h3>
-<table class="compat">
-<tr class="compathead">
-<td class="compatname">CPU</td>
-<td class="compatbits">Bits</td>
-<td class="compatx">Requirements</td>
-<td class="compatx">Variants</td>
-<td class="compatx">LuaJIT Versions</td>
-</tr>
-<tr class="odd separate">
-<td class="compatname">x86</td>
-<td class="compatbits">32</td>
-<td class="compatx">v2.1+: SSE2</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname">x64</td>
-<td class="compatbits">64</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname">ARM</td>
-<td class="compatbits">32</td>
-<td class="compatx">ARMv5+, ARM9E+</td>
-<td class="compatx">hard-fp + soft-fp</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname">ARM64</td>
-<td class="compatbits">64</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">ARM64le + ARM64be</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname">PPC32</td>
-<td class="compatbits">32</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">hard-fp + soft-fp</td>
-<td class="compatx">v2.0 &ndash; v2.1 EOL</td>
-</tr>
-<tr class="even">
-<td class="compatname">PPC/e500</td>
-<td class="compatbits">32</td>
-<td class="compatx">e500v2</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">v2.0 EOL</td>
-</tr>
-<tr class="odd">
-<td class="compatname">MIPS32</td>
-<td class="compatbits">32</td>
-<td class="compatx">MIPS32r1 &ndash; r5</td>
-<td class="compatx">hard-fp + soft-fp</td>
-<td class="compatx">v2.0 &ndash;</td>
-</tr>
-<tr class="even">
-<td class="compatname">MIPS64</td>
-<td class="compatbits">64</td>
-<td class="compatx">MIPS64r1 &ndash; r5</td>
-<td class="compatx">hard-fp + soft-fp</td>
-<td class="compatx">v2.1 &ndash;</td>
-</tr>
-<tr class="odd">
-<td class="compatname">MIPS64</td>
-<td class="compatbits">64</td>
-<td class="compatx">MIPS64r6</td>
-<td class="compatx">hard-fp + soft-fp</td>
-<td class="compatx">v2.1 EOL</td>
-</tr>
-<tr class="even">
-<td class="compatname">RISC-V</td>
-<td class="compatbits">64</td>
-<td class="compatx">RVA22+</td>
-<td class="compatx">&nbsp;</td>
-<td class="compatx">TBA</td>
-</tr>
-</table>
 <p>
-There are no plans to add historic architectures or to continue support
-for end-of-life (EOL) architectures, for which no new CPUs are commonly
-available anymore. Likewise, there are no plans to support marginal
-and/or de-facto-dead architectures.
+Batch files are provided for MSVC++ builds and console cross-builds.
 </p>
 
 <h2>Configuring LuaJIT</h2>
@@ -296,7 +114,6 @@ Usually there is no need to tweak the settings. The following files
 hold all user-configurable settings:
 </p>
 <ul>
-<li><tt>src/luaconf.h</tt> sets some configuration variables.</li>
 <li><tt>Makefile</tt> has settings for <b>installing</b> LuaJIT (POSIX
 only).</li>
 <li><tt>src/Makefile</tt> has settings for <b>compiling</b> LuaJIT
@@ -319,23 +136,11 @@ Please check the note about the
 <h2 id="posix">POSIX Systems (Linux, macOS, *BSD etc.)</h2>
 <h3>Prerequisites</h3>
 <p>
-Depending on your distribution, you may need to install a package for
-GCC, the development headers and/or a complete SDK. E.g. on a current
-Debian/Ubuntu, install <tt>libc6-dev</tt> with the package manager.
+Depending on your distribution, you may need to install a package for a
+compiler (GCC or Clang/LLVM), the development headers and/or a complete SDK.
+E.g. on a current Debian/Ubuntu, install <tt>build-essential</tt> with the
+package manager.
 </p>
-<p>
-The recommended way to fetch the latest version is to do a pull from
-the git repository.
-</p>
-<p>
-Alternatively, download the latest source package of LuaJIT (pick the .tar.gz).
-Move it to a directory of your choice, open a terminal window and change
-to this directory. Now unpack the archive and change to the newly created
-directory (replace XX.YY.ZZ with the version you downloaded):
-</p>
-<pre class="code">
-tar zxf LuaJIT-XX.YY.ZZ.tar.gz
-cd LuaJIT-XX.YY.ZZ
 </pre>
 <h3>Building LuaJIT</h3>
 <p>
@@ -396,15 +201,10 @@ Either install one of the open source SDKs
 GCC plus the required development headers.
 Or install Microsoft's Visual Studio (MSVC).
 </p>
-<p>
-Next, pull from the git repository or download the source package and
-unpack it using an archive manager (e.g. the Windows Explorer) to
-a directory of your choice.
-</p>
 <h3>Building with MSVC</h3>
 <p>
-Open a "Visual Studio Command Prompt" (either x86 or x64), <tt>cd</tt> to the
-directory where you've unpacked the sources and run these commands:
+Open a "Visual Studio Command Prompt" (x86, x64 or ARM64), <tt>cd</tt> to the
+directory with the source code and run these commands:
 </p>
 <pre class="code">
 cd src
@@ -414,11 +214,14 @@ msvcbuild
 Check the <tt>msvcbuild.bat</tt> file for more options.
 Then follow the installation instructions below.
 </p>
+<p>
+For an x64 to ARM64 cross-build run this first: <tt>vcvarsall.bat x64_arm64</tt>
+</p>
 <h3>Building with MinGW or Cygwin</h3>
 <p>
 Open a command prompt window and make sure the MinGW or Cygwin programs
-are in your path. Then <tt>cd</tt> to the directory of the git repository
-or where you've unpacked the sources. Then run this command for MinGW:
+are in your path. Then <tt>cd</tt> to the directory of the git repository.
+Then run this command for MinGW:
 </p>
 <pre class="code">
 mingw32-make
@@ -466,6 +269,7 @@ for any supported target:
 <li>Yes, you need a toolchain for both your host <em>and</em> your target!</li>
 <li>Both host and target architectures must have the same pointer size.</li>
 <li>E.g. if you want to cross-compile to a 32 bit target on a 64 bit host, you need to install the multilib development package (e.g. <tt>libc6-dev-i386</tt> on Debian/Ubuntu) and build a 32 bit host part (<tt>HOST_CC="gcc -m32"</tt>).</li>
+<li>On some distro versions, multilib conflicts with cross-compilers. The workaround is to install the x86 cross-compiler package <tt>gcc-i686-linux-gnu</tt> and use it to build the host part (<tt>HOST_CC=i686-linux-gnu-gcc</tt>).</li>
 <li>64 bit targets always require compilation on a 64 bit host.</li>
 </ul>
 <p>
@@ -520,15 +324,15 @@ make HOST_CC="gcc -m32" CROSS=arm-linux-gnueabi- \
 make HOST_CC="gcc -m32" CROSS=arm-linux-gnueabihf-
 
 # ARM64
-make CROSS=aarch64-linux-
+make CROSS=aarch64-linux-gnu-
 
 # PPC
 make HOST_CC="gcc -m32" CROSS=powerpc-linux-gnu-
 
 # MIPS32 big-endian
-make HOST_CC="gcc -m32" CROSS=mips-linux-
+make HOST_CC="gcc -m32" CROSS=mips-linux-gnu-
 # MIPS32 little-endian
-make HOST_CC="gcc -m32" CROSS=mipsel-linux-
+make HOST_CC="gcc -m32" CROSS=mipsel-linux-gnu-
 
 # MIPS64 big-endian
 make CROSS=mips-linux- TARGET_CFLAGS="-mips64r2 -mabi=64"
@@ -607,8 +411,8 @@ make HOST_CC="gcc -m32" CROSS=ppu-lv2-
 To cross-compile for the other consoles from a Windows host, open a
 "Native Tools Command Prompt for VS". You need to choose either the 32
 or the 64&nbsp;bit version of the host compiler to match the target.
-Then <tt>cd</tt> to the <tt>src</tt> directory below where you've
-unpacked the sources and run the build command given in the table:
+Then <tt>cd</tt> to the <tt>src</tt> directory below the source code
+and run the build command given in the table:
 </p>
 <table class="compat">
 <tr class="compathead">
@@ -768,7 +572,7 @@ to me (the upstream) and not you (the package maintainer), anyway.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/luajit.html b/lib/luajit2/doc/luajit.html
similarity index 77%
rename from lib/luajit-3065c9/doc/luajit.html
rename to lib/luajit2/doc/luajit.html
index 03a295286..030cf705a 100644
--- a/lib/luajit-3065c9/doc/luajit.html
+++ b/lib/luajit2/doc/luajit.html
@@ -3,7 +3,7 @@
 <head>
 <title>LuaJIT</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -67,30 +67,6 @@ table.fcompat td {
   background-image: -o-linear-gradient(#41bfbf 10%, #b0ffff 95%);
   background-image: -ms-linear-gradient(#41bfbf 10%, #b0ffff 95%);
 }
-table.stats td {
-  color: #ffffff;
-  background: #a0a0a0;
-  background-image: linear-gradient(#808080 10%, #d0d0d0 95%);
-  background-image: -moz-linear-gradient(#808080 10%, #d0d0d0 95%);
-  background-image: -webkit-linear-gradient(#808080 10%, #d0d0d0 95%);
-  background-image: -o-linear-gradient(#808080 10%, #d0d0d0 95%);
-  background-image: -ms-linear-gradient(#808080 10%, #d0d0d0 95%);
-}
-table.stats td.speed {
-  color: #ff4020;
-}
-table.stats td.kb {
-  color: #ffff80;
-  background: #808080;
-  background-image: linear-gradient(#606060 10%, #c0c0c0 95%);
-  background-image: -moz-linear-gradient(#606060 10%, #c0c0c0 95%);
-  background-image: -webkit-linear-gradient(#606060 10%, #c0c0c0 95%);
-  background-image: -o-linear-gradient(#606060 10%, #c0c0c0 95%);
-  background-image: -ms-linear-gradient(#606060 10%, #c0c0c0 95%);
-}
-table.feature small {
-  font-size: 50%;
-}
 </style>
 </head>
 <body>
@@ -131,11 +107,9 @@ table.feature small {
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
-</li><li>
-<a href="faq.html">FAQ</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
@@ -148,7 +122,7 @@ Lua is a powerful, dynamic and light-weight programming language.
 It may be embedded or used as a general-purpose, stand-alone language.
 </p>
 <p>
-LuaJIT is Copyright &copy; 2005-2022 Mike Pall, released under the
+LuaJIT is Copyright &copy; 2005-2023 Mike Pall, released under the
 <a href="https://www.opensource.org/licenses/mit-license.php"><span class="ext">&raquo;</span>&nbsp;MIT open source license</a>.
 </p>
 <p>
@@ -175,23 +149,20 @@ LuaJIT is Copyright &copy; 2005-2022 Mike Pall, released under the
 </table>
 
 <h2>Overview</h2>
-<table class="feature stats">
-<tr>
-<td class="speed">3x<br>-&nbsp;&nbsp;100x</td>
-<td class="kb">115&nbsp;<small>KB</small><br>VM</td>
-<td class="kb">90&nbsp;<small>KB</small><br>JIT</td>
-<td class="kloc">63&nbsp;<small>KLOC</small><br>C</td>
-<td class="kloc">24&nbsp;<small>KLOC</small><br>ASM</td>
-<td class="kloc">11&nbsp;<small>KLOC</small><br>Lua</td>
-</tr>
-</table>
 <p style="margin-top: 1em;">
 LuaJIT has been successfully used as a <b>scripting middleware</b> in
 games, appliances, network and graphics apps, numerical simulations,
-trading platforms and many other specialty applications. It scales from
-embedded devices, smartphones, desktops up to server farms. It combines
-high flexibility with high performance
-and an unmatched <b>low memory footprint</b>.
+trading platforms and many other specialty applications.
+</p>
+<p>
+LuaJIT is part of a hundred million web sites, huge SaaS installations,
+network switches, set-top boxes and other embedded devices. You've probably
+already used LuaJIT without knowing about it.
+</p>
+<p>
+LuaJIT scales from embedded devices, smartphones, desktops up to server
+farms. It combines high flexibility with high performance and an unmatched
+<b>low memory footprint</b>.
 </p>
 <p>
 LuaJIT has been in continuous development since 2005. It's widely
@@ -222,7 +193,7 @@ Please select a sub-topic in the navigation bar to learn more about LuaJIT.
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit-3065c9/doc/running.html b/lib/luajit2/doc/running.html
similarity index 92%
rename from lib/luajit-3065c9/doc/running.html
rename to lib/luajit2/doc/running.html
index 177e63576..142b810fc 100644
--- a/lib/luajit-3065c9/doc/running.html
+++ b/lib/luajit2/doc/running.html
@@ -3,7 +3,7 @@
 <head>
 <title>Running LuaJIT</title>
 <meta charset="utf-8">
-<meta name="Copyright" content="Copyright (C) 2005-2022">
+<meta name="Copyright" content="Copyright (C) 2005-2023">
 <meta name="Language" content="en">
 <link rel="stylesheet" type="text/css" href="bluequad.css" media="screen">
 <link rel="stylesheet" type="text/css" href="bluequad-print.css" media="print">
@@ -68,16 +68,15 @@ td.param_default {
 <a href="ext_profiler.html">Profiler</a>
 </li></ul>
 </li><li>
-<a href="status.html">Status</a>
+<a href="https://luajit.org/status.html">Status <span class="ext">&raquo;</span></a>
 </li><li>
-<a href="faq.html">FAQ</a>
-</li><li>
-<a href="http://wiki.luajit.org/">Wiki <span class="ext">&raquo;</span></a>
+<a href="https://luajit.org/faq.html">FAQ <span class="ext">&raquo;</span></a>
 </li><li>
 <a href="https://luajit.org/list.html">Mailing List <span class="ext">&raquo;</span></a>
 </li></ul>
 </div>
 <div id="main">
+
 <p>
 LuaJIT has only a single stand-alone executable, called <tt>luajit</tt> on
 POSIX systems or <tt>luajit.exe</tt> on Windows. It can be used to run simple
@@ -107,10 +106,14 @@ are accepted:
 <li><tt>-l</tt> &mdash; Only list bytecode.</li>
 <li><tt>-s</tt> &mdash; Strip debug info (this is the default).</li>
 <li><tt>-g</tt> &mdash; Keep debug info.</li>
+<li><tt>-W</tt> &mdash; Generate 32 bit (non-GC64) bytecode.</li>
+<li><tt>-X</tt> &mdash; Generate 64 bit (GC64) bytecode.</li>
+<li><tt>-d</tt> &mdash; Generate bytecode in deterministic manner.</li>
 <li><tt>-n name</tt> &mdash; Set module name (default: auto-detect from input name)</li>
 <li><tt>-t type</tt> &mdash; Set output file type (default: auto-detect from output name).</li>
 <li><tt>-a arch</tt> &mdash; Override architecture for object files (default: native).</li>
 <li><tt>-o os</tt> &mdash; Override OS for object files (default: native).</li>
+<li><tt>-F name</tt> &mdash; Override filename (default: input filename).</li>
 <li><tt>-e chunk</tt> &mdash; Use chunk string as input.</li>
 <li><tt>-</tt> (a single minus sign) &mdash; Use stdin as input and/or stdout as output.</li>
 </ul>
@@ -120,7 +123,8 @@ file name:
 </p>
 <ul>
 <li><tt>c</tt> &mdash; C source file, exported bytecode data.</li>
-<li><tt>h</tt> &mdash; C header file, static bytecode data.</li>
+<li><tt>cc</tt> &mdash; C++ source file, exported bytecode data.</li>
+<li><tt>h</tt> &mdash; C/C++ header file, static bytecode data.</li>
 <li><tt>obj</tt> or <tt>o</tt> &mdash; Object file, exported bytecode data
 (OS- and architecture-specific).</li>
 <li><tt>raw</tt> or any other extension &mdash; Raw bytecode file (portable).
@@ -221,6 +225,12 @@ mix the three forms, but note that setting an optimization level
 overrides all earlier flags.
 </p>
 <p>
+Note that <tt>-Ofma</tt> is not enabled by default at any level,
+because it affects floating-point result accuracy. Only enable this,
+if you fully understand the trade-offs of FMA for performance (higher),
+determinism (lower) and numerical accuracy (higher).
+</p>
+<p>
 Here are the available flags and at what optimization levels they
 are enabled:
 </p>
@@ -252,6 +262,8 @@ are enabled:
 <td class="flag_name">sink</td><td class="flag_level">&nbsp;</td><td class="flag_level">&nbsp;</td><td class="flag_level">&bull;</td><td class="flag_desc">Allocation/Store Sinking</td></tr>
 <tr class="even">
 <td class="flag_name">fuse</td><td class="flag_level">&nbsp;</td><td class="flag_level">&nbsp;</td><td class="flag_level">&bull;</td><td class="flag_desc">Fusion of operands into instructions</td></tr>
+<tr class="odd">
+<td class="flag_name">fma </td><td class="flag_level">&nbsp;</td><td class="flag_level">&nbsp;</td><td class="flag_level">&nbsp;</td><td class="flag_desc">Fused multiply-add</td></tr>
 </table>
 <p>
 Here are the parameters and their default settings:
@@ -295,7 +307,7 @@ Here are the parameters and their default settings:
 </div>
 <div id="foot">
 <hr class="hide">
-Copyright &copy; 2005-2022
+Copyright &copy; 2005-2023
 <span class="noprint">
 &middot;
 <a href="contact.html">Contact</a>
diff --git a/lib/luajit2/dynasm/Examples/run.sh b/lib/luajit2/dynasm/Examples/run.sh
new file mode 100644
index 000000000..da79a3e90
--- /dev/null
+++ b/lib/luajit2/dynasm/Examples/run.sh
@@ -0,0 +1,14 @@
+#!/bin/bash
+# set -x
+
+# run test
+lua ../dynasm.lua test_z_inst.c | gcc -DDASM_CHECKS -std=gnu99 -Wall -Werror -g -x c -o test_z_inst -
+./test_z_inst
+ec=$?
+
+# cleanup
+rm -f ./test_z_inst
+
+# exit
+exit $ec
+
diff --git a/lib/luajit2/dynasm/Examples/test_z_inst.c b/lib/luajit2/dynasm/Examples/test_z_inst.c
new file mode 100644
index 000000000..5a87cc174
--- /dev/null
+++ b/lib/luajit2/dynasm/Examples/test_z_inst.c
@@ -0,0 +1,488 @@
+#include <assert.h>
+#include <stdio.h>
+#include <sys/mman.h>
+
+#include "../dasm_proto.h"
+#include "../dasm_s390x.h"
+
+// DynASM directives.
+|.arch s390x
+|.actionlist actions
+|.globals lab_
+
+static void add(dasm_State *state)
+{
+  dasm_State ** Dst = &state;
+
+  | ar r2,r3
+  | br r14
+}
+
+/*
+static void add_rrd(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+  
+  | lgfi r4 , 0x02
+  | maer r2 , r3 , r4
+  | br r14
+}
+*/
+
+static void sub(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  | sr r2,r3
+  | br r14
+}
+
+static void mul(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  | msr r2 , r3
+  | br r14
+}
+
+static void rx(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  int x = 1;
+  int y = 4095;
+
+  | la r4, 4095(r2, r3)
+  | la r5, 4095(r4)
+  | la r1, x(r5)
+  | la r2, y(r1, r0)
+  | br r14
+}
+
+static void rxy(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  int x = -524287;
+  int y = 524286;
+
+  | lay r4, -524288(r2, r3)
+  | lay r5, 524287(r4)
+  | lay r1, x(r5)
+  | lay r2, y(r1, r0)
+  | br r14
+}
+
+static void lab(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  // r1 = 0; do { r2 += r2; r1 += 1; } while(r1 < r3);
+  | la r1, 0(r0)
+  |1:
+  | agr r2, r2
+  | la r1, 1(r1)
+  | cgr r1, r3
+  | jl <1
+  | br r14
+}
+
+static void labg(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  // r1 = 0; do { r2 += r2; r1 += 1; } while(r1 < r3);
+  | la r1, 0(r0)
+  |1:
+  | agr r2, r2
+  | la r1, 1(r1)
+  | cgr r1, r3
+  | jgl <1
+  | jgnl >1
+  | stg r0, 0(r0)
+  |1:
+  | br r14
+}
+
+static void jmp_fwd(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+  
+  // while(r2!=r3){r2 += 2};
+  | j >1
+  |1:
+  | cgr r2 , r3
+  | jne >2
+  | je >3
+  |2:
+  | afi r2, 0x2
+  | j <1
+  |3:
+  | br r14
+
+}
+
+static void add_imm16(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+  
+  | ahi r2 , 0xf
+  | br r14
+}
+
+static void add_imm32(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+  
+  | afi r2 , 0xe
+  | br r14
+}
+
+static void save(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  |.define CFRAME_SPACE,	224	// Delta for sp, 8 byte aligned.
+  |
+  |// Register save area.
+  |.define SAVE_GPRS,	264(sp)	// Save area for r6-r15 (10*8 bytes).
+  |
+  |// Argument save area, each slot is 8-bytes (32-bit types are sign/zero extended).
+  |.define RESERVED,	232(sp)	// Reserved for compiler use.
+  |.define BACKCHAIN,	224(sp)
+  |
+  |// Current stack frame.
+  |.define SAVE_FPR15,	216(sp)
+  |.define SAVE_FPR14,	208(sp)
+  |.define SAVE_FPR13,	200(sp)
+  |.define SAVE_FPR12,	192(sp)
+  |.define SAVE_FPR11,	184(sp)
+  |.define SAVE_FPR10,	176(sp)
+  |.define SAVE_FPR9,	168(sp)
+  |.define SAVE_FPR8,	160(sp)
+  |
+  |// Callee save area.
+  |.define CALLEESAVE,	000(sp)
+  |
+  |.macro saveregs
+  |  lay sp, -CFRAME_SPACE(sp)	// Allocate stack frame.
+  |  stmg r6, r15, SAVE_GPRS	// Technically we restore r15 regardless.
+  |  std f8, SAVE_FPR8		// f8-f15 are callee-saved.
+  |  std f9, SAVE_FPR9
+  |  std f10, SAVE_FPR10
+  |  std f11, SAVE_FPR11
+  |  std f12, SAVE_FPR12
+  |  std f13, SAVE_FPR13
+  |  std f14, SAVE_FPR14
+  |  std f15, SAVE_FPR15
+  |.endmacro
+  |
+  |.macro restoreregs
+  |  ld f8, SAVE_FPR8		// f8-f15 are callee-saved.
+  |  ld f9, SAVE_FPR9
+  |  ld f10, SAVE_FPR10
+  |  ld f11, SAVE_FPR11
+  |  ld f12, SAVE_FPR12
+  |  ld f13, SAVE_FPR13
+  |  ld f14, SAVE_FPR14
+  |  ld f15, SAVE_FPR15
+  |  lmg r6, r15, SAVE_GPRS	// Restores the stack pointer.
+  |.endmacro
+  |
+  | saveregs
+  | lgfi r7, 0x10 // 16
+  | lgfi r8, 0x20 // 32
+  | agr r2, r3
+  | agr r7, r8
+  | msgr r2, r7
+  | restoreregs
+  | br r14
+}
+
+static void labmul(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  // Multiply using an add function.
+  // Only correct if input is positive.
+  |->mul_func:
+  | stmg r6, r14, 48(sp)
+  | lgr r6, r2
+  | lgr r7, r3
+  | cgfi r7, 0
+  | je >3
+  | cgfi r7, 1
+  | je >2
+  |1:
+  | lgr r3, r6
+  | brasl r14, ->add_func
+  | lay r7, -1(r7)
+  | cgfi r7, 1
+  | jh <1
+  |2:
+  | lmg r6, r14, 48(sp)
+  | br r14
+  |3:
+  | la r2, 0(r0)
+  | j <2
+
+  |->add_func:
+  | agr r2, r3
+  | br r14
+}
+
+static void pc(dasm_State *state) {
+  dasm_State **Dst = &state;
+  int MAX = 10;
+  dasm_growpc(Dst, MAX+1);
+
+  | j =>MAX
+  for (int i = 0; i <= MAX; i++) {
+    |=>i:
+    if (i == 0) {
+      | br r14
+    } else {
+      | aghi r2, i
+      | j =>i-1
+    }
+  }
+}
+
+/*
+static void load_test(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+  
+  | ltdr r2 , r3
+  | br r14
+}
+*/
+
+
+static void test_mask(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  |lay   sp , -8(sp)
+  |stg   r2,  4(sp)
+  |tm    4(sp),0x04
+  |je >2
+  |jne >1
+|1:
+  |ar r2,r3
+  |br r14
+|2:
+  |sr r2,r3
+  |br r14
+}
+
+static void ssa(dasm_State *state) {
+  dasm_State **Dst = &state;
+
+  | lay sp, -16(sp)
+  | lay r0, -1(r0)
+  | stg r0, 8(sp)
+  | xc 8(8, sp), 8(sp)
+  | stg r2, 0(sp)
+  | mvc 13(2, sp), 6(sp)
+  | lg r2, 8(sp)
+  | la sp, 16(sp)
+  | br r14
+}
+
+static void ssa_act(dasm_State *state) {
+  dasm_State **Dst = &state;
+
+  int xl = 8;
+  int d1 = 13;
+  int l1 = 2;
+  int d2 = 6;
+
+  | lay sp, -16(sp)
+  | lay r0, -1(r0)
+  | stg r0, 8(sp)
+  | xc 8(xl, sp), 8(sp)
+  | stg r2, 0(sp)
+  | mvc d1(l1, sp), d2(sp)
+  | lg r2, 8(sp)
+  | la sp, 16(sp)
+  | br r14
+}
+
+typedef struct {
+  int a;
+  int b;
+} SimpleStruct;
+
+static void type(dasm_State *state) {
+  dasm_State **Dst = &state;
+
+  | .type SIMPLE, SimpleStruct
+  | lay sp, -8(sp)
+  | stg r2, 0(sp)
+  | xgr r2, r2
+  | l r2, SIMPLE:sp->b
+  | la sp, 8(sp)
+  | br r14
+}
+
+static void sil(dasm_State *state) {
+  dasm_State **Dst = &state;
+
+  | lay sp, -16(sp)
+  | xc 0(16, sp), 0(sp)
+  | mvghi 0(sp), 5
+  | mvhi 8(sp), 7
+  | mvhhi 12(sp), 11
+  | lghi r2, 0
+  | ag r2, 0(sp)  // r2 += 5
+  | a r2, 8(sp)   // r2 += 7
+  | ah r2, 12(sp) // r2 += 11
+  | la sp, 16(sp)
+  | br r14
+}
+
+static void rrfe_rrd(dasm_State *state) {
+  dasm_State ** Dst = &state;
+
+  | cefbr f0,r2
+  | cefbr f2,r3
+  | cefbr f4,r4
+  | maebr f0 ,f2 ,f4
+  | cfebr r2, 0, f0
+  | br r14
+}
+
+static void rre(dasm_State *state)  {
+
+  dasm_State **Dst = &state;
+
+  | lay   sp , -8(sp)
+  | cefbr f0 ,  r2
+  | cefbr f1 ,  r3
+  | fidr  f0 ,  f1
+  | cfebr r2 ,0,f0
+  | la    sp,   8(sp)
+  | br   r14
+}
+
+static void rsb(dasm_State *state) {
+  dasm_State **Dst = &state;
+
+  | lay sp, -4(sp)
+  | lghi r3, 0x0706
+  | lghi r4, 0
+  | iill r4, 6
+  | iilh r4, 7
+  | st r4, 0(sp)
+  | lghi r2, 0
+  | clm r3, 5, 0(sp)
+  | jne >1
+  | lghi r2, 1
+  |1:
+  | la sp, 4(sp)
+  | br r14
+}
+
+static void sqrt_rxe(dasm_State *state)
+{
+  dasm_State **Dst = &state;
+
+  | lay     sp , -8(sp)
+  | cefbr   f0 , r2
+  | stdy    f0 , 0(sp)
+  | sqeb    f0 ,0(r4,sp)
+  | cfebr   r2 ,0, f0
+  | la      sp, 8(sp)
+  | br      r14
+
+}
+
+static void rxf(dasm_State *state) {
+  dasm_State **Dst = &state;
+
+  | lay    sp , -8(sp)
+  | cegbra f1 ,0, r2,0
+  | cegbra f2 ,0,r3,0
+  | ste    f2 ,0(sp)
+  | maeb   f1, f2, 0(sp)
+  | cfebr  r2 ,0, f1
+  | la     sp, 8(sp)
+  | br     r14
+
+}
+
+typedef struct {
+  int64_t arg1;
+  int64_t arg2;
+  int64_t arg3;
+  void (*fn)(dasm_State *);
+  int64_t want;
+  const char *testname;
+} test_table;
+
+test_table test[] = {
+  { 1, 2, 0,       add,        3,     "add"},
+  {10, 5, 0,       sub,        5,     "sub"},
+  { 2, 3, 0,       mul,        6,     "mul"},
+  { 5, 7, 0,        rx,    12298,      "rx"},
+  { 5, 7, 0,       rxy,       10,     "rxy"},
+  { 2, 4, 0,       lab,       32,     "lab"},
+  { 2, 4, 0,      labg,       32,    "labg"},
+  { 2, 0, 0, add_imm16,       17,   "imm16"},
+  { 2, 0, 0, add_imm32,       16,   "imm32"},
+  { 7, 3, 0,      save,      480,    "save"},
+  { 7, 3, 0,    labmul,       21, "labmul0"},
+  { 7, 0, 0,    labmul,        0, "labmul1"},
+  { 0, 0, 0,        pc,       55,      "pc"},
+  { 2,12, 0,   jmp_fwd,       12, "jmp_fwd"},
+//  { 9,8, 0,    add_rrd,       25, "add_rrd"},
+//  { 2,4, 0,  load_test,        4,"load_test"},
+  {-1, 0, 0,       ssa, 65535<<8,     "ssa"},
+  {-1, 0, 0,   ssa_act, 65535<<8, "ssa_act"},
+  {27, 0, 0,      type,       27,    "type"},
+  { 0, 0, 0,       sil,       23,     "sil"},
+  {15, 3,10,   rrfe_rrd,      45, "rrfe_rrd"},
+  { 0, 0, 0,        rsb,       0,     "rsb"},
+  {12,10, 0,        rre,      10,     "rre"},
+  {16,10, 0,   sqrt_rxe,       4,"sqrt_rxe"},
+  {16,10, 0,        rxf,     116,     "rxf"},
+  { 4, 3, 0,  test_mask,       1,"test_mask"}
+};
+
+static void *jitcode(dasm_State **state, size_t *size)
+{
+  int dasm_status = dasm_link(state, size);
+  assert(dasm_status == DASM_S_OK);
+
+  void *ret = mmap(0, *size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+  dasm_encode(state, ret);
+  dasm_free(state);
+
+  mprotect(ret, *size, PROT_READ | PROT_EXEC);
+  return (int *)ret;
+}
+
+int main(int argc, char *argv[])
+{
+  dasm_State *state;
+  for(int i = 0; i < sizeof(test)/sizeof(test[0]); i++) {
+    dasm_init(&state, 1);
+    void* labels[lab__MAX];
+    dasm_setupglobal(&state, labels, lab__MAX);
+    dasm_setup(&state, actions);
+    test[i].fn(state);
+    size_t size;
+    int64_t (*fptr)(int64_t, int64_t, int64_t) = jitcode(&state, &size);
+    int64_t got = fptr(test[i].arg1, test[i].arg2, test[i].arg3);
+
+    if (got != test[i].want) {
+      fprintf(stderr, "FAIL: test %s: want %ld, got %ld\n", test[i].testname, test[i].want, got);
+      exit(1);
+    }
+    munmap(fptr, size);
+  }
+  printf("all tests passed\n");
+  return 0;
+}
+
diff --git a/lib/luajit-3065c9/dynasm/dasm_arm.h b/lib/luajit2/dynasm/dasm_arm.h
similarity index 95%
rename from lib/luajit-3065c9/dynasm/dasm_arm.h
rename to lib/luajit2/dynasm/dasm_arm.h
index fbfebee09..eaa94d9c2 100644
--- a/lib/luajit-3065c9/dynasm/dasm_arm.h
+++ b/lib/luajit2/dynasm/dasm_arm.h
@@ -1,6 +1,6 @@
 /*
 ** DynASM ARM encoding engine.
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 ** Released under the MIT license. See dynasm.lua for full copyright notice.
 */
 
@@ -70,7 +70,7 @@ struct dasm_State {
   size_t lgsize;
   int *pclabels;		/* PC label chains/pos ptrs. */
   size_t pcsize;
-  void **globals;		/* Array of globals (bias -10). */
+  void **globals;		/* Array of globals. */
   dasm_Section *section;	/* Pointer to active section. */
   size_t codesize;		/* Total size of all code sections. */
   int maxsection;		/* 0 <= sectionidx < maxsection. */
@@ -87,7 +87,6 @@ void dasm_init(Dst_DECL, int maxsection)
 {
   dasm_State *D;
   size_t psz = 0;
-  int i;
   Dst_REF = NULL;
   DASM_M_GROW(Dst, struct dasm_State, Dst_REF, psz, DASM_PSZ(maxsection));
   D = Dst_REF;
@@ -98,12 +97,7 @@ void dasm_init(Dst_DECL, int maxsection)
   D->pcsize = 0;
   D->globals = NULL;
   D->maxsection = maxsection;
-  for (i = 0; i < maxsection; i++) {
-    D->sections[i].buf = NULL;  /* Need this for pass3. */
-    D->sections[i].rbuf = D->sections[i].buf - DASM_SEC2POS(i);
-    D->sections[i].bsize = 0;
-    D->sections[i].epos = 0;  /* Wrong, but is recalculated after resize. */
-  }
+  memset((void *)D->sections, 0, maxsection * sizeof(dasm_Section));
 }
 
 /* Free DynASM state. */
@@ -123,7 +117,7 @@ void dasm_free(Dst_DECL)
 void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl)
 {
   dasm_State *D = Dst_REF;
-  D->globals = gl - 10;  /* Negative bias to compensate for locals. */
+  D->globals = gl;
   DASM_M_GROW(Dst, int, D->lglabels, D->lgsize, (10+maxgl)*sizeof(int));
 }
 
@@ -148,6 +142,7 @@ void dasm_setup(Dst_DECL, const void *actionlist)
   if (D->pclabels) memset((void *)D->pclabels, 0, D->pcsize);
   for (i = 0; i < D->maxsection; i++) {
     D->sections[i].pos = DASM_SEC2POS(i);
+    D->sections[i].rbuf = D->sections[i].buf - D->sections[i].pos;
     D->sections[i].ofs = 0;
   }
 }
@@ -372,7 +367,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  break;
 	case DASM_REL_LG:
 	  if (n < 0) {
-	    n = (int)((ptrdiff_t)D->globals[-n] - (ptrdiff_t)cp - 4);
+	    n = (int)((ptrdiff_t)D->globals[-n-10] - (ptrdiff_t)cp - 4);
 	    goto patchrel;
 	  }
 	  /* fallthrough */
@@ -396,7 +391,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  }
 	  break;
 	case DASM_LABEL_LG:
-	  ins &= 2047; if (ins >= 20) D->globals[ins-10] = (void *)(base + n);
+	  ins &= 2047; if (ins >= 20) D->globals[ins-20] = (void *)(base + n);
 	  break;
 	case DASM_LABEL_PC: break;
 	case DASM_IMM:
diff --git a/lib/luajit-3065c9/dynasm/dasm_arm.lua b/lib/luajit2/dynasm/dasm_arm.lua
similarity index 99%
rename from lib/luajit-3065c9/dynasm/dasm_arm.lua
rename to lib/luajit2/dynasm/dasm_arm.lua
index 3b4db86e5..edb575366 100644
--- a/lib/luajit-3065c9/dynasm/dasm_arm.lua
+++ b/lib/luajit2/dynasm/dasm_arm.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM ARM module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 ------------------------------------------------------------------------------
 
diff --git a/lib/luajit-3065c9/dynasm/dasm_arm64.h b/lib/luajit2/dynasm/dasm_arm64.h
similarity index 96%
rename from lib/luajit-3065c9/dynasm/dasm_arm64.h
rename to lib/luajit2/dynasm/dasm_arm64.h
index 47c9c37d6..1c541e5d0 100644
--- a/lib/luajit-3065c9/dynasm/dasm_arm64.h
+++ b/lib/luajit2/dynasm/dasm_arm64.h
@@ -1,6 +1,6 @@
 /*
 ** DynASM ARM64 encoding engine.
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 ** Released under the MIT license. See dynasm.lua for full copyright notice.
 */
 
@@ -72,7 +72,7 @@ struct dasm_State {
   size_t lgsize;
   int *pclabels;		/* PC label chains/pos ptrs. */
   size_t pcsize;
-  void **globals;		/* Array of globals (bias -10). */
+  void **globals;		/* Array of globals. */
   dasm_Section *section;	/* Pointer to active section. */
   size_t codesize;		/* Total size of all code sections. */
   int maxsection;		/* 0 <= sectionidx < maxsection. */
@@ -89,7 +89,6 @@ void dasm_init(Dst_DECL, int maxsection)
 {
   dasm_State *D;
   size_t psz = 0;
-  int i;
   Dst_REF = NULL;
   DASM_M_GROW(Dst, struct dasm_State, Dst_REF, psz, DASM_PSZ(maxsection));
   D = Dst_REF;
@@ -100,12 +99,7 @@ void dasm_init(Dst_DECL, int maxsection)
   D->pcsize = 0;
   D->globals = NULL;
   D->maxsection = maxsection;
-  for (i = 0; i < maxsection; i++) {
-    D->sections[i].buf = NULL;  /* Need this for pass3. */
-    D->sections[i].rbuf = D->sections[i].buf - DASM_SEC2POS(i);
-    D->sections[i].bsize = 0;
-    D->sections[i].epos = 0;  /* Wrong, but is recalculated after resize. */
-  }
+  memset((void *)D->sections, 0, maxsection * sizeof(dasm_Section));
 }
 
 /* Free DynASM state. */
@@ -125,7 +119,7 @@ void dasm_free(Dst_DECL)
 void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl)
 {
   dasm_State *D = Dst_REF;
-  D->globals = gl - 10;  /* Negative bias to compensate for locals. */
+  D->globals = gl;
   DASM_M_GROW(Dst, int, D->lglabels, D->lgsize, (10+maxgl)*sizeof(int));
 }
 
@@ -150,6 +144,7 @@ void dasm_setup(Dst_DECL, const void *actionlist)
   if (D->pclabels) memset((void *)D->pclabels, 0, D->pcsize);
   for (i = 0; i < D->maxsection; i++) {
     D->sections[i].pos = DASM_SEC2POS(i);
+    D->sections[i].rbuf = D->sections[i].buf - D->sections[i].pos;
     D->sections[i].ofs = 0;
   }
 }
@@ -444,7 +439,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  break;
 	case DASM_REL_LG:
 	  if (n < 0) {
-	    ptrdiff_t na = (ptrdiff_t)D->globals[-n] - (ptrdiff_t)cp + 4;
+	    ptrdiff_t na = (ptrdiff_t)D->globals[-n-10] - (ptrdiff_t)cp + 4;
 	    n = (int)na;
 	    CK((ptrdiff_t)n == na, RANGE_REL);
 	    goto patchrel;
@@ -487,7 +482,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  goto patchrel;
 	}
 	case DASM_LABEL_LG:
-	  ins &= 2047; if (ins >= 20) D->globals[ins-10] = (void *)(base + n);
+	  ins &= 2047; if (ins >= 20) D->globals[ins-20] = (void *)(base + n);
 	  break;
 	case DASM_LABEL_PC: break;
 	case DASM_IMM:
diff --git a/lib/luajit-3065c9/dynasm/dasm_arm64.lua b/lib/luajit2/dynasm/dasm_arm64.lua
similarity index 98%
rename from lib/luajit-3065c9/dynasm/dasm_arm64.lua
rename to lib/luajit2/dynasm/dasm_arm64.lua
index 1f581ba05..05ea3e228 100644
--- a/lib/luajit-3065c9/dynasm/dasm_arm64.lua
+++ b/lib/luajit2/dynasm/dasm_arm64.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM ARM64 module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 ------------------------------------------------------------------------------
 
@@ -549,7 +549,7 @@ end
 local function parse_load_pair(params, nparams, n, op)
   if params[n+2] then werror("too many operands") end
   local pn, p2 = params[n], params[n+1]
-  local scale = shr(op, 30) == 0 and 2 or 3
+  local scale = 2 + shr(op, 31 - band(shr(op, 26), 1))
   local p1, wb = match(pn, "^%[%s*(.-)%s*%](!?)$")
   if not p1 then
     if not p2 then
@@ -806,8 +806,8 @@ map_op = {
   ["ldrsw_*"] = "98000000DxB|b8800000DxL",
   -- NOTE: ldur etc. are handled by ldr et al.
 
-  ["stp_*"]   = "28000000DAwP|a8000000DAxP|2c000000DAsP|6c000000DAdP",
-  ["ldp_*"]   = "28400000DAwP|a8400000DAxP|2c400000DAsP|6c400000DAdP",
+  ["stp_*"]   = "28000000DAwP|a8000000DAxP|2c000000DAsP|6c000000DAdP|ac000000DAqP",
+  ["ldp_*"]   = "28400000DAwP|a8400000DAxP|2c400000DAsP|6c400000DAdP|ac400000DAqP",
   ["ldpsw_*"] = "68400000DAxP",
 
   -- Branches.
@@ -823,6 +823,13 @@ map_op = {
   tbz_3  = "36000000DTBw|36000000DTBx",
   tbnz_3 = "37000000DTBw|37000000DTBx",
 
+  -- ARM64e: Pointer authentication codes (PAC).
+  blraaz_1  = "d63f081fNx",
+  braa_2    = "d71f0800NDx",
+  braaz_1   = "d61f081fNx",
+  pacibsp_0 = "d503237f",
+  retab_0   = "d65f0fff",
+
   -- Miscellaneous instructions.
   -- TODO: hlt, hvc, smc, svc, eret, dcps[123], drps, mrs, msr
   -- TODO: sys, sysl, ic, dc, at, tlbi
@@ -935,7 +942,7 @@ local function parse_template(params, template, nparams, pos)
 	werror("bad register type")
       end
       parse_reg_type = false
-    elseif p == "x" or p == "w" or p == "d" or p == "s" then
+    elseif p == "x" or p == "w" or p == "d" or p == "s" or p == "q" then
       if parse_reg_type ~= p then
 	werror("register size mismatch")
       end
diff --git a/lib/luajit-3065c9/dynasm/dasm_mips.h b/lib/luajit2/dynasm/dasm_mips.h
similarity index 95%
rename from lib/luajit-3065c9/dynasm/dasm_mips.h
rename to lib/luajit2/dynasm/dasm_mips.h
index 3e99a0050..7800e9338 100644
--- a/lib/luajit-3065c9/dynasm/dasm_mips.h
+++ b/lib/luajit2/dynasm/dasm_mips.h
@@ -1,6 +1,6 @@
 /*
 ** DynASM MIPS encoding engine.
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 ** Released under the MIT license. See dynasm.lua for full copyright notice.
 */
 
@@ -69,7 +69,7 @@ struct dasm_State {
   size_t lgsize;
   int *pclabels;		/* PC label chains/pos ptrs. */
   size_t pcsize;
-  void **globals;		/* Array of globals (bias -10). */
+  void **globals;		/* Array of globals. */
   dasm_Section *section;	/* Pointer to active section. */
   size_t codesize;		/* Total size of all code sections. */
   int maxsection;		/* 0 <= sectionidx < maxsection. */
@@ -86,7 +86,6 @@ void dasm_init(Dst_DECL, int maxsection)
 {
   dasm_State *D;
   size_t psz = 0;
-  int i;
   Dst_REF = NULL;
   DASM_M_GROW(Dst, struct dasm_State, Dst_REF, psz, DASM_PSZ(maxsection));
   D = Dst_REF;
@@ -97,12 +96,7 @@ void dasm_init(Dst_DECL, int maxsection)
   D->pcsize = 0;
   D->globals = NULL;
   D->maxsection = maxsection;
-  for (i = 0; i < maxsection; i++) {
-    D->sections[i].buf = NULL;  /* Need this for pass3. */
-    D->sections[i].rbuf = D->sections[i].buf - DASM_SEC2POS(i);
-    D->sections[i].bsize = 0;
-    D->sections[i].epos = 0;  /* Wrong, but is recalculated after resize. */
-  }
+  memset((void *)D->sections, 0, maxsection * sizeof(dasm_Section));
 }
 
 /* Free DynASM state. */
@@ -122,7 +116,7 @@ void dasm_free(Dst_DECL)
 void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl)
 {
   dasm_State *D = Dst_REF;
-  D->globals = gl - 10;  /* Negative bias to compensate for locals. */
+  D->globals = gl;
   DASM_M_GROW(Dst, int, D->lglabels, D->lgsize, (10+maxgl)*sizeof(int));
 }
 
@@ -147,6 +141,7 @@ void dasm_setup(Dst_DECL, const void *actionlist)
   if (D->pclabels) memset((void *)D->pclabels, 0, D->pcsize);
   for (i = 0; i < D->maxsection; i++) {
     D->sections[i].pos = DASM_SEC2POS(i);
+    D->sections[i].rbuf = D->sections[i].buf - D->sections[i].pos;
     D->sections[i].ofs = 0;
   }
 }
@@ -350,7 +345,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  break;
 	case DASM_REL_LG:
 	  if (n < 0) {
-	    n = (int)((ptrdiff_t)D->globals[-n] - (ptrdiff_t)cp);
+	    n = (int)((ptrdiff_t)D->globals[-n-10] - (ptrdiff_t)cp);
 	    goto patchrel;
 	  }
 	  /* fallthrough */
@@ -369,7 +364,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  }
 	  break;
 	case DASM_LABEL_LG:
-	  ins &= 2047; if (ins >= 20) D->globals[ins-10] = (void *)(base + n);
+	  ins &= 2047; if (ins >= 20) D->globals[ins-20] = (void *)(base + n);
 	  break;
 	case DASM_LABEL_PC: break;
 	case DASM_IMMS:
diff --git a/lib/luajit-3065c9/dynasm/dasm_mips.lua b/lib/luajit2/dynasm/dasm_mips.lua
similarity index 99%
rename from lib/luajit-3065c9/dynasm/dasm_mips.lua
rename to lib/luajit2/dynasm/dasm_mips.lua
index 6f893fe0a..1c605b681 100644
--- a/lib/luajit-3065c9/dynasm/dasm_mips.lua
+++ b/lib/luajit2/dynasm/dasm_mips.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM MIPS32/MIPS64 module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 ------------------------------------------------------------------------------
 
diff --git a/lib/luajit-3065c9/dynasm/dasm_mips64.lua b/lib/luajit2/dynasm/dasm_mips64.lua
similarity index 89%
rename from lib/luajit-3065c9/dynasm/dasm_mips64.lua
rename to lib/luajit2/dynasm/dasm_mips64.lua
index b4f8707dd..c97d666b3 100644
--- a/lib/luajit-3065c9/dynasm/dasm_mips64.lua
+++ b/lib/luajit2/dynasm/dasm_mips64.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM MIPS64 module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 ------------------------------------------------------------------------------
 -- This module just sets 64 bit mode for the combined MIPS/MIPS64 module.
diff --git a/lib/luajit-3065c9/dynasm/dasm_ppc.h b/lib/luajit2/dynasm/dasm_ppc.h
similarity index 95%
rename from lib/luajit-3065c9/dynasm/dasm_ppc.h
rename to lib/luajit2/dynasm/dasm_ppc.h
index fdb89bce4..4c7d7289f 100644
--- a/lib/luajit-3065c9/dynasm/dasm_ppc.h
+++ b/lib/luajit2/dynasm/dasm_ppc.h
@@ -1,6 +1,6 @@
 /*
 ** DynASM PPC/PPC64 encoding engine.
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 ** Released under the MIT license. See dynasm.lua for full copyright notice.
 */
 
@@ -69,7 +69,7 @@ struct dasm_State {
   size_t lgsize;
   int *pclabels;		/* PC label chains/pos ptrs. */
   size_t pcsize;
-  void **globals;		/* Array of globals (bias -10). */
+  void **globals;		/* Array of globals. */
   dasm_Section *section;	/* Pointer to active section. */
   size_t codesize;		/* Total size of all code sections. */
   int maxsection;		/* 0 <= sectionidx < maxsection. */
@@ -86,7 +86,6 @@ void dasm_init(Dst_DECL, int maxsection)
 {
   dasm_State *D;
   size_t psz = 0;
-  int i;
   Dst_REF = NULL;
   DASM_M_GROW(Dst, struct dasm_State, Dst_REF, psz, DASM_PSZ(maxsection));
   D = Dst_REF;
@@ -97,12 +96,7 @@ void dasm_init(Dst_DECL, int maxsection)
   D->pcsize = 0;
   D->globals = NULL;
   D->maxsection = maxsection;
-  for (i = 0; i < maxsection; i++) {
-    D->sections[i].buf = NULL;  /* Need this for pass3. */
-    D->sections[i].rbuf = D->sections[i].buf - DASM_SEC2POS(i);
-    D->sections[i].bsize = 0;
-    D->sections[i].epos = 0;  /* Wrong, but is recalculated after resize. */
-  }
+  memset((void *)D->sections, 0, maxsection * sizeof(dasm_Section));
 }
 
 /* Free DynASM state. */
@@ -122,7 +116,7 @@ void dasm_free(Dst_DECL)
 void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl)
 {
   dasm_State *D = Dst_REF;
-  D->globals = gl - 10;  /* Negative bias to compensate for locals. */
+  D->globals = gl;
   DASM_M_GROW(Dst, int, D->lglabels, D->lgsize, (10+maxgl)*sizeof(int));
 }
 
@@ -147,6 +141,7 @@ void dasm_setup(Dst_DECL, const void *actionlist)
   if (D->pclabels) memset((void *)D->pclabels, 0, D->pcsize);
   for (i = 0; i < D->maxsection; i++) {
     D->sections[i].pos = DASM_SEC2POS(i);
+    D->sections[i].rbuf = D->sections[i].buf - D->sections[i].pos;
     D->sections[i].ofs = 0;
   }
 }
@@ -354,7 +349,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  break;
 	case DASM_REL_LG:
 	  if (n < 0) {
-	    n = (int)((ptrdiff_t)D->globals[-n] - (ptrdiff_t)cp);
+	    n = (int)((ptrdiff_t)D->globals[-n-10] - (ptrdiff_t)cp);
 	    goto patchrel;
 	  }
 	  /* fallthrough */
@@ -368,7 +363,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  cp[-1] |= ((n+4) & ((ins & 2048) ? 0x0000fffc: 0x03fffffc));
 	  break;
 	case DASM_LABEL_LG:
-	  ins &= 2047; if (ins >= 20) D->globals[ins-10] = (void *)(base + n);
+	  ins &= 2047; if (ins >= 20) D->globals[ins-20] = (void *)(base + n);
 	  break;
 	case DASM_LABEL_PC: break;
 	case DASM_IMM:
diff --git a/lib/luajit-3065c9/dynasm/dasm_ppc.lua b/lib/luajit2/dynasm/dasm_ppc.lua
similarity index 99%
rename from lib/luajit-3065c9/dynasm/dasm_ppc.lua
rename to lib/luajit2/dynasm/dasm_ppc.lua
index 3624e882e..2f5f768ca 100644
--- a/lib/luajit-3065c9/dynasm/dasm_ppc.lua
+++ b/lib/luajit2/dynasm/dasm_ppc.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM PPC/PPC64 module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 --
 -- Support for various extensions contributed by Caio Souza Oliveira.
@@ -257,9 +257,11 @@ map_op = {
   addic_3 =	"30000000RRI",
   ["addic._3"] = "34000000RRI",
   addi_3 =	"38000000RR0I",
+  addil_3 =	"38000000RR0J",
   li_2 =	"38000000RI",
   la_2 =	"38000000RD",
   addis_3 =	"3c000000RR0I",
+  addisl_3 =	"3c000000RR0J",
   lis_2 =	"3c000000RI",
   lus_2 =	"3c000000RU",
   bc_3 =	"40000000AAK",
@@ -842,6 +844,9 @@ map_op = {
   srdi_3 =	op_alias("rldicl_4", function(p)
     p[4] = p[3]; p[3] = "64-("..p[3]..")"
   end),
+  ["srdi._3"] =	op_alias("rldicl._4", function(p)
+    p[4] = p[3]; p[3] = "64-("..p[3]..")"
+  end),
   clrldi_3 =	op_alias("rldicl_4", function(p)
     p[4] = p[3]; p[3] = "0"
   end),
diff --git a/lib/luajit-3065c9/dynasm/dasm_proto.h b/lib/luajit2/dynasm/dasm_proto.h
similarity index 97%
rename from lib/luajit-3065c9/dynasm/dasm_proto.h
rename to lib/luajit2/dynasm/dasm_proto.h
index d798554b8..3f50f5028 100644
--- a/lib/luajit-3065c9/dynasm/dasm_proto.h
+++ b/lib/luajit2/dynasm/dasm_proto.h
@@ -1,6 +1,6 @@
 /*
 ** DynASM encoding engine prototypes.
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 ** Released under the MIT license. See dynasm.lua for full copyright notice.
 */
 
diff --git a/lib/luajit2/dynasm/dasm_s390x.h b/lib/luajit2/dynasm/dasm_s390x.h
new file mode 100644
index 000000000..fe278d5ee
--- /dev/null
+++ b/lib/luajit2/dynasm/dasm_s390x.h
@@ -0,0 +1,542 @@
+/*
+** DynASM s390x encoding engine.
+** Copyright (C) 2005-2017 Mike Pall. All rights reserved.
+** Released under the MIT license. See dynasm.lua for full copyright notice.
+*/
+
+#include <stddef.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdlib.h>
+
+#define DASM_ARCH		"s390x"
+
+#ifndef DASM_EXTERN
+#define DASM_EXTERN(a,b,c,d)	0
+#endif
+
+/* Action definitions. */
+enum {
+  DASM_STOP, DASM_SECTION, DASM_ESC, DASM_REL_EXT,
+  /* The following actions need a buffer position. */
+  DASM_ALIGN, DASM_REL_LG, DASM_LABEL_LG,
+  /* The following actions also have an argument. */
+  DASM_REL_PC, DASM_LABEL_PC,
+  DASM_DISP12, DASM_DISP20,
+  DASM_IMM8, DASM_IMM16, DASM_IMM32,
+  DASM_LEN8R,DASM_LEN4HR,DASM_LEN4LR,
+  DASM__MAX
+};
+
+/* Maximum number of section buffer positions for a single dasm_put() call. */
+#define DASM_MAXSECPOS		25
+
+/* DynASM encoder status codes. Action list offset or number are or'ed in. */
+#define DASM_S_OK		0x00000000
+#define DASM_S_NOMEM		0x01000000
+#define DASM_S_PHASE		0x02000000
+#define DASM_S_MATCH_SEC	0x03000000
+#define DASM_S_RANGE_I		0x11000000
+#define DASM_S_RANGE_SEC	0x12000000
+#define DASM_S_RANGE_LG		0x13000000
+#define DASM_S_RANGE_PC		0x14000000
+#define DASM_S_RANGE_REL	0x15000000
+#define DASM_S_UNDEF_LG		0x21000000
+#define DASM_S_UNDEF_PC		0x22000000
+
+/* Macros to convert positions (8 bit section + 24 bit index). */
+#define DASM_POS2IDX(pos)	((pos)&0x00ffffff)
+#define DASM_POS2BIAS(pos)	((pos)&0xff000000)
+#define DASM_SEC2POS(sec)	((sec)<<24)
+#define DASM_POS2SEC(pos)	((pos)>>24)
+#define DASM_POS2PTR(D, pos)	(D->sections[DASM_POS2SEC(pos)].rbuf + (pos))
+
+/* Action list type. */
+typedef const unsigned short *dasm_ActList;
+
+/* Per-section structure. */
+typedef struct dasm_Section {
+  int *rbuf;                    /* Biased buffer pointer (negative section bias). */
+  int *buf;                     /* True buffer pointer. */
+  size_t bsize;                 /* Buffer size in bytes. */
+  int pos;                      /* Biased buffer position. */
+  int epos;                     /* End of biased buffer position - max single put. */
+  int ofs;                      /* Byte offset into section. */
+} dasm_Section;
+
+/* Core structure holding the DynASM encoding state. */
+struct dasm_State {
+  size_t psize;                 /* Allocated size of this structure. */
+  dasm_ActList actionlist;      /* Current actionlist pointer. */
+  int *lglabels;                /* Local/global chain/pos ptrs. */
+  size_t lgsize;
+  int *pclabels;                /* PC label chains/pos ptrs. */
+  size_t pcsize;
+  void **globals;               /* Array of globals. */
+  dasm_Section *section;        /* Pointer to active section. */
+  size_t codesize;              /* Total size of all code sections. */
+  int maxsection;               /* 0 <= sectionidx < maxsection. */
+  int status;                   /* Status code. */
+  dasm_Section sections[1];     /* All sections. Alloc-extended. */
+};
+
+/* The size of the core structure depends on the max. number of sections. */
+#define DASM_PSZ(ms)	(sizeof(dasm_State)+(ms-1)*sizeof(dasm_Section))
+
+
+/* Initialize DynASM state. */
+void dasm_init(Dst_DECL, int maxsection)
+{
+  dasm_State *D;
+  size_t psz = 0;
+  Dst_REF = NULL;
+  DASM_M_GROW(Dst, struct dasm_State, Dst_REF, psz, DASM_PSZ(maxsection));
+  D = Dst_REF;
+  D->psize = psz;
+  D->lglabels = NULL;
+  D->lgsize = 0;
+  D->pclabels = NULL;
+  D->pcsize = 0;
+  D->globals = NULL;
+  D->maxsection = maxsection;
+  memset((void *)D->sections, 0, maxsection * sizeof(dasm_Section));
+}
+
+/* Free DynASM state. */
+void dasm_free(Dst_DECL)
+{
+  dasm_State *D = Dst_REF;
+  int i;
+  for (i = 0; i < D->maxsection; i++)
+    if (D->sections[i].buf)
+      DASM_M_FREE(Dst, D->sections[i].buf, D->sections[i].bsize);
+  if (D->pclabels)
+    DASM_M_FREE(Dst, D->pclabels, D->pcsize);
+  if (D->lglabels)
+    DASM_M_FREE(Dst, D->lglabels, D->lgsize);
+  DASM_M_FREE(Dst, D, D->psize);
+}
+
+/* Setup global label array. Must be called before dasm_setup(). */
+void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl)
+{
+  dasm_State *D = Dst_REF;
+  D->globals = gl;
+  DASM_M_GROW(Dst, int, D->lglabels, D->lgsize, (10 + maxgl) * sizeof(int));
+}
+
+/* Grow PC label array. Can be called after dasm_setup(), too. */
+void dasm_growpc(Dst_DECL, unsigned int maxpc)
+{
+  dasm_State *D = Dst_REF;
+  size_t osz = D->pcsize;
+  DASM_M_GROW(Dst, int, D->pclabels, D->pcsize, maxpc * sizeof(int));
+  memset((void *)(((unsigned char *)D->pclabels) + osz), 0, D->pcsize - osz);
+}
+
+/* Setup encoder. */
+void dasm_setup(Dst_DECL, const void *actionlist)
+{
+  dasm_State *D = Dst_REF;
+  int i;
+  D->actionlist = (dasm_ActList) actionlist;
+  D->status = DASM_S_OK;
+  D->section = &D->sections[0];
+  memset((void *)D->lglabels, 0, D->lgsize);
+  if (D->pclabels)
+    memset((void *)D->pclabels, 0, D->pcsize);
+  for (i = 0; i < D->maxsection; i++) {
+    D->sections[i].pos = DASM_SEC2POS(i);
+    D->sections[i].rbuf = D->sections[i].buf - D->sections[i].pos;
+    D->sections[i].ofs = 0;
+  }
+}
+
+
+#ifdef DASM_CHECKS
+#define CK(x, st) \
+  do { if (!(x)) { \
+    D->status = DASM_S_##st|(p-D->actionlist-1); return; } } while (0)
+#define CKPL(kind, st) \
+  do { if ((size_t)((char *)pl-(char *)D->kind##labels) >= D->kind##size) { \
+    D->status = DASM_S_RANGE_##st|(p-D->actionlist-1); return; } } while (0)
+#else
+#define CK(x, st)	((void)0)
+#define CKPL(kind, st)	((void)0)
+#endif
+
+/* Pass 1: Store actions and args, link branches/labels, estimate offsets. */
+void dasm_put(Dst_DECL, int start, ...)
+{
+  va_list ap;
+  dasm_State *D = Dst_REF;
+  dasm_ActList p = D->actionlist + start;
+  dasm_Section *sec = D->section;
+  int pos = sec->pos, ofs = sec->ofs;
+  int *b;
+
+  if (pos >= sec->epos) {
+    DASM_M_GROW(Dst, int, sec->buf, sec->bsize,
+                sec->bsize + 2 * DASM_MAXSECPOS * sizeof(int));
+    sec->rbuf = sec->buf - DASM_POS2BIAS(pos);
+    sec->epos =
+      (int)sec->bsize / sizeof(int) - DASM_MAXSECPOS + DASM_POS2BIAS(pos);
+  }
+
+  b = sec->rbuf;
+  b[pos++] = start;
+
+  va_start(ap, start);
+  while (1) {
+    unsigned short ins = *p++;
+    unsigned short action = ins;
+    if (action >= DASM__MAX) {
+      ofs += 2;
+      continue;
+    }
+
+    int *pl, n = action >= DASM_REL_PC ? va_arg(ap, int) : 0;
+    switch (action) {
+    case DASM_STOP:
+      goto stop;
+    case DASM_SECTION:
+      n = *p++ & 255;
+      CK(n < D->maxsection, RANGE_SEC);
+      D->section = &D->sections[n];
+      goto stop;
+    case DASM_ESC:
+      p++;
+      ofs += 2;
+      break;
+    case DASM_REL_EXT:
+      p++;
+      ofs += 4;
+      break;
+    case DASM_ALIGN:
+      ofs += *p++;
+      b[pos++] = ofs;
+      break;
+    case DASM_REL_LG:
+      if (p[-2] >> 12 == 0xc) { /* RIL instruction needs 32-bit immediate. */
+        ofs += 2;
+      }
+      n = *p++ - 10;
+      pl = D->lglabels + n;
+      /* Bkwd rel or global. */
+      if (n >= 0) {
+        CK(n >= 10 || *pl < 0, RANGE_LG);
+        CKPL(lg, LG);
+        goto putrel;
+      }
+      pl += 10;
+      n = *pl;
+      if (n < 0)
+        n = 0;                  /* Start new chain for fwd rel if label exists. */
+      goto linkrel;
+    case DASM_REL_PC:
+      if (p[-2] >> 12 == 0xc) { /* RIL instruction needs 32-bit immediate. */
+        ofs += 2;
+      }
+      pl = D->pclabels + n;
+      CKPL(pc, PC);
+    putrel:
+      n = *pl;
+      if (n < 0) {              /* Label exists. Get label pos and store it. */
+        b[pos] = -n;
+      } else {
+      linkrel:
+        b[pos] = n;             /* Else link to rel chain, anchored at label. */
+        *pl = pos;
+      }
+      ofs += 2;
+      pos++;
+      break;
+    case DASM_LABEL_LG:
+      pl = D->lglabels + *p++ - 10;
+      CKPL(lg, LG);
+      goto putlabel;
+    case DASM_LABEL_PC:
+      pl = D->pclabels + n;
+      CKPL(pc, PC);
+    putlabel:
+      n = *pl;                  /* n > 0: Collapse rel chain and replace with label pos. */
+      while (n > 0) {
+        int *pb = DASM_POS2PTR(D, n);
+        n = *pb;
+        *pb = pos;
+      }
+      *pl = -pos;               /* Label exists now. */
+      b[pos++] = ofs;           /* Store pass1 offset estimate. */
+      break;
+    case DASM_IMM8:
+      b[pos++] = n;
+      break;
+    case DASM_IMM16:
+      CK(((short)n) == n || ((unsigned short)n) == n, RANGE_I);     /* TODO: is this the right way to handle unsigned immediates? */
+      ofs += 2;
+      b[pos++] = n;
+      break;
+    case DASM_IMM32:
+      ofs += 4;
+      b[pos++] = n;
+      break;
+    case DASM_DISP20:
+      CK(-(1 << 19) <= n && n < (1 << 19), RANGE_I);
+      b[pos++] = n;
+      break;
+    case DASM_DISP12:
+      CK((n >> 12) == 0, RANGE_I);
+      b[pos++] = n;
+      break;
+    case DASM_LEN8R:
+      CK(n >= 1 && n <= 256, RANGE_I);
+      b[pos++] = n;
+      break;
+    case DASM_LEN4HR:
+    case DASM_LEN4LR:
+      CK(n >= 1 && n <= 128, RANGE_I);
+      b[pos++] = n;
+      break;
+    }
+  }
+stop:
+  va_end(ap);
+  sec->pos = pos;
+  sec->ofs = ofs;
+}
+
+#undef CK
+
+/* Pass 2: Link sections, shrink aligns, fix label offsets. */
+int dasm_link(Dst_DECL, size_t * szp)
+{
+  dasm_State *D = Dst_REF;
+  int secnum;
+  int ofs = 0;
+
+#ifdef DASM_CHECKS
+  *szp = 0;
+  if (D->status != DASM_S_OK)
+    return D->status;
+  {
+    int pc;
+    for (pc = 0; pc * sizeof(int) < D->pcsize; pc++)
+      if (D->pclabels[pc] > 0)
+        return DASM_S_UNDEF_PC | pc;
+  }
+#endif
+
+  {                             /* Handle globals not defined in this translation unit. */
+    int idx;
+    for (idx = 20; idx * sizeof(int) < D->lgsize; idx++) {
+      int n = D->lglabels[idx];
+      /* Undefined label: Collapse rel chain and replace with marker (< 0). */
+      while (n > 0) {
+        int *pb = DASM_POS2PTR(D, n);
+        n = *pb;
+        *pb = -idx;
+      }
+    }
+  }
+
+  /* Combine all code sections. No support for data sections (yet). */
+  for (secnum = 0; secnum < D->maxsection; secnum++) {
+    dasm_Section *sec = D->sections + secnum;
+    int *b = sec->rbuf;
+    int pos = DASM_SEC2POS(secnum);
+    int lastpos = sec->pos;
+
+    while (pos != lastpos) {
+      dasm_ActList p = D->actionlist + b[pos++];
+      while (1) {
+        unsigned short ins = *p++;
+        unsigned short action = ins;
+        switch (action) {
+        case DASM_STOP:
+        case DASM_SECTION:
+          goto stop;
+        case DASM_ESC:
+          p++;
+          break;
+        case DASM_REL_EXT:
+          p++;
+          break;
+        case DASM_ALIGN:
+          ofs -= (b[pos++] + ofs) & *p++;
+          break;
+        case DASM_REL_LG:
+        case DASM_REL_PC:
+          p++;
+          pos++;
+          break;
+        case DASM_LABEL_LG:
+        case DASM_LABEL_PC:
+          p++;
+          b[pos++] += ofs;
+          break;
+        case DASM_IMM8:
+        case DASM_IMM16:
+        case DASM_IMM32:
+        case DASM_DISP20:
+        case DASM_DISP12:
+        case DASM_LEN8R:
+        case DASM_LEN4HR:
+        case DASM_LEN4LR:
+          pos++;
+          break;
+        }
+      }
+    stop:(void)0;
+    }
+    ofs += sec->ofs;            /* Next section starts right after current section. */
+  }
+
+  D->codesize = ofs;            /* Total size of all code sections */
+  *szp = ofs;
+  return DASM_S_OK;
+}
+
+#ifdef DASM_CHECKS
+#define CK(x, st) \
+  do { if (!(x)) return DASM_S_##st|(p-D->actionlist-1); } while (0)
+#else
+#define CK(x, st)	((void)0)
+#endif
+
+/* Pass 3: Encode sections. */
+int dasm_encode(Dst_DECL, void *buffer)
+{
+  dasm_State *D = Dst_REF;
+  char *base = (char *)buffer;
+  unsigned short *cp = (unsigned short *)buffer;
+  int secnum;
+
+  /* Encode all code sections. No support for data sections (yet). */
+  for (secnum = 0; secnum < D->maxsection; secnum++) {
+    dasm_Section *sec = D->sections + secnum;
+    int *b = sec->buf;
+    int *endb = sec->rbuf + sec->pos;
+
+    while (b != endb) {
+      dasm_ActList p = D->actionlist + *b++;
+      while (1) {
+        unsigned short ins = *p++;
+        unsigned short action = ins;
+        int n = (action >= DASM_ALIGN && action < DASM__MAX) ? *b++ : 0;
+        switch (action) {
+        case DASM_STOP:
+        case DASM_SECTION:
+          goto stop;
+        case DASM_ESC:
+          *cp++ = *p++;
+          break;
+        case DASM_REL_EXT:
+          n = DASM_EXTERN(Dst, (unsigned char *)cp, *p++, 1) - 4;
+          goto patchrel;
+        case DASM_ALIGN:
+          ins = *p++;
+          /* TODO: emit 4-byte noprs instead of 2-byte nops where possible. */
+          while ((((char *)cp - base) & ins))
+            *cp++ = 0x0700;     /* nop */
+          break;
+        case DASM_REL_LG:
+          CK(n >= 0, UNDEF_LG);
+        case DASM_REL_PC:
+          CK(n >= 0, UNDEF_PC);
+          n = *DASM_POS2PTR(D, n) - (int)((char *)cp - base);
+          p++;                  /* skip argument */
+        patchrel:
+          /* Offsets are halfword aligned (so need to be halved). */
+          n += 2;               /* Offset is relative to start of instruction. */
+          if (cp[-1] >> 12 == 0xc) {
+            *cp++ = n >> 17;
+          } else {
+            CK(-(1 << 16) <= n && n < (1 << 16) && (n & 1) == 0, RANGE_LG);
+          }
+          *cp++ = n >> 1;
+          break;
+        case DASM_LABEL_LG:
+          ins = *p++;
+          if (ins >= 20)
+            D->globals[ins - 20] = (void *)(base + n);
+          break;
+        case DASM_LABEL_PC:
+          break;
+        case DASM_IMM8:
+          cp[-1] |= n & 0xff;  
+          break;
+        case DASM_IMM16:
+          *cp++ = n;
+          break;
+        case DASM_IMM32:
+          *cp++ = n >> 16;
+          *cp++ = n;
+          break;
+        case DASM_DISP20:
+          cp[-2] |= n & 0xfff;
+          cp[-1] |= (n >> 4) & 0xff00;
+          break;
+        case DASM_DISP12:
+          cp[-1] |= n & 0xfff;
+          break;
+        case DASM_LEN8R:
+          cp[-1] |= (n - 1) & 0xff;
+          break;
+        case DASM_LEN4HR:
+          cp[-1] |= ((n - 1) << 4) & 0xf0;
+          break;
+        case DASM_LEN4LR:
+          cp[-1] |= (n - 1) & 0x0f;
+          break;
+        default:
+          *cp++ = ins;
+          break;
+        }
+      }
+    stop:(void)0;
+    }
+  }
+
+  if (base + D->codesize != (char *)cp) /* Check for phase errors. */
+    return DASM_S_PHASE;
+  return DASM_S_OK;
+}
+
+#undef CK
+
+/* Get PC label offset. */
+int dasm_getpclabel(Dst_DECL, unsigned int pc)
+{
+  dasm_State *D = Dst_REF;
+  if (pc * sizeof(int) < D->pcsize) {
+    int pos = D->pclabels[pc];
+    if (pos < 0)
+      return *DASM_POS2PTR(D, -pos);
+    if (pos > 0)
+      return -1;                /* Undefined. */
+  }
+  return -2;                    /* Unused or out of range. */
+}
+
+#ifdef DASM_CHECKS
+/* Optional sanity checker to call between isolated encoding steps. */
+int dasm_checkstep(Dst_DECL, int secmatch)
+{
+  dasm_State *D = Dst_REF;
+  if (D->status == DASM_S_OK) {
+    int i;
+    for (i = 1; i <= 9; i++) {
+      if (D->lglabels[i] > 0) {
+        D->status = DASM_S_UNDEF_LG | i;
+        break;
+      }
+      D->lglabels[i] = 0;
+    }
+  }
+  if (D->status == DASM_S_OK && secmatch >= 0 &&
+      D->section != &D->sections[secmatch])
+    D->status = DASM_S_MATCH_SEC | (D->section - D->sections);
+  return D->status;
+}
+#endif
+
diff --git a/lib/luajit2/dynasm/dasm_s390x.lua b/lib/luajit2/dynasm/dasm_s390x.lua
new file mode 100644
index 000000000..772f029a3
--- /dev/null
+++ b/lib/luajit2/dynasm/dasm_s390x.lua
@@ -0,0 +1,1633 @@
+------------------------------------------------------------------------------
+-- DynASM s390x module.
+--
+-- Copyright (C) 2005-2017 Mike Pall. All rights reserved.
+-- See dynasm.lua for full copyright notice.
+------------------------------------------------------------------------------
+
+-- Module information:
+local _info = {
+  arch =	"s390x",
+  description =	"DynASM s390x module",
+  version =	"1.4.0",
+  vernum =	 10400,
+  release =	"2015-10-18",
+  author =	"Mike Pall",
+  license =	"MIT",
+}
+
+-- Exported glue functions for the arch-specific module.
+local _M = { _info = _info }
+
+-- Cache library functions.
+local type, tonumber, pairs, ipairs = type, tonumber, pairs, ipairs
+local assert, setmetatable, rawget = assert, setmetatable, rawget
+local _s = string
+local sub, format, byte, char = _s.sub, _s.format, _s.byte, _s.char
+local match, gmatch, gsub = _s.match, _s.gmatch, _s.gsub
+local concat, sort, insert = table.concat, table.sort, table.insert
+local bit = bit or require("bit")
+local band, shl, shr, sar = bit.band, bit.lshift, bit.rshift, bit.arshift
+local ror, tohex = bit.ror, bit.tohex
+
+-- Inherited tables and callbacks.
+local g_opt, g_arch
+local wline, werror, wfatal, wwarn
+
+-- Action name list.
+-- CHECK: Keep this in sync with the C code!
+local action_names = {
+  "STOP", "SECTION", "ESC", "REL_EXT",
+  "ALIGN", "REL_LG", "LABEL_LG",
+  "REL_PC", "LABEL_PC", "DISP12", "DISP20", "IMM8", "IMM16", "IMM32", "LEN8R","LEN4HR","LEN4LR",
+}
+
+-- Maximum number of section buffer positions for dasm_put().
+-- CHECK: Keep this in sync with the C code!
+local maxsecpos = 25 -- Keep this low, to avoid excessively long C lines.
+
+-- Action name -> action number.
+local map_action = {}
+local max_action = 0
+for n, name in ipairs(action_names) do
+  map_action[name] = n-1
+  max_action = n
+end
+
+-- Action list buffer.
+local actlist = {}
+
+-- Argument list for next dasm_put(). Start with offset 0 into action list.
+local actargs = { 0 }
+
+-- Current number of section buffer positions for dasm_put().
+local secpos = 1
+
+------------------------------------------------------------------------------
+
+-- Dump action names and numbers.
+local function dumpactions(out)
+  out:write("DynASM encoding engine action codes:\n")
+  for n, name in ipairs(action_names) do
+    local num = map_action[name]
+    out:write(format("  %-10s %02X  %d\n", name, num, num))
+  end
+  out:write("\n")
+end
+
+local function havearg(a)
+  return a == "ESC" or
+         a == "SECTION" or
+         a == "REL_LG" or
+         a == "LABEL_LG" or
+         a == "REL_EXT"
+end
+
+-- Write action list buffer as a huge static C array.
+local function writeactions(out, name)
+  local nn = #actlist
+  if nn == 0 then nn = 1; actlist[0] = map_action.STOP end
+  out:write("static const unsigned short ", name, "[", nn, "] = {")
+  local esc = false -- also need to escape for action arguments
+  for i = 1, nn do
+    assert(out:write("\n  0x", sub(tohex(actlist[i]), 5, 8)))
+    if i ~= nn then assert(out:write(",")) end
+    local name = action_names[actlist[i]+1]
+    if not esc and name then
+      assert(out:write(" /* ", name, " */"))
+      esc = havearg(name)
+    else
+      esc = false
+    end
+  end
+  assert(out:write("\n};\n\n"))
+end
+
+------------------------------------------------------------------------------
+
+-- Add halfword to action list.
+local function wputxhw(n)
+  assert(n >= 0 and n <= 0xffff, "halfword out of range")
+  actlist[#actlist+1] = n
+end
+
+-- Add action to list with optional arg. Advance buffer pos, too.
+local function waction(action, val, a, num)
+  local w = assert(map_action[action], "bad action name `"..action.."'")
+  wputxhw(w)
+  if val then wputxhw(val) end -- Not sure about this, do we always have one arg?
+  if a then actargs[#actargs+1] = a end
+  if val or a or num then secpos = secpos + (num or 1) end
+end
+
+-- Flush action list (intervening C code or buffer pos overflow).
+local function wflush(term)
+  if #actlist == actargs[1] then return end -- Nothing to flush.
+  if not term then waction("STOP") end -- Terminate action list.
+  wline(format("dasm_put(Dst, %s);", concat(actargs, ", ")), true)
+  actargs = { #actlist } -- Actionlist offset is 1st arg to next dasm_put().
+  secpos = 1 -- The actionlist offset occupies a buffer position, too.
+end
+
+-- Put escaped halfword.
+local function wputhw(n)
+  if n <= max_action then waction("ESC") end
+  wputxhw(n)
+end
+
+-- Reserve position for halfword.
+local function wpos()
+  local pos = #actlist+1
+  actlist[pos] = ""
+  return pos
+end
+
+------------------------------------------------------------------------------
+
+-- Global label name -> global label number. With auto assignment on 1st use.
+local next_global = 20
+local map_global = setmetatable({}, { __index = function(t, name)
+  if not match(name, "^[%a_][%w_]*$") then werror("bad global label") end
+  local n = next_global
+  if n > 2047 then werror("too many global labels") end
+  next_global = n + 1
+  t[name] = n
+  return n
+end})
+
+-- Dump global labels.
+local function dumpglobals(out, lvl)
+  local t = {}
+  for name, n in pairs(map_global) do t[n] = name end
+  out:write("Global labels:\n")
+  for i=20, next_global-1 do
+    out:write(format("  %s\n", t[i]))
+  end
+  out:write("\n")
+end
+
+-- Write global label enum.
+local function writeglobals(out, prefix)
+  local t = {}
+  for name, n in pairs(map_global) do t[n] = name end
+  out:write("enum {\n")
+  for i=20, next_global-1 do
+    out:write("  ", prefix, t[i], ",\n")
+  end
+  out:write("  ", prefix, "_MAX\n};\n")
+end
+
+-- Write global label names.
+local function writeglobalnames(out, name)
+  local t = {}
+  for name, n in pairs(map_global) do t[n] = name end
+  out:write("static const char *const ", name, "[] = {\n")
+  for i=20, next_global-1 do
+    out:write("  \"", t[i], "\",\n")
+  end
+  out:write("  (const char *)0\n};\n")
+end
+
+------------------------------------------------------------------------------
+
+-- Extern label name -> extern label number. With auto assignment on 1st use.
+local next_extern = 0
+local map_extern_ = {}
+local map_extern = setmetatable({}, { __index = function(t, name)
+  -- No restrictions on the name for now.
+  local n = next_extern
+  if n > 2047 then werror("too many extern labels") end
+  next_extern = n + 1
+  t[name] = n
+  map_extern_[n] = name
+  return n
+end})
+
+-- Dump extern labels.
+local function dumpexterns(out, lvl)
+  out:write("Extern labels:\n")
+  for i=0, next_extern-1 do
+    out:write(format("  %s\n", map_extern_[i]))
+  end
+  out:write("\n")
+end
+
+-- Write extern label names.
+local function writeexternnames(out, name)
+  out:write("static const char *const ", name, "[] = {\n")
+  for i=0, next_extern-1 do
+    out:write("  \"", map_extern_[i], "\",\n")
+  end
+  out:write("  (const char *)0\n};\n")
+end
+
+------------------------------------------------------------------------------
+
+-- Arch-specific maps.
+-- Ext. register name -> int. name.
+local map_archdef = { sp = "r15" }
+
+-- Int. register name -> ext. name.
+local map_reg_rev = { r15 = "sp" }
+
+local map_type = {}		-- Type name -> { ctype, reg }
+local ctypenum = 0		-- Type number (for Dt... macros).
+
+-- Reverse defines for registers.
+function _M.revdef(s)
+  return map_reg_rev[s] or s
+end
+
+local map_cond = {
+  o = 1, h = 2, nle = 3, l = 4,
+  nhe = 5, lh = 6, ne = 7, e = 8,
+  nlh = 9, he = 10, nl = 11, le = 12,
+  nh = 13, no = 14, [""] = 15,
+}
+
+------------------------------------------------------------------------------
+
+local function parse_reg(expr)
+  if not expr then werror("expected register name") end
+  local tname, ovreg = match(expr, "^([%w_]+):(r1?%d)$")
+  local tp = map_type[tname or expr]
+  if tp then
+    local reg = ovreg or tp.reg
+    if not reg then
+      werror("type `"..(tname or expr).."' needs a register override")
+    end
+    expr = reg
+  end
+  local r = match(expr, "^[rf](1?%d)$")
+  if r then
+    r = tonumber(r)
+    if r <= 15 then return r, tp end
+  end
+  werror("bad register name `"..expr.."'")
+end
+
+local parse_ctx = {}
+
+local loadenv = setfenv and function(s)
+  local code = loadstring(s, "")
+  if code then setfenv(code, parse_ctx) end
+  return code
+end or function(s)
+  return load(s, "", nil, parse_ctx)
+end
+
+-- Try to parse simple arithmetic, too, since some basic ops are aliases.
+local function parse_number(n)
+  local x = tonumber(n)
+  if x then return x end
+  local code = loadenv("return "..n)
+  if code then
+    local ok, y = pcall(code)
+    if ok then return y end
+  end
+  return nil
+end
+
+local function is_uint12(num)
+  return 0 <= num and num < 4096
+end
+
+local function is_int20(num)
+  return -shl(1, 19) <= num and num < shl(1, 19)
+end
+
+local function is_int32(num)
+  return -2147483648 <= num and num < 2147483648
+end
+
+local function is_uint16(num)
+  return 0 <= num and num < 0xffff
+end
+
+local function is_int16(num)
+  return -32768 <= num and num < 32768
+end
+
+local function is_int8(num)
+  return -128 <= num and num < 128
+end
+
+local function is_uint8(num)
+  return 0 <= num and num < 256
+end
+
+-- Split a memory operand of the form d(b) or d(x,b) into d, x and b.
+-- If x is not specified then it is 0.
+local function split_memop(arg)
+  local reg = "[%w_:]+"
+  local d, x, b = match(arg, "^(.*)%(%s*("..reg..")%s*,%s*("..reg..")%s*%)$")
+  if d then
+    return d, parse_reg(x), parse_reg(b)
+  end
+  local d, b = match(arg, "^(.*)%(%s*("..reg..")%s*%)$")
+  if d then
+    return d, 0, parse_reg(b)
+  end
+  -- Assume the two registers are passed as "(r1,r2)", and displacement(d) is not specified. TODO: not sure if we want to do this, GAS doesn't.
+  local x, b = match(arg,"%(%s*("..reg..")%s*,%s*("..reg..")%s*%)$")
+  if b then
+    return 0, parse_reg(x), parse_reg(b)
+  end
+  -- Accept a lone integer as a displacement. TODO: allow expressions/variables here? Interacts badly with the other rules currently.
+  local d = match(arg,"^(-?[%d]+)$")
+  if d then
+    return d, 0, 0
+  end
+  local reg, tailr = match(arg, "^([%w_:]+)%s*(.*)$")
+  if reg then
+    local r, tp = parse_reg(reg)
+    if tp then
+      return format(tp.ctypefmt, tailr), 0, r
+    end
+  end
+  werror("bad memory operand: "..arg)
+  return nil
+end
+
+-- Parse memory operand of the form d(x, b) where 0 <= d < 4096 and b and x
+-- are GPRs.
+-- If the fourth return value is not-nil then it needs to be called to
+-- insert an action.
+-- Encoded as: xbddd
+local function parse_mem_bx(arg)
+  local d, x, b = split_memop(arg)
+  local dval = tonumber(d)
+  if dval then
+    if not is_uint12(dval) then
+      werror("displacement out of range: ", dval)
+    end
+    return dval, x, b, nil
+  end
+  if match(d, "^[rf]1?[0-9]?") then
+    werror("expected immediate operand, got register")
+  end
+  return 0, x, b, function() waction("DISP12", nil, d) end
+end
+
+-- Parse memory operand of the form d(b) where 0 <= d < 4096 and b is a GPR.
+-- Encoded as: bddd
+local function parse_mem_b(arg)
+  local d, x, b, a = parse_mem_bx(arg)
+  if x ~= 0 then
+    werror("unexpected index register")
+  end
+  return d, b, a
+end
+
+-- Parse memory operand of the form d(x, b) where -(2^20)/2 <= d < (2^20)/2
+-- and b and x are GPRs.
+-- Encoded as: xblllhh (ls are the low-bits of d, and hs are the high bits).
+local function parse_mem_bxy(arg)
+  local d, x, b = split_memop(arg)
+  local dval = tonumber(d)
+  if dval then
+    if not is_int20(dval) then
+      werror("displacement out of range: ", dval)
+    end
+    return dval, x, b, nil
+  end
+  if match(d, "^[rf]1?[0-9]?") then
+    werror("expected immediate operand, got register")
+  end
+  return 0, x, b, function() waction("DISP20", nil, d) end
+end
+
+-- Parse memory operand of the form d(b) where -(2^20)/2 <= d < (2^20)/2 and
+-- b is a GPR.
+-- Encoded as: blllhh (ls are the low-bits of d, and hs are the high bits).
+local function parse_mem_by(arg)
+  local d, x, b, a = parse_mem_bxy(arg)
+  if x ~= 0 then
+    werror("unexpected index register")
+  end
+  return d, b, a
+end
+
+-- Parse memory operand of the form d(l, b) where 0 <= d < 4096, 1 <= l <= 256,
+-- and b is a GPR.
+local function parse_mem_lb(arg)
+  local reg = "r1?[0-9]"
+  local d, l, b = match(arg, "^(.*)%s*%(%s*(.*)%s*,%s*("..reg..")%s*%)$")
+  if not d then
+    -- TODO: handle values without registers?
+    -- TODO: handle registers without a displacement?
+    werror("bad memory operand: "..arg)
+    return nil
+  end
+  local dval = tonumber(d)
+  local dact = nil
+  if dval then
+    if not is_uint12(dval) then
+      werror("displacement out of range: ", dval)
+    end
+  else
+    dval = 0
+    dact = function() waction("DISP12", nil, d) end
+  end
+  local lval = tonumber(l)
+  local lact = nil
+  if lval then
+    if lval < 1 or lval > 256 then
+      werror("length out of range: ", dval)
+    end
+    lval = lval - 1
+  else
+    lval = 0
+    lact = function() waction("LEN8R", nil, l) end
+  end
+  return dval, lval, parse_reg(b), dact, lact
+end
+
+local function parse_mem_l2b(arg, high_l)
+  local reg = "r1?[0-9]"
+  local d, l, b = match(arg, "^(.*)%s*%(%s*(.*)%s*,%s*("..reg..")%s*%)$")
+  if not d then
+    -- TODO: handle values without registers?
+    -- TODO: handle registers without a displacement?
+    werror("bad memory operand: "..arg)
+    return nil
+  end
+  local dval = tonumber(d)
+  local dact = nil
+  if dval then
+    if not is_uint12(dval) then
+      werror("displacement out of range: ", dval)
+    end
+  else
+    dval = 0
+    dact = function() waction("DISP12", nil, d) end
+  end
+  local lval = tonumber(l)
+  local lact = nil
+  if lval then
+    if lval < 1 or lval > 128 then
+      werror("length out of range: ", dval)
+    end
+    lval = lval - 1
+  else
+    lval = 0
+    if high_l then
+    lact = function() waction("LEN4HR", nil, l) end
+    else
+    lact = function() waction("LEN4LR", nil, l) end
+    end
+  end
+  return dval, lval, parse_reg(b), dact, lact
+end
+
+local function parse_imm32(imm)
+  local imm_val = tonumber(imm)
+  if imm_val then
+    if not is_int32(imm_val) then
+      werror("immediate value out of range: ", imm_val)
+    end
+    wputhw(band(shr(imm_val, 16), 0xffff))
+    wputhw(band(imm_val, 0xffff))
+  elseif match(imm, "^[rfv]([1-3]?[0-9])$") or
+	 match(imm, "^([%w_]+):(r1?[0-9])$") then
+    werror("expected immediate operand, got register")
+  else
+    waction("IMM32", nil, imm) -- if we get label
+  end
+end
+
+local function parse_imm16(imm)
+  local imm_val = tonumber(imm)
+  if imm_val then
+    if not is_int16(imm_val) and not is_uint16(imm_val) then
+      werror("immediate value out of range: ", imm_val)
+    end
+    wputhw(band(imm_val, 0xffff))
+  elseif match(imm, "^[rfv]([1-3]?[0-9])$") or
+	 match(imm, "^([%w_]+):(r1?[0-9])$") then
+    werror("expected immediate operand, got register")
+  else
+    waction("IMM16", nil, imm)
+  end
+end
+
+local function parse_imm8(imm)
+  local imm_val = tonumber(imm)
+  if imm_val then
+    if not is_int8(imm_val) and not is_uint8(imm_val) then
+      werror("Immediate value out of range: ", imm_val)
+    end
+    return imm_val, nil
+  end
+  return 0, function() waction("IMM8", nil, imm) end
+end
+
+local function parse_mask(mask)
+  local m3 = parse_number(mask)
+  if m3 then
+    if ((m3 == 1) or (m3 == 0) or ( m3 >=3 and m3 <=7)) then
+      return m3
+    else
+      werror("Mask value should be 0,1 or 3-7: ", m3)
+    end
+  end
+end
+
+local function parse_mask2(mask)
+  local m4 = parse_number(mask)
+  if ( m4 >=0 and m4 <=1) then
+    return m4
+  else
+    werror("Mask value should be 0 or 1: ", m4)
+  end
+end
+
+local function parse_label(label, def)
+  local prefix = sub(label, 1, 2)
+  -- =>label (pc label reference)
+  if prefix == "=>" then
+    return "PC", 0, sub(label, 3)
+  end
+  -- ->name (global label reference)
+  if prefix == "->" then
+    return "LG", map_global[sub(label, 3)]
+  end
+  if def then
+    -- [1-9] (local label definition)
+    if match(label, "^[1-9]$") then
+      return "LG", 10+tonumber(label)
+    end
+  else
+    -- [<>][1-9] (local label reference)
+    local dir, lnum = match(label, "^([<>])([1-9])$")
+    if dir then -- Fwd: 1-9, Bkwd: 11-19.
+      return "LG", lnum + (dir == ">" and 0 or 10)
+    end
+    -- extern label (extern label reference)
+    local extname = match(label, "^extern%s+(%S+)$")
+    if extname then
+      return "EXT", map_extern[extname]
+    end
+  end
+  werror("bad label `"..label.."'")
+end
+
+------------------------------------------------------------------------------
+
+local map_op, op_template
+
+local function op_alias(opname, f)
+  return function(params, nparams)
+    if not params then return "-> "..opname:sub(1, -3) end
+    f(params, nparams)
+    op_template(params, map_op[opname], nparams)
+  end
+end
+
+-- Template strings for s390x instructions.
+map_op = {
+  a_2 =		"00005a000000RX-a",
+  ad_2 =	"00006a000000RX-a",
+  adb_2 =	"ed000000001aRXE",
+  adbr_2 =	"0000b31a0000RRE",
+  adr_2 =	"000000002a00RR",
+  ae_2 =	"00007a000000RX-a",
+  aeb_2 =	"ed000000000aRXE",
+  aebr_2 =	"0000b30a0000RRE",
+  aer_2 =	"000000003a00RR",
+  afi_2 =	"c20900000000RIL-a",
+  ag_2 =	"e30000000008RXY-a",
+  agf_2 =	"e30000000018RXY-a",
+  agfi_2 =	"c20800000000RIL-a",
+  agfr_2 =	"0000b9180000RRE",
+  aghi_2 =	"0000a70b0000RI-a",
+  agr_2 =	"0000b9080000RRE",
+  ah_2 =	"00004a000000RX-a",
+  ahi_2 =	"0000a70a0000RI-a",
+  ahy_2 =	"e3000000007aRXY-a",
+  aih_2 =	"cc0800000000RIL-a",
+  al_2 =	"00005e000000RX-a",
+  alc_2 =	"e30000000098RXY-a",
+  alcg_2 =	"e30000000088RXY-a",
+  alcgr_2 =	"0000b9880000RRE",
+  alcr_2 =	"0000b9980000RRE",
+  alfi_2 =	"c20b00000000RIL-a",
+  alg_2 =	"e3000000000aRXY-a",
+  algf_2 =	"e3000000001aRXY-a",
+  algfi_2 =	"c20a00000000RIL-a",
+  algfr_2 =	"0000b91a0000RRE",
+  algr_2 =	"0000b90a0000RRE",
+  alr_2 =	"000000001e00RR",
+  alsih_2 =	"cc0a00000000RIL-a",
+  alsihn_2 =	"cc0b00000000RIL-a",
+  aly_2 =	"e3000000005eRXY-a",
+  ap_2 =	"fa0000000000SS-b",
+  ar_2 =	"000000001a00RR",
+  au_2 =	"00007e000000RX-a",
+  aur_2 =	"000000003e00RR",
+  aw_2 =	"00006e000000RX-a",
+  awr_2 =	"000000002e00RR",
+  axbr_2 =	"0000b34a0000RRE",
+  axr_2 =	"000000003600RR",
+  ay_2 =	"e3000000005aRXY-a",
+  bakr_2 =	"0000b2400000RRE",
+  bal_2 =	"000045000000RX-a",
+  balr_2 =	"000000000500RR",
+  bas_2 =	"00004d000000RX-a",
+  basr_2 =	"000000000d00RR",
+  bassm_2 =	"000000000c00RR",
+  bc_2 =	"000047000000RX-b",
+  bcr_2 =	"000000000700RR",
+  bct_2 =	"000046000000RX-a",
+  bctg_2 =	"e30000000046RXY-a",
+  bctgr_2 =	"0000b9460000RRE",
+  bctr_2 =	"000000000600RR",
+  bras_2 =	"0000a7050000RI-b",
+  brasl_2 =	"c00500000000RIL-b",
+  brc_2 =	"0000a7040000RI-c",
+  brcl_2 =	"c00400000000RIL-c",
+  brct_2 =	"0000a7060000RI-b",
+  brctg_2 =	"0000a7070000RI-b",
+  brcth_2 =	"cc0600000000RIL-b",
+  brxh_3 =	"000084000000RSI",
+  brxhg_3 =	"ec0000000044RIE-e",
+  bsa_2 =	"0000b25a0000RRE",
+  bsg_2 =	"0000b2580000RRE",
+  bsm_2 =	"000000000b00RR",
+  bxh_3 =	"000086000000RS-a",
+  bxhg_3 =	"eb0000000044RSY-a",
+  bxle_3 =	"000087000000RS-a",
+  bxleg_3 =	"eb0000000045RSY-a",
+  c_2 =		"000059000000RX-a",
+  cd_2 =	"000069000000RX-a",
+  cdb_2 =	"ed0000000019RXE",
+  cdbr_2 =	"0000b3190000RRE",
+  cdfbr_2 =	"0000b3950000RRE",
+  cdfbra_4 =	"0000b3950000RRF-e",
+  cdfr_2 =	"0000b3b50000RRE",
+  cdftr_2 =	"0000b9510000RRE",
+  cdgbr_2 =	"0000b3a50000RRE",
+  cdgbra_4 =	"0000b3a50000RRF-e",
+  cdgr_2 =	"0000b3c50000RRE",
+  cdgtr_2 =	"0000b3f10000RRE",
+  cdr_2 =	"000000002900RR",
+  cds_3 =	"0000bb000000RS-a",
+  cdsg_3 =	"eb000000003eRSY-a",
+  cdstr_2 =	"0000b3f30000RRE",
+  cdsy_3 =	"eb0000000031RSY-a",
+  cdtr_2 =	"0000b3e40000RRE",
+  cdutr_2 =	"0000b3f20000RRE",
+  ce_2 =	"000079000000RX-a",
+  ceb_2 =	"ed0000000009RXE",
+  cebr_2 =	"0000b3090000RRE",
+  cedtr_2 =	"0000b3f40000RRE",
+  cefbr_2 =	"0000b3940000RRE",
+  cefbra_4 =	"0000b3940000RRF-e",
+  cefr_2 =	"0000b3b40000RRE",
+  cegbr_2 =	"0000b3a40000RRE",
+  cegbra_4 =	"0000b3a40000RRF-e",
+  cegr_2 =	"0000b3c40000RRE",
+  cer_2 =	"000000003900RR",
+  cextr_2 =	"0000b3fc0000RRE",
+  cfdbr_3 =	"0000b3990000RRF-e",
+  cfdbra_4 =	"0000b3990000RRF-e",
+  cfebr_3 =	"0000b3980000RRF-e",
+  cfebra_4 =	"0000b3980000RRF-e",
+  cfi_2 =	"c20d00000000RIL-a",
+  cfxbr_3 =	"0000b39a0000RRF-e",
+  cfxbra_4 =	"0000b39a0000RRF-e",
+  cg_2 =	"e30000000020RXY-a",
+  cgdbr_3 =	"0000b3a90000RRF-e",
+  cgdbra_4 =	"0000b3a90000RRF-e",
+  cgebr_3 =	"0000b3a80000RRF-e",
+  cgebra_4 =	"0000b3a80000RRF-e",
+  cgf_2 =	"e30000000030RXY-a",
+  cgfi_2 =	"c20c00000000RIL-a",
+  cgfr_2 =	"0000b9300000RRE",
+  cgfrl_2 =	"c60c00000000RIL-b",
+  cgh_2 =	"e30000000034RXY-a",
+  cghi_2 =	"0000a70f0000RI-a",
+  cghrl_2 =	"c60400000000RIL-b",
+  cgr_2 =	"0000b9200000RRE",
+  cgrl_2 =	"c60800000000RIL-b",
+  cgxbr_3 =	"0000b3aa0000RRF-e",
+  cgxbra_4 =	"0000b3aa0000RRF-e",
+  ch_2 =	"000049000000RX-a",
+  chf_2 =	"e300000000cdRXY-a",
+  chhr_2 =	"0000b9cd0000RRE",
+  chi_2 =	"0000a70e0000RI-a",
+  chlr_2 =	"0000b9dd0000RRE",
+  chrl_2 =	"c60500000000RIL-b",
+  chy_2 =	"e30000000079RXY-a",
+  cih_2 =	"cc0d00000000RIL-a",
+  cksm_2 =	"0000b2410000RRE",
+  cl_2 =	"000055000000RX-a",
+  clc_2 =	"d50000000000SS-a",
+  clcl_2 =	"000000000f00RR",
+  clcle_3 =	"0000a9000000RS-a",
+  clclu_3 =	"eb000000008fRSY-a",
+  clfi_2 =	"c20f00000000RIL-a",
+  clg_2 =	"e30000000021RXY-a",
+  clgf_2 =	"e30000000031RXY-a",
+  clgfi_2 =	"c20e00000000RIL-a",
+  clgfr_2 =	"0000b9310000RRE",
+  clgfrl_2 =	"c60e00000000RIL-b",
+  clghrl_2 =	"c60600000000RIL-b",
+  clgr_2 =	"0000b9210000RRE",
+  clgrl_2 =	"c60a00000000RIL-b",
+  clhf_2 =	"e300000000cfRXY-a",
+  clhhr_2 =	"0000b9cf0000RRE",
+  clhlr_2 =	"0000b9df0000RRE",
+  clhrl_2 =	"c60700000000RIL-b",
+  cli_2 =	"000095000000SI",
+  clih_2 =	"cc0f00000000RIL-a",
+  clm_3 =	"0000bd000000RS-b",
+  clmh_3 =	"eb0000000020RSY-b",
+  clmy_3 =	"eb0000000021RSY-b",
+  clr_2 =	"000000001500RR",
+  clrl_2 =	"c60f00000000RIL-b",
+  clst_2 =	"0000b25d0000RRE",
+  cly_2 =	"e30000000055RXY-a",
+  cmpsc_2 =	"0000b2630000RRE",
+  cpya_2 =	"0000b24d0000RRE",
+  cr_2 =	"000000001900RR",
+  crl_2 =	"c60d00000000RIL-b",
+  cs_3 =	"0000ba000000RS-a",
+  csg_3 =	"eb0000000030RSY-a",
+  csp_2 =	"0000b2500000RRE",
+  cspg_2 =	"0000b98a0000RRE",
+  csy_3 =	"eb0000000014RSY-a",
+  cu41_2 =	"0000b9b20000RRE",
+  cu42_2 =	"0000b9b30000RRE",
+  cudtr_2 =	"0000b3e20000RRE",
+  cuse_2 =	"0000b2570000RRE",
+  cuxtr_2 =	"0000b3ea0000RRE",
+  cvb_2 =	"00004f000000RX-a",
+  cvbg_2 =	"e3000000000eRXY-a",
+  cvby_2 =	"e30000000006RXY-a",
+  cvd_2 =	"00004e000000RX-a",
+  cvdg_2 =	"e3000000002eRXY-a",
+  cvdy_2 =	"e30000000026RXY-a",
+  cxbr_2 =	"0000b3490000RRE",
+  cxfbr_2 =	"0000b3960000RRE",
+  cxfbra_4 =	"0000b3960000RRF-e",
+  cxfr_2 =	"0000b3b60000RRE",
+  cxftr_2 =	"0000b9590000RRE",
+  cxgbr_2 =	"0000b3a60000RRE",
+  cxgbra_4 =	"0000b3a60000RRF-e",
+  cxgr_2 =	"0000b3c60000RRE",
+  cxgtr_2 =	"0000b3f90000RRE",
+  cxr_2 =	"0000b3690000RRE",
+  cxstr_2 =	"0000b3fb0000RRE",
+  cxtr_2 =	"0000b3ec0000RRE",
+  cxutr_2 =	"0000b3fa0000RRE",
+  cy_2 =	"e30000000059RXY-a",
+  d_2 =		"00005d000000RX-a",
+  dd_2 =	"00006d000000RX-a",
+  ddb_2 =	"ed000000001dRXE",
+  ddbr_2 =	"0000b31d0000RRE",
+  ddr_2 =	"000000002d00RR",
+  de_2 =	"00007d000000RX-a",
+  deb_2 =	"ed000000000dRXE",
+  debr_2 =	"0000b30d0000RRE",
+  der_2 =	"000000003d00RR",
+  didbr_4 =	"0000b35b0000RRF-b",
+  dl_2 =	"e30000000097RXY-a",
+  dlg_2 =	"e30000000087RXY-a",
+  dlgr_2 =	"0000b9870000RRE",
+  dlr_2 =	"0000b9970000RRE",
+  dr_2 =	"000000001d00RR",
+  dsg_2 =	"e3000000000dRXY-a",
+  dsgf_2 =	"e3000000001dRXY-a",
+  dsgfr_2 =	"0000b91d0000RRE",
+  dsgr_2 =	"0000b90d0000RRE",
+  dxbr_2 =	"0000b34d0000RRE",
+  dxr_2 =	"0000b22d0000RRE",
+  ear_2 =	"0000b24f0000RRE",
+  ecag_3 =	"eb000000004cRSY-a",
+  ed_2 =	"de0000000000SS-a",
+  edmk_2 =	"df0000000000SS-a",
+  eedtr_2 =	"0000b3e50000RRE",
+  eextr_2 =	"0000b3ed0000RRE",
+  efpc_2 =	"0000b38c0000RRE",
+  epair_2 =	"0000b99a0000RRE",
+  epar_2 =	"0000b2260000RRE",
+  epsw_2 =	"0000b98d0000RRE",
+  ereg_2 =	"0000b2490000RRE",
+  eregg_2 =	"0000b90e0000RRE",
+  esair_2 =	"0000b99b0000RRE",
+  esar_2 =	"0000b2270000RRE",
+  esdtr_2 =	"0000b3e70000RRE",
+  esea_2 =	"0000b99d0000RRE",
+  esta_2 =	"0000b24a0000RRE",
+  esxtr_2 =	"0000b3ef0000RRE",
+  ex_2 =	"000044000000RX-a",
+  exrl_2 =	"c60000000000RIL-b",
+  fidbra_4 =	"0000b35f0000RRF-e",
+  fidr_2 =	"0000b37f0000RRE",
+  fier_2 =	"0000b3770000RRE",
+  fixr_2 =	"0000b3670000RRE",
+  flogr_2 =	"0000b9830000RRE",
+  hdr_2 =	"000000002400RR",
+  her_2 =	"000000003400RR",
+  iac_2 =	"0000b2240000RRE",
+  ic_2 =	"000043000000RX-a",
+  icm_3 =	"0000bf000000RS-b",
+  icmh_3 =	"eb0000000080RSY-b",
+  icmy_3 =	"eb0000000081RSY-b",
+  icy_2 =	"e30000000073RXY-a",
+  iihf_2 =	"c00800000000RIL-a",
+  iihh_2 =	"0000a5000000RI-a",
+  iihl_2 =	"0000a5010000RI-a",
+  iilf_2 =	"c00900000000RIL-a",
+  iilh_2 =	"0000a5020000RI-a",
+  iill_2 =	"0000a5030000RI-a",
+  ipm_2 =	"0000b2220000RRE",
+  iske_2 =	"0000b2290000RRE",
+  ivsk_2 =	"0000b2230000RRE",
+  kdbr_2 =	"0000b3180000RRE",
+  kdtr_2 =	"0000b3e00000RRE",
+  kebr_2 =	"0000b3080000RRE",
+  kimd_2 =	"0000b93e0000RRE",
+  klmd_2 =	"0000b93f0000RRE",
+  km_2 =	"0000b92e0000RRE",
+  kmac_2 =	"0000b91e0000RRE",
+  kmc_2 =	"0000b92f0000RRE",
+  kmf_2 =	"0000b92a0000RRE",
+  kmo_2 =	"0000b92b0000RRE",
+  kxbr_2 =	"0000b3480000RRE",
+  kxtr_2 =	"0000b3e80000RRE",
+  l_2 =		"000058000000RX-a",
+  la_2 =	"000041000000RX-a",
+  laa_3 =	"eb00000000f8RSY-a",
+  laag_3 =	"eb00000000e8RSY-a",
+  laal_3 =	"eb00000000faRSY-a",
+  laalg_3 =	"eb00000000eaRSY-a",
+  lae_2 =	"000051000000RX-a",
+  laey_2 =	"e30000000075RXY-a",
+  lam_3 =	"00009a000000RS-a",
+  lamy_3 =	"eb000000009aRSY-a",
+  lan_3 =	"eb00000000f4RSY-a",
+  lang_3 =	"eb00000000e4RSY-a",
+  lao_3 =	"eb00000000f6RSY-a",
+  laog_3 =	"eb00000000e6RSY-a",
+  larl_2 =	"c00000000000RIL-b",
+  lax_3 =	"eb00000000f7RSY-a",
+  laxg_3 =	"eb00000000e7RSY-a",
+  lay_2 =	"e30000000071RXY-a",
+  lb_2 =	"e30000000076RXY-a",
+  lbh_2 =	"e300000000c0RXY-a",
+  lbr_2 =	"0000b9260000RRE",
+  lcdbr_2 =	"0000b3130000RRE",
+  lcdfr_2 =	"0000b3730000RRE",
+  lcdr_2 =	"000000002300RR",
+  lcebr_2 =	"0000b3030000RRE",
+  lcer_2 =	"000000003300RR",
+  lcgfr_2 =	"0000b9130000RRE",
+  lcgr_2 =	"0000b9030000RRE",
+  lcr_2 =	"000000001300RR",
+  lctl_3 =	"0000b7000000RS-a",
+  lctlg_3 =	"eb000000002fRSY-a",
+  lcxbr_2 =	"0000b3430000RRE",
+  lcxr_2 =	"0000b3630000RRE",
+  ld_2 =	"000068000000RX-a",
+  ldebr_2 =	"0000b3040000RRE",
+  lder_2 =	"0000b3240000RRE",
+  ldgr_2 =	"0000b3c10000RRE",
+  ldr_2 =	"000000002800RR",
+  ldxbr_2 =	"0000b3450000RRE",
+  ldxr_2 =	"000000002500RR",
+  ldy_2 =	"ed0000000065RXY-a",
+  le_2 =	"000078000000RX-a",
+  ledbr_2 =	"0000b3440000RRE",
+  ledr_2 =	"000000003500RR",
+  ler_2 =	"000000003800RR",
+  lexbr_2 =	"0000b3460000RRE",
+  lexr_2 =	"0000b3660000RRE",
+  ley_2 =	"ed0000000064RXY-a",
+  lfh_2 =	"e300000000caRXY-a",
+  lg_2 =	"e30000000004RXY-a",
+  lgb_2 =	"e30000000077RXY-a",
+  lgbr_2 =	"0000b9060000RRE",
+  lgdr_2 =	"0000b3cd0000RRE",
+  lgf_2 =	"e30000000014RXY-a",
+  lgfi_2 =	"c00100000000RIL-a",
+  lgfr_2 =	"0000b9140000RRE",
+  lgfrl_2 =	"c40c00000000RIL-b",
+  lgh_2 =	"e30000000015RXY-a",
+  lghi_2 =	"0000a7090000RI-a",
+  lghr_2 =	"0000b9070000RRE",
+  lghrl_2 =	"c40400000000RIL-b",
+  lgr_2 =	"0000b9040000RRE",
+  lgrl_2 =	"c40800000000RIL-b",
+  lh_2 =	"000048000000RX-a",
+  lhh_2 =	"e300000000c4RXY-a",
+  lhi_2 =	"0000a7080000RI-a",
+  lhr_2 =	"0000b9270000RRE",
+  lhrl_2 =	"c40500000000RIL-b",
+  lhy_2 =	"e30000000078RXY-a",
+  llc_2 =	"e30000000094RXY-a",
+  llch_2 =	"e300000000c2RXY-a",
+  llcr_2 =	"0000b9940000RRE",
+  llgc_2 =	"e30000000090RXY-a",
+  llgcr_2 =	"0000b9840000RRE",
+  llgf_2 =	"e30000000016RXY-a",
+  llgfr_2 =	"0000b9160000RRE",
+  llgfrl_2 =	"c40e00000000RIL-b",
+  llgh_2 =	"e30000000091RXY-a",
+  llghr_2 =	"0000b9850000RRE",
+  llghrl_2 =	"c40600000000RIL-b",
+  llgt_2 =	"e30000000017RXY-a",
+  llgtr_2 =	"0000b9170000RRE",
+  llh_2 =	"e30000000095RXY-a",
+  llhh_2 =	"e300000000c6RXY-a",
+  llhr_2 =	"0000b9950000RRE",
+  llhrl_2 =	"c40200000000RIL-b",
+  llihf_2 =	"c00e00000000RIL-a",
+  llihh_2 =	"0000a50c0000RI-a",
+  llihl_2 =	"0000a50d0000RI-a",
+  llilf_2 =	"c00f00000000RIL-a",
+  llilh_2 =	"0000a50e0000RI-a",
+  llill_2 =	"0000a50f0000RI-a",
+  lm_3 =	"000098000000RS-a",
+  lmg_3 =	"eb0000000004RSY-a",
+  lmh_3 =	"eb0000000096RSY-a",
+  lmy_3 =	"eb0000000098RSY-a",
+  lndbr_2 =	"0000b3110000RRE",
+  lndfr_2 =	"0000b3710000RRE",
+  lndr_2 =	"000000002100RR",
+  lnebr_2 =	"0000b3010000RRE",
+  lner_2 =	"000000003100RR",
+  lngfr_2 =	"0000b9110000RRE",
+  lngr_2 =	"0000b9010000RRE",
+  lnr_2 =	"000000001100RR",
+  lnxbr_2 =	"0000b3410000RRE",
+  lnxr_2 =	"0000b3610000RRE",
+  loc_3 =	"eb00000000f2RSY-b",
+  locg_3 =	"eb00000000e2RSY-b",
+  lpdbr_2 =	"0000b3100000RRE",
+  lpdfr_2 =	"0000b3700000RRE",
+  lpdr_2 =	"000000002000RR",
+  lpebr_2 =	"0000b3000000RRE",
+  lper_2 =	"000000003000RR",
+  lpgfr_2 =	"0000b9100000RRE",
+  lpgr_2 =	"0000b9000000RRE",
+  lpq_2 =	"e3000000008fRXY-a",
+  lpr_2 =	"000000001000RR",
+  lpxbr_2 =	"0000b3400000RRE",
+  lpxr_2 =	"0000b3600000RRE",
+  lr_2 =	"000000001800RR",
+  lra_2 =	"0000b1000000RX-a",
+  lrag_2 =	"e30000000003RXY-a",
+  lray_2 =	"e30000000013RXY-a",
+  lrdr_2 =	"000000002500RR",
+  lrer_2 =	"000000003500RR",
+  lrl_2 =	"c40d00000000RIL-b",
+  lrv_2 =	"e3000000001eRXY-a",
+  lrvg_2 =	"e3000000000fRXY-a",
+  lrvgr_2 =	"0000b90f0000RRE",
+  lrvh_2 =	"e3000000001fRXY-a",
+  lrvr_2 =	"0000b91f0000RRE",
+  lt_2 =	"e30000000012RXY-a",
+  ltdbr_2 =	"0000b3120000RRE",
+  ltdr_2 =	"000000002200RR",
+  ltdtr_2 =	"0000b3d60000RRE",
+  ltebr_2 =	"0000b3020000RRE",
+  lter_2 =	"000000003200RR",
+  ltg_2 =	"e30000000002RXY-a",
+  ltgf_2 =	"e30000000032RXY-a",
+  ltgfr_2 =	"0000b9120000RRE",
+  ltgr_2 =	"0000b9020000RRE",
+  ltr_2 =	"000000001200RR",
+  ltxbr_2 =	"0000b3420000RRE",
+  ltxr_2 =	"0000b3620000RRE",
+  ltxtr_2 =	"0000b3de0000RRE",
+  lura_2 =	"0000b24b0000RRE",
+  lurag_2 =	"0000b9050000RRE",
+  lxdbr_2 =	"0000b3050000RRE",
+  lxdr_2 =	"0000b3250000RRE",
+  lxebr_2 =	"0000b3060000RRE",
+  lxer_2 =	"0000b3260000RRE",
+  lxr_2 =	"0000b3650000RRE",
+  ly_2 =	"e30000000058RXY-a",
+  lzdr_2 =	"0000b3750000RRE",
+  lzer_2 =	"0000b3740000RRE",
+  lzxr_2 =	"0000b3760000RRE",
+  m_2 =		"00005c000000RX-a",
+  madb_3 =	"ed000000001eRXF",
+  maeb_3 =	"ed000000000eRXF",
+  maebr_3 =	"0000b30e0000RRD",
+  maer_3 =	"0000b32e0000RRD",
+  md_2 =	"00006c000000RX-a",
+  mdb_2 =	"ed000000001cRXE",
+  mdbr_2 =	"0000b31c0000RRE",
+  mde_2 =	"00007c000000RX-a",
+  mdeb_2 =	"ed000000000cRXE",
+  mdebr_2 =	"0000b30c0000RRE",
+  mder_2 =	"000000003c00RR",
+  mdr_2 =	"000000002c00RR",
+  me_2 =	"00007c000000RX-a",
+  meeb_2 =	"ed0000000017RXE",
+  meebr_2 =	"0000b3170000RRE",
+  meer_2 =	"0000b3370000RRE",
+  mer_2 =	"000000003c00RR",
+  mfy_2 =	"e3000000005cRXY-a",
+  mghi_2 =	"0000a70d0000RI-a",
+  mh_2 =	"00004c000000RX-a",
+  mhi_2 =	"0000a70c0000RI-a",
+  mhy_2 =	"e3000000007cRXY-a",
+  ml_2 =	"e30000000096RXY-a",
+  mlg_2 =	"e30000000086RXY-a",
+  mlgr_2 =	"0000b9860000RRE",
+  mlr_2 =	"0000b9960000RRE",
+  mr_2 =	"000000001c00RR",
+  ms_2 =	"000071000000RX-a",
+  msfi_2 =	"c20100000000RIL-a",
+  msg_2 =	"e3000000000cRXY-a",
+  msgf_2 =	"e3000000001cRXY-a",
+  msgfi_2 =	"c20000000000RIL-a",
+  msgfr_2 =	"0000b91c0000RRE",
+  msgr_2 =	"0000b90c0000RRE",
+  msr_2 =	"0000b2520000RRE",
+  msta_2 =	"0000b2470000RRE",
+  msy_2 =	"e30000000051RXY-a",
+  mvc_2 =	"d20000000000SS-a",
+  mvcin_2 =	"e80000000000SS-a",
+  mvcl_2 =	"000000000e00RR",
+  mvcle_3 =	"0000a8000000RS-a",
+  mvclu_3 =	"eb000000008eRSY-a",
+  mvghi_2 =	"e54800000000SIL",
+  mvhhi_2 =	"e54400000000SIL",
+  mvhi_2 =	"e54c00000000SIL",
+  mvi_2 =	"000092000000SI",
+  mvn_2 =	"d10000000000SS-a",
+  mvpg_2 =	"0000b2540000RRE",
+  mvst_2 =	"0000b2550000RRE",
+  mvz_2 =	"d30000000000SS-a",
+  mxbr_2 =	"0000b34c0000RRE",
+  mxd_2 =	"000067000000RX-a",
+  mxdb_2 =	"ed0000000007RXE",
+  mxdbr_2 =	"0000b3070000RRE",
+  mxdr_2 =	"000000002700RR",
+  mxr_2 =	"000000002600RR",
+  n_2 =		"000054000000RX-a",
+  nc_2 =	"d40000000000SS-a",
+  ng_2 =	"e30000000080RXY-a",
+  ngr_2 =	"0000b9800000RRE",
+  ni_2 =	"000094000000SI",
+  nihf_2 =	"c00a00000000RIL-a",
+  nihh_2 =	"0000a5040000RI-a",
+  nihl_2 =	"0000a5050000RI-a",
+  nilf_2 =	"c00b00000000RIL-a",
+  nilh_2 =	"0000a5060000RI-a",
+  nill_2 =	"0000a5070000RI-a",
+  nr_2 =	"000000001400RR",
+  ny_2 =	"e30000000054RXY-a",
+  o_2 =		"000056000000RX-a",
+  oc_2 =	"d60000000000SS-a",
+  og_2 =	"e30000000081RXY-a",
+  ogr_2 =	"0000b9810000RRE",
+  oi_2 =	"000096000000SI",
+  oihf_2 =	"c00c00000000RIL-a",
+  oihh_2 =	"0000a5080000RI-a",
+  oihl_2 =	"0000a5090000RI-a",
+  oilf_2 =	"c00d00000000RIL-a",
+  oilh_2 =	"0000a50a0000RI-a",
+  oill_2 =	"0000a50b0000RI-a",
+  or_2 =	"000000001600RR",
+  oy_2 =	"e30000000056RXY-a",
+  palb_2 =	"0000b2480000RRE",
+  pcc_2 =	"0000b92c0000RRE",
+  pckmo_2 =	"0000b9280000RRE",
+  pfd_2 =	"e30000000036m",
+  pfdrl_2 =	"c60200000000RIL-c",
+  pfmf_2 =	"0000b9af0000RRE",
+  pgin_2 =	"0000b22e0000RRE",
+  pgout_2 =	"0000b22f0000RRE",
+  popcnt_2 =	"0000b9e10000RRE",
+  pt_2 =	"0000b2280000RRE",
+  ptf_2 =	"0000b9a20000RRE",
+  pti_2 =	"0000b99e0000RRE",
+  rll_3 =	"eb000000001dRSY-a",
+  rllg_3 =	"eb000000001cRSY-a",
+  rrbe_2 =	"0000b22a0000RRE",
+  rrbm_2 =	"0000b9ae0000RRE",
+  s_2 =		"00005b000000RX-a",
+  sar_2 =	"0000b24e0000RRE",
+  sd_2 =	"00006b000000RX-a",
+  sdb_2 =	"ed000000001bRXE",
+  sdbr_2 =	"0000b31b0000RRE",
+  sdr_2 =	"000000002b00RR",
+  se_2 =	"00007b000000RX-a",
+  seb_2 =	"ed000000000bRXE",
+  sebr_2 =	"0000b30b0000RRE",
+  ser_2 =	"000000003b00RR",
+  sfasr_2 =	"0000b3850000RRE",
+  sfpc_2 =	"0000b3840000RRE",
+  sg_2 =	"e30000000009RXY-a",
+  sgf_2 =	"e30000000019RXY-a",
+  sgfr_2 =	"0000b9190000RRE",
+  sgr_2 =	"0000b9090000RRE",
+  sh_2 =	"00004b000000RX-a",
+  shy_2 =	"e3000000007bRXY-a",
+  sl_2 =	"00005f000000RX-a",
+  sla_2 =	"00008b000000RS-a",
+  slag_3 =	"eb000000000bRSY-a",
+  slak_3 =	"eb00000000ddRSY-a",
+  slb_2 =	"e30000000099RXY-a",
+  slbg_2 =	"e30000000089RXY-a",
+  slbgr_2 =	"0000b9890000RRE",
+  slbr_2 =	"0000b9990000RRE",
+  slda_2 =	"00008f000000RS-a",
+  sldl_2 =	"00008d000000RS-a",
+  slfi_2 =	"c20500000000RIL-a",
+  slg_2 =	"e3000000000bRXY-a",
+  slgf_2 =	"e3000000001bRXY-a",
+  slgfi_2 =	"c20400000000RIL-a",
+  slgfr_2 =	"0000b91b0000RRE",
+  slgr_2 =	"0000b90b0000RRE",
+  sll_2 =	"000089000000RS-a",
+  sllg_3 =	"eb000000000dRSY-a",
+  sllk_3 =	"eb00000000dfRSY-a",
+  slr_2 =	"000000001f00RR",
+  sly_2 =	"e3000000005fRXY-a",
+  spm_2 =	"000000000400RR",
+  sqdb_2 =	"ed0000000015RXE",
+  sqdbr_2 =	"0000b3150000RRE",
+  sqdr_2 =	"0000b2440000RRE",
+  sqeb_2 =	"ed0000000014RXE",
+  sqebr_2 =	"0000b3140000RRE",
+  sqer_2 =	"0000b2450000RRE",
+  sqxbr_2 =	"0000b3160000RRE",
+  sqxr_2 =	"0000b3360000RRE",
+  sr_2 =	"000000001b00RR",
+  sra_2 =	"00008a000000RS-a",
+  srag_3 =	"eb000000000aRSY-a",
+  srak_3 =	"eb00000000dcRSY-a",
+  srda_2 =	"00008e000000RS-a",
+  srdl_2 =	"00008c000000RS-a",
+  srl_2 =	"000088000000RS-a",
+  srlg_3 =	"eb000000000cRSY-a",
+  srlk_3 =	"eb00000000deRSY-a",
+  srst_2 =	"0000b25e0000RRE",
+  srstu_2 =	"0000b9be0000RRE",
+  ssair_2 =	"0000b99f0000RRE",
+  ssar_2 =	"0000b2250000RRE",
+  st_2 =	"000050000000RX-a",
+  stam_3 =	"00009b000000RS-a",
+  stamy_3 =	"eb000000009bRSY-a",
+  stc_2 =	"000042000000RX-a",
+  stch_2 =	"e300000000c3RXY-a",
+  stcm_3 =	"0000be000000RS-b",
+  stcmh_3 =	"eb000000002cRSY-b",
+  stcmy_3 =	"eb000000002dRSY-b",
+  stctg_3 =	"eb0000000025RSY-a",
+  stctl_3 =	"0000b6000000RS-a",
+  stcy_2 =	"e30000000072RXY-a",
+  std_2 =	"000060000000RX-a",
+  stdy_2 =	"ed0000000067RXY-a",
+  ste_2 =	"000070000000RX-a",
+  stey_2 =	"ed0000000066RXY-a",
+  stfh_2 =	"e300000000cbRXY-a",
+  stfl_1 =	"0000b2b10000S",
+  stg_2 =	"e30000000024RXY-a",
+  stgrl_2 =	"c40b00000000RIL-b",
+  sth_2 =	"000040000000RX-a",
+  sthh_2 =	"e300000000c7RXY-a",
+  sthrl_2 =	"c40700000000RIL-b",
+  sthy_2 =	"e30000000070RXY-a",
+  stm_3 =	"000090000000RS-a",
+  stmg_3 =	"eb0000000024RSY-a",
+  stmh_3 =	"eb0000000026RSY-a",
+  stmy_3 =	"eb0000000090RSY-a",
+  stoc_3 =	"eb00000000f3RSY-b",
+  stocg_3 =	"eb00000000e3RSY-b",
+  stpq_2 =	"e3000000008eRXY-a",
+  strl_2 =	"c40f00000000RIL-b",
+  strv_2 =	"e3000000003eRXY-a",
+  strvg_2 =	"e3000000002fRXY-a",
+  strvh_2 =	"e3000000003fRXY-a",
+  stura_2 =	"0000b2460000RRE",
+  sturg_2 =	"0000b9250000RRE",
+  sty_2 =	"e30000000050RXY-a",
+  su_2 =	"00007f000000RX-a",
+  sur_2 =	"000000003f00RR",
+  svc_1 =	"000000000a00I",
+  sw_2 =	"00006f000000RX-a",
+  swr_2 =	"000000002f00RR",
+  sxbr_2 =	"0000b34b0000RRE",
+  sxr_2 =	"000000003700RR",
+  sy_2 =	"e3000000005bRXY-a",
+  tar_2 =	"0000b24c0000RRE",
+  tb_2 =	"0000b22c0000RRE",
+  thder_2 =	"0000b3580000RRE",
+  thdr_2 =	"0000b3590000RRE",
+  tm_2 =	"000091000000SI",
+  tmhh_2 =	"0000a7020000RI-a",
+  tmhl_2 =	"0000a7030000RI-a",
+  tmlh_2 =	"0000a7000000RI-a",
+  tmll_2 =	"0000a7010000RI-a",
+  tmy_2 =	"eb0000000051SIY",
+  tr_2 =	"dc0000000000SS-a",
+  trace_3 =	"000099000000RS-a",
+  tracg_3 =	"eb000000000fRSY-a",
+  tre_2 =	"0000b2a50000RRE",
+  trt_2 =	"dd0000000000SS-a",
+  trtr_2 =	"d00000000000SS-a",
+  unpka_2 =	"ea0000000000SS-a",
+  unpku_2 =	"e20000000000SS-a",
+  x_2 =		"000057000000RX-a",
+  xc_2 =	"d70000000000SS-a",
+  xg_2 =	"e30000000082RXY-a",
+  xgr_2 =	"0000b9820000RRE",
+  xi_2 =	"000097000000SI",
+  xihf_2 =	"c00600000000RIL-a",
+  xilf_2 =	"c00700000000RIL-a",
+  xr_2 =	"000000001700RR",
+  xy_2 =	"e30000000057RXY-a",
+}
+for cond, c in pairs(map_cond) do
+  -- Extended mnemonics for branches.
+  -- TODO: replace 'B' with correct encoding.
+  -- brc
+  map_op["j"..cond.."_1"] = "0000"..tohex(0xa7040000+shl(c, 20)).."RI-c"
+  -- brcl
+  map_op["jg"..cond.."_1"] = tohex(0xc0040000+shl(c, 20)).."0000".."RIL-c"
+  -- bc
+  map_op["b"..cond.."_1"] = "0000"..tohex(0x47000000+shl(c, 20)).."RX-b"
+  -- bcr
+  map_op["b"..cond.."r_1"] = "0000"..tohex(0x0700+shl(c, 4)).."RR"
+end
+------------------------------------------------------------------------------
+-- Handle opcodes defined with template strings.
+local function parse_template(params, template, nparams, pos)
+  -- Read the template in 16-bit chunks.
+  -- Leading halfword zeroes should not be written out.
+  local op0 = tonumber(sub(template, 1, 4), 16)
+  local op1 = tonumber(sub(template, 5, 8), 16)
+  local op2 = tonumber(sub(template, 9, 12), 16)
+
+  -- Process each character.
+  local p = sub(template, 13)
+  if p == "I" then
+    local imm_val, a = parse_imm8(params[1])
+    op2 = op2 + imm_val
+    wputhw(op2)
+    if a then a() end
+  elseif p == "RI-a" then
+    op1 = op1 + shl(parse_reg(params[1]), 4)
+    wputhw(op1)
+    parse_imm16(params[2])
+  elseif p == "RI-b" then
+    op1 = op1 + shl(parse_reg(params[1]), 4)
+    wputhw(op1)
+    local mode, n, s = parse_label(params[2])
+    waction("REL_"..mode, n, s)
+  elseif p == "RI-c" then
+    if #params > 1 then
+      op1 = op1 + shl(parse_num(params[1]), 4)
+    end
+    wputhw(op1)
+    local mode, n, s = parse_label(params[#params])
+    waction("REL_"..mode, n, s)
+  elseif p == "RIE-e" then
+    op0 = op0 + shl(parse_reg(params[1]), 4) + parse_reg(params[2])
+    wputhw1(op0)
+    local mode, n, s = parse_label(params[3])
+    waction("REL_"..mode, n, s)
+    wputhw(op2)
+  elseif p == "RIL-a" then
+    op0 = op0 + shl(parse_reg(params[1]), 4)
+    wputhw(op0);
+    parse_imm32(params[2])
+  elseif p == "RIL-b" then
+    op0 = op0 + shl(parse_reg(params[1]), 4)
+    wputhw(op0)
+    local mode, n, s = parse_label(params[2])
+    waction("REL_"..mode, n, s)
+  elseif p == "RIL-c" then
+    if #params > 1 then
+      op0 = op0 + shl(parse_num(params[1]), 4)
+    end
+    wputhw(op0)
+    local mode, n, s = parse_label(params[#params])
+    waction("REL_"..mode, n, s)
+  elseif p == "RR" then
+    if #params > 1 then
+      op2 = op2 + shl(parse_reg(params[1]), 4)
+    end
+    op2 = op2 + parse_reg(params[#params])
+    wputhw(op2)
+  elseif p == "RRD" then
+    wputhw(op1)
+    op2 = op2 + shl(parse_reg(params[1]), 12) + shl(parse_reg(params[2]), 4) + parse_reg(params[3])
+    wputhw(op2)
+  elseif p == "RRE" then
+    op2 = op2 + shl(parse_reg(params[1]), 4) + parse_reg(params[2])
+    wputhw(op1); wputhw(op2)
+  elseif p == "RRF-b" then
+    wputhw(op1)
+    op2 = op2 + shl(parse_reg(params[1]), 4) + shl(parse_reg(params[2]), 12) + parse_reg(params[3]) + shl(parse_mask(params[4]), 8)
+    wputhw(op2)
+  elseif p == "RRF-e" then
+    wputhw(op1)
+    op2 = op2 + shl(parse_reg(params[1]), 4) + shl(parse_mask(params[2]), 12) + parse_reg(params[3])
+    if params[4] then
+      op2 = op2 + shl(parse_mask2(params[4]), 8)
+    end
+    wputhw(op2)
+  elseif p == "RS-a" then
+    if (params[3]) then
+      local d, b, a = parse_mem_b(params[3])
+      op1 = op1 + shl(parse_reg(params[1]), 4) + parse_reg(params[2])
+      op2 = op2 + shl(b, 12) + d
+    else
+      local d, b, a = parse_mem_b(params[2])
+      op1 = op1 + shl(parse_reg(params[1]), 4)
+      op2 = op2 + shl(b, 12) + d
+    end
+    wputhw(op1); wputhw(op2)
+    if a then a() end
+  elseif p == "RS-b" then
+    local m = parse_mask(params[2])
+    local d, b, a = parse_mem_b(params[3])
+    op1 = op1 + shl(parse_reg(params[1]), 4) + m
+    op2 = op2 + shl(b, 12) + d
+    wputhw(op1); wputhw(op2)
+    if a then a() end
+  elseif p == "RSI" then
+    op1 = op1 + shl(parse_reg(params[1]), 4) + parse_reg(params[2])
+    wputhw(op1)
+    local mode, n, s = parse_label(params[3])
+    waction("REL_"..mode, n, s)
+  elseif p == "RSY-a" then
+    local d, b, a = parse_mem_by(params[3])
+    op0 = op0 + shl(parse_reg(params[1]), 4) + parse_reg(params[2])
+    op1 = op1 + shl(b, 12) + band(d, 0xfff)
+    op2 = op2 + band(shr(d, 4), 0xff00)
+    wputhw(op0); wputhw(op1); wputhw(op2)
+    if a then a() end -- a() emits action.
+  elseif p == "RX-a" then
+    local d, x, b, a = parse_mem_bx(params[2])
+    op1 = op1 + shl(parse_reg(params[1]), 4) + x
+    op2 = op2 + shl(b, 12) + d
+    wputhw(op1); wputhw(op2)
+    if a then a() end
+  elseif p == "RX-b" then
+    local d, x, b, a = parse_mem_bx(params[#params])
+    if #params > 1 then
+      op1 = op1 + shl(parse_num(params[1]), 4)
+    end
+    op1 = op1 + x
+    op2 = op2 + shl(b, 12) + d
+    wputhw(op1); wputhw(op2)
+    if a then a() end
+  elseif p == "RXE" then
+    local d, x, b, a = parse_mem_bx(params[2])
+    op0 = op0 + shl(parse_reg(params[1]), 4) + x
+    op1 = op1 + shl(b, 12) + d
+    wputhw(op0); wputhw(op1)
+    if a then a() end
+    wputhw(op2);
+  elseif p == "RXF" then
+    local d, x, b, a = parse_mem_bx(params[3])
+    op0 = op0 + shl(parse_reg(params[2]), 4) + x
+    op1 = op1 + shl(b, 12) + d
+    wputhw(op0); wputhw(op1)
+    if a then a() end
+    op2 = op2 + shl(parse_reg(params[1]), 12)
+    wputhw(op2)
+  elseif p == "RXY-a" then
+    local d, x, b, a = parse_mem_bxy(params[2])
+    op0 = op0 + shl(parse_reg(params[1]), 4) + x
+    op1 = op1 + shl(b, 12) + band(d, 0xfff)
+    op2 = op2 + band(shr(d, 4), 0xff00)
+    wputhw(op0); wputhw(op1); wputhw(op2)
+    if a then a() end
+  elseif p == "S" then
+    wputhw(op1);
+    local d, b, a = parse_mem_b(params[1])
+    op2 = op2 + shl(b, 12) + d
+    wputhw(op2)
+    if a then a() end
+  elseif p == "SI" then
+    local imm_val, a = parse_imm8(params[2])
+    op1 = op1 + imm_val
+    wputhw(op1)
+    if a then a() end
+    local d, b, a = parse_mem_b(params[1])
+    op2 = op2 + shl(b, 12) + d
+    wputhw(op2)
+    if a then a() end
+  elseif p == "SIL" then
+    wputhw(op0)
+    local d, b, a = parse_mem_b(params[1])
+    op1 = op1 + shl(b, 12) + d
+    wputhw(op1)
+    if a then a() end
+    parse_imm16(params[2])
+  elseif p == "SIY" then
+    local imm8, iact = parse_imm8(params[2])
+    op0 = op0 + shl(imm8, 8)
+    wputhw(op0)
+    if iact then iact() end
+    local d, b, a = parse_mem_by(params[1])
+    op1 = op1 + shl(b, 12) + band(d, 0xfff)
+    op2 = op2 + band(shr(d, 4), 0xff00)
+    wputhw(op1); wputhw(op2)
+    if a then a() end
+  elseif p == "SS-a" then
+    local d1, l1, b1, d1a, l1a = parse_mem_lb(params[1])
+    local d2, b2, d2a = parse_mem_b(params[2])
+    op0 = op0 + l1
+    op1 = op1 + shl(b1, 12) + d1
+    op2 = op2 + shl(b2, 12) + d2
+    wputhw(op0)
+    if l1a then l1a() end
+    wputhw(op1)
+    if d1a then d1a() end
+    wputhw(op2)
+    if d2a then d2a() end
+  elseif p == "SS-b" then
+    local high_l = true
+    local d1, l1, b1, d1a, l1a = parse_mem_l2b(params[1], high_l)
+    high_l = false
+    local d2, l2, b2, d2a, l2a = parse_mem_l2b(params[2], high_l)
+    op0 = op0 + shl(l1, 4) + l2
+    op1 = op1 + shl(b1, 12) + d1
+    op2 = op2 + shl(b2, 12) + d2
+    wputhw(op0)
+    if l1a then l1a() end
+    if l2a then l2a() end
+    wputhw(op1)
+    if d1a then d1a() end
+    wputhw(op2)
+    if d2a then d2a() end
+  else
+    werror("unrecognized encoding")
+  end
+end
+
+function op_template(params, template, nparams)
+  if not params then return template:gsub("%x%x%x%x%x%x%x%x%x%x%x%x", "") end
+  -- Limit number of section buffer positions used by a single dasm_put().
+  -- A single opcode needs a maximum of 5 positions.
+  if secpos+5 > maxsecpos then wflush() end
+  local lpos, apos, spos = #actlist, #actargs, secpos
+  local ok, err
+  for t in gmatch(template, "[^|]+") do
+    ok, err = pcall(parse_template, params, t, nparams)
+    if ok then return end
+    secpos = spos
+    actlist[lpos+1] = nil
+    actlist[lpos+2] = nil
+    actlist[lpos+3] = nil
+    actargs[apos+1] = nil
+    actargs[apos+2] = nil
+    actargs[apos+3] = nil
+  end
+  error(err, 0)
+end
+map_op[".template__"] = op_template
+------------------------------------------------------------------------------
+-- Pseudo-opcode to mark the position where the action list is to be emitted.
+map_op[".actionlist_1"] = function(params)
+  if not params then return "cvar" end
+  local name = params[1] -- No syntax check. You get to keep the pieces.
+  wline(function(out) writeactions(out, name) end)
+end
+-- Pseudo-opcode to mark the position where the global enum is to be emitted.
+map_op[".globals_1"] = function(params)
+  if not params then return "prefix" end
+  local prefix = params[1] -- No syntax check. You get to keep the pieces.
+  wline(function(out) writeglobals(out, prefix) end)
+end
+-- Pseudo-opcode to mark the position where the global names are to be emitted.
+map_op[".globalnames_1"] = function(params)
+  if not params then return "cvar" end
+  local name = params[1] -- No syntax check. You get to keep the pieces.
+  wline(function(out) writeglobalnames(out, name) end)
+end
+-- Pseudo-opcode to mark the position where the extern names are to be emitted.
+map_op[".externnames_1"] = function(params)
+  if not params then return "cvar" end
+  local name = params[1] -- No syntax check. You get to keep the pieces.
+  wline(function(out) writeexternnames(out, name) end)
+end
+------------------------------------------------------------------------------
+-- Label pseudo-opcode (converted from trailing colon form).
+map_op[".label_1"] = function(params)
+  if not params then return "[1-9] | ->global | =>pcexpr" end
+  if secpos+1 > maxsecpos then wflush() end
+  local mode, n, s = parse_label(params[1], true)
+  if mode == "EXT" then werror("bad label definition") end
+  waction("LABEL_"..mode, n, s, 1)
+end
+------------------------------------------------------------------------------
+-- Pseudo-opcodes for data storage.
+map_op[".long_*"] = function(params)
+  if not params then return "imm..." end
+  for _, p in ipairs(params) do
+    local n = tonumber(p)
+    if not n then werror("bad immediate `"..p.."'") end
+    if n < 0 then n = n + 2^32 end
+    wputw(n)
+    if secpos+2 > maxsecpos then wflush() end
+  end
+end
+-- Alignment pseudo-opcode.
+map_op[".align_1"] = function(params)
+  if not params then return "numpow2" end
+  if secpos+1 > maxsecpos then wflush() end
+  local align = tonumber(params[1])
+  if align then
+    local x = align
+    -- Must be a power of 2 in the range (2 ... 256).
+    for i=1, 8 do
+      x = x / 2
+      if x == 1 then
+	waction("ALIGN", align-1, nil, 1) -- Action halfword is 2**n-1.
+	return
+      end
+    end
+  end
+  werror("bad alignment")
+end
+------------------------------------------------------------------------------
+-- Pseudo-opcode for (primitive) type definitions (map to C types).
+map_op[".type_3"] = function(params, nparams)
+  if not params then
+    return nparams == 2 and "name, ctype" or "name, ctype, reg"
+  end
+  local name, ctype, reg = params[1], params[2], params[3]
+  if not match(name, "^[%a_][%w_]*$") then
+    werror("bad type name `"..name.."'")
+  end
+  local tp = map_type[name]
+  if tp then
+    werror("duplicate type `"..name.."'")
+  end
+  -- Add #type to defines. A bit unclean to put it in map_archdef.
+  map_archdef["#"..name] = "sizeof("..ctype..")"
+  -- Add new type and emit shortcut define.
+  local num = ctypenum + 1
+  map_type[name] = {
+    ctype = ctype,
+    ctypefmt = format("Dt%X(%%s)", num),
+    reg = reg,
+  }
+  wline(format("#define Dt%X(_V) (int)(ptrdiff_t)&(((%s *)0)_V)", num, ctype))
+  ctypenum = num
+end
+map_op[".type_2"] = map_op[".type_3"]
+-- Dump type definitions.
+local function dumptypes(out, lvl)
+  local t = {}
+  for name in pairs(map_type) do t[#t+1] = name end
+  sort(t)
+  out:write("Type definitions:\n")
+  for _, name in ipairs(t) do
+    local tp = map_type[name]
+    local reg = tp.reg or ""
+    out:write(format("  %-20s %-20s %s\n", name, tp.ctype, reg))
+  end
+  out:write("\n")
+end
+------------------------------------------------------------------------------
+-- Set the current section.
+function _M.section(num)
+  waction("SECTION", num)
+  wflush(true) -- SECTION is a terminal action.
+end
+------------------------------------------------------------------------------
+-- Dump architecture description.
+function _M.dumparch(out)
+  out:write(format("DynASM %s version %s, released %s\n\n",
+    _info.arch, _info.version, _info.release))
+  dumpactions(out)
+end
+-- Dump all user defined elements.
+function _M.dumpdef(out, lvl)
+  dumptypes(out, lvl)
+  dumpglobals(out, lvl)
+  dumpexterns(out, lvl)
+end
+------------------------------------------------------------------------------
+-- Pass callbacks from/to the DynASM core.
+function _M.passcb(wl, we, wf, ww)
+  wline, werror, wfatal, wwarn = wl, we, wf, ww
+  return wflush
+end
+-- Setup the arch-specific module.
+function _M.setup(arch, opt)
+  g_arch, g_opt = arch, opt
+end
+-- Merge the core maps and the arch-specific maps.
+function _M.mergemaps(map_coreop, map_def)
+  setmetatable(map_op, { __index = map_coreop })
+  setmetatable(map_def, { __index = map_archdef })
+  return map_op, map_def
+end
+return _M
+------------------------------------------------------------------------------
+
diff --git a/lib/luajit-3065c9/dynasm/dasm_x64.lua b/lib/luajit2/dynasm/dasm_x64.lua
similarity index 89%
rename from lib/luajit-3065c9/dynasm/dasm_x64.lua
rename to lib/luajit2/dynasm/dasm_x64.lua
index 1779c5bfb..72d9bb87b 100644
--- a/lib/luajit-3065c9/dynasm/dasm_x64.lua
+++ b/lib/luajit2/dynasm/dasm_x64.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM x64 module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 ------------------------------------------------------------------------------
 -- This module just sets 64 bit mode for the combined x86/x64 module.
diff --git a/lib/luajit-3065c9/dynasm/dasm_x86.h b/lib/luajit2/dynasm/dasm_x86.h
similarity index 96%
rename from lib/luajit-3065c9/dynasm/dasm_x86.h
rename to lib/luajit2/dynasm/dasm_x86.h
index f0327302d..aded99903 100644
--- a/lib/luajit-3065c9/dynasm/dasm_x86.h
+++ b/lib/luajit2/dynasm/dasm_x86.h
@@ -1,6 +1,6 @@
 /*
 ** DynASM x86 encoding engine.
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 ** Released under the MIT license. See dynasm.lua for full copyright notice.
 */
 
@@ -68,7 +68,7 @@ struct dasm_State {
   size_t lgsize;
   int *pclabels;		/* PC label chains/pos ptrs. */
   size_t pcsize;
-  void **globals;		/* Array of globals (bias -10). */
+  void **globals;		/* Array of globals. */
   dasm_Section *section;	/* Pointer to active section. */
   size_t codesize;		/* Total size of all code sections. */
   int maxsection;		/* 0 <= sectionidx < maxsection. */
@@ -85,7 +85,6 @@ void dasm_init(Dst_DECL, int maxsection)
 {
   dasm_State *D;
   size_t psz = 0;
-  int i;
   Dst_REF = NULL;
   DASM_M_GROW(Dst, struct dasm_State, Dst_REF, psz, DASM_PSZ(maxsection));
   D = Dst_REF;
@@ -96,12 +95,7 @@ void dasm_init(Dst_DECL, int maxsection)
   D->pcsize = 0;
   D->globals = NULL;
   D->maxsection = maxsection;
-  for (i = 0; i < maxsection; i++) {
-    D->sections[i].buf = NULL;  /* Need this for pass3. */
-    D->sections[i].rbuf = D->sections[i].buf - DASM_SEC2POS(i);
-    D->sections[i].bsize = 0;
-    D->sections[i].epos = 0;  /* Wrong, but is recalculated after resize. */
-  }
+  memset((void *)D->sections, 0, maxsection * sizeof(dasm_Section));
 }
 
 /* Free DynASM state. */
@@ -121,7 +115,7 @@ void dasm_free(Dst_DECL)
 void dasm_setupglobal(Dst_DECL, void **gl, unsigned int maxgl)
 {
   dasm_State *D = Dst_REF;
-  D->globals = gl - 10;  /* Negative bias to compensate for locals. */
+  D->globals = gl;
   DASM_M_GROW(Dst, int, D->lglabels, D->lgsize, (10+maxgl)*sizeof(int));
 }
 
@@ -146,6 +140,7 @@ void dasm_setup(Dst_DECL, const void *actionlist)
   if (D->pclabels) memset((void *)D->pclabels, 0, D->pcsize);
   for (i = 0; i < D->maxsection; i++) {
     D->sections[i].pos = DASM_SEC2POS(i);
+    D->sections[i].rbuf = D->sections[i].buf - D->sections[i].pos;
     D->sections[i].ofs = 0;
   }
 }
@@ -445,7 +440,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	  break;
 	}
 	case DASM_REL_LG: p++; if (n >= 0) goto rel_pc;
-	  b++; n = (int)(ptrdiff_t)D->globals[-n];
+	  b++; n = (int)(ptrdiff_t)D->globals[-n-10];
 	  /* fallthrough */
 	case DASM_REL_A: rel_a:
 	  n -= (unsigned int)(ptrdiff_t)(cp+4); goto wd; /* !x64 */
@@ -459,7 +454,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	}
 	case DASM_IMM_LG:
 	  p++;
-	  if (n < 0) { dasma((ptrdiff_t)D->globals[-n]); break; }
+	  if (n < 0) { dasma((ptrdiff_t)D->globals[-n-10]); break; }
 	  /* fallthrough */
 	case DASM_IMM_PC: {
 	  int *pb = DASM_POS2PTR(D, n);
@@ -469,7 +464,7 @@ int dasm_encode(Dst_DECL, void *buffer)
 	case DASM_LABEL_LG: {
 	  int idx = *p++;
 	  if (idx >= 10)
-	    D->globals[idx] = (void *)(base + (*p == DASM_SETLABEL ? *b : n));
+	    D->globals[idx-10] = (void *)(base + (*p == DASM_SETLABEL ? *b : n));
 	  break;
 	}
 	case DASM_LABEL_PC: case DASM_SETLABEL: break;
diff --git a/lib/luajit-3065c9/dynasm/dasm_x86.lua b/lib/luajit2/dynasm/dasm_x86.lua
similarity index 99%
rename from lib/luajit-3065c9/dynasm/dasm_x86.lua
rename to lib/luajit2/dynasm/dasm_x86.lua
index b442cd0dd..7c789f821 100644
--- a/lib/luajit-3065c9/dynasm/dasm_x86.lua
+++ b/lib/luajit2/dynasm/dasm_x86.lua
@@ -1,7 +1,7 @@
 ------------------------------------------------------------------------------
 -- DynASM x86/x64 module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See dynasm.lua for full copyright notice.
 ------------------------------------------------------------------------------
 
@@ -627,7 +627,11 @@ local function wputmrmsib(t, imark, s, vsreg, psz, sk)
 	werror("NYI: rip-relative displacement followed by immediate")
       end
       -- The previous byte in the action buffer cannot be 0xe9 or 0x80-0x8f.
-      wputlabel("REL_", disp[1], 2)
+      if disp[2] == "iPJ" then
+	waction("REL_A", disp[1])
+      else
+	wputlabel("REL_", disp[1], 2)
+      end
     else
       wputdarg(disp)
     end
@@ -744,9 +748,9 @@ local function dispexpr(expr)
     return imm*map_opsizenum[ops]
   end
   local mode, iexpr = immexpr(dispt)
-  if mode == "iJ" then
+  if mode == "iJ" or mode == "iPJ" then
     if c == "-" then werror("cannot invert label reference") end
-    return { iexpr }
+    return { iexpr, mode }
   end
   return expr -- Need to return original signed expression.
 end
@@ -1147,6 +1151,8 @@ local map_op = {
   rep_0 =	"F3",
   repe_0 =	"F3",
   repz_0 =	"F3",
+  endbr32_0 =	"F30F1EFB",
+  endbr64_0 =	"F30F1EFA",
   -- F4: *hlt
   cmc_0 =	"F5",
   -- F6: test... mb,i; div... mb
diff --git a/lib/luajit-3065c9/dynasm/dynasm.lua b/lib/luajit2/dynasm/dynasm.lua
similarity index 99%
rename from lib/luajit-3065c9/dynasm/dynasm.lua
rename to lib/luajit2/dynasm/dynasm.lua
index 95251b936..0d15a8728 100644
--- a/lib/luajit-3065c9/dynasm/dynasm.lua
+++ b/lib/luajit2/dynasm/dynasm.lua
@@ -2,7 +2,7 @@
 -- DynASM. A dynamic assembler for code generation engines.
 -- Originally designed and implemented for LuaJIT.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- See below for full copyright notice.
 ------------------------------------------------------------------------------
 
@@ -17,7 +17,7 @@ local _info = {
   url =		"https://luajit.org/dynasm.html",
   license =	"MIT",
   copyright =	[[
-Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 
 Permission is hereby granted, free of charge, to any person obtaining
 a copy of this software and associated documentation files (the
@@ -75,7 +75,7 @@ local function wline(line, needindent)
   g_synclineno = g_synclineno + 1
 end
 
--- Write assembler line as a comment, if requestd.
+-- Write assembler line as a comment, if requested.
 local function wcomment(aline)
   if g_opt.comment then
     wline(g_opt.comment..aline..g_opt.endcomment, true)
diff --git a/lib/luajit-3065c9/etc/luajit.1 b/lib/luajit2/etc/luajit.1
similarity index 97%
rename from lib/luajit-3065c9/etc/luajit.1
rename to lib/luajit2/etc/luajit.1
index a979b4784..a2eed514e 100644
--- a/lib/luajit-3065c9/etc/luajit.1
+++ b/lib/luajit2/etc/luajit.1
@@ -74,7 +74,7 @@ luajit \-jv \-e "for i=1,10 do for j=1,10 do for k=1,100 do end end end"
 Runs some nested loops and shows the resulting traces.
 .SH COPYRIGHT
 .PP
-\fBLuaJIT\fR is Copyright \(co 2005-2022 Mike Pall.
+\fBLuaJIT\fR is Copyright \(co 2005-2023 Mike Pall.
 .br
 \fBLuaJIT\fR is open source software, released under the MIT license.
 .SH SEE ALSO
diff --git a/lib/luajit-3065c9/etc/luajit.pc b/lib/luajit2/etc/luajit.pc
similarity index 91%
rename from lib/luajit-3065c9/etc/luajit.pc
rename to lib/luajit2/etc/luajit.pc
index 39e1e5772..96433008c 100644
--- a/lib/luajit-3065c9/etc/luajit.pc
+++ b/lib/luajit2/etc/luajit.pc
@@ -1,8 +1,8 @@
 # Package information for LuaJIT to be used by pkg-config.
 majver=2
 minver=1
-relver=0
-version=${majver}.${minver}.${relver}-beta3
+relver=ROLLING
+version=${majver}.${minver}.${relver}
 abiver=5.1
 
 prefix=/usr/local
diff --git a/lib/luajit-3065c9/src/.gitignore b/lib/luajit2/src/.gitignore
similarity index 74%
rename from lib/luajit-3065c9/src/.gitignore
rename to lib/luajit2/src/.gitignore
index 1a30573c9..736a729af 100644
--- a/lib/luajit-3065c9/src/.gitignore
+++ b/lib/luajit2/src/.gitignore
@@ -1,4 +1,6 @@
 luajit
+luajit.h
+luajit_relver.txt
 lj_bcdef.h
 lj_ffdef.h
 lj_libdef.h
diff --git a/lib/luajit-3065c9/src/Makefile b/lib/luajit2/src/Makefile
similarity index 92%
rename from lib/luajit-3065c9/src/Makefile
rename to lib/luajit2/src/Makefile
index 30d64be2a..d80e45a8a 100644
--- a/lib/luajit-3065c9/src/Makefile
+++ b/lib/luajit2/src/Makefile
@@ -7,12 +7,11 @@
 # Also works with MinGW and Cygwin on Windows.
 # Please check msvcbuild.bat for building with MSVC on Windows.
 #
-# Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+# Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 ##############################################################################
 
 MAJVER=  2
 MINVER=  1
-RELVER=  0
 ABIVER=  5.1
 NODOTABIVER= 51
 
@@ -54,9 +53,9 @@ CCOPT_arm64=
 CCOPT_ppc=
 CCOPT_mips=
 #
-CCDEBUG=
+#CCDEBUG=
 # Uncomment the next line to generate debug information:
-#CCDEBUG= -g
+CCDEBUG= -g
 #
 CCWARN= -Wall
 # Uncomment the next line to enable more warnings:
@@ -234,7 +233,7 @@ TARGET_ALDFLAGS= $(LDOPTIONS) $(TARGET_XLDFLAGS) $(TARGET_FLAGS) $(TARGET_LDFLAG
 TARGET_ASHLDFLAGS= $(LDOPTIONS) $(TARGET_XSHLDFLAGS) $(TARGET_FLAGS) $(TARGET_SHLDFLAGS)
 TARGET_ALIBS= $(TARGET_XLIBS) $(LIBS) $(TARGET_LIBS)
 
-TARGET_TESTARCH=$(shell $(TARGET_CC) $(TARGET_TCFLAGS) -E lj_arch.h -dM)
+TARGET_TESTARCH:=$(shell $(TARGET_CC) $(TARGET_TCFLAGS) -E lj_arch.h -dM)
 ifneq (,$(findstring LJ_TARGET_X64 ,$(TARGET_TESTARCH)))
   TARGET_LJARCH= x64
 else
@@ -244,6 +243,9 @@ else
 ifneq (,$(findstring LJ_TARGET_ARM ,$(TARGET_TESTARCH)))
   TARGET_LJARCH= arm
 else
+ifneq (,$(findstring LJ_TARGET_S390X ,$(TARGET_TESTARCH)))
+  TARGET_LJARCH= s390x
+else
 ifneq (,$(findstring LJ_TARGET_ARM64 ,$(TARGET_TESTARCH)))
   ifneq (,$(findstring __AARCH64EB__ ,$(TARGET_TESTARCH)))
     TARGET_ARCH= -D__AARCH64EB__=1
@@ -275,6 +277,7 @@ endif
 endif
 endif
 endif
+endif
 
 ifneq (,$(findstring LJ_TARGET_PS3 1,$(TARGET_TESTARCH)))
   TARGET_SYS= PS3
@@ -323,13 +326,13 @@ ifeq (Darwin,$(TARGET_SYS))
   TARGET_XCFLAGS+= -DLUAJIT_UNWIND_EXTERNAL
   TARGET_XSHLDFLAGS= -dynamiclib -single_module -undefined dynamic_lookup -fPIC
   TARGET_DYNXLDOPTS=
-  TARGET_XSHLDFLAGS+= -install_name $(TARGET_DYLIBPATH) -compatibility_version $(MAJVER).$(MINVER) -current_version $(MAJVER).$(MINVER).$(RELVER)
+  TARGET_XSHLDFLAGS+= -install_name $(TARGET_DYLIBPATH) -compatibility_version $(MAJVER).$(MINVER) -current_version $(MAJVER).$(MINVER).255
 else
 ifeq (iOS,$(TARGET_SYS))
   TARGET_STRIP+= -x
   TARGET_XSHLDFLAGS= -dynamiclib -single_module -undefined dynamic_lookup -fPIC
   TARGET_DYNXLDOPTS=
-  TARGET_XSHLDFLAGS+= -install_name $(TARGET_DYLIBPATH) -compatibility_version $(MAJVER).$(MINVER) -current_version $(MAJVER).$(MINVER).$(RELVER)
+  TARGET_XSHLDFLAGS+= -install_name $(TARGET_DYLIBPATH) -compatibility_version $(MAJVER).$(MINVER) -current_version $(MAJVER).$(MINVER).255
   ifeq (arm64,$(TARGET_LJARCH))
     TARGET_XCFLAGS+= -fno-omit-frame-pointer
   endif
@@ -388,10 +391,11 @@ MINILUA_O= host/minilua.o
 MINILUA_LIBS= -lm
 MINILUA_T= host/minilua
 MINILUA_X= $(MINILUA_T)
+MINILUA_DEP=
 
 ifeq (,$(HOST_LUA))
   HOST_LUA= $(MINILUA_X)
-  DASM_DEP= $(MINILUA_T)
+  MINILUA_DEP= $(MINILUA_T)
 endif
 
 DASM_DIR= ../dynasm
@@ -433,6 +437,10 @@ ifneq (,$(findstring LJ_NO_UNWIND 1,$(TARGET_TESTARCH)))
   DASM_AFLAGS+= -D NO_UNWIND
   TARGET_ARCH+= -DLUAJIT_NO_UNWIND
 endif
+ifneq (,$(findstring LJ_ABI_PAUTH 1,$(TARGET_TESTARCH)))
+  DASM_AFLAGS+= -D PAUTH
+  TARGET_ARCH+= -DLJ_ABI_PAUTH=1
+endif
 DASM_AFLAGS+= -D VER=$(subst LJ_ARCH_VERSION_,,$(filter LJ_ARCH_VERSION_%,$(subst LJ_ARCH_VERSION ,LJ_ARCH_VERSION_,$(TARGET_TESTARCH))))
 ifeq (Windows,$(TARGET_SYS))
   DASM_AFLAGS+= -D WIN
@@ -461,7 +469,16 @@ ifeq (ppc,$(TARGET_LJARCH))
     DASM_AFLAGS+= -D GPR64
   endif
   ifeq (PS3,$(TARGET_SYS))
-    DASM_AFLAGS+= -D PPE -D TOC
+    DASM_AFLAGS+= -D PPE
+  endif
+  ifneq (,$(findstring LJ_ARCH_PPC_OPD 1,$(TARGET_TESTARCH)))
+    DASM_AFLAGS+= -D OPD
+  endif
+  ifneq (,$(findstring LJ_ARCH_PPC_OPDENV 1,$(TARGET_TESTARCH)))
+    DASM_AFLAGS+= -D OPDENV
+  endif
+  ifneq (,$(findstring LJ_ARCH_PPC_ELFV2 1,$(TARGET_TESTARCH)))
+    DASM_AFLAGS+= -D ELFV2
   endif
 endif
 endif
@@ -470,6 +487,14 @@ endif
 DASM_FLAGS= $(DASM_XFLAGS) $(DASM_AFLAGS)
 DASM_DASC= vm_$(DASM_ARCH).dasc
 
+GIT= git
+ifeq (Windows,$(HOST_SYS)$(HOST_MSYS))
+  GIT_RELVER= if exist ..\.git ( $(GIT) show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+else
+  GIT_RELVER= [ -e ../.git ] && $(GIT) show -s --format=%ct >luajit_relver.txt 2>/dev/null || cat ../.relver >luajit_relver.txt 2>/dev/null || :
+endif
+GIT_DEP= $(wildcard ../.git/HEAD ../.git/refs/heads/*)
+
 BUILDVM_O= host/buildvm.o host/buildvm_asm.o host/buildvm_peobj.o \
 	   host/buildvm_lib.o host/buildvm_fold.o
 BUILDVM_T= host/buildvm
@@ -501,10 +526,16 @@ LJCORE_O= lj_assert.o lj_gc.o lj_err.o lj_char.o lj_bc.o lj_obj.o lj_buf.o \
 	  lj_ctype.o lj_cdata.o lj_cconv.o lj_ccall.o lj_ccallback.o \
 	  lj_carith.o lj_clib.o lj_cparse.o \
 	  lj_lib.o lj_alloc.o lib_aux.o \
-	  $(LJLIB_O) lib_init.o
+	  $(LJLIB_O) lib_init.o lj_str_hash.o
+
+ifeq (x64,$(TARGET_LJARCH))
+  lj_str_hash-CFLAGS = -msse4.2
+endif
+
+F_CFLAGS = $($(patsubst %.c,%-CFLAGS,$<))
 
 LJVMCORE_O= $(LJVM_O) $(LJCORE_O)
-LJVMCORE_DYNO= $(LJVMCORE_O:.o=_dyn.o)
+LJVMCORE_DYNO= $(LJVMCORE_O:.o=_dyn.o) lj_init_dyn.o
 
 LIB_VMDEF= jit/vmdef.lua
 LIB_VMDEFP= $(LIB_VMDEF)
@@ -516,8 +547,8 @@ LUAJIT_T= luajit
 
 ALL_T= $(LUAJIT_T) $(LUAJIT_A) $(LUAJIT_SO) $(HOST_T)
 ALL_HDRGEN= lj_bcdef.h lj_ffdef.h lj_libdef.h lj_recdef.h lj_folddef.h \
-	    host/buildvm_arch.h
-ALL_GEN= $(LJVM_S) $(ALL_HDRGEN) $(LIB_VMDEFP)
+	    host/buildvm_arch.h luajit.h
+ALL_GEN= $(LJVM_S) $(ALL_HDRGEN) luajit_relver.txt $(LIB_VMDEFP)
 WIN_RM= *.obj *.lib *.exp *.dll *.exe *.manifest *.pdb *.ilk
 ALL_RM= $(ALL_T) $(ALL_GEN) *.o host/*.o $(WIN_RM)
 
@@ -526,7 +557,7 @@ ALL_RM= $(ALL_T) $(ALL_GEN) *.o host/*.o $(WIN_RM)
 ##############################################################################
 
 # Mixed mode defaults.
-TARGET_O= $(LUAJIT_A)
+TARGET_O= lj_init.o $(LUAJIT_A)
 TARGET_T= $(LUAJIT_T) $(LUAJIT_SO)
 TARGET_DEP= $(LIB_VMDEF) $(LUAJIT_SO)
 
@@ -608,7 +639,7 @@ E= @echo
 default all:	$(TARGET_T)
 
 amalg:
-	$(MAKE) all "LJCORE_O=ljamalg.o"
+	$(MAKE) all "LJCORE_O=ljamalg.o lj_str_hash.o"
 
 clean:
 	$(HOST_RM) $(ALL_RM)
@@ -641,7 +672,12 @@ $(MINILUA_T): $(MINILUA_O)
 	$(E) "HOSTLINK  $@"
 	$(Q)$(HOST_CC) $(HOST_ALDFLAGS) -o $@ $(MINILUA_O) $(MINILUA_LIBS) $(HOST_ALIBS)
 
-host/buildvm_arch.h: $(DASM_DASC) $(DASM_DEP) $(DASM_DIR)/*.lua lj_arch.h lua.h luaconf.h
+luajit.h: $(MINILUA_DEP) $(GIT_DEP) luajit_rolling.h
+	$(E) "VERSION   $@"
+	$(Q)$(GIT_RELVER)
+	$(Q)$(HOST_LUA) host/genversion.lua
+
+host/buildvm_arch.h: $(DASM_DASC) $(MINILUA_DEP) lj_arch.h lua.h luaconf.h
 	$(E) "DYNASM    $@"
 	$(Q)$(DASM) $(DASM_FLAGS) -o $@ $(DASM_DASC)
 
@@ -685,8 +721,8 @@ lj_folddef.h: $(BUILDVM_T) lj_opt_fold.c
 
 %.o: %.c
 	$(E) "CC        $@"
-	$(Q)$(TARGET_DYNCC) $(TARGET_ACFLAGS) -c -o $(@:.o=_dyn.o) $<
-	$(Q)$(TARGET_CC) $(TARGET_ACFLAGS) -c -o $@ $<
+	$(Q)$(TARGET_DYNCC) $(TARGET_ACFLAGS) $(F_CFLAGS) -c -o $(@:.o=_dyn.o) $<
+	$(Q)$(TARGET_CC) $(TARGET_ACFLAGS) $(F_CFLAGS) -c -o $@ $<
 
 %.o: %.S
 	$(E) "ASM       $@"
diff --git a/lib/luajit-3065c9/src/Makefile.dep b/lib/luajit2/src/Makefile.dep
similarity index 91%
rename from lib/luajit-3065c9/src/Makefile.dep
rename to lib/luajit2/src/Makefile.dep
index 1ad6701a9..fda77c835 100644
--- a/lib/luajit-3065c9/src/Makefile.dep
+++ b/lib/luajit2/src/Makefile.dep
@@ -1,6 +1,6 @@
 lib_aux.o: lib_aux.c lua.h luaconf.h lauxlib.h lj_obj.h lj_def.h \
  lj_arch.h lj_err.h lj_errmsg.h lj_state.h lj_trace.h lj_jit.h lj_ir.h \
- lj_dispatch.h lj_bc.h lj_traceerr.h lj_lib.h
+ lj_dispatch.h lj_bc.h lj_traceerr.h lj_lib.h lj_vmevent.h
 lib_base.o: lib_base.c lua.h luaconf.h lauxlib.h lualib.h lj_obj.h \
  lj_def.h lj_arch.h lj_gc.h lj_err.h lj_errmsg.h lj_debug.h lj_buf.h \
  lj_str.h lj_tab.h lj_meta.h lj_state.h lj_frame.h lj_bc.h lj_ctype.h \
@@ -55,7 +55,7 @@ lj_asm.o: lj_asm.c lj_obj.h lua.h luaconf.h lj_def.h lj_arch.h lj_gc.h \
  lj_buf.h lj_str.h lj_tab.h lj_frame.h lj_bc.h lj_ctype.h lj_ir.h \
  lj_jit.h lj_ircall.h lj_iropt.h lj_mcode.h lj_trace.h lj_dispatch.h \
  lj_traceerr.h lj_snap.h lj_asm.h lj_vm.h lj_target.h lj_target_*.h \
- lj_emit_*.h lj_asm_*.h
+ lj_prng.h lj_emit_*.h lj_asm_*.h
 lj_assert.o: lj_assert.c lj_obj.h lua.h luaconf.h lj_def.h lj_arch.h
 lj_bc.o: lj_bc.c lj_obj.h lua.h luaconf.h lj_def.h lj_arch.h lj_bc.h \
  lj_bcdef.h
@@ -124,7 +124,7 @@ lj_func.o: lj_func.c lj_obj.h lua.h luaconf.h lj_def.h lj_arch.h lj_gc.h \
 lj_gc.o: lj_gc.c lj_obj.h lua.h luaconf.h lj_def.h lj_arch.h lj_gc.h \
  lj_err.h lj_errmsg.h lj_buf.h lj_str.h lj_tab.h lj_func.h lj_udata.h \
  lj_meta.h lj_state.h lj_frame.h lj_bc.h lj_ctype.h lj_cdata.h lj_trace.h \
- lj_jit.h lj_ir.h lj_dispatch.h lj_traceerr.h lj_vm.h
+ lj_jit.h lj_ir.h lj_dispatch.h lj_traceerr.h lj_vm.h lj_vmevent.h
 lj_gdbjit.o: lj_gdbjit.c lj_obj.h lua.h luaconf.h lj_def.h lj_arch.h \
  lj_gc.h lj_err.h lj_errmsg.h lj_debug.h lj_frame.h lj_bc.h lj_buf.h \
  lj_str.h lj_strfmt.h lj_jit.h lj_ir.h lj_dispatch.h
@@ -222,25 +222,25 @@ ljamalg.o: ljamalg.c lua.h luaconf.h lauxlib.h lj_assert.c lj_obj.h \
  lj_def.h lj_arch.h lj_gc.c lj_gc.h lj_err.h lj_errmsg.h lj_buf.h \
  lj_str.h lj_tab.h lj_func.h lj_udata.h lj_meta.h lj_state.h lj_frame.h \
  lj_bc.h lj_ctype.h lj_cdata.h lj_trace.h lj_jit.h lj_ir.h lj_dispatch.h \
- lj_traceerr.h lj_vm.h lj_err.c lj_debug.h lj_ff.h lj_ffdef.h lj_strfmt.h \
- lj_char.c lj_char.h lj_bc.c lj_bcdef.h lj_obj.c lj_buf.c lj_str.c \
- lj_prng.h lj_tab.c lj_func.c lj_udata.c lj_meta.c lj_strscan.h lj_lib.h \
- lj_debug.c lj_prng.c lj_state.c lj_lex.h lj_alloc.h luajit.h \
- lj_dispatch.c lj_ccallback.h lj_profile.h lj_vmevent.c lj_vmevent.h \
- lj_vmmath.c lj_strscan.c lj_strfmt.c lj_strfmt_num.c lj_serialize.c \
- lj_serialize.h lj_api.c lj_profile.c lj_lex.c lualib.h lj_parse.h \
- lj_parse.c lj_bcread.c lj_bcdump.h lj_bcwrite.c lj_load.c lj_ctype.c \
- lj_cdata.c lj_cconv.h lj_cconv.c lj_ccall.c lj_ccall.h lj_ccallback.c \
- lj_target.h lj_target_*.h lj_mcode.h lj_carith.c lj_carith.h lj_clib.c \
- lj_clib.h lj_cparse.c lj_cparse.h lj_lib.c lj_ir.c lj_ircall.h \
- lj_iropt.h lj_opt_mem.c lj_opt_fold.c lj_folddef.h lj_opt_narrow.c \
- lj_opt_dce.c lj_opt_loop.c lj_snap.h lj_opt_split.c lj_opt_sink.c \
- lj_mcode.c lj_snap.c lj_record.c lj_record.h lj_ffrecord.h lj_crecord.c \
- lj_crecord.h lj_ffrecord.c lj_recdef.h lj_asm.c lj_asm.h lj_emit_*.h \
- lj_asm_*.h lj_trace.c lj_gdbjit.h lj_gdbjit.c lj_alloc.c lib_aux.c \
- lib_base.c lj_libdef.h lib_math.c lib_string.c lib_table.c lib_io.c \
- lib_os.c lib_package.c lib_debug.c lib_bit.c lib_jit.c lib_ffi.c \
- lib_buffer.c lib_init.c
+ lj_traceerr.h lj_vm.h lj_vmevent.h lj_err.c lj_debug.h lj_ff.h \
+ lj_ffdef.h lj_strfmt.h lj_char.c lj_char.h lj_bc.c lj_bcdef.h lj_obj.c \
+ lj_buf.c lj_str.c lj_prng.h lj_tab.c lj_func.c lj_udata.c lj_meta.c \
+ lj_strscan.h lj_lib.h lj_debug.c lj_prng.c lj_state.c lj_lex.h \
+ lj_alloc.h luajit.h lj_dispatch.c lj_ccallback.h lj_profile.h \
+ lj_vmevent.c lj_vmmath.c lj_strscan.c lj_strfmt.c lj_strfmt_num.c \
+ lj_serialize.c lj_serialize.h lj_api.c lj_profile.c lj_lex.c lualib.h \
+ lj_parse.h lj_parse.c lj_bcread.c lj_bcdump.h lj_bcwrite.c lj_load.c \
+ lj_ctype.c lj_cdata.c lj_cconv.h lj_cconv.c lj_ccall.c lj_ccall.h \
+ lj_ccallback.c lj_target.h lj_target_*.h lj_mcode.h lj_carith.c \
+ lj_carith.h lj_clib.c lj_clib.h lj_cparse.c lj_cparse.h lj_lib.c lj_ir.c \
+ lj_ircall.h lj_iropt.h lj_opt_mem.c lj_opt_fold.c lj_folddef.h \
+ lj_opt_narrow.c lj_opt_dce.c lj_opt_loop.c lj_snap.h lj_opt_split.c \
+ lj_opt_sink.c lj_mcode.c lj_snap.c lj_record.c lj_record.h lj_ffrecord.h \
+ lj_crecord.c lj_crecord.h lj_ffrecord.c lj_recdef.h lj_asm.c lj_asm.h \
+ lj_emit_*.h lj_asm_*.h lj_trace.c lj_gdbjit.h lj_gdbjit.c lj_alloc.c \
+ lib_aux.c lib_base.c lj_libdef.h lib_math.c lib_string.c lib_table.c \
+ lib_io.c lib_os.c lib_package.c lib_debug.c lib_bit.c lib_jit.c \
+ lib_ffi.c lib_buffer.c lib_init.c
 luajit.o: luajit.c lua.h luaconf.h lauxlib.h lualib.h luajit.h lj_arch.h
 host/buildvm.o: host/buildvm.c host/buildvm.h lj_def.h lua.h luaconf.h \
  lj_arch.h lj_obj.h lj_def.h lj_arch.h lj_gc.h lj_obj.h lj_bc.h lj_ir.h \
diff --git a/lib/luajit-3065c9/src/host/.gitignore b/lib/luajit2/src/host/.gitignore
similarity index 100%
rename from lib/luajit-3065c9/src/host/.gitignore
rename to lib/luajit2/src/host/.gitignore
diff --git a/lib/luajit-3065c9/src/host/README b/lib/luajit2/src/host/README
similarity index 100%
rename from lib/luajit-3065c9/src/host/README
rename to lib/luajit2/src/host/README
diff --git a/lib/luajit-3065c9/src/host/buildvm.c b/lib/luajit2/src/host/buildvm.c
similarity index 98%
rename from lib/luajit-3065c9/src/host/buildvm.c
rename to lib/luajit2/src/host/buildvm.c
index 9ee47adae..d460b3144 100644
--- a/lib/luajit-3065c9/src/host/buildvm.c
+++ b/lib/luajit2/src/host/buildvm.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM builder.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** This is a tool to build the hand-tuned assembler code required for
 ** LuaJIT's bytecode interpreter. It supports a variety of output formats
@@ -67,6 +67,8 @@ static int collect_reloc(BuildCtx *ctx, uint8_t *addr, int idx, int type);
 #include "../dynasm/dasm_ppc.h"
 #elif LJ_TARGET_MIPS
 #include "../dynasm/dasm_mips.h"
+#elif LJ_TARGET_S390X
+#include "../dynasm/dasm_s390x.h"
 #else
 #error "No support for this architecture (yet)"
 #endif
@@ -329,6 +331,7 @@ static void emit_vmdef(BuildCtx *ctx)
 #endif
   int i;
   fprintf(ctx->fp, "-- This is a generated file. DO NOT EDIT!\n\n");
+  fprintf(ctx->fp, "assert(require(\"jit\").version == \"%s\", \"LuaJIT core/library version mismatch\")\n\n", LUAJIT_VERSION);
   fprintf(ctx->fp, "return {\n\n");
 
   fprintf(ctx->fp, "bcnames = \"");
diff --git a/lib/luajit-3065c9/src/host/buildvm.h b/lib/luajit2/src/host/buildvm.h
similarity index 97%
rename from lib/luajit-3065c9/src/host/buildvm.h
rename to lib/luajit2/src/host/buildvm.h
index 18cd8848e..add8ee154 100644
--- a/lib/luajit-3065c9/src/host/buildvm.h
+++ b/lib/luajit2/src/host/buildvm.h
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM builder.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _BUILDVM_H
diff --git a/lib/luajit-3065c9/src/host/buildvm_asm.c b/lib/luajit2/src/host/buildvm_asm.c
similarity index 80%
rename from lib/luajit-3065c9/src/host/buildvm_asm.c
rename to lib/luajit2/src/host/buildvm_asm.c
index 7baa011fd..5e25de9d2 100644
--- a/lib/luajit-3065c9/src/host/buildvm_asm.c
+++ b/lib/luajit2/src/host/buildvm_asm.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM builder: Assembler source code emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "buildvm.h"
@@ -87,6 +87,54 @@ err:
   }
   fprintf(ctx->fp, "\t%s %s\n", opname, sym);
 }
+#elif LJ_TARGET_S390X
+/* Emit halfwords piecewise as assembler text. */
+static void emit_asm_halfwords(BuildCtx *ctx, uint8_t *p, int n)
+{
+  uint16_t *cp = (uint16_t*)p;
+  n /= 2;
+  int i;
+  for (i = 0; i < n; i++) {
+    if ((i & 7) == 0)
+      fprintf(ctx->fp, "\t.hword 0x%hx", cp[i]);
+    else
+      fprintf(ctx->fp, ",0x%hx", cp[i]);
+    if ((i & 7) == 7) putc('\n', ctx->fp);
+  }
+  if ((n & 7) != 0) putc('\n', ctx->fp);
+}
+
+/* Emit s390x text relocations. */
+static void emit_asm_reloc_text(BuildCtx *ctx, uint8_t *cp, int n,
+				const char *sym)
+{
+  if (n & 1 || n < 2) {
+    fprintf(stderr, "Error: instruction stream length invalid: %d.\n", n);
+    exit(1);
+  }
+  n -= 2;
+  const char *opname = NULL;
+  const char *argt = ""; /* Inserted before argument. */
+  int opcode = *(uint16_t*)(&cp[n]);
+  int arg = (opcode>>4) & 0xf;
+  switch (opcode & 0xff0f) {
+  case 0xa705: opname = "bras"; argt = "%r"; break;
+  case 0xc005: opname = "brasl"; argt = "%r"; break;
+  case 0xa704: opname = "brc"; break;
+  case 0xc004: opname = "brcl"; break;
+  default:
+    fprintf(stderr, "Error: unsupported opcode for %s symbol relocation.\n",
+	    sym);
+    exit(1);
+  }
+  emit_asm_halfwords(ctx, cp, n);
+  if (strncmp(sym+(*sym == '_'), LABEL_PREFIX, sizeof(LABEL_PREFIX)-1)) {
+    /* Various fixups for external symbols outside of our binary. */
+    fprintf(ctx->fp, "\t%s %s%d, %s@PLT\n", opname, argt, arg, sym);
+    return;
+  }
+  fprintf(ctx->fp, "\t%s %s%d, %s\n", opname, argt, arg, sym);
+}
 #else
 /* Emit words piecewise as assembler text. */
 static void emit_asm_words(BuildCtx *ctx, uint8_t *p, int n)
@@ -140,7 +188,11 @@ static void emit_asm_wordreloc(BuildCtx *ctx, uint8_t *p, int n,
 #else
 #define TOCPREFIX ""
 #endif
-  if ((ins >> 26) == 16) {
+  if ((ins >> 26) == 14) {
+    fprintf(ctx->fp, "\taddi %d,%d,%s\n", (ins >> 21) & 31, (ins >> 16) & 31, sym);
+  } else if ((ins >> 26) == 15) {
+    fprintf(ctx->fp, "\taddis %d,%d,%s\n", (ins >> 21) & 31, (ins >> 16) & 31, sym);
+  } else if ((ins >> 26) == 16) {
     fprintf(ctx->fp, "\t%s %d, %d, " TOCPREFIX "%s\n",
 	    (ins & 1) ? "bcl" : "bc", (ins >> 21) & 31, (ins >> 16) & 31, sym);
   } else if ((ins >> 26) == 18) {
@@ -242,7 +294,16 @@ void emit_asm(BuildCtx *ctx)
   int i, rel;
 
   fprintf(ctx->fp, "\t.file \"buildvm_%s.dasc\"\n", ctx->dasm_arch);
+#if LJ_ARCH_PPC_ELFV2
+  fprintf(ctx->fp, "\t.abiversion 2\n");
+#endif
   fprintf(ctx->fp, "\t.text\n");
+#if LJ_TARGET_MIPS32 && !LJ_ABI_SOFTFP
+  fprintf(ctx->fp, "\t.module fp=32\n");
+#endif
+#if LJ_TARGET_MIPS
+  fprintf(ctx->fp, "\t.set nomips16\n\t.abicalls\n\t.set noreorder\n\t.set nomacro\n");
+#endif
   emit_asm_align(ctx, 4);
 
 #if LJ_TARGET_PS3
@@ -268,9 +329,6 @@ void emit_asm(BuildCtx *ctx)
 	  ".save {r4, r5, r6, r7, r8, r9, r10, r11, lr}\n"
 	  ".pad #28\n");
 #endif
-#endif
-#if LJ_TARGET_MIPS
-  fprintf(ctx->fp, ".set nomips16\n.abicalls\n.set noreorder\n.set nomacro\n");
 #endif
 
   for (i = rel = 0; i < ctx->nsym; i++) {
@@ -299,6 +357,9 @@ void emit_asm(BuildCtx *ctx)
 	emit_asm_reloc(ctx, r->type, ctx->relocsym[r->sym]);
       }
       ofs += n+4;
+#elif LJ_TARGET_S390X
+      emit_asm_reloc_text(ctx, ctx->code+ofs, n, ctx->relocsym[r->sym]);
+      ofs += n+4;
 #else
       emit_asm_wordreloc(ctx, ctx->code+ofs, n, ctx->relocsym[r->sym]);
       ofs += n;
@@ -307,6 +368,8 @@ void emit_asm(BuildCtx *ctx)
     }
 #if LJ_TARGET_X86ORX64
     emit_asm_bytes(ctx, ctx->code+ofs, next-ofs);
+#elif LJ_TARGET_S390X
+    emit_asm_halfwords(ctx, ctx->code+ofs, next-ofs);
 #else
     emit_asm_words(ctx, ctx->code+ofs, next-ofs);
 #endif
diff --git a/lib/luajit-3065c9/src/host/buildvm_fold.c b/lib/luajit2/src/host/buildvm_fold.c
similarity index 99%
rename from lib/luajit-3065c9/src/host/buildvm_fold.c
rename to lib/luajit2/src/host/buildvm_fold.c
index edb557684..cc392e930 100644
--- a/lib/luajit-3065c9/src/host/buildvm_fold.c
+++ b/lib/luajit2/src/host/buildvm_fold.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM builder: IR folding hash table generator.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "buildvm.h"
diff --git a/lib/luajit-3065c9/src/host/buildvm_lib.c b/lib/luajit2/src/host/buildvm_lib.c
similarity index 97%
rename from lib/luajit-3065c9/src/host/buildvm_lib.c
rename to lib/luajit2/src/host/buildvm_lib.c
index b125ea122..99d12a27f 100644
--- a/lib/luajit-3065c9/src/host/buildvm_lib.c
+++ b/lib/luajit2/src/host/buildvm_lib.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM builder: library definition compiler.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "buildvm.h"
@@ -379,13 +379,20 @@ void emit_lib(BuildCtx *ctx)
       /* Simplistic pre-processor. Only handles top-level #if/#endif. */
       if (buf[0] == '#' && buf[1] == 'i' && buf[2] == 'f') {
 	int ok = 1;
-	if (!strcmp(buf, "#if LJ_52\n"))
+	size_t len = strlen(buf);
+	if (buf[len-1] == '\n') {
+	  buf[len-1] = 0;
+	  if (buf[len-2] == '\r') {
+	    buf[len-2] = 0;
+	  }
+	}
+	if (!strcmp(buf, "#if LJ_52"))
 	  ok = LJ_52;
-	else if (!strcmp(buf, "#if LJ_HASJIT\n"))
+	else if (!strcmp(buf, "#if LJ_HASJIT"))
 	  ok = LJ_HASJIT;
-	else if (!strcmp(buf, "#if LJ_HASFFI\n"))
+	else if (!strcmp(buf, "#if LJ_HASFFI"))
 	  ok = LJ_HASFFI;
-	else if (!strcmp(buf, "#if LJ_HASBUFFER\n"))
+	else if (!strcmp(buf, "#if LJ_HASBUFFER"))
 	  ok = LJ_HASBUFFER;
 	if (!ok) {
 	  int lvl = 1;
diff --git a/lib/luajit-3065c9/src/host/buildvm_libbc.h b/lib/luajit2/src/host/buildvm_libbc.h
similarity index 100%
rename from lib/luajit-3065c9/src/host/buildvm_libbc.h
rename to lib/luajit2/src/host/buildvm_libbc.h
diff --git a/lib/luajit-3065c9/src/host/buildvm_peobj.c b/lib/luajit2/src/host/buildvm_peobj.c
similarity index 74%
rename from lib/luajit-3065c9/src/host/buildvm_peobj.c
rename to lib/luajit2/src/host/buildvm_peobj.c
index b030f234b..8f04c496d 100644
--- a/lib/luajit-3065c9/src/host/buildvm_peobj.c
+++ b/lib/luajit2/src/host/buildvm_peobj.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM builder: PE object emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Only used for building on Windows, since we cannot assume the presence
 ** of a suitable assembler. The host and target byte order must match.
@@ -9,7 +9,7 @@
 #include "buildvm.h"
 #include "lj_bc.h"
 
-#if LJ_TARGET_X86ORX64
+#if LJ_TARGET_WINDOWS || LJ_TARGET_CYGWIN
 
 /* Context for PE object emitter. */
 static char *strtab;
@@ -93,6 +93,17 @@ typedef struct PEsymaux {
 #define PEOBJ_RELOC_ADDR32NB	0x03
 #define PEOBJ_RELOC_OFS		0
 #define PEOBJ_TEXT_FLAGS	0x60500020  /* 60=r+x, 50=align16, 20=code. */
+#define PEOBJ_PDATA_NRELOC	6
+#define PEOBJ_XDATA_SIZE	(8*2+4+6*2)
+#elif LJ_TARGET_ARM64
+#define PEOBJ_ARCH_TARGET	0xaa64
+#define PEOBJ_RELOC_REL32	0x03  /* MS: BRANCH26. */
+#define PEOBJ_RELOC_DIR32	0x01
+#define PEOBJ_RELOC_ADDR32NB	0x02
+#define PEOBJ_RELOC_OFS		(-4)
+#define PEOBJ_TEXT_FLAGS	0x60500020  /* 60=r+x, 50=align16, 20=code. */
+#define PEOBJ_PDATA_NRELOC	4
+#define PEOBJ_XDATA_SIZE	(4+24+4 +4+8)
 #endif
 
 /* Section numbers (0-based). */
@@ -100,7 +111,7 @@ enum {
   PEOBJ_SECT_ABS = -2,
   PEOBJ_SECT_UNDEF = -1,
   PEOBJ_SECT_TEXT,
-#if LJ_TARGET_X64
+#ifdef PEOBJ_PDATA_NRELOC
   PEOBJ_SECT_PDATA,
   PEOBJ_SECT_XDATA,
 #elif LJ_TARGET_X86
@@ -175,6 +186,9 @@ void emit_peobj(BuildCtx *ctx)
   uint32_t sofs;
   int i, nrsym;
   union { uint8_t b; uint32_t u; } host_endian;
+#ifdef PEOBJ_PDATA_NRELOC
+  uint32_t fcofs = (uint32_t)ctx->sym[ctx->nsym-1].ofs;
+#endif
 
   sofs = sizeof(PEheader) + PEOBJ_NSECTIONS*sizeof(PEsection);
 
@@ -188,18 +202,18 @@ void emit_peobj(BuildCtx *ctx)
   /* Flags: 60 = read+execute, 50 = align16, 20 = code. */
   pesect[PEOBJ_SECT_TEXT].flags = PEOBJ_TEXT_FLAGS;
 
-#if LJ_TARGET_X64
+#ifdef PEOBJ_PDATA_NRELOC
   memcpy(pesect[PEOBJ_SECT_PDATA].name, ".pdata", sizeof(".pdata")-1);
   pesect[PEOBJ_SECT_PDATA].ofs = sofs;
-  sofs += (pesect[PEOBJ_SECT_PDATA].size = 6*4);
+  sofs += (pesect[PEOBJ_SECT_PDATA].size = PEOBJ_PDATA_NRELOC*4);
   pesect[PEOBJ_SECT_PDATA].relocofs = sofs;
-  sofs += (pesect[PEOBJ_SECT_PDATA].nreloc = 6) * PEOBJ_RELOC_SIZE;
+  sofs += (pesect[PEOBJ_SECT_PDATA].nreloc = PEOBJ_PDATA_NRELOC) * PEOBJ_RELOC_SIZE;
   /* Flags: 40 = read, 30 = align4, 40 = initialized data. */
   pesect[PEOBJ_SECT_PDATA].flags = 0x40300040;
 
   memcpy(pesect[PEOBJ_SECT_XDATA].name, ".xdata", sizeof(".xdata")-1);
   pesect[PEOBJ_SECT_XDATA].ofs = sofs;
-  sofs += (pesect[PEOBJ_SECT_XDATA].size = 8*2+4+6*2);  /* See below. */
+  sofs += (pesect[PEOBJ_SECT_XDATA].size = PEOBJ_XDATA_SIZE);  /* See below. */
   pesect[PEOBJ_SECT_XDATA].relocofs = sofs;
   sofs += (pesect[PEOBJ_SECT_XDATA].nreloc = 1) * PEOBJ_RELOC_SIZE;
   /* Flags: 40 = read, 30 = align4, 40 = initialized data. */
@@ -234,7 +248,7 @@ void emit_peobj(BuildCtx *ctx)
   */
   nrsym = ctx->nrelocsym;
   pehdr.nsyms = 1+PEOBJ_NSECTIONS*2 + 1+ctx->nsym + nrsym;
-#if LJ_TARGET_X64
+#ifdef PEOBJ_PDATA_NRELOC
   pehdr.nsyms += 1;  /* Symbol for lj_err_unwind_win. */
 #endif
 
@@ -259,7 +273,6 @@ void emit_peobj(BuildCtx *ctx)
 
 #if LJ_TARGET_X64
   { /* Write .pdata section. */
-    uint32_t fcofs = (uint32_t)ctx->sym[ctx->nsym-1].ofs;
     uint32_t pdata[3];  /* Start of .text, end of .text and .xdata. */
     PEreloc reloc;
     pdata[0] = 0; pdata[1] = fcofs; pdata[2] = 0;
@@ -308,6 +321,87 @@ void emit_peobj(BuildCtx *ctx)
     reloc.type = PEOBJ_RELOC_ADDR32NB;
     owrite(ctx, &reloc, PEOBJ_RELOC_SIZE);
   }
+#elif LJ_TARGET_ARM64
+  /* https://learn.microsoft.com/en-us/cpp/build/arm64-exception-handling */
+  { /* Write .pdata section. */
+    uint32_t pdata[4];
+    PEreloc reloc;
+    pdata[0] = 0;
+    pdata[1] = 0;
+    pdata[2] = fcofs;
+    pdata[3] = 4+24+4;
+    owrite(ctx, &pdata, sizeof(pdata));
+    /* Start of .text and start of .xdata. */
+    reloc.vaddr = 0; reloc.symidx = 1+2+nrsym+2+2+1;
+    reloc.type = PEOBJ_RELOC_ADDR32NB;
+    owrite(ctx, &reloc, PEOBJ_RELOC_SIZE);
+    reloc.vaddr = 4; reloc.symidx = 1+2+nrsym+2;
+    reloc.type = PEOBJ_RELOC_ADDR32NB;
+    owrite(ctx, &reloc, PEOBJ_RELOC_SIZE);
+    /* Start of vm_ffi_call and start of second part of .xdata. */
+    reloc.vaddr = 8; reloc.symidx = 1+2+nrsym+2+2+1;
+    reloc.type = PEOBJ_RELOC_ADDR32NB;
+    owrite(ctx, &reloc, PEOBJ_RELOC_SIZE);
+    reloc.vaddr = 12; reloc.symidx = 1+2+nrsym+2;
+    reloc.type = PEOBJ_RELOC_ADDR32NB;
+    owrite(ctx, &reloc, PEOBJ_RELOC_SIZE);
+  }
+  { /* Write .xdata section. */
+    uint32_t u32;
+    uint8_t *p, uwc[24];
+    PEreloc reloc;
+
+#define CBE16(x)	(*p = ((x) >> 8) & 0xff, p[1] = (x) & 0xff, p += 2)
+#define CALLOC_S(s)	(*p++ = ((s) >> 4))  /* s < 512 */
+#define CSAVE_FPLR(o)	(*p++ = 0x40 | ((o) >> 3))  /* o <= 504 */
+#define CSAVE_REGP(r,o)	CBE16(0xc800 | (((r) - 19) << 6) | ((o) >> 3))
+#define CSAVE_REGS(r1,r2,o1) do { \
+  int r, o; for (r = r1, o = o1; r <= r2; r += 2, o -= 16) CSAVE_REGP(r, o); \
+} while (0)
+#define CSAVE_REGPX(r,o) CBE16(0xcc00 | (((r) - 19) << 6) | (~(o) >> 3))
+#define CSAVE_FREGP(r,o) CBE16(0xd800 | (((r) - 8) << 6) | ((o) >> 3))
+#define CSAVE_FREGS(r1,r2,o1) do { \
+  int r, o; for (r = r1, o = o1; r <= r2; r += 2, o -= 16) CSAVE_FREGP(r, o); \
+} while (0)
+#define CADD_FP(s)	CBE16(0xe200 | ((s) >> 3))  /* s < 8*256 */
+#define CODE_NOP	0xe3
+#define CODE_END	0xe4
+#define CEND_ALIGN	do { \
+  *p++ = CODE_END; \
+  while ((p - uwc) & 3) *p++ = CODE_NOP; \
+} while (0)
+
+    /* Unwind codes for .text section with handler. */
+    p = uwc;
+    CADD_FP(192);		/* +2 */
+    CSAVE_REGS(19, 28, 176);	/* +5*2 */
+    CSAVE_FREGS(8, 15, 96);	/* +4*2 */
+    CSAVE_FPLR(192);		/* +1 */
+    CALLOC_S(208);		/* +1 */
+    CEND_ALIGN;			/* +1 +1 -> 24 */
+
+    u32 = ((24u >> 2) << 27) | (1u << 20) | (fcofs >> 2);
+    owrite(ctx, &u32, 4);
+    owrite(ctx, &uwc, 24);
+
+    u32 = 0;  /* Handler RVA to be relocated at 4 + 24. */
+    owrite(ctx, &u32, 4);
+
+    /* Unwind codes for vm_ffi_call without handler. */
+    p = uwc;
+    CADD_FP(16);		/* +2 */
+    CSAVE_FPLR(16);		/* +1 */
+    CSAVE_REGPX(19, -32);	/* +2 */
+    CEND_ALIGN;			/* +1 +2 -> 8 */
+
+    u32 = ((8u >> 2) << 27) | (((uint32_t)ctx->codesz - fcofs) >> 2);
+    owrite(ctx, &u32, 4);
+    owrite(ctx, &uwc, 8);
+
+    reloc.vaddr = 4 + 24; reloc.symidx = 1+2+nrsym+2+2;
+    reloc.type = PEOBJ_RELOC_ADDR32NB;
+    owrite(ctx, &reloc, PEOBJ_RELOC_SIZE);
+  }
 #elif LJ_TARGET_X86
   /* Write .sxdata section. */
   for (i = 0; i < nrsym; i++) {
@@ -339,7 +433,7 @@ void emit_peobj(BuildCtx *ctx)
       emit_peobj_sym(ctx, ctx->relocsym[i], 0,
 		     PEOBJ_SECT_UNDEF, PEOBJ_TYPE_FUNC, PEOBJ_SCL_EXTERN);
 
-#if LJ_TARGET_X64
+#ifdef PEOBJ_PDATA_NRELOC
     emit_peobj_sym_sect(ctx, pesect, PEOBJ_SECT_PDATA);
     emit_peobj_sym_sect(ctx, pesect, PEOBJ_SECT_XDATA);
     emit_peobj_sym(ctx, "lj_err_unwind_win", 0,
diff --git a/lib/luajit-3065c9/src/host/genlibbc.lua b/lib/luajit2/src/host/genlibbc.lua
similarity index 74%
rename from lib/luajit-3065c9/src/host/genlibbc.lua
rename to lib/luajit2/src/host/genlibbc.lua
index ba18812c8..e697fceb8 100644
--- a/lib/luajit-3065c9/src/host/genlibbc.lua
+++ b/lib/luajit2/src/host/genlibbc.lua
@@ -2,7 +2,7 @@
 -- Lua script to dump the bytecode of the library functions written in Lua.
 -- The resulting 'buildvm_libbc.h' is used for the build process of LuaJIT.
 ----------------------------------------------------------------------------
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 
@@ -138,65 +138,73 @@ local function fixup_dump(dump, fixup)
   return { dump = ndump, startbc = startbc, sizebc = sizebc }
 end
 
-local function find_defs(src)
+local function find_defs(src, mode)
   local defs = {}
   for name, code in string.gmatch(src, "LJLIB_LUA%(([^)]*)%)%s*/%*(.-)%*/") do
-    local env = {}
     local tcode, fixup = transform_lua(code)
-    local func = assert(load(tcode, "", nil, env))()
-    defs[name] = fixup_dump(string.dump(func, true), fixup)
+    local func = assert(load(tcode, "", mode))
+    defs[name] = fixup_dump(string.dump(func, mode), fixup)
     defs[#defs+1] = name
   end
   return defs
 end
 
-local function gen_header(defs)
+local function gen_header(defs32, defs64)
   local t = {}
   local function w(x) t[#t+1] = x end
   w("/* This is a generated file. DO NOT EDIT! */\n\n")
   w("static const int libbc_endian = ") w(isbe and 1 or 0) w(";\n\n")
-  local s, sb = "", ""
-  for i,name in ipairs(defs) do
-    local d = defs[name]
-    s = s .. d.dump
-    sb = sb .. string.char(i) .. ("\0"):rep(d.startbc - 1)
-	    .. (isbe and "\0\0\0\255" or "\255\0\0\0"):rep(d.sizebc)
-	    .. ("\0"):rep(#d.dump - d.startbc - d.sizebc*4)
-  end
-  w("static const uint8_t libbc_code[] = {\n")
-  local n = 0
-  for i=1,#s do
-    local x = string.byte(s, i)
-    local xb = string.byte(sb, i)
-    if xb == 255 then
-      local name = BCN[x]
-      local m = #name + 4
-      if n + m > 78 then n = 0; w("\n") end
-      n = n + m
-      w("BC_"); w(name)
+  for j,defs in ipairs{defs64, defs32} do
+    local s, sb = "", ""
+    for i,name in ipairs(defs) do
+      local d = defs[name]
+      s = s .. d.dump
+      sb = sb .. string.char(i) .. ("\0"):rep(d.startbc - 1)
+	      .. (isbe and "\0\0\0\255" or "\255\0\0\0"):rep(d.sizebc)
+	      .. ("\0"):rep(#d.dump - d.startbc - d.sizebc*4)
+    end
+    if j == 1 then
+      w("static const uint8_t libbc_code[] = {\n#if LJ_FR2\n")
     else
-      local m = x < 10 and 2 or (x < 100 and 3 or 4)
-      if xb == 0 then
+      w("\n#else\n")
+    end
+    local n = 0
+    for i=1,#s do
+      local x = string.byte(s, i)
+      local xb = string.byte(sb, i)
+      if xb == 255 then
+	local name = BCN[x]
+	local m = #name + 4
 	if n + m > 78 then n = 0; w("\n") end
+	n = n + m
+	w("BC_"); w(name)
       else
-	local name = defs[xb]:gsub("_", ".")
-	if n ~= 0 then w("\n") end
-	w("/* "); w(name); w(" */ ")
-	n = #name + 7
+	local m = x < 10 and 2 or (x < 100 and 3 or 4)
+	if xb == 0 then
+	  if n + m > 78 then n = 0; w("\n") end
+	else
+	  local name = defs[xb]:gsub("_", ".")
+	  if n ~= 0 then w("\n") end
+	  w("/* "); w(name); w(" */ ")
+	  n = #name + 7
+	end
+	n = n + m
+	w(x)
       end
-      n = n + m
-      w(x)
+      w(",")
     end
-    w(",")
   end
-  w("\n0\n};\n\n")
+  w("\n#endif\n0\n};\n\n")
   w("static const struct { const char *name; int ofs; } libbc_map[] = {\n")
-  local m = 0
-  for _,name in ipairs(defs) do
-    w('{"'); w(name); w('",'); w(m) w('},\n')
-    m = m + #defs[name].dump
+  local m32, m64 = 0, 0
+  for i,name in ipairs(defs32) do
+    assert(name == defs64[i])
+    w('{"'); w(name); w('",'); w(m32) w('},\n')
+    m32 = m32 + #defs32[name].dump
+    m64 = m64 + #defs64[name].dump
+    assert(m32 == m64)
   end
-  w("{NULL,"); w(m); w("}\n};\n\n")
+  w("{NULL,"); w(m32); w("}\n};\n\n")
   return table.concat(t)
 end
 
@@ -219,7 +227,8 @@ end
 
 local outfile = parse_arg(arg)
 local src = read_files(arg)
-local defs = find_defs(src)
-local hdr = gen_header(defs)
+local defs32 = find_defs(src, "Wdts")
+local defs64 = find_defs(src, "Xdts")
+local hdr = gen_header(defs32, defs64)
 write_file(outfile, hdr)
 
diff --git a/lib/luajit-3065c9/src/host/genminilua.lua b/lib/luajit2/src/host/genminilua.lua
similarity index 99%
rename from lib/luajit-3065c9/src/host/genminilua.lua
rename to lib/luajit2/src/host/genminilua.lua
index e8e86c538..9a6414b8e 100644
--- a/lib/luajit-3065c9/src/host/genminilua.lua
+++ b/lib/luajit2/src/host/genminilua.lua
@@ -2,7 +2,7 @@
 -- Lua script to generate a customized, minified version of Lua.
 -- The resulting 'minilua' is used for the build process of LuaJIT.
 ----------------------------------------------------------------------------
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 
diff --git a/lib/luajit2/src/host/genversion.lua b/lib/luajit2/src/host/genversion.lua
new file mode 100644
index 000000000..f0925160e
--- /dev/null
+++ b/lib/luajit2/src/host/genversion.lua
@@ -0,0 +1,45 @@
+----------------------------------------------------------------------------
+-- Lua script to embed the rolling release version in luajit.h.
+----------------------------------------------------------------------------
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
+-- Released under the MIT license. See Copyright Notice in luajit.h
+----------------------------------------------------------------------------
+
+local arg = {...}
+local FILE_ROLLING_H = arg[1] or "luajit_rolling.h"
+local FILE_RELVER_TXT = arg[2] or "luajit_relver.txt"
+local FILE_LUAJIT_H = arg[3] or "luajit.h"
+
+local function file_read(file)
+  local fp = assert(io.open(file, "rb"), "run from the wrong directory")
+  local data = assert(fp:read("*a"))
+  fp:close()
+  return data
+end
+
+local function file_write_mod(file, data)
+  local fp = io.open(file, "rb")
+  if fp then
+    local odata = assert(fp:read("*a"))
+    fp:close()
+    if odata == data then return end
+  end
+  fp = assert(io.open(file, "wb"))
+  assert(fp:write(data))
+  assert(fp:close())
+end
+
+local text = file_read(FILE_ROLLING_H):gsub("#error.-\n", "")
+local relver = file_read(FILE_RELVER_TXT):match("(%d+)")
+
+if relver then
+  text = text:gsub("ROLLING", relver)
+else
+  io.stderr:write([[
+**** WARNING Cannot determine rolling release version from git log.
+**** WARNING The 'git' command must be available during the build.
+]])
+  file_write_mod(FILE_RELVER_TXT, "ROLLING\n") -- Fallback for install target.
+end
+
+file_write_mod(FILE_LUAJIT_H, text)
diff --git a/lib/luajit-3065c9/src/host/minilua.c b/lib/luajit2/src/host/minilua.c
similarity index 100%
rename from lib/luajit-3065c9/src/host/minilua.c
rename to lib/luajit2/src/host/minilua.c
diff --git a/lib/luajit-3065c9/src/jit/.gitignore b/lib/luajit2/src/jit/.gitignore
similarity index 100%
rename from lib/luajit-3065c9/src/jit/.gitignore
rename to lib/luajit2/src/jit/.gitignore
diff --git a/lib/luajit-3065c9/src/jit/bc.lua b/lib/luajit2/src/jit/bc.lua
similarity index 78%
rename from lib/luajit-3065c9/src/jit/bc.lua
rename to lib/luajit2/src/jit/bc.lua
index 8d0844c0e..9e8ad8ba2 100644
--- a/lib/luajit-3065c9/src/jit/bc.lua
+++ b/lib/luajit2/src/jit/bc.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT bytecode listing module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 --
@@ -41,7 +41,6 @@
 
 -- Cache some library functions and objects.
 local jit = require("jit")
-assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
 local jutil = require("jit.util")
 local vmdef = require("jit.vmdef")
 local bit = require("bit")
@@ -63,15 +62,21 @@ local function ctlsub(c)
 end
 
 -- Return one bytecode line.
-local function bcline(func, pc, prefix)
-  local ins, m = funcbc(func, pc)
+local function bcline(func, pc, prefix, lineinfo)
+  local ins, m, l = funcbc(func, pc, lineinfo and 1 or 0)
   if not ins then return end
   local ma, mb, mc = band(m, 7), band(m, 15*8), band(m, 15*128)
   local a = band(shr(ins, 8), 0xff)
   local oidx = 6*band(ins, 0xff)
   local op = sub(bcnames, oidx+1, oidx+6)
-  local s = format("%04d %s %-6s %3s ",
-    pc, prefix or "  ", op, ma == 0 and "" or a)
+  local s
+  if lineinfo then
+    s = format("%04d %7s %s %-6s %3s ",
+      pc, "["..l.."]", prefix or "  ", op, ma == 0 and "" or a)
+  else
+    s = format("%04d %s %-6s %3s ",
+      pc, prefix or "  ", op, ma == 0 and "" or a)
+  end
   local d = shr(ins, 16)
   if mc == 13*128 then -- BCMjump
     return format("%s=> %04d\n", s, pc+d-0x7fff)
@@ -124,20 +129,52 @@ local function bctargets(func)
 end
 
 -- Dump bytecode instructions of a function.
-local function bcdump(func, out, all)
+local function bcdump(func, out, all, lineinfo)
   if not out then out = stdout end
   local fi = funcinfo(func)
   if all and fi.children then
     for n=-1,-1000000000,-1 do
       local k = funck(func, n)
       if not k then break end
-      if type(k) == "proto" then bcdump(k, out, true) end
+      if type(k) == "proto" then bcdump(k, out, true, lineinfo) end
     end
   end
   out:write(format("-- BYTECODE -- %s-%d\n", fi.loc, fi.lastlinedefined))
+
+  for n=-1,-1000000000,-1 do
+    local kc = funck(func, n)
+    if not kc then break end
+
+    local typ = type(kc)
+    if typ == "string" then
+      kc = format(#kc > 40 and '"%.40s"~' or '"%s"', gsub(kc, "%c", ctlsub))
+      out:write(format("KGC    %d    %s\n", -(n + 1), kc))
+    elseif typ == "proto" then
+      local fi = funcinfo(kc)
+      if fi.ffid then
+	kc = vmdef.ffnames[fi.ffid]
+      else
+	kc = fi.loc
+      end
+      out:write(format("KGC    %d    %s\n", -(n + 1), kc))
+    elseif typ == "table" then
+      out:write(format("KGC    %d    table\n", -(n + 1)))
+    else
+      -- error("unknown KGC type: " .. typ)
+    end
+  end
+
+  for n=1,1000000000 do
+    local kc = funck(func, n)
+    if not kc then break end
+    if type(kc) == "number" then
+      out:write(format("KN    %d    %s\n", n, kc))
+    end
+  end
+
   local target = bctargets(func)
   for pc=1,1000000000 do
-    local s = bcline(func, pc, target[pc] and "=>")
+    local s = bcline(func, pc, target[pc] and "=>", lineinfo)
     if not s then break end
     out:write(s)
   end
diff --git a/lib/luajit-3065c9/src/jit/bcsave.lua b/lib/luajit2/src/jit/bcsave.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/bcsave.lua
rename to lib/luajit2/src/jit/bcsave.lua
index f8ed3a1b6..eba2a0c06 100644
--- a/lib/luajit-3065c9/src/jit/bcsave.lua
+++ b/lib/luajit2/src/jit/bcsave.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT module to save/list bytecode.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 --
@@ -11,7 +11,7 @@
 ------------------------------------------------------------------------------
 
 local jit = require("jit")
-assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
+assert(jit.version_num == 20199, "LuaJIT core/library version mismatch")
 local bit = require("bit")
 
 -- Symbol name prefix for LuaJIT bytecode.
@@ -27,17 +27,22 @@ local function usage()
   io.stderr:write[[
 Save LuaJIT bytecode: luajit -b[options] input output
   -l        Only list bytecode.
+  -L        Only list bytecode with lineinfo.
   -s        Strip debug info (default).
   -g        Keep debug info.
+  -W        Generate 32 bit (non-GC64) bytecode.
+  -X        Generate 64 bit (GC64) bytecode.
+  -d        Generate bytecode in deterministic manner.
   -n name   Set module name (default: auto-detect from input name).
   -t type   Set output file type (default: auto-detect from output name).
   -a arch   Override architecture for object files (default: native).
   -o os     Override OS for object files (default: native).
+  -F name   Override filename (default: input filename).
   -e chunk  Use chunk string as input.
   --        Stop handling options.
   -         Use stdin as input and/or stdout as output.
 
-File types: c h obj o raw (default)
+File types: c cc h obj o raw (default)
 ]]
   os.exit(1)
 end
@@ -49,10 +54,23 @@ local function check(ok, ...)
   os.exit(1)
 end
 
-local function readfile(input)
-  if type(input) == "function" then return input end
-  if input == "-" then input = nil end
-  return check(loadfile(input))
+local function readfile(ctx, input)
+  if ctx.string then
+    return check(loadstring(input, nil, ctx.mode))
+  elseif ctx.filename then
+    local data
+    if input == "-" then
+      data = io.stdin:read("*a")
+    else
+      local fp = assert(io.open(input, "rb"))
+      data = assert(fp:read("*a"))
+      assert(fp:close())
+    end
+    return check(load(data, ctx.filename, ctx.mode))
+  else
+    if input == "-" then input = nil end
+    return check(loadfile(input, ctx.mode))
+  end
 end
 
 local function savefile(name, mode)
@@ -68,7 +86,7 @@ end
 ------------------------------------------------------------------------------
 
 local map_type = {
-  raw = "raw", c = "c", h = "h", o = "obj", obj = "obj",
+  raw = "raw", c = "c", cc = "c", h = "h", o = "obj", obj = "obj",
 }
 
 local map_arch = {
@@ -84,6 +102,7 @@ local map_arch = {
   mips64el =	{ e = "le", b = 64, m = 8, f = 0x80000007, },
   mips64r6 =	{ e = "be", b = 64, m = 8, f = 0xa0000407, },
   mips64r6el =	{ e = "le", b = 64, m = 8, f = 0xa0000407, },
+  s390x =	{ e = "be", b = 64, m = 22, },
 }
 
 local map_os = {
@@ -604,14 +623,14 @@ end
 
 ------------------------------------------------------------------------------
 
-local function bclist(input, output)
-  local f = readfile(input)
-  require("jit.bc").dump(f, savefile(output, "w"), true)
+local function bclist(ctx, input, output, lineinfo)
+  local f = readfile(ctx, input)
+  require("jit.bc").dump(f, savefile(output, "w"), true, lineinfo)
 end
 
 local function bcsave(ctx, input, output)
-  local f = readfile(input)
-  local s = string.dump(f, ctx.strip)
+  local f = readfile(ctx, input)
+  local s = string.dump(f, ctx.mode)
   local t = ctx.type
   if not t then
     t = detecttype(output)
@@ -633,10 +652,13 @@ local function docmd(...)
   local arg = {...}
   local n = 1
   local list = false
+  local lineinfo = false
   local ctx = {
-    strip = true, arch = jit.arch, os = jit.os:lower(),
-    type = false, modname = false,
+    mode = "bt", arch = jit.arch, os = jit.os:lower(),
+    type = false, modname = false, string = false,
   }
+  local strip = "s"
+  local gc64 = ""
   while n <= #arg do
     local a = arg[n]
     if type(a) == "string" and a:sub(1, 1) == "-" and a ~= "-" then
@@ -646,15 +668,22 @@ local function docmd(...)
 	local opt = a:sub(m, m)
 	if opt == "l" then
 	  list = true
+	elseif opt == "L" then
+	  list = true
+	  lineinfo = true
 	elseif opt == "s" then
-	  ctx.strip = true
+	  strip = "s"
 	elseif opt == "g" then
-	  ctx.strip = false
+	  strip = ""
+	elseif opt == "W" or opt == "X" then
+	  gc64 = opt
+	elseif opt == "d" then
+	  ctx.mode = ctx.mode .. opt
 	else
 	  if arg[n] == nil or m ~= #a then usage() end
 	  if opt == "e" then
 	    if n ~= 1 then usage() end
-	    arg[1] = check(loadstring(arg[1]))
+	    ctx.string = true
 	  elseif opt == "n" then
 	    ctx.modname = checkmodname(tremove(arg, n))
 	  elseif opt == "t" then
@@ -663,6 +692,8 @@ local function docmd(...)
 	    ctx.arch = checkarg(tremove(arg, n), map_arch, "architecture")
 	  elseif opt == "o" then
 	    ctx.os = checkarg(tremove(arg, n), map_os, "OS name")
+	  elseif opt == "F" then
+	    ctx.filename = "@"..tremove(arg, n)
 	  else
 	    usage()
 	  end
@@ -672,9 +703,10 @@ local function docmd(...)
       n = n + 1
     end
   end
+  ctx.mode = ctx.mode .. strip .. gc64
   if list then
     if #arg == 0 or #arg > 2 then usage() end
-    bclist(arg[1], arg[2] or "-")
+    bclist(ctx, arg[1], arg[2] or "-", lineinfo)
   else
     if #arg ~= 2 then usage() end
     bcsave(ctx, arg[1], arg[2])
diff --git a/lib/luajit-3065c9/src/jit/dis_arm.lua b/lib/luajit2/src/jit/dis_arm.lua
similarity index 99%
rename from lib/luajit-3065c9/src/jit/dis_arm.lua
rename to lib/luajit2/src/jit/dis_arm.lua
index 18ab68dfc..a7546a455 100644
--- a/lib/luajit-3065c9/src/jit/dis_arm.lua
+++ b/lib/luajit2/src/jit/dis_arm.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT ARM disassembler module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This is a helper module used by the LuaJIT machine code dumper module.
diff --git a/lib/luajit-3065c9/src/jit/dis_arm64.lua b/lib/luajit2/src/jit/dis_arm64.lua
similarity index 95%
rename from lib/luajit-3065c9/src/jit/dis_arm64.lua
rename to lib/luajit2/src/jit/dis_arm64.lua
index 531584a19..846776662 100644
--- a/lib/luajit-3065c9/src/jit/dis_arm64.lua
+++ b/lib/luajit2/src/jit/dis_arm64.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT ARM64 disassembler module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 --
 -- Contributed by Djordje Kovacevic and Stefan Pejic from RT-RK.com.
@@ -107,24 +107,20 @@ local map_logsr = { -- Logical, shifted register.
     [0] = {
       shift = 29, mask = 3,
       [0] = {
-	shift = 21, mask = 7,
-	[0] = "andDNMSg", "bicDNMSg", "andDNMSg", "bicDNMSg",
-	"andDNMSg", "bicDNMSg", "andDNMg", "bicDNMg"
+	shift = 21, mask = 1,
+	[0] = "andDNMSg", "bicDNMSg"
       },
       {
-	shift = 21, mask = 7,
-	[0] ="orr|movDN0MSg", "orn|mvnDN0MSg", "orr|movDN0MSg", "orn|mvnDN0MSg",
-	     "orr|movDN0MSg", "orn|mvnDN0MSg", "orr|movDN0Mg", "orn|mvnDN0Mg"
+	shift = 21, mask = 1,
+	[0] = "orr|movDN0MSg", "orn|mvnDN0MSg"
       },
       {
-	shift = 21, mask = 7,
-	[0] = "eorDNMSg", "eonDNMSg", "eorDNMSg", "eonDNMSg",
-	"eorDNMSg", "eonDNMSg", "eorDNMg", "eonDNMg"
+	shift = 21, mask = 1,
+	[0] = "eorDNMSg", "eonDNMSg"
       },
       {
-	shift = 21, mask = 7,
-	[0] = "ands|tstD0NMSg", "bicsDNMSg", "ands|tstD0NMSg", "bicsDNMSg",
-	"ands|tstD0NMSg", "bicsDNMSg", "ands|tstD0NMg", "bicsDNMg"
+	shift = 21, mask = 1,
+	[0] = "ands|tstD0NMSg", "bicsDNMSg"
       }
     },
     false -- unallocated
@@ -132,24 +128,20 @@ local map_logsr = { -- Logical, shifted register.
   {
     shift = 29, mask = 3,
     [0] = {
-      shift = 21, mask = 7,
-      [0] = "andDNMSg", "bicDNMSg", "andDNMSg", "bicDNMSg",
-      "andDNMSg", "bicDNMSg", "andDNMg", "bicDNMg"
+      shift = 21, mask = 1,
+      [0] = "andDNMSg", "bicDNMSg"
     },
     {
-      shift = 21, mask = 7,
-      [0] = "orr|movDN0MSg", "orn|mvnDN0MSg", "orr|movDN0MSg", "orn|mvnDN0MSg",
-      "orr|movDN0MSg", "orn|mvnDN0MSg", "orr|movDN0Mg", "orn|mvnDN0Mg"
+      shift = 21, mask = 1,
+      [0] = "orr|movDN0MSg", "orn|mvnDN0MSg"
     },
     {
-      shift = 21, mask = 7,
-      [0] = "eorDNMSg", "eonDNMSg", "eorDNMSg", "eonDNMSg",
-      "eorDNMSg", "eonDNMSg", "eorDNMg", "eonDNMg"
+      shift = 21, mask = 1,
+      [0] = "eorDNMSg", "eonDNMSg"
     },
     {
-      shift = 21, mask = 7,
-      [0] = "ands|tstD0NMSg", "bicsDNMSg", "ands|tstD0NMSg", "bicsDNMSg",
-      "ands|tstD0NMSg", "bicsDNMSg", "ands|tstD0NMg", "bicsDNMg"
+      shift = 21, mask = 1,
+      [0] = "ands|tstD0NMSg", "bicsDNMSg"
     }
   }
 }
@@ -735,7 +727,7 @@ local map_cond = {
   "hi", "ls", "ge", "lt", "gt", "le", "al",
 }
 
-local map_shift = { [0] = "lsl", "lsr", "asr", }
+local map_shift = { [0] = "lsl", "lsr", "asr", "ror"}
 
 local map_extend = {
   [0] = "uxtb", "uxth", "uxtw", "uxtx", "sxtb", "sxth", "sxtw", "sxtx",
@@ -956,7 +948,7 @@ local function disass_ins(ctx)
     elseif p == "U" then
       local rn = map_regs.x[band(rshift(op, 5), 31)]
       local sz = band(rshift(op, 30), 3)
-      local imm12 = lshift(arshift(lshift(op, 10), 20), sz)
+      local imm12 = lshift(rshift(lshift(op, 10), 20), sz)
       if imm12 ~= 0 then
 	x = "["..rn..", #"..imm12.."]"
       else
@@ -993,8 +985,7 @@ local function disass_ins(ctx)
 	x = x.."]"
       end
     elseif p == "P" then
-      local opcv, sh = rshift(op, 26), 2
-      if opcv >= 0x2a then sh = 4 elseif opcv >= 0x1b then sh = 3 end
+      local sh = 2 + rshift(op, 31 - band(rshift(op, 26), 1))
       local imm7 = lshift(arshift(lshift(op, 10), 25), sh)
       local rn = map_regs.x[band(rshift(op, 5), 31)]
       local ind = band(rshift(op, 23), 3)
diff --git a/lib/luajit-3065c9/src/jit/dis_arm64be.lua b/lib/luajit2/src/jit/dis_arm64be.lua
similarity index 90%
rename from lib/luajit-3065c9/src/jit/dis_arm64be.lua
rename to lib/luajit2/src/jit/dis_arm64be.lua
index 7337f5b7d..f7a563526 100644
--- a/lib/luajit-3065c9/src/jit/dis_arm64be.lua
+++ b/lib/luajit2/src/jit/dis_arm64be.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT ARM64BE disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- ARM64 instructions are always little-endian. So just forward to the
diff --git a/lib/luajit-3065c9/src/jit/dis_mips.lua b/lib/luajit2/src/jit/dis_mips.lua
similarity index 99%
rename from lib/luajit-3065c9/src/jit/dis_mips.lua
rename to lib/luajit2/src/jit/dis_mips.lua
index 05dc30fd1..b0e99df42 100644
--- a/lib/luajit-3065c9/src/jit/dis_mips.lua
+++ b/lib/luajit2/src/jit/dis_mips.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT MIPS disassembler module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT/X license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This is a helper module used by the LuaJIT machine code dumper module.
diff --git a/lib/luajit-3065c9/src/jit/dis_mips64.lua b/lib/luajit2/src/jit/dis_mips64.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/dis_mips64.lua
rename to lib/luajit2/src/jit/dis_mips64.lua
index 1236e524d..5f3a4dab9 100644
--- a/lib/luajit-3065c9/src/jit/dis_mips64.lua
+++ b/lib/luajit2/src/jit/dis_mips64.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT MIPS64 disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This module just exports the big-endian functions from the
diff --git a/lib/luajit-3065c9/src/jit/dis_mips64el.lua b/lib/luajit2/src/jit/dis_mips64el.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/dis_mips64el.lua
rename to lib/luajit2/src/jit/dis_mips64el.lua
index 7c478d2d0..ea5136493 100644
--- a/lib/luajit-3065c9/src/jit/dis_mips64el.lua
+++ b/lib/luajit2/src/jit/dis_mips64el.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT MIPS64EL disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This module just exports the little-endian functions from the
diff --git a/lib/luajit-3065c9/src/jit/dis_mips64r6.lua b/lib/luajit2/src/jit/dis_mips64r6.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/dis_mips64r6.lua
rename to lib/luajit2/src/jit/dis_mips64r6.lua
index c5789ce4e..1d9484119 100644
--- a/lib/luajit-3065c9/src/jit/dis_mips64r6.lua
+++ b/lib/luajit2/src/jit/dis_mips64r6.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT MIPS64R6 disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This module just exports the r6 big-endian functions from the
diff --git a/lib/luajit-3065c9/src/jit/dis_mips64r6el.lua b/lib/luajit2/src/jit/dis_mips64r6el.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/dis_mips64r6el.lua
rename to lib/luajit2/src/jit/dis_mips64r6el.lua
index f67f62400..26592e170 100644
--- a/lib/luajit-3065c9/src/jit/dis_mips64r6el.lua
+++ b/lib/luajit2/src/jit/dis_mips64r6el.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT MIPS64R6EL disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This module just exports the r6 little-endian functions from the
diff --git a/lib/luajit-3065c9/src/jit/dis_mipsel.lua b/lib/luajit2/src/jit/dis_mipsel.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/dis_mipsel.lua
rename to lib/luajit2/src/jit/dis_mipsel.lua
index a4fa6c600..6906a779e 100644
--- a/lib/luajit-3065c9/src/jit/dis_mipsel.lua
+++ b/lib/luajit2/src/jit/dis_mipsel.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT MIPSEL disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This module just exports the little-endian functions from the
diff --git a/lib/luajit-3065c9/src/jit/dis_ppc.lua b/lib/luajit2/src/jit/dis_ppc.lua
similarity index 99%
rename from lib/luajit-3065c9/src/jit/dis_ppc.lua
rename to lib/luajit2/src/jit/dis_ppc.lua
index 8f65f25aa..95c3da848 100644
--- a/lib/luajit-3065c9/src/jit/dis_ppc.lua
+++ b/lib/luajit2/src/jit/dis_ppc.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT PPC disassembler module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT/X license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This is a helper module used by the LuaJIT machine code dumper module.
diff --git a/lib/luajit2/src/jit/dis_s390x.lua b/lib/luajit2/src/jit/dis_s390x.lua
new file mode 100644
index 000000000..d03b8bb41
--- /dev/null
+++ b/lib/luajit2/src/jit/dis_s390x.lua
@@ -0,0 +1,1593 @@
+----------------------------------------------------------------------------
+-- LuaJIT s390x disassembler module.
+--
+-- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Released under the MIT license. See Copyright Notice in luajit.h
+--
+-- Contributed by Aditya Bisht from Open Mainframe.
+----------------------------------------------------------------------------
+-- This is a helper module used by the LuaJIT machine code dumper module.
+--
+-- NYI: 
+------------------------------------------------------------------------------
+
+local type = type
+local sub, byte, format = string.sub, string.byte, string.format
+local match, gmatch, gsub = string.match, string.gmatch, string.gsub
+local lower, rep = string.lower, string.rep
+local bit = require("bit")
+local band, lshift, bor, rshift = bit.band, bit.lshift, bit.bor, bit.rshift
+local tohex = bit.tohex
+
+local ONELONG = "%08lx: "
+
+local OPERAND_GPR = 	0x1	/* Operand printed as %rx */
+local OPERAND_FPR = 	0x2	/* Operand printed as %fx */
+local OPERAND_AR =  	0x4	/* Operand printed as %ax */
+local OPERAND_CR =  	0x8	/* Operand printed as %cx */
+local OPERAND_DISP =	0x10	/* Operand printed as displacement */
+local OPERAND_BASE =	0x20	/* Operand printed as base register */
+local OPERAND_INDEX =	0x40	/* Operand printed as index register */
+local OPERAND_PCREL =	0x80	/* Operand printed as pc-relative symbol */
+local OPERAND_SIGNED =	0x100	/* Operand printed as signed value */
+local OPERAND_LENGTH =	0x200	/* Operand printed as length (+1) */
+
+-- Registers
+
+local UNUSED = 0,	/* Indicates the end of the operand list */
+local R_8 = 1,	/* GPR starting at position 8 */
+local R_12 = 2,	/* GPR starting at position 12 */
+local R_16 = 3,	/* GPR starting at position 16 */
+local R_20 = 4,	/* GPR starting at position 20 */
+local R_24 = 5,	/* GPR starting at position 24 */
+local R_28 = 6,	/* GPR starting at position 28 */
+local R_32 = 7,	/* GPR starting at position 32 */
+local F_8 = 8,	/* FPR starting at position 8 */
+local F_12 = 9,	/* FPR starting at position 12 */
+local F_16 = 10,	/* FPR starting at position 16 */
+local F_20 = 11,	/* FPR starting at position 16 */
+local F_24 = 12,	/* FPR starting at position 24 */
+local F_28 = 13,	/* FPR starting at position 28 */
+local F_32 = 14,	/* FPR starting at position 32 */
+local A_8 = 15,	/* Access reg. starting at position 8 */
+local A_12 = 16,	/* Access reg. starting at position 12 */
+local A_24 = 17,	/* Access reg. starting at position 24 */
+local A_28 = 18,	/* Access reg. starting at position 28 */
+local C_8 = 19,	/* Control reg. starting at position 8 */
+local C_12 = 20,	/* Control reg. starting at position 12 */
+local B_16 = 21,	/* Base register starting at position 16 */
+local B_32 = 22,	/* Base register starting at position 32 */
+local X_12 = 23,	/* Index register starting at position 12 */
+local D_20 = 24,	/* Displacement starting at position 20 */
+local D_36 = 25,	/* Displacement starting at position 36 */
+local D20_20 = 26,	/* 20 bit displacement starting at 20 */
+local L4_8 = 27,	/* 4 bit length starting at position 8 */
+local L4_12 = 28,	/* 4 bit length starting at position 12 */
+local L8_8 = 29,	/* 8 bit length starting at position 8 */
+local U4_8 = 30,	/* 4 bit unsigned value starting at 8 */
+local U4_12 = 31,	/* 4 bit unsigned value starting at 12 */
+local U4_16 = 32,	/* 4 bit unsigned value starting at 16 */
+local U4_20 = 33,	/* 4 bit unsigned value starting at 20 */
+local U4_32 = 34,	/* 4 bit unsigned value starting at 32 */
+local U8_8 = 35,	/* 8 bit unsigned value starting at 8 */
+local U8_16 = 36,	/* 8 bit unsigned value starting at 16 */
+local U8_24 = 37,	/* 8 bit unsigned value starting at 24 */
+local U8_32 = 38,	/* 8 bit unsigned value starting at 32 */
+local I8_8 = 39,	/* 8 bit signed value starting at 8 */
+local I8_32 = 40,	/* 8 bit signed value starting at 32 */
+local I16_16 = 41,	/* 16 bit signed value starting at 16 */
+local I16_32 = 42,	/* 32 bit signed value starting at 16 */
+local U16_16 = 43,	/* 16 bit unsigned value starting at 16 */
+local U16_32 = 44,	/* 32 bit unsigned value starting at 16 */
+local J16_16 = 45,	/* PC relative jump offset at 16 */
+local J32_16 = 46,	/* PC relative long offset at 16 */
+local I32_16 = 47,	/* 32 bit signed value starting at 16 */
+local U32_16 = 48,	/* 32 bit unsigned value starting at 16 */
+local M_16 = 49,	/* 4 bit optional mask starting at 16 */
+local RO_28 = 50	/* optional GPR starting at position 28 */
+
+-- Enumeration of the different instruction formats.
+-- For details consult the principles of operation.
+
+local INSTR_INVALID = 1,
+local INSTR_E = 2,
+local INSTR_RIE_R0IU = 3,
+local INSTR_RIE_R0UU = 4,
+local INSTR_RIE_RRP = 5,
+local INSTR_RIE_RRPU = 6,
+local INSTR_RIE_RRUUU = 7,
+local INSTR_RIE_RUPI = 8,
+local INSTR_RIE_RUPU = 9,
+local INSTR_RIL_RI = 10,
+local INSTR_RIL_RP = 11,
+local INSTR_RIL_RU = 12,
+local INSTR_RIL_UP = 13,
+local INSTR_RIS_R0RDU = 14,
+local INSTR_RIS_R0UU = 15,
+local INSTR_RIS_RURDI = 16,
+local INSTR_RIS_RURDU = 17,
+local INSTR_RI_RI = 18,
+local INSTR_RI_RP = 19,
+local INSTR_RI_RU = 20,
+local INSTR_RI_UP = 21,
+local INSTR_RRE_00 = 22,
+local INSTR_RRE_0R = 23,
+local INSTR_RRE_AA = 24,
+local INSTR_RRE_AR = 25,
+local INSTR_RRE_F0 = 26,
+local INSTR_RRE_FF = 27,
+local INSTR_RRE_FR = 28,
+local INSTR_RRE_R0 = 29,
+local INSTR_RRE_RA = 30,
+local INSTR_RRE_RF = 31,
+local INSTR_RRE_RR = 32,
+local INSTR_RRE_RR_OPT = 33,
+local INSTR_RRF_0UFF = 34,
+local INSTR_RRF_F0FF = 35,
+local INSTR_RRF_F0FF2 = 36,
+local INSTR_RRF_F0FR = 37,
+local INSTR_RRF_FFRU = 38,
+local INSTR_RRF_FUFF = 39,
+local INSTR_RRF_M0RR = 40,
+local INSTR_RRF_R0RR = 41,
+local INSTR_RRF_RURR = 42,
+local INSTR_RRF_U0FF = 43,
+local INSTR_RRF_U0RF = 44,
+local INSTR_RRF_U0RR = 45,
+local INSTR_RRF_UUFF = 46,
+local INSTR_RRR_F0FF = 47,
+local INSTR_RRS_RRRDU = 48,
+local INSTR_RR_FF = 49,
+local INSTR_RR_R0 = 50,
+local INSTR_RR_RR = 51,
+local INSTR_RR_U0 = 52,
+local INSTR_RR_UR = 53,
+local INSTR_RSE_CCRD = 54,
+local INSTR_RSE_RRRD = 55,
+local INSTR_RSE_RURD = 56,
+local INSTR_RSI_RRP = 57,
+local INSTR_RSL_R0RD = 58,
+local INSTR_RSY_AARD = 59,
+local INSTR_RSY_CCRD = 60,
+local INSTR_RSY_RRRD = 61,
+local INSTR_RSY_RURD = 62,
+local INSTR_RS_AARD = 63,
+local INSTR_RS_CCRD = 64,
+local INSTR_RS_R0RD = 65,
+local INSTR_RS_RRRD = 66,
+local INSTR_RS_RURD = 67,
+local INSTR_RXE_FRRD = 68,
+local INSTR_RXE_RRRD = 69,
+local INSTR_RXF_FRRDF = 70,
+local INSTR_RXY_FRRD = 71,
+local INSTR_RXY_RRRD = 72,
+local INSTR_RXY_URRD = 73,
+local INSTR_RX_FRRD = 74,
+local INSTR_RX_RRRD = 75,
+local INSTR_RX_URRD = 76,
+local INSTR_SIL_RDI = 77,
+local INSTR_SIL_RDU = 78,
+local INSTR_SIY_IRD = 79,
+local INSTR_SIY_URD = 80,
+local INSTR_SI_URD = 81,
+local INSTR_SSE_RDRD = 82,
+local INSTR_SSF_RRDRD = 83,
+local INSTR_SS_L0RDRD = 84,
+local INSTR_SS_LIRDRD = 85,
+local INSTR_SS_LLRDRD = 86,
+local INSTR_SS_RRRDRD = 87,
+local INSTR_SS_RRRDRD2 = 88,
+local INSTR_SS_RRRDRD3 = 89,
+local INSTR_S_00 = 90,
+local INSTR_S_RD = 91
+
+local operands = {
+    [UNUSED]  = { 0, 0, 0 },
+	[R_8]	 = {  4,  8, OPERAND_GPR },
+	[R_12]	 = {  4, 12, OPERAND_GPR },
+	[R_16]	 = {  4, 16, OPERAND_GPR },
+	[R_20]	 = {  4, 20, OPERAND_GPR },
+	[R_24]	 = {  4, 24, OPERAND_GPR },
+	[R_28]	 = {  4, 28, OPERAND_GPR },
+	[R_32]	 = {  4, 32, OPERAND_GPR },
+	[F_8]	 = {  4,  8, OPERAND_FPR },
+	[F_12]	 = {  4, 12, OPERAND_FPR },
+	[F_16]	 = {  4, 16, OPERAND_FPR },
+	[F_20]	 = {  4, 16, OPERAND_FPR },
+	[F_24]	 = {  4, 24, OPERAND_FPR },
+	[F_28]	 = {  4, 28, OPERAND_FPR },
+	[F_32]	 = {  4, 32, OPERAND_FPR },
+	[A_8]	 = {  4,  8, OPERAND_AR },
+	[A_12]	 = {  4, 12, OPERAND_AR },
+	[A_24]	 = {  4, 24, OPERAND_AR },
+	[A_28]	 = {  4, 28, OPERAND_AR },
+	[C_8]	 = {  4,  8, OPERAND_CR },
+	[C_12]	 = {  4, 12, OPERAND_CR },
+	[B_16]	 = {  4, 16, OPERAND_BASE | OPERAND_GPR },
+	[B_32]	 = {  4, 32, OPERAND_BASE | OPERAND_GPR },
+	[X_12]	 = {  4, 12, OPERAND_INDEX | OPERAND_GPR },
+	[D_20]	 = { 12, 20, OPERAND_DISP },
+	[D_36]	 = { 12, 36, OPERAND_DISP },
+	[D20_20] = { 20, 20, OPERAND_DISP | OPERAND_SIGNED },
+	[L4_8]	 = {  4,  8, OPERAND_LENGTH },
+	[L4_12]  = {  4, 12, OPERAND_LENGTH },
+	[L8_8]	 = {  8,  8, OPERAND_LENGTH },
+	[U4_8]	 = {  4,  8, 0 },
+	[U4_12]  = {  4, 12, 0 },
+	[U4_16]  = {  4, 16, 0 },
+	[U4_20]  = {  4, 20, 0 },
+	[U4_32]  = {  4, 32, 0 },
+	[U8_8]	 = {  8,  8, 0 },
+	[U8_16]  = {  8, 16, 0 },
+	[U8_24]  = {  8, 24, 0 },
+	[U8_32]  = {  8, 32, 0 },
+	[I16_16] = { 16, 16, OPERAND_SIGNED },
+	[U16_16] = { 16, 16, 0 },
+	[U16_32] = { 16, 32, 0 },
+	[J16_16] = { 16, 16, OPERAND_PCREL },
+	[I16_32] = { 16, 32, OPERAND_SIGNED },
+	[J32_16] = { 32, 16, OPERAND_PCREL },
+	[I32_16] = { 32, 16, OPERAND_SIGNED },
+	[U32_16] = { 32, 16, 0 },
+	[M_16]	 = {  4, 16, 0 },
+	[RO_28]  = {  4, 28, OPERAND_GPR }
+}
+
+local formats = {
+    [INSTR_E]	  = { 0xff, 0,0,0,0,0,0 },
+	[INSTR_RIE_R0UU]  = { 0xff, R_8,U16_16,U4_32,0,0,0 },
+	[INSTR_RIE_RRPU]  = { 0xff, R_8,R_12,U4_32,J16_16,0,0 },
+	[INSTR_RIE_RRP]	  = { 0xff, R_8,R_12,J16_16,0,0,0 },
+	[INSTR_RIE_RRUUU] = { 0xff, R_8,R_12,U8_16,U8_24,U8_32,0 },
+	[INSTR_RIE_RUPI]  = { 0xff, R_8,I8_32,U4_12,J16_16,0,0 },
+	[INSTR_RIL_RI]	  = { 0x0f, R_8,I32_16,0,0,0,0 },
+	[INSTR_RIL_RP]	  = { 0x0f, R_8,J32_16,0,0,0,0 },
+	[INSTR_RIL_RU]	  = { 0x0f, R_8,U32_16,0,0,0,0 },
+	[INSTR_RIL_UP]	  = { 0x0f, U4_8,J32_16,0,0,0,0 },
+	[INSTR_RIS_R0RDU] = { 0xff, R_8,U8_32,D_20,B_16,0,0 },
+	[INSTR_RIS_RURDI] = { 0xff, R_8,I8_32,U4_12,D_20,B_16,0 },
+	[INSTR_RIS_RURDU] = { 0xff, R_8,U8_32,U4_12,D_20,B_16,0 },
+	[INSTR_RI_RI]	  = { 0x0f, R_8,I16_16,0,0,0,0 },
+	[INSTR_RI_RP]	  = { 0x0f, R_8,J16_16,0,0,0,0 },
+	[INSTR_RI_RU]	  = { 0x0f, R_8,U16_16,0,0,0,0 },
+	[INSTR_RI_UP]	  = { 0x0f, U4_8,J16_16,0,0,0,0 },
+	[INSTR_RRE_00]	  = { 0xff, 0,0,0,0,0,0 },
+	[INSTR_RRE_0R]	  = { 0xff, R_28,0,0,0,0,0 },
+	[INSTR_RRE_AA]	  = { 0xff, A_24,A_28,0,0,0,0 },
+	[INSTR_RRE_AR]	  = { 0xff, A_24,R_28,0,0,0,0 },
+	[INSTR_RRE_F0]	  = { 0xff, F_24,0,0,0,0,0 },
+	[INSTR_RRE_FF]	  = { 0xff, F_24,F_28,0,0,0,0 },
+	[INSTR_RRE_FR]	  = { 0xff, F_24,R_28,0,0,0,0 },
+	[INSTR_RRE_R0]	  = { 0xff, R_24,0,0,0,0,0 },
+	[INSTR_RRE_RA]	  = { 0xff, R_24,A_28,0,0,0,0 },
+	[INSTR_RRE_RF]	  = { 0xff, R_24,F_28,0,0,0,0 },
+	[INSTR_RRE_RR]	  = { 0xff, R_24,R_28,0,0,0,0 },
+	[INSTR_RRE_RR_OPT]= { 0xff, R_24,RO_28,0,0,0,0 },
+	[INSTR_RRF_0UFF]  = { 0xff, F_24,F_28,U4_20,0,0,0 },
+	[INSTR_RRF_F0FF2] = { 0xff, F_24,F_16,F_28,0,0,0 },
+	[INSTR_RRF_F0FF]  = { 0xff, F_16,F_24,F_28,0,0,0 },
+	[INSTR_RRF_F0FR]  = { 0xff, F_24,F_16,R_28,0,0,0 },
+	[INSTR_RRF_FFRU]  = { 0xff, F_24,F_16,R_28,U4_20,0,0 },
+	[INSTR_RRF_FUFF]  = { 0xff, F_24,F_16,F_28,U4_20,0,0 },
+	[INSTR_RRF_M0RR]  = { 0xff, R_24,R_28,M_16,0,0,0 },
+	[INSTR_RRF_R0RR]  = { 0xff, R_24,R_16,R_28,0,0,0 },
+	[INSTR_RRF_RURR]  = { 0xff, R_24,R_28,R_16,U4_20,0,0 },
+	[INSTR_RRF_U0FF]  = { 0xff, F_24,U4_16,F_28,0,0,0 },
+	[INSTR_RRF_U0RF]  = { 0xff, R_24,U4_16,F_28,0,0,0 },
+	[INSTR_RRF_U0RR]  = { 0xff, R_24,R_28,U4_16,0,0,0 },
+	[INSTR_RRF_UUFF]  = { 0xff, F_24,U4_16,F_28,U4_20,0,0 },
+	[INSTR_RRR_F0FF]  = { 0xff, F_24,F_28,F_16,0,0,0 },
+	[INSTR_RRS_RRRDU] = { 0xff, R_8,R_12,U4_32,D_20,B_16,0 },
+	[INSTR_RR_FF]	  = { 0xff, F_8,F_12,0,0,0,0 },
+	[INSTR_RR_R0]	  = { 0xff, R_8, 0,0,0,0,0 },
+	[INSTR_RR_RR]	  = { 0xff, R_8,R_12,0,0,0,0 },
+	[INSTR_RR_U0]	  = { 0xff, U8_8, 0,0,0,0,0 },
+	[INSTR_RR_UR]	  = { 0xff, U4_8,R_12,0,0,0,0 },
+	[INSTR_RSE_CCRD]  = { 0xff, C_8,C_12,D_20,B_16,0,0 },
+	[INSTR_RSE_RRRD]  = { 0xff, R_8,R_12,D_20,B_16,0,0 },
+	[INSTR_RSE_RURD]  = { 0xff, R_8,U4_12,D_20,B_16,0,0 },
+	[INSTR_RSI_RRP]	  = { 0xff, R_8,R_12,J16_16,0,0,0 },
+	[INSTR_RSL_R0RD]  = { 0xff, D_20,L4_8,B_16,0,0,0 },
+	[INSTR_RSY_AARD]  = { 0xff, A_8,A_12,D20_20,B_16,0,0 },
+	[INSTR_RSY_CCRD]  = { 0xff, C_8,C_12,D20_20,B_16,0,0 },
+	[INSTR_RSY_RRRD]  = { 0xff, R_8,R_12,D20_20,B_16,0,0 },
+	[INSTR_RSY_RURD]  = { 0xff, R_8,U4_12,D20_20,B_16,0,0 },
+	[INSTR_RS_AARD]	  = { 0xff, A_8,A_12,D_20,B_16,0,0 },
+	[INSTR_RS_CCRD]	  = { 0xff, C_8,C_12,D_20,B_16,0,0 },
+	[INSTR_RS_R0RD]	  = { 0xff, R_8,D_20,B_16,0,0,0 },
+	[INSTR_RS_RRRD]	  = { 0xff, R_8,R_12,D_20,B_16,0,0 },
+	[INSTR_RS_RURD]	  = { 0xff, R_8,U4_12,D_20,B_16,0,0 },
+	[INSTR_RXE_FRRD]  = { 0xff, F_8,D_20,X_12,B_16,0,0 },
+	[INSTR_RXE_RRRD]  = { 0xff, R_8,D_20,X_12,B_16,0,0 },
+	[INSTR_RXF_FRRDF] = { 0xff, F_32,F_8,D_20,X_12,B_16,0 },
+	[INSTR_RXY_FRRD]  = { 0xff, F_8,D20_20,X_12,B_16,0,0 },
+	[INSTR_RXY_RRRD]  = { 0xff, R_8,D20_20,X_12,B_16,0,0 },
+	[INSTR_RXY_URRD]  = { 0xff, U4_8,D20_20,X_12,B_16,0,0 },
+	[INSTR_RX_FRRD]	  = { 0xff, F_8,D_20,X_12,B_16,0,0 },
+	[INSTR_RX_RRRD]	  = { 0xff, R_8,D_20,X_12,B_16,0,0 },
+	[INSTR_RX_URRD]	  = { 0xff, U4_8,D_20,X_12,B_16,0,0 },
+	[INSTR_SIL_RDI]   = { 0xff, D_20,B_16,I16_32,0,0,0 },
+	[INSTR_SIL_RDU]   = { 0xff, D_20,B_16,U16_32,0,0,0 },
+	[INSTR_SIY_IRD]   = { 0xff, D20_20,B_16,I8_8,0,0,0 },
+	[INSTR_SIY_URD]	  = { 0xff, D20_20,B_16,U8_8,0,0,0 },
+	[INSTR_SI_URD]	  = { 0xff, D_20,B_16,U8_8,0,0,0 },
+	[INSTR_SSE_RDRD]  = { 0xff, D_20,B_16,D_36,B_32,0,0 },
+	[INSTR_SSF_RRDRD] = { 0x00, D_20,B_16,D_36,B_32,R_8,0 },
+	[INSTR_SS_L0RDRD] = { 0xff, D_20,L8_8,B_16,D_36,B_32,0 },
+	[INSTR_SS_LIRDRD] = { 0xff, D_20,L4_8,B_16,D_36,B_32,U4_12 },
+	[INSTR_SS_LLRDRD] = { 0xff, D_20,L4_8,B_16,D_36,L4_12,B_32 },
+	[INSTR_SS_RRRDRD2]= { 0xff, R_8,D_20,B_16,R_12,D_36,B_32 },
+	[INSTR_SS_RRRDRD3]= { 0xff, R_8,R_12,D_20,B_16,D_36,B_32 },
+	[INSTR_SS_RRRDRD] = { 0xff, D_20,R_8,B_16,D_36,B_32,R_12 },
+	[INSTR_S_00]	  = { 0xff, 0,0,0,0,0,0 },
+	[INSTR_S_RD]	  = { 0xff, D_20,B_16,0,0,0,0 },
+}
+
+local opcode = {
+    { "lmd", 0xef, INSTR_SS_RRRDRD3 },
+    { "spm", 0x04, INSTR_RR_R0 },
+	{ "balr", 0x05, INSTR_RR_RR },
+	{ "bctr", 0x06, INSTR_RR_RR },
+	{ "bcr", 0x07, INSTR_RR_UR },
+	{ "svc", 0x0a, INSTR_RR_U0 },
+	{ "bsm", 0x0b, INSTR_RR_RR },
+	{ "bassm", 0x0c, INSTR_RR_RR },
+	{ "basr", 0x0d, INSTR_RR_RR },
+	{ "mvcl", 0x0e, INSTR_RR_RR },
+	{ "clcl", 0x0f, INSTR_RR_RR },
+	{ "lpr", 0x10, INSTR_RR_RR },
+	{ "lnr", 0x11, INSTR_RR_RR },
+	{ "ltr", 0x12, INSTR_RR_RR },
+	{ "lcr", 0x13, INSTR_RR_RR },
+	{ "nr", 0x14, INSTR_RR_RR },
+	{ "clr", 0x15, INSTR_RR_RR },
+	{ "or", 0x16, INSTR_RR_RR },
+	{ "xr", 0x17, INSTR_RR_RR },
+	{ "lr", 0x18, INSTR_RR_RR },
+	{ "cr", 0x19, INSTR_RR_RR },
+	{ "ar", 0x1a, INSTR_RR_RR },
+	{ "sr", 0x1b, INSTR_RR_RR },
+	{ "mr", 0x1c, INSTR_RR_RR },
+	{ "dr", 0x1d, INSTR_RR_RR },
+	{ "alr", 0x1e, INSTR_RR_RR },
+	{ "slr", 0x1f, INSTR_RR_RR },
+	{ "lpdr", 0x20, INSTR_RR_FF },
+	{ "lndr", 0x21, INSTR_RR_FF },
+	{ "ltdr", 0x22, INSTR_RR_FF },
+	{ "lcdr", 0x23, INSTR_RR_FF },
+	{ "hdr", 0x24, INSTR_RR_FF },
+	{ "ldxr", 0x25, INSTR_RR_FF },
+	{ "lrdr", 0x25, INSTR_RR_FF },
+	{ "mxr", 0x26, INSTR_RR_FF },
+	{ "mxdr", 0x27, INSTR_RR_FF },
+	{ "ldr", 0x28, INSTR_RR_FF },
+	{ "cdr", 0x29, INSTR_RR_FF },
+	{ "adr", 0x2a, INSTR_RR_FF },
+	{ "sdr", 0x2b, INSTR_RR_FF },
+	{ "mdr", 0x2c, INSTR_RR_FF },
+	{ "ddr", 0x2d, INSTR_RR_FF },
+	{ "awr", 0x2e, INSTR_RR_FF },
+	{ "swr", 0x2f, INSTR_RR_FF },
+	{ "lper", 0x30, INSTR_RR_FF },
+	{ "lner", 0x31, INSTR_RR_FF },
+	{ "lter", 0x32, INSTR_RR_FF },
+	{ "lcer", 0x33, INSTR_RR_FF },
+	{ "her", 0x34, INSTR_RR_FF },
+	{ "ledr", 0x35, INSTR_RR_FF },
+	{ "lrer", 0x35, INSTR_RR_FF },
+	{ "axr", 0x36, INSTR_RR_FF },
+	{ "sxr", 0x37, INSTR_RR_FF },
+	{ "ler", 0x38, INSTR_RR_FF },
+	{ "cer", 0x39, INSTR_RR_FF },
+	{ "aer", 0x3a, INSTR_RR_FF },
+	{ "ser", 0x3b, INSTR_RR_FF },
+	{ "mder", 0x3c, INSTR_RR_FF },
+	{ "mer", 0x3c, INSTR_RR_FF },
+	{ "der", 0x3d, INSTR_RR_FF },
+	{ "aur", 0x3e, INSTR_RR_FF },
+	{ "sur", 0x3f, INSTR_RR_FF },
+	{ "sth", 0x40, INSTR_RX_RRRD },
+	{ "la", 0x41, INSTR_RX_RRRD },
+	{ "stc", 0x42, INSTR_RX_RRRD },
+	{ "ic", 0x43, INSTR_RX_RRRD },
+	{ "ex", 0x44, INSTR_RX_RRRD },
+	{ "bal", 0x45, INSTR_RX_RRRD },
+	{ "bct", 0x46, INSTR_RX_RRRD },
+	{ "bc", 0x47, INSTR_RX_URRD },
+	{ "lh", 0x48, INSTR_RX_RRRD },
+	{ "ch", 0x49, INSTR_RX_RRRD },
+	{ "ah", 0x4a, INSTR_RX_RRRD },
+	{ "sh", 0x4b, INSTR_RX_RRRD },
+	{ "mh", 0x4c, INSTR_RX_RRRD },
+	{ "bas", 0x4d, INSTR_RX_RRRD },
+	{ "cvd", 0x4e, INSTR_RX_RRRD },
+	{ "cvb", 0x4f, INSTR_RX_RRRD },
+	{ "st", 0x50, INSTR_RX_RRRD },
+	{ "lae", 0x51, INSTR_RX_RRRD },
+	{ "n", 0x54, INSTR_RX_RRRD },
+	{ "cl", 0x55, INSTR_RX_RRRD },
+	{ "o", 0x56, INSTR_RX_RRRD },
+	{ "x", 0x57, INSTR_RX_RRRD },
+	{ "l", 0x58, INSTR_RX_RRRD },
+	{ "c", 0x59, INSTR_RX_RRRD },
+	{ "a", 0x5a, INSTR_RX_RRRD },
+	{ "s", 0x5b, INSTR_RX_RRRD },
+	{ "m", 0x5c, INSTR_RX_RRRD },
+	{ "d", 0x5d, INSTR_RX_RRRD },
+	{ "al", 0x5e, INSTR_RX_RRRD },
+	{ "sl", 0x5f, INSTR_RX_RRRD },
+	{ "std", 0x60, INSTR_RX_FRRD },
+	{ "mxd", 0x67, INSTR_RX_FRRD },
+	{ "ld", 0x68, INSTR_RX_FRRD },
+	{ "cd", 0x69, INSTR_RX_FRRD },
+	{ "ad", 0x6a, INSTR_RX_FRRD },
+	{ "sd", 0x6b, INSTR_RX_FRRD },
+	{ "md", 0x6c, INSTR_RX_FRRD },
+	{ "dd", 0x6d, INSTR_RX_FRRD },
+	{ "aw", 0x6e, INSTR_RX_FRRD },
+	{ "sw", 0x6f, INSTR_RX_FRRD },
+	{ "ste", 0x70, INSTR_RX_FRRD },
+	{ "ms", 0x71, INSTR_RX_RRRD },
+	{ "le", 0x78, INSTR_RX_FRRD },
+	{ "ce", 0x79, INSTR_RX_FRRD },
+	{ "ae", 0x7a, INSTR_RX_FRRD },
+	{ "se", 0x7b, INSTR_RX_FRRD },
+	{ "mde", 0x7c, INSTR_RX_FRRD },
+	{ "me", 0x7c, INSTR_RX_FRRD },
+	{ "de", 0x7d, INSTR_RX_FRRD },
+	{ "au", 0x7e, INSTR_RX_FRRD },
+	{ "su", 0x7f, INSTR_RX_FRRD },
+	{ "ssm", 0x80, INSTR_S_RD },
+	{ "lpsw", 0x82, INSTR_S_RD },
+	{ "diag", 0x83, INSTR_RS_RRRD },
+	{ "brxh", 0x84, INSTR_RSI_RRP },
+	{ "brxle", 0x85, INSTR_RSI_RRP },
+	{ "bxh", 0x86, INSTR_RS_RRRD },
+	{ "bxle", 0x87, INSTR_RS_RRRD },
+	{ "srl", 0x88, INSTR_RS_R0RD },
+	{ "sll", 0x89, INSTR_RS_R0RD },
+	{ "sra", 0x8a, INSTR_RS_R0RD },
+	{ "sla", 0x8b, INSTR_RS_R0RD },
+	{ "srdl", 0x8c, INSTR_RS_R0RD },
+	{ "sldl", 0x8d, INSTR_RS_R0RD },
+	{ "srda", 0x8e, INSTR_RS_R0RD },
+	{ "slda", 0x8f, INSTR_RS_R0RD },
+	{ "stm", 0x90, INSTR_RS_RRRD },
+	{ "tm", 0x91, INSTR_SI_URD },
+	{ "mvi", 0x92, INSTR_SI_URD },
+	{ "ts", 0x93, INSTR_S_RD },
+	{ "ni", 0x94, INSTR_SI_URD },
+	{ "cli", 0x95, INSTR_SI_URD },
+	{ "oi", 0x96, INSTR_SI_URD },
+	{ "xi", 0x97, INSTR_SI_URD },
+	{ "lm", 0x98, INSTR_RS_RRRD },
+	{ "trace", 0x99, INSTR_RS_RRRD },
+	{ "lam", 0x9a, INSTR_RS_AARD },
+	{ "stam", 0x9b, INSTR_RS_AARD },
+	{ "mvcle", 0xa8, INSTR_RS_RRRD },
+	{ "clcle", 0xa9, INSTR_RS_RRRD },
+	{ "stnsm", 0xac, INSTR_SI_URD },
+	{ "stosm", 0xad, INSTR_SI_URD },
+	{ "sigp", 0xae, INSTR_RS_RRRD },
+	{ "mc", 0xaf, INSTR_SI_URD },
+	{ "lra", 0xb1, INSTR_RX_RRRD },
+	{ "stctl", 0xb6, INSTR_RS_CCRD },
+	{ "lctl", 0xb7, INSTR_RS_CCRD },
+	{ "cs", 0xba, INSTR_RS_RRRD },
+	{ "cds", 0xbb, INSTR_RS_RRRD },
+	{ "clm", 0xbd, INSTR_RS_RURD },
+	{ "stcm", 0xbe, INSTR_RS_RURD },
+	{ "icm", 0xbf, INSTR_RS_RURD },
+	{ "mvn", 0xd1, INSTR_SS_L0RDRD },
+	{ "mvc", 0xd2, INSTR_SS_L0RDRD },
+	{ "mvz", 0xd3, INSTR_SS_L0RDRD },
+	{ "nc", 0xd4, INSTR_SS_L0RDRD },
+	{ "clc", 0xd5, INSTR_SS_L0RDRD },
+	{ "oc", 0xd6, INSTR_SS_L0RDRD },
+	{ "xc", 0xd7, INSTR_SS_L0RDRD },
+	{ "mvck", 0xd9, INSTR_SS_RRRDRD },
+	{ "mvcp", 0xda, INSTR_SS_RRRDRD },
+	{ "mvcs", 0xdb, INSTR_SS_RRRDRD },
+	{ "tr", 0xdc, INSTR_SS_L0RDRD },
+	{ "trt", 0xdd, INSTR_SS_L0RDRD },
+	{ "ed", 0xde, INSTR_SS_L0RDRD },
+	{ "edmk", 0xdf, INSTR_SS_L0RDRD },
+	{ "pku", 0xe1, INSTR_SS_L0RDRD },
+	{ "unpku", 0xe2, INSTR_SS_L0RDRD },
+	{ "mvcin", 0xe8, INSTR_SS_L0RDRD },
+	{ "pka", 0xe9, INSTR_SS_L0RDRD },
+	{ "unpka", 0xea, INSTR_SS_L0RDRD },
+	{ "plo", 0xee, INSTR_SS_RRRDRD2 },
+	{ "srp", 0xf0, INSTR_SS_LIRDRD },
+	{ "mvo", 0xf1, INSTR_SS_LLRDRD },
+	{ "pack", 0xf2, INSTR_SS_LLRDRD },
+	{ "unpk", 0xf3, INSTR_SS_LLRDRD },
+	{ "zap", 0xf8, INSTR_SS_LLRDRD },
+	{ "cp", 0xf9, INSTR_SS_LLRDRD },
+	{ "ap", 0xfa, INSTR_SS_LLRDRD },
+	{ "sp", 0xfb, INSTR_SS_LLRDRD },
+	{ "mp", 0xfc, INSTR_SS_LLRDRD },
+	{ "dp", 0xfd, INSTR_SS_LLRDRD },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_01 = {
+    { "sam64", 0x0e, INSTR_E },
+	{ "pfpo", 0x0a, INSTR_E },
+	{ "ptff", 0x04, INSTR_E },
+    { "pr", 0x01, INSTR_E },
+	{ "upt", 0x02, INSTR_E },
+	{ "sckpf", 0x07, INSTR_E },
+	{ "tam", 0x0b, INSTR_E },
+	{ "sam24", 0x0c, INSTR_E },
+	{ "sam31", 0x0d, INSTR_E },
+	{ "trap2", 0xff, INSTR_E },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_a5 = {
+    { "iihh", 0x00, INSTR_RI_RU },
+	{ "iihl", 0x01, INSTR_RI_RU },
+	{ "iilh", 0x02, INSTR_RI_RU },
+	{ "iill", 0x03, INSTR_RI_RU },
+	{ "nihh", 0x04, INSTR_RI_RU },
+	{ "nihl", 0x05, INSTR_RI_RU },
+	{ "nilh", 0x06, INSTR_RI_RU },
+	{ "nill", 0x07, INSTR_RI_RU },
+	{ "oihh", 0x08, INSTR_RI_RU },
+	{ "oihl", 0x09, INSTR_RI_RU },
+	{ "oilh", 0x0a, INSTR_RI_RU },
+	{ "oill", 0x0b, INSTR_RI_RU },
+	{ "llihh", 0x0c, INSTR_RI_RU },
+	{ "llihl", 0x0d, INSTR_RI_RU },
+	{ "llilh", 0x0e, INSTR_RI_RU },
+	{ "llill", 0x0f, INSTR_RI_RU },
+    { "", 0, INSTR_INVALID }
+}
+
+local opcode_a7 = {
+    { "tmhh", 0x02, INSTR_RI_RU },
+	{ "tmhl", 0x03, INSTR_RI_RU },
+	{ "brctg", 0x07, INSTR_RI_RP },
+	{ "lghi", 0x09, INSTR_RI_RI },
+	{ "aghi", 0x0b, INSTR_RI_RI },
+	{ "mghi", 0x0d, INSTR_RI_RI },
+	{ "cghi", 0x0f, INSTR_RI_RI },
+    { "tmlh", 0x00, INSTR_RI_RU },
+	{ "tmll", 0x01, INSTR_RI_RU },
+	{ "brc", 0x04, INSTR_RI_UP },
+	{ "bras", 0x05, INSTR_RI_RP },
+	{ "brct", 0x06, INSTR_RI_RP },
+	{ "lhi", 0x08, INSTR_RI_RI },
+	{ "ahi", 0x0a, INSTR_RI_RI },
+	{ "mhi", 0x0c, INSTR_RI_RI },
+	{ "chi", 0x0e, INSTR_RI_RI },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_b2 = {
+    { "sske", 0x2b, INSTR_RRF_M0RR },
+	{ "stckf", 0x7c, INSTR_S_RD },
+	{ "cu21", 0xa6, INSTR_RRF_M0RR },
+	{ "cuutf", 0xa6, INSTR_RRF_M0RR },
+	{ "cu12", 0xa7, INSTR_RRF_M0RR },
+	{ "cutfu", 0xa7, INSTR_RRF_M0RR },
+	{ "stfle", 0xb0, INSTR_S_RD },
+	{ "lpswe", 0xb2, INSTR_S_RD },
+	{ "srnmt", 0xb9, INSTR_S_RD },
+	{ "lfas", 0xbd, INSTR_S_RD },
+    { "stidp", 0x02, INSTR_S_RD },
+	{ "sck", 0x04, INSTR_S_RD },
+	{ "stck", 0x05, INSTR_S_RD },
+	{ "sckc", 0x06, INSTR_S_RD },
+	{ "stckc", 0x07, INSTR_S_RD },
+	{ "spt", 0x08, INSTR_S_RD },
+	{ "stpt", 0x09, INSTR_S_RD },
+	{ "spka", 0x0a, INSTR_S_RD },
+	{ "ipk", 0x0b, INSTR_S_00 },
+	{ "ptlb", 0x0d, INSTR_S_00 },
+	{ "spx", 0x10, INSTR_S_RD },
+	{ "stpx", 0x11, INSTR_S_RD },
+	{ "stap", 0x12, INSTR_S_RD },
+	{ "sie", 0x14, INSTR_S_RD },
+	{ "pc", 0x18, INSTR_S_RD },
+	{ "sac", 0x19, INSTR_S_RD },
+	{ "cfc", 0x1a, INSTR_S_RD },
+	{ "ipte", 0x21, INSTR_RRE_RR },
+	{ "ipm", 0x22, INSTR_RRE_R0 },
+	{ "ivsk", 0x23, INSTR_RRE_RR },
+	{ "iac", 0x24, INSTR_RRE_R0 },
+	{ "ssar", 0x25, INSTR_RRE_R0 },
+	{ "epar", 0x26, INSTR_RRE_R0 },
+	{ "esar", 0x27, INSTR_RRE_R0 },
+	{ "pt", 0x28, INSTR_RRE_RR },
+	{ "iske", 0x29, INSTR_RRE_RR },
+	{ "rrbe", 0x2a, INSTR_RRE_RR },
+	{ "sske", 0x2b, INSTR_RRE_RR },
+	{ "tb", 0x2c, INSTR_RRE_0R },
+	{ "dxr", 0x2d, INSTR_RRE_F0 },
+	{ "pgin", 0x2e, INSTR_RRE_RR },
+	{ "pgout", 0x2f, INSTR_RRE_RR },
+	{ "csch", 0x30, INSTR_S_00 },
+	{ "hsch", 0x31, INSTR_S_00 },
+	{ "msch", 0x32, INSTR_S_RD },
+	{ "ssch", 0x33, INSTR_S_RD },
+	{ "stsch", 0x34, INSTR_S_RD },
+	{ "tsch", 0x35, INSTR_S_RD },
+	{ "tpi", 0x36, INSTR_S_RD },
+	{ "sal", 0x37, INSTR_S_00 },
+	{ "rsch", 0x38, INSTR_S_00 },
+	{ "stcrw", 0x39, INSTR_S_RD },
+	{ "stcps", 0x3a, INSTR_S_RD },
+	{ "rchp", 0x3b, INSTR_S_00 },
+	{ "schm", 0x3c, INSTR_S_00 },
+	{ "bakr", 0x40, INSTR_RRE_RR },
+	{ "cksm", 0x41, INSTR_RRE_RR },
+	{ "sqdr", 0x44, INSTR_RRE_F0 },
+	{ "sqer", 0x45, INSTR_RRE_F0 },
+	{ "stura", 0x46, INSTR_RRE_RR },
+	{ "msta", 0x47, INSTR_RRE_R0 },
+	{ "palb", 0x48, INSTR_RRE_00 },
+	{ "ereg", 0x49, INSTR_RRE_RR },
+	{ "esta", 0x4a, INSTR_RRE_RR },
+	{ "lura", 0x4b, INSTR_RRE_RR },
+	{ "tar", 0x4c, INSTR_RRE_AR },
+	{ "cpya", 0x4d, INSTR_RRE_AA },
+	{ "sar", 0x4e, INSTR_RRE_AR },
+	{ "ear", 0x4f, INSTR_RRE_RA },
+	{ "csp", 0x50, INSTR_RRE_RR },
+	{ "msr", 0x52, INSTR_RRE_RR },
+	{ "mvpg", 0x54, INSTR_RRE_RR },
+	{ "mvst", 0x55, INSTR_RRE_RR },
+	{ "cuse", 0x57, INSTR_RRE_RR },
+	{ "bsg", 0x58, INSTR_RRE_RR },
+	{ "bsa", 0x5a, INSTR_RRE_RR },
+	{ "clst", 0x5d, INSTR_RRE_RR },
+	{ "srst", 0x5e, INSTR_RRE_RR },
+	{ "cmpsc", 0x63, INSTR_RRE_RR },
+	{ "siga", 0x74, INSTR_S_RD },
+	{ "xsch", 0x76, INSTR_S_00 },
+	{ "rp", 0x77, INSTR_S_RD },
+	{ "stcke", 0x78, INSTR_S_RD },
+	{ "sacf", 0x79, INSTR_S_RD },
+	{ "stsi", 0x7d, INSTR_S_RD },
+	{ "srnm", 0x99, INSTR_S_RD },
+	{ "stfpc", 0x9c, INSTR_S_RD },
+	{ "lfpc", 0x9d, INSTR_S_RD },
+	{ "tre", 0xa5, INSTR_RRE_RR },
+	{ "cuutf", 0xa6, INSTR_RRE_RR },
+	{ "cutfu", 0xa7, INSTR_RRE_RR },
+	{ "stfl", 0xb1, INSTR_S_RD },
+	{ "trap4", 0xff, INSTR_S_RD },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_b3 = {
+    { "maylr", 0x38, INSTR_RRF_F0FF },
+	{ "mylr", 0x39, INSTR_RRF_F0FF },
+	{ "mayr", 0x3a, INSTR_RRF_F0FF },
+	{ "myr", 0x3b, INSTR_RRF_F0FF },
+	{ "mayhr", 0x3c, INSTR_RRF_F0FF },
+	{ "myhr", 0x3d, INSTR_RRF_F0FF },
+	{ "cegbr", 0xa4, INSTR_RRE_RR },
+	{ "cdgbr", 0xa5, INSTR_RRE_RR },
+	{ "cxgbr", 0xa6, INSTR_RRE_RR },
+	{ "cgebr", 0xa8, INSTR_RRF_U0RF },
+	{ "cgdbr", 0xa9, INSTR_RRF_U0RF },
+	{ "cgxbr", 0xaa, INSTR_RRF_U0RF },
+	{ "cfer", 0xb8, INSTR_RRF_U0RF },
+	{ "cfdr", 0xb9, INSTR_RRF_U0RF },
+	{ "cfxr", 0xba, INSTR_RRF_U0RF },
+	{ "cegr", 0xc4, INSTR_RRE_RR },
+	{ "cdgr", 0xc5, INSTR_RRE_RR },
+	{ "cxgr", 0xc6, INSTR_RRE_RR },
+	{ "cger", 0xc8, INSTR_RRF_U0RF },
+	{ "cgdr", 0xc9, INSTR_RRF_U0RF },
+	{ "cgxr", 0xca, INSTR_RRF_U0RF },
+	{ "lpdfr", 0x70, INSTR_RRE_FF },
+	{ "lndfr", 0x71, INSTR_RRE_FF },
+	{ "cpsdr", 0x72, INSTR_RRF_F0FF2 },
+	{ "lcdfr", 0x73, INSTR_RRE_FF },
+	{ "ldgr", 0xc1, INSTR_RRE_FR },
+	{ "lgdr", 0xcd, INSTR_RRE_RF },
+	{ "adtr", 0xd2, INSTR_RRR_F0FF },
+	{ "axtr", 0xda, INSTR_RRR_F0FF },
+	{ "cdtr", 0xe4, INSTR_RRE_FF },
+	{ "cxtr", 0xec, INSTR_RRE_FF },
+	{ "kdtr", 0xe0, INSTR_RRE_FF },
+	{ "kxtr", 0xe8, INSTR_RRE_FF },
+	{ "cedtr", 0xf4, INSTR_RRE_FF },
+	{ "cextr", 0xfc, INSTR_RRE_FF },
+	{ "cdgtr", 0xf1, INSTR_RRE_FR },
+	{ "cxgtr", 0xf9, INSTR_RRE_FR },
+	{ "cdstr", 0xf3, INSTR_RRE_FR },
+	{ "cxstr", 0xfb, INSTR_RRE_FR },
+	{ "cdutr", 0xf2, INSTR_RRE_FR },
+	{ "cxutr", 0xfa, INSTR_RRE_FR },
+	{ "cgdtr", 0xe1, INSTR_RRF_U0RF },
+	{ "cgxtr", 0xe9, INSTR_RRF_U0RF },
+	{ "csdtr", 0xe3, INSTR_RRE_RF },
+	{ "csxtr", 0xeb, INSTR_RRE_RF },
+	{ "cudtr", 0xe2, INSTR_RRE_RF },
+	{ "cuxtr", 0xea, INSTR_RRE_RF },
+	{ "ddtr", 0xd1, INSTR_RRR_F0FF },
+	{ "dxtr", 0xd9, INSTR_RRR_F0FF },
+	{ "eedtr", 0xe5, INSTR_RRE_RF },
+	{ "eextr", 0xed, INSTR_RRE_RF },
+	{ "esdtr", 0xe7, INSTR_RRE_RF },
+	{ "esxtr", 0xef, INSTR_RRE_RF },
+	{ "iedtr", 0xf6, INSTR_RRF_F0FR },
+	{ "iextr", 0xfe, INSTR_RRF_F0FR },
+	{ "ltdtr", 0xd6, INSTR_RRE_FF },
+	{ "ltxtr", 0xde, INSTR_RRE_FF },
+	{ "fidtr", 0xd7, INSTR_RRF_UUFF },
+	{ "fixtr", 0xdf, INSTR_RRF_UUFF },
+	{ "ldetr", 0xd4, INSTR_RRF_0UFF },
+	{ "lxdtr", 0xdc, INSTR_RRF_0UFF },
+	{ "ledtr", 0xd5, INSTR_RRF_UUFF },
+	{ "ldxtr", 0xdd, INSTR_RRF_UUFF },
+	{ "mdtr", 0xd0, INSTR_RRR_F0FF },
+	{ "mxtr", 0xd8, INSTR_RRR_F0FF },
+	{ "qadtr", 0xf5, INSTR_RRF_FUFF },
+	{ "qaxtr", 0xfd, INSTR_RRF_FUFF },
+	{ "rrdtr", 0xf7, INSTR_RRF_FFRU },
+	{ "rrxtr", 0xff, INSTR_RRF_FFRU },
+	{ "sfasr", 0x85, INSTR_RRE_R0 },
+	{ "sdtr", 0xd3, INSTR_RRR_F0FF },
+	{ "sxtr", 0xdb, INSTR_RRR_F0FF },
+    { "lpebr", 0x00, INSTR_RRE_FF },
+	{ "lnebr", 0x01, INSTR_RRE_FF },
+	{ "ltebr", 0x02, INSTR_RRE_FF },
+	{ "lcebr", 0x03, INSTR_RRE_FF },
+	{ "ldebr", 0x04, INSTR_RRE_FF },
+	{ "lxdbr", 0x05, INSTR_RRE_FF },
+	{ "lxebr", 0x06, INSTR_RRE_FF },
+	{ "mxdbr", 0x07, INSTR_RRE_FF },
+	{ "kebr", 0x08, INSTR_RRE_FF },
+	{ "cebr", 0x09, INSTR_RRE_FF },
+	{ "aebr", 0x0a, INSTR_RRE_FF },
+	{ "sebr", 0x0b, INSTR_RRE_FF },
+	{ "mdebr", 0x0c, INSTR_RRE_FF },
+	{ "debr", 0x0d, INSTR_RRE_FF },
+	{ "maebr", 0x0e, INSTR_RRF_F0FF },
+	{ "msebr", 0x0f, INSTR_RRF_F0FF },
+	{ "lpdbr", 0x10, INSTR_RRE_FF },
+	{ "lndbr", 0x11, INSTR_RRE_FF },
+	{ "ltdbr", 0x12, INSTR_RRE_FF },
+	{ "lcdbr", 0x13, INSTR_RRE_FF },
+	{ "sqebr", 0x14, INSTR_RRE_FF },
+	{ "sqdbr", 0x15, INSTR_RRE_FF },
+	{ "sqxbr", 0x16, INSTR_RRE_FF },
+	{ "meebr", 0x17, INSTR_RRE_FF },
+	{ "kdbr", 0x18, INSTR_RRE_FF },
+	{ "cdbr", 0x19, INSTR_RRE_FF },
+	{ "adbr", 0x1a, INSTR_RRE_FF },
+	{ "sdbr", 0x1b, INSTR_RRE_FF },
+	{ "mdbr", 0x1c, INSTR_RRE_FF },
+	{ "ddbr", 0x1d, INSTR_RRE_FF },
+	{ "madbr", 0x1e, INSTR_RRF_F0FF },
+	{ "msdbr", 0x1f, INSTR_RRF_F0FF },
+	{ "lder", 0x24, INSTR_RRE_FF },
+	{ "lxdr", 0x25, INSTR_RRE_FF },
+	{ "lxer", 0x26, INSTR_RRE_FF },
+	{ "maer", 0x2e, INSTR_RRF_F0FF },
+	{ "mser", 0x2f, INSTR_RRF_F0FF },
+	{ "sqxr", 0x36, INSTR_RRE_FF },
+	{ "meer", 0x37, INSTR_RRE_FF },
+	{ "madr", 0x3e, INSTR_RRF_F0FF },
+	{ "msdr", 0x3f, INSTR_RRF_F0FF },
+	{ "lpxbr", 0x40, INSTR_RRE_FF },
+	{ "lnxbr", 0x41, INSTR_RRE_FF },
+	{ "ltxbr", 0x42, INSTR_RRE_FF },
+	{ "lcxbr", 0x43, INSTR_RRE_FF },
+	{ "ledbr", 0x44, INSTR_RRE_FF },
+	{ "ldxbr", 0x45, INSTR_RRE_FF },
+	{ "lexbr", 0x46, INSTR_RRE_FF },
+	{ "fixbr", 0x47, INSTR_RRF_U0FF },
+	{ "kxbr", 0x48, INSTR_RRE_FF },
+	{ "cxbr", 0x49, INSTR_RRE_FF },
+	{ "axbr", 0x4a, INSTR_RRE_FF },
+	{ "sxbr", 0x4b, INSTR_RRE_FF },
+	{ "mxbr", 0x4c, INSTR_RRE_FF },
+	{ "dxbr", 0x4d, INSTR_RRE_FF },
+	{ "tbedr", 0x50, INSTR_RRF_U0FF },
+	{ "tbdr", 0x51, INSTR_RRF_U0FF },
+	{ "diebr", 0x53, INSTR_RRF_FUFF },
+	{ "fiebr", 0x57, INSTR_RRF_U0FF },
+	{ "thder", 0x58, INSTR_RRE_RR },
+	{ "thdr", 0x59, INSTR_RRE_RR },
+	{ "didbr", 0x5b, INSTR_RRF_FUFF },
+	{ "fidbr", 0x5f, INSTR_RRF_U0FF },
+	{ "lpxr", 0x60, INSTR_RRE_FF },
+	{ "lnxr", 0x61, INSTR_RRE_FF },
+	{ "ltxr", 0x62, INSTR_RRE_FF },
+	{ "lcxr", 0x63, INSTR_RRE_FF },
+	{ "lxr", 0x65, INSTR_RRE_RR },
+	{ "lexr", 0x66, INSTR_RRE_FF },
+	{ "fixr", 0x67, INSTR_RRF_U0FF },
+	{ "cxr", 0x69, INSTR_RRE_FF },
+	{ "lzer", 0x74, INSTR_RRE_R0 },
+	{ "lzdr", 0x75, INSTR_RRE_R0 },
+	{ "lzxr", 0x76, INSTR_RRE_R0 },
+	{ "fier", 0x77, INSTR_RRF_U0FF },
+	{ "fidr", 0x7f, INSTR_RRF_U0FF },
+	{ "sfpc", 0x84, INSTR_RRE_RR_OPT },
+	{ "efpc", 0x8c, INSTR_RRE_RR_OPT },
+	{ "cefbr", 0x94, INSTR_RRE_RF },
+	{ "cdfbr", 0x95, INSTR_RRE_RF },
+	{ "cxfbr", 0x96, INSTR_RRE_RF },
+	{ "cfebr", 0x98, INSTR_RRF_U0RF },
+	{ "cfdbr", 0x99, INSTR_RRF_U0RF },
+	{ "cfxbr", 0x9a, INSTR_RRF_U0RF },
+	{ "cefr", 0xb4, INSTR_RRE_RF },
+	{ "cdfr", 0xb5, INSTR_RRE_RF },
+	{ "cxfr", 0xb6, INSTR_RRE_RF },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_b9 = {
+    { "lpgr", 0x00, INSTR_RRE_RR },
+	{ "lngr", 0x01, INSTR_RRE_RR },
+	{ "ltgr", 0x02, INSTR_RRE_RR },
+	{ "lcgr", 0x03, INSTR_RRE_RR },
+	{ "lgr", 0x04, INSTR_RRE_RR },
+	{ "lurag", 0x05, INSTR_RRE_RR },
+	{ "lgbr", 0x06, INSTR_RRE_RR },
+	{ "lghr", 0x07, INSTR_RRE_RR },
+	{ "agr", 0x08, INSTR_RRE_RR },
+	{ "sgr", 0x09, INSTR_RRE_RR },
+	{ "algr", 0x0a, INSTR_RRE_RR },
+	{ "slgr", 0x0b, INSTR_RRE_RR },
+	{ "msgr", 0x0c, INSTR_RRE_RR },
+	{ "dsgr", 0x0d, INSTR_RRE_RR },
+	{ "eregg", 0x0e, INSTR_RRE_RR },
+	{ "lrvgr", 0x0f, INSTR_RRE_RR },
+	{ "lpgfr", 0x10, INSTR_RRE_RR },
+	{ "lngfr", 0x11, INSTR_RRE_RR },
+	{ "ltgfr", 0x12, INSTR_RRE_RR },
+	{ "lcgfr", 0x13, INSTR_RRE_RR },
+	{ "lgfr", 0x14, INSTR_RRE_RR },
+	{ "llgfr", 0x16, INSTR_RRE_RR },
+	{ "llgtr", 0x17, INSTR_RRE_RR },
+	{ "agfr", 0x18, INSTR_RRE_RR },
+	{ "sgfr", 0x19, INSTR_RRE_RR },
+	{ "algfr", 0x1a, INSTR_RRE_RR },
+	{ "slgfr", 0x1b, INSTR_RRE_RR },
+	{ "msgfr", 0x1c, INSTR_RRE_RR },
+	{ "dsgfr", 0x1d, INSTR_RRE_RR },
+	{ "cgr", 0x20, INSTR_RRE_RR },
+	{ "clgr", 0x21, INSTR_RRE_RR },
+	{ "sturg", 0x25, INSTR_RRE_RR },
+	{ "lbr", 0x26, INSTR_RRE_RR },
+	{ "lhr", 0x27, INSTR_RRE_RR },
+	{ "cgfr", 0x30, INSTR_RRE_RR },
+	{ "clgfr", 0x31, INSTR_RRE_RR },
+	{ "bctgr", 0x46, INSTR_RRE_RR },
+	{ "ngr", 0x80, INSTR_RRE_RR },
+	{ "ogr", 0x81, INSTR_RRE_RR },
+	{ "xgr", 0x82, INSTR_RRE_RR },
+	{ "flogr", 0x83, INSTR_RRE_RR },
+	{ "llgcr", 0x84, INSTR_RRE_RR },
+	{ "llghr", 0x85, INSTR_RRE_RR },
+	{ "mlgr", 0x86, INSTR_RRE_RR },
+	{ "dlgr", 0x87, INSTR_RRE_RR },
+	{ "alcgr", 0x88, INSTR_RRE_RR },
+	{ "slbgr", 0x89, INSTR_RRE_RR },
+	{ "cspg", 0x8a, INSTR_RRE_RR },
+	{ "idte", 0x8e, INSTR_RRF_R0RR },
+	{ "llcr", 0x94, INSTR_RRE_RR },
+	{ "llhr", 0x95, INSTR_RRE_RR },
+	{ "esea", 0x9d, INSTR_RRE_R0 },
+	{ "lptea", 0xaa, INSTR_RRF_RURR },
+	{ "cu14", 0xb0, INSTR_RRF_M0RR },
+	{ "cu24", 0xb1, INSTR_RRF_M0RR },
+	{ "cu41", 0xb2, INSTR_RRF_M0RR },
+	{ "cu42", 0xb3, INSTR_RRF_M0RR },
+	{ "crt", 0x72, INSTR_RRF_U0RR },
+	{ "cgrt", 0x60, INSTR_RRF_U0RR },
+	{ "clrt", 0x73, INSTR_RRF_U0RR },
+	{ "clgrt", 0x61, INSTR_RRF_U0RR },
+	{ "ptf", 0xa2, INSTR_RRE_R0 },
+	{ "pfmf", 0xaf, INSTR_RRE_RR },
+	{ "trte", 0xbf, INSTR_RRF_M0RR },
+	{ "trtre", 0xbd, INSTR_RRF_M0RR },
+    { "kmac", 0x1e, INSTR_RRE_RR },
+	{ "lrvr", 0x1f, INSTR_RRE_RR },
+	{ "km", 0x2e, INSTR_RRE_RR },
+	{ "kmc", 0x2f, INSTR_RRE_RR },
+	{ "kimd", 0x3e, INSTR_RRE_RR },
+	{ "klmd", 0x3f, INSTR_RRE_RR },
+	{ "epsw", 0x8d, INSTR_RRE_RR },
+	{ "trtt", 0x90, INSTR_RRE_RR },
+	{ "trtt", 0x90, INSTR_RRF_M0RR },
+	{ "trto", 0x91, INSTR_RRE_RR },
+	{ "trto", 0x91, INSTR_RRF_M0RR },
+	{ "trot", 0x92, INSTR_RRE_RR },
+	{ "trot", 0x92, INSTR_RRF_M0RR },
+	{ "troo", 0x93, INSTR_RRE_RR },
+	{ "troo", 0x93, INSTR_RRF_M0RR },
+	{ "mlr", 0x96, INSTR_RRE_RR },
+	{ "dlr", 0x97, INSTR_RRE_RR },
+	{ "alcr", 0x98, INSTR_RRE_RR },
+	{ "slbr", 0x99, INSTR_RRE_RR },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_c0 = {
+	{ "lgfi", 0x01, INSTR_RIL_RI },
+	{ "xihf", 0x06, INSTR_RIL_RU },
+	{ "xilf", 0x07, INSTR_RIL_RU },
+	{ "iihf", 0x08, INSTR_RIL_RU },
+	{ "iilf", 0x09, INSTR_RIL_RU },
+	{ "nihf", 0x0a, INSTR_RIL_RU },
+	{ "nilf", 0x0b, INSTR_RIL_RU },
+	{ "oihf", 0x0c, INSTR_RIL_RU },
+	{ "oilf", 0x0d, INSTR_RIL_RU },
+	{ "llihf", 0x0e, INSTR_RIL_RU },
+	{ "llilf", 0x0f, INSTR_RIL_RU },
+	{ "larl", 0x00, INSTR_RIL_RP },
+	{ "brcl", 0x04, INSTR_RIL_UP },
+	{ "brasl", 0x05, INSTR_RIL_RP },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_c2 = {
+	{ "slgfi", 0x04, INSTR_RIL_RU },
+	{ "slfi", 0x05, INSTR_RIL_RU },
+	{ "agfi", 0x08, INSTR_RIL_RI },
+	{ "afi", 0x09, INSTR_RIL_RI },
+	{ "algfi", 0x0a, INSTR_RIL_RU },
+	{ "alfi", 0x0b, INSTR_RIL_RU },
+	{ "cgfi", 0x0c, INSTR_RIL_RI },
+	{ "cfi", 0x0d, INSTR_RIL_RI },
+	{ "clgfi", 0x0e, INSTR_RIL_RU },
+	{ "clfi", 0x0f, INSTR_RIL_RU },
+	{ "msfi", 0x01, INSTR_RIL_RI },
+	{ "msgfi", 0x00, INSTR_RIL_RI },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_c4 = {
+	{ "lrl", 0x0d, INSTR_RIL_RP },
+	{ "lgrl", 0x08, INSTR_RIL_RP },
+	{ "lgfrl", 0x0c, INSTR_RIL_RP },
+	{ "lhrl", 0x05, INSTR_RIL_RP },
+	{ "lghrl", 0x04, INSTR_RIL_RP },
+	{ "llgfrl", 0x0e, INSTR_RIL_RP },
+	{ "llhrl", 0x02, INSTR_RIL_RP },
+	{ "llghrl", 0x06, INSTR_RIL_RP },
+	{ "strl", 0x0f, INSTR_RIL_RP },
+	{ "stgrl", 0x0b, INSTR_RIL_RP },
+	{ "sthrl", 0x07, INSTR_RIL_RP },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_c6 = {
+	{ "crl", 0x0d, INSTR_RIL_RP },
+	{ "cgrl", 0x08, INSTR_RIL_RP },
+	{ "cgfrl", 0x0c, INSTR_RIL_RP },
+	{ "chrl", 0x05, INSTR_RIL_RP },
+	{ "cghrl", 0x04, INSTR_RIL_RP },
+	{ "clrl", 0x0f, INSTR_RIL_RP },
+	{ "clgrl", 0x0a, INSTR_RIL_RP },
+	{ "clgfrl", 0x0e, INSTR_RIL_RP },
+	{ "clhrl", 0x07, INSTR_RIL_RP },
+	{ "clghrl", 0x06, INSTR_RIL_RP },
+	{ "pfdrl", 0x02, INSTR_RIL_UP },
+	{ "exrl", 0x00, INSTR_RIL_RP },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_c8 = {
+	{ "mvcos", 0x00, INSTR_SSF_RRDRD },
+	{ "ectg", 0x01, INSTR_SSF_RRDRD },
+	{ "csst", 0x02, INSTR_SSF_RRDRD },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_e3 = {
+	{ "ltg", 0x02, INSTR_RXY_RRRD },
+	{ "lrag", 0x03, INSTR_RXY_RRRD },
+	{ "lg", 0x04, INSTR_RXY_RRRD },
+	{ "cvby", 0x06, INSTR_RXY_RRRD },
+	{ "ag", 0x08, INSTR_RXY_RRRD },
+	{ "sg", 0x09, INSTR_RXY_RRRD },
+	{ "alg", 0x0a, INSTR_RXY_RRRD },
+	{ "slg", 0x0b, INSTR_RXY_RRRD },
+	{ "msg", 0x0c, INSTR_RXY_RRRD },
+	{ "dsg", 0x0d, INSTR_RXY_RRRD },
+	{ "cvbg", 0x0e, INSTR_RXY_RRRD },
+	{ "lrvg", 0x0f, INSTR_RXY_RRRD },
+	{ "lt", 0x12, INSTR_RXY_RRRD },
+	{ "lray", 0x13, INSTR_RXY_RRRD },
+	{ "lgf", 0x14, INSTR_RXY_RRRD },
+	{ "lgh", 0x15, INSTR_RXY_RRRD },
+	{ "llgf", 0x16, INSTR_RXY_RRRD },
+	{ "llgt", 0x17, INSTR_RXY_RRRD },
+	{ "agf", 0x18, INSTR_RXY_RRRD },
+	{ "sgf", 0x19, INSTR_RXY_RRRD },
+	{ "algf", 0x1a, INSTR_RXY_RRRD },
+	{ "slgf", 0x1b, INSTR_RXY_RRRD },
+	{ "msgf", 0x1c, INSTR_RXY_RRRD },
+	{ "dsgf", 0x1d, INSTR_RXY_RRRD },
+	{ "cg", 0x20, INSTR_RXY_RRRD },
+	{ "clg", 0x21, INSTR_RXY_RRRD },
+	{ "stg", 0x24, INSTR_RXY_RRRD },
+	{ "cvdy", 0x26, INSTR_RXY_RRRD },
+	{ "cvdg", 0x2e, INSTR_RXY_RRRD },
+	{ "strvg", 0x2f, INSTR_RXY_RRRD },
+	{ "cgf", 0x30, INSTR_RXY_RRRD },
+	{ "clgf", 0x31, INSTR_RXY_RRRD },
+	{ "strvh", 0x3f, INSTR_RXY_RRRD },
+	{ "bctg", 0x46, INSTR_RXY_RRRD },
+	{ "sty", 0x50, INSTR_RXY_RRRD },
+	{ "msy", 0x51, INSTR_RXY_RRRD },
+	{ "ny", 0x54, INSTR_RXY_RRRD },
+	{ "cly", 0x55, INSTR_RXY_RRRD },
+	{ "oy", 0x56, INSTR_RXY_RRRD },
+	{ "xy", 0x57, INSTR_RXY_RRRD },
+	{ "ly", 0x58, INSTR_RXY_RRRD },
+	{ "cy", 0x59, INSTR_RXY_RRRD },
+	{ "ay", 0x5a, INSTR_RXY_RRRD },
+	{ "sy", 0x5b, INSTR_RXY_RRRD },
+	{ "aly", 0x5e, INSTR_RXY_RRRD },
+	{ "sly", 0x5f, INSTR_RXY_RRRD },
+	{ "sthy", 0x70, INSTR_RXY_RRRD },
+	{ "lay", 0x71, INSTR_RXY_RRRD },
+	{ "stcy", 0x72, INSTR_RXY_RRRD },
+	{ "icy", 0x73, INSTR_RXY_RRRD },
+	{ "lb", 0x76, INSTR_RXY_RRRD },
+	{ "lgb", 0x77, INSTR_RXY_RRRD },
+	{ "lhy", 0x78, INSTR_RXY_RRRD },
+	{ "chy", 0x79, INSTR_RXY_RRRD },
+	{ "ahy", 0x7a, INSTR_RXY_RRRD },
+	{ "shy", 0x7b, INSTR_RXY_RRRD },
+	{ "ng", 0x80, INSTR_RXY_RRRD },
+	{ "og", 0x81, INSTR_RXY_RRRD },
+	{ "xg", 0x82, INSTR_RXY_RRRD },
+	{ "mlg", 0x86, INSTR_RXY_RRRD },
+	{ "dlg", 0x87, INSTR_RXY_RRRD },
+	{ "alcg", 0x88, INSTR_RXY_RRRD },
+	{ "slbg", 0x89, INSTR_RXY_RRRD },
+	{ "stpq", 0x8e, INSTR_RXY_RRRD },
+	{ "lpq", 0x8f, INSTR_RXY_RRRD },
+	{ "llgc", 0x90, INSTR_RXY_RRRD },
+	{ "llgh", 0x91, INSTR_RXY_RRRD },
+	{ "llc", 0x94, INSTR_RXY_RRRD },
+	{ "llh", 0x95, INSTR_RXY_RRRD },
+	{ "cgh", 0x34, INSTR_RXY_RRRD },
+	{ "laey", 0x75, INSTR_RXY_RRRD },
+	{ "ltgf", 0x32, INSTR_RXY_RRRD },
+	{ "mfy", 0x5c, INSTR_RXY_RRRD },
+	{ "mhy", 0x7c, INSTR_RXY_RRRD },
+	{ "pfd", 0x36, INSTR_RXY_URRD },
+	{ "lrv", 0x1e, INSTR_RXY_RRRD },
+	{ "lrvh", 0x1f, INSTR_RXY_RRRD },
+	{ "strv", 0x3e, INSTR_RXY_RRRD },
+	{ "ml", 0x96, INSTR_RXY_RRRD },
+	{ "dl", 0x97, INSTR_RXY_RRRD },
+	{ "alc", 0x98, INSTR_RXY_RRRD },
+	{ "slb", 0x99, INSTR_RXY_RRRD },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_e5 = {
+	{ "strag", 0x02, INSTR_SSE_RDRD },
+	{ "chhsi", 0x54, INSTR_SIL_RDI },
+	{ "chsi", 0x5c, INSTR_SIL_RDI },
+	{ "cghsi", 0x58, INSTR_SIL_RDI },
+	{ "clhhsi", 0x55, INSTR_SIL_RDU },
+	{ "clfhsi", 0x5d, INSTR_SIL_RDU },
+	{ "clghsi", 0x59, INSTR_SIL_RDU },
+	{ "mvhhi", 0x44, INSTR_SIL_RDI },
+	{ "mvhi", 0x4c, INSTR_SIL_RDI },
+	{ "mvghi", 0x48, INSTR_SIL_RDI },
+	{ "lasp", 0x00, INSTR_SSE_RDRD },
+	{ "tprot", 0x01, INSTR_SSE_RDRD },
+	{ "mvcsk", 0x0e, INSTR_SSE_RDRD },
+	{ "mvcdk", 0x0f, INSTR_SSE_RDRD },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_eb = {
+	{ "lmg", 0x04, INSTR_RSY_RRRD },
+	{ "srag", 0x0a, INSTR_RSY_RRRD },
+	{ "slag", 0x0b, INSTR_RSY_RRRD },
+	{ "srlg", 0x0c, INSTR_RSY_RRRD },
+	{ "sllg", 0x0d, INSTR_RSY_RRRD },
+	{ "tracg", 0x0f, INSTR_RSY_RRRD },
+	{ "csy", 0x14, INSTR_RSY_RRRD },
+	{ "rllg", 0x1c, INSTR_RSY_RRRD },
+	{ "clmh", 0x20, INSTR_RSY_RURD },
+	{ "clmy", 0x21, INSTR_RSY_RURD },
+	{ "stmg", 0x24, INSTR_RSY_RRRD },
+	{ "stctg", 0x25, INSTR_RSY_CCRD },
+	{ "stmh", 0x26, INSTR_RSY_RRRD },
+	{ "stcmh", 0x2c, INSTR_RSY_RURD },
+	{ "stcmy", 0x2d, INSTR_RSY_RURD },
+	{ "lctlg", 0x2f, INSTR_RSY_CCRD },
+	{ "csg", 0x30, INSTR_RSY_RRRD },
+	{ "cdsy", 0x31, INSTR_RSY_RRRD },
+	{ "cdsg", 0x3e, INSTR_RSY_RRRD },
+	{ "bxhg", 0x44, INSTR_RSY_RRRD },
+	{ "bxleg", 0x45, INSTR_RSY_RRRD },
+	{ "tmy", 0x51, INSTR_SIY_URD },
+	{ "mviy", 0x52, INSTR_SIY_URD },
+	{ "niy", 0x54, INSTR_SIY_URD },
+	{ "cliy", 0x55, INSTR_SIY_URD },
+	{ "oiy", 0x56, INSTR_SIY_URD },
+	{ "xiy", 0x57, INSTR_SIY_URD },
+	{ "icmh", 0x80, INSTR_RSE_RURD },
+	{ "icmh", 0x80, INSTR_RSY_RURD },
+	{ "icmy", 0x81, INSTR_RSY_RURD },
+	{ "clclu", 0x8f, INSTR_RSY_RRRD },
+	{ "stmy", 0x90, INSTR_RSY_RRRD },
+	{ "lmh", 0x96, INSTR_RSY_RRRD },
+	{ "lmy", 0x98, INSTR_RSY_RRRD },
+	{ "lamy", 0x9a, INSTR_RSY_AARD },
+	{ "stamy", 0x9b, INSTR_RSY_AARD },
+	{ "asi", 0x6a, INSTR_SIY_IRD },
+	{ "agsi", 0x7a, INSTR_SIY_IRD },
+	{ "alsi", 0x6e, INSTR_SIY_IRD },
+	{ "algsi", 0x7e, INSTR_SIY_IRD },
+	{ "ecag", 0x4c, INSTR_RSY_RRRD },
+	{ "rll", 0x1d, INSTR_RSY_RRRD },
+	{ "mvclu", 0x8e, INSTR_RSY_RRRD },
+	{ "tp", 0xc0, INSTR_RSL_R0RD },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_ec = {
+	{ "brxhg", 0x44, INSTR_RIE_RRP },
+	{ "brxlg", 0x45, INSTR_RIE_RRP },
+	{ "crb", 0xf6, INSTR_RRS_RRRDU },
+	{ "cgrb", 0xe4, INSTR_RRS_RRRDU },
+	{ "crj", 0x76, INSTR_RIE_RRPU },
+	{ "cgrj", 0x64, INSTR_RIE_RRPU },
+	{ "cib", 0xfe, INSTR_RIS_RURDI },
+	{ "cgib", 0xfc, INSTR_RIS_RURDI },
+	{ "cij", 0x7e, INSTR_RIE_RUPI },
+	{ "cgij", 0x7c, INSTR_RIE_RUPI },
+	{ "cit", 0x72, INSTR_RIE_R0IU },
+	{ "cgit", 0x70, INSTR_RIE_R0IU },
+	{ "clrb", 0xf7, INSTR_RRS_RRRDU },
+	{ "clgrb", 0xe5, INSTR_RRS_RRRDU },
+	{ "clrj", 0x77, INSTR_RIE_RRPU },
+	{ "clgrj", 0x65, INSTR_RIE_RRPU },
+	{ "clib", 0xff, INSTR_RIS_RURDU },
+	{ "clgib", 0xfd, INSTR_RIS_RURDU },
+	{ "clij", 0x7f, INSTR_RIE_RUPU },
+	{ "clgij", 0x7d, INSTR_RIE_RUPU },
+	{ "clfit", 0x73, INSTR_RIE_R0UU },
+	{ "clgit", 0x71, INSTR_RIE_R0UU },
+	{ "rnsbg", 0x54, INSTR_RIE_RRUUU },
+	{ "rxsbg", 0x57, INSTR_RIE_RRUUU },
+	{ "rosbg", 0x56, INSTR_RIE_RRUUU },
+	{ "risbg", 0x55, INSTR_RIE_RRUUU },
+	{ "", 0, INSTR_INVALID }
+}
+
+local opcode_ed[] = {
+	{ "mayl", 0x38, INSTR_RXF_FRRDF },
+	{ "myl", 0x39, INSTR_RXF_FRRDF },
+	{ "may", 0x3a, INSTR_RXF_FRRDF },
+	{ "my", 0x3b, INSTR_RXF_FRRDF },
+	{ "mayh", 0x3c, INSTR_RXF_FRRDF },
+	{ "myh", 0x3d, INSTR_RXF_FRRDF },
+	{ "ley", 0x64, INSTR_RXY_FRRD },
+	{ "ldy", 0x65, INSTR_RXY_FRRD },
+	{ "stey", 0x66, INSTR_RXY_FRRD },
+	{ "stdy", 0x67, INSTR_RXY_FRRD },
+	{ "sldt", 0x40, INSTR_RXF_FRRDF },
+	{ "slxt", 0x48, INSTR_RXF_FRRDF },
+	{ "srdt", 0x41, INSTR_RXF_FRRDF },
+	{ "srxt", 0x49, INSTR_RXF_FRRDF },
+	{ "tdcet", 0x50, INSTR_RXE_FRRD },
+	{ "tdcdt", 0x54, INSTR_RXE_FRRD },
+	{ "tdcxt", 0x58, INSTR_RXE_FRRD },
+	{ "tdget", 0x51, INSTR_RXE_FRRD },
+	{ "tdgdt", 0x55, INSTR_RXE_FRRD },
+	{ "tdgxt", 0x59, INSTR_RXE_FRRD },
+	{ "ldeb", 0x04, INSTR_RXE_FRRD },
+	{ "lxdb", 0x05, INSTR_RXE_FRRD },
+	{ "lxeb", 0x06, INSTR_RXE_FRRD },
+	{ "mxdb", 0x07, INSTR_RXE_FRRD },
+	{ "keb", 0x08, INSTR_RXE_FRRD },
+	{ "ceb", 0x09, INSTR_RXE_FRRD },
+	{ "aeb", 0x0a, INSTR_RXE_FRRD },
+	{ "seb", 0x0b, INSTR_RXE_FRRD },
+	{ "mdeb", 0x0c, INSTR_RXE_FRRD },
+	{ "deb", 0x0d, INSTR_RXE_FRRD },
+	{ "maeb", 0x0e, INSTR_RXF_FRRDF },
+	{ "mseb", 0x0f, INSTR_RXF_FRRDF },
+	{ "tceb", 0x10, INSTR_RXE_FRRD },
+	{ "tcdb", 0x11, INSTR_RXE_FRRD },
+	{ "tcxb", 0x12, INSTR_RXE_FRRD },
+	{ "sqeb", 0x14, INSTR_RXE_FRRD },
+	{ "sqdb", 0x15, INSTR_RXE_FRRD },
+	{ "meeb", 0x17, INSTR_RXE_FRRD },
+	{ "kdb", 0x18, INSTR_RXE_FRRD },
+	{ "cdb", 0x19, INSTR_RXE_FRRD },
+	{ "adb", 0x1a, INSTR_RXE_FRRD },
+	{ "sdb", 0x1b, INSTR_RXE_FRRD },
+	{ "mdb", 0x1c, INSTR_RXE_FRRD },
+	{ "ddb", 0x1d, INSTR_RXE_FRRD },
+	{ "madb", 0x1e, INSTR_RXF_FRRDF },
+	{ "msdb", 0x1f, INSTR_RXF_FRRDF },
+	{ "lde", 0x24, INSTR_RXE_FRRD },
+	{ "lxd", 0x25, INSTR_RXE_FRRD },
+	{ "lxe", 0x26, INSTR_RXE_FRRD },
+	{ "mae", 0x2e, INSTR_RXF_FRRDF },
+	{ "mse", 0x2f, INSTR_RXF_FRRDF },
+	{ "sqe", 0x34, INSTR_RXE_FRRD },
+	{ "sqd", 0x35, INSTR_RXE_FRRD },
+	{ "mee", 0x37, INSTR_RXE_FRRD },
+	{ "mad", 0x3e, INSTR_RXF_FRRDF },
+	{ "msd", 0x3f, INSTR_RXF_FRRDF },
+	{ "", 0, INSTR_INVALID }
+}
+
+-- Extracts an operand value from an instruction.
+local function extract_operand(code, operand)
+    code += operand[2] / 8;
+    bits = band(operand[2], 7) + operand[1]
+    val = 0
+    repeat
+        val = lshift(val, 8)
+        val = bor(val, *code++)
+        bits -= 8
+    until(bits > 0)
+
+    val = rshift(val, -bits)
+    val = band(val, lshift(lshift(1U,operand[1] - 1), 1) - 1)
+    
+    -- Check for special long displacement case.
+    if(operand[1] == 20 && operand[2] == 20) then
+        val = bor(lshift(band(val, 0xff), 12), rshift(band(val, 0xfff00), 8))
+    end
+
+    -- Sign extend value if the operand is signed or pc relative.
+    if(band(operand->flags, bor(OPERAND_SIGNED, OPERAND_PCREL)) && band(val, lshift(1U,(operand[1] - 1)))) then
+        val = bor(val, lshift(lshift(-1U, (operand[1] - 1)), 1))
+    end
+
+    -- Double value if the operand is pc relative.
+    if(band(operand[2], OPERAND_PCREL)) then
+        val = lshift(val, 1)
+    end
+
+    -- Length x in an instructions has real length x + 1.
+    if(band(operand[2], OPERAND_LENGTH)) then
+        val++
+    end
+    return val
+end
+
+local function insn_length(code)
+    return lshift((rshift((tonumber(code) + 64), 7) + 1), 1);
+end
+
+local find_insn(code){
+    opfrag = code[1]
+    table = opcode
+
+    if(code[0] == 0x01) then
+		table = opcode_01
+    elseif(code[0] == 0xa5)
+		table = opcode_a5
+    elseif(code[0] == 0xa7)
+		table = opcode_a7
+    elseif(code[0] == 0xb2)
+		table = opcode_b2
+    elseif(code[0] == 0xb3)
+		table = opcode_b3
+    elseif(code[0] == 0xb9)
+		table = opcode_b9
+    elseif(code[0] == 0xc0)
+		table = opcode_c0
+    elseif(code[0] == 0xc2)
+		table = opcode_c2
+    elseif(code[0] == 0xc4)
+		table = opcode_c4
+    elseif(code[0] == 0xc6)
+		table = opcode_c6
+    elseif(code[0] == 0xc8)
+		table = opcode_c8
+    elseif(code[0] == 0xe3)
+		table = opcode_e3
+		opfrag = code[5]
+    elseif(code[0] == 0xe5)
+		table = opcode_e5
+    elseif(code[0] == 0xeb)
+		table = opcode_eb
+		opfrag = code[5]
+    elseif(code[0] == 0xec)
+		table = opcode_ec
+		opfrag = code[5]
+    elseif(code[0] == 0xed)
+		table = opcode_ed
+		opfrag = code[5]
+    else
+        opfrag = code[0]
+    end
+
+    for k, insn in pairs(table) do
+        opmask = formats[insn[3]][1]
+        if(insn[2] == band(opfrag, opmask)) then
+            return insn
+        end
+    end
+    return NULL
+}
+
+------------------------------------------------------------------------------
+
+-- Output a nicely formatted line with an opcode and operands.
+local function putop(ctx, text, operands)
+    local pos = ctx.pos
+    local extra = ""
+    if ctx.rel then
+      local sym = ctx.symtab[ctx.rel]
+      if sym then
+        extra = "\t->"..sym
+      elseif band(ctx.op, 0x0e000000) ~= 0x0a000000 then
+        extra = "\t; 0x"..tohex(ctx.rel)
+      end
+    end
+    if ctx.hexdump > 0 then
+      ctx.out(format("%08x  %s  %-5s %s%s\n",
+          ctx.addr+pos, tohex(ctx.op), text, concat(operands, ", "), extra))
+    else
+      ctx.out(format("%08x  %-5s %s%s\n",
+          ctx.addr+pos, text, concat(operands, ", "), extra))
+    end
+    ctx.pos = pos + 4
+  end
+  
+  -- Fallback for unknown opcodes.
+  local function unknown(ctx)
+    return putop(ctx, ".long", { "0x"..tohex(ctx.op) })
+  end
+  
+  -- Format operand 2 of load/store opcodes.
+  local function fmtload(ctx, op, pos)
+    local base = map_gpr[band(rshift(op, 16), 15)]
+    local x, ofs
+    local ext = (band(op, 0x04000000) == 0)
+    if not ext and band(op, 0x02000000) == 0 then
+      ofs = band(op, 4095)
+      if band(op, 0x00800000) == 0 then ofs = -ofs end
+      if base == "pc" then ctx.rel = ctx.addr + pos + 8 + ofs end
+      ofs = "#"..ofs
+    elseif ext and band(op, 0x00400000) ~= 0 then
+      ofs = band(op, 15) + band(rshift(op, 4), 0xf0)
+      if band(op, 0x00800000) == 0 then ofs = -ofs end
+      if base == "pc" then ctx.rel = ctx.addr + pos + 8 + ofs end
+      ofs = "#"..ofs
+    else
+      ofs = map_gpr[band(op, 15)]
+      if ext or band(op, 0xfe0) == 0 then
+      elseif band(op, 0xfe0) == 0x60 then
+        ofs = format("%s, rrx", ofs)
+      else
+        local sh = band(rshift(op, 7), 31)
+        if sh == 0 then sh = 32 end
+        ofs = format("%s, %s #%d", ofs, map_shift[band(rshift(op, 5), 3)], sh)
+      end
+      if band(op, 0x00800000) == 0 then ofs = "-"..ofs end
+    end
+    if ofs == "#0" then
+      x = format("[%s]", base)
+    elseif band(op, 0x01000000) == 0 then
+      x = format("[%s], %s", base, ofs)
+    else
+      x = format("[%s, %s]", base, ofs)
+    end
+    if band(op, 0x01200000) == 0x01200000 then x = x.."!" end
+    return x
+  end
+  
+  -- Format operand 2 of vector load/store opcodes.
+  local function fmtvload(ctx, op, pos)
+    local base = map_gpr[band(rshift(op, 16), 15)]
+    local ofs = band(op, 255)*4
+    if band(op, 0x00800000) == 0 then ofs = -ofs end
+    if base == "pc" then ctx.rel = ctx.addr + pos + 8 + ofs end
+    if ofs == 0 then
+      return format("[%s]", base)
+    else
+      return format("[%s, #%d]", base, ofs)
+    end
+  end
+  
+  local function fmtvr(op, vr, sh0, sh1)
+    if vr == "s" then
+      return format("s%d", 2*band(rshift(op, sh0), 15)+band(rshift(op, sh1), 1))
+    else
+      return format("d%d", band(rshift(op, sh0), 15)+band(rshift(op, sh1-4), 16))
+    end
+  end
+  
+  -- Disassemble a single instruction.
+  local function disass_ins(ctx)
+    local pos = ctx.pos
+    local b0, b1, b2, b3 = byte(ctx.code, pos+1, pos+4)
+    local op = bor(lshift(b3, 24), lshift(b2, 16), lshift(b1, 8), b0)
+    local operands = {}
+    local suffix = ""
+    local last, name, pat
+    local vr
+    ctx.op = op
+    ctx.rel = nil
+
+    print("noice")
+  
+    -- local cond = rshift(op, 28)
+    -- local opat
+    -- if cond == 15 then
+    --   opat = map_uncondins[band(rshift(op, 25), 7)]
+    -- else
+    --   if cond ~= 14 then suffix = map_cond[cond] end
+    --   opat = map_condins[band(rshift(op, 25), 7)]
+    -- end
+    -- while type(opat) ~= "string" do
+    --   if not opat then return unknown(ctx) end
+    --   opat = opat[band(rshift(op, opat.shift), opat.mask)] or opat._
+    -- end
+    -- name, pat = match(opat, "^([a-z0-9]*)(.*)")
+    -- if sub(pat, 1, 1) == "." then
+    --   local s2, p2 = match(pat, "^([a-z0-9.]*)(.*)")
+    --   suffix = suffix..s2
+    --   pat = p2
+    -- end
+  
+    -- for p in gmatch(pat, ".") do
+    --   local x = nil
+    --   if p == "D" then
+    --     x = map_gpr[band(rshift(op, 12), 15)]
+    --   elseif p == "N" then
+    --     x = map_gpr[band(rshift(op, 16), 15)]
+    --   elseif p == "S" then
+    --     x = map_gpr[band(rshift(op, 8), 15)]
+    --   elseif p == "M" then
+    --     x = map_gpr[band(op, 15)]
+    --   elseif p == "d" then
+    --     x = fmtvr(op, vr, 12, 22)
+    --   elseif p == "n" then
+    --     x = fmtvr(op, vr, 16, 7)
+    --   elseif p == "m" then
+    --     x = fmtvr(op, vr, 0, 5)
+    --   elseif p == "P" then
+    --     if band(op, 0x02000000) ~= 0 then
+    --   x = ror(band(op, 255), 2*band(rshift(op, 8), 15))
+    --     else
+    --   x = map_gpr[band(op, 15)]
+    --   if band(op, 0xff0) ~= 0 then
+    --     operands[#operands+1] = x
+    --     local s = map_shift[band(rshift(op, 5), 3)]
+    --     local r = nil
+    --     if band(op, 0xf90) == 0 then
+    --       if s == "ror" then s = "rrx" else r = "#32" end
+    --     elseif band(op, 0x10) == 0 then
+    --       r = "#"..band(rshift(op, 7), 31)
+    --     else
+    --       r = map_gpr[band(rshift(op, 8), 15)]
+    --     end
+    --     if name == "mov" then name = s; x = r
+    --     elseif r then x = format("%s %s", s, r)
+    --     else x = s end
+    --   end
+    --     end
+    --   elseif p == "L" then
+    --     x = fmtload(ctx, op, pos)
+    --   elseif p == "l" then
+    --     x = fmtvload(ctx, op, pos)
+    --   elseif p == "B" then
+    --     local addr = ctx.addr + pos + 8 + arshift(lshift(op, 8), 6)
+    --     if cond == 15 then addr = addr + band(rshift(op, 23), 2) end
+    --     ctx.rel = addr
+    --     x = "0x"..tohex(addr)
+    --   elseif p == "F" then
+    --     vr = "s"
+    --   elseif p == "G" then
+    --     vr = "d"
+    --   elseif p == "." then
+    --     suffix = suffix..(vr == "s" and ".f32" or ".f64")
+    --   elseif p == "R" then
+    --     if band(op, 0x00200000) ~= 0 and #operands == 1 then
+    --   operands[1] = operands[1].."!"
+    --     end
+    --     local t = {}
+    --     for i=0,15 do
+    --   if band(rshift(op, i), 1) == 1 then t[#t+1] = map_gpr[i] end
+    --     end
+    --     x = "{"..concat(t, ", ").."}"
+    --   elseif p == "r" then
+    --     if band(op, 0x00200000) ~= 0 and #operands == 2 then
+    --   operands[1] = operands[1].."!"
+    --     end
+    --     local s = tonumber(sub(last, 2))
+    --     local n = band(op, 255)
+    --     if vr == "d" then n = rshift(n, 1) end
+    --     operands[#operands] = format("{%s-%s%d}", last, vr, s+n-1)
+    --   elseif p == "W" then
+    --     x = band(op, 0x0fff) + band(rshift(op, 4), 0xf000)
+    --   elseif p == "T" then
+    --     x = "#0x"..tohex(band(op, 0x00ffffff), 6)
+    --   elseif p == "U" then
+    --     x = band(rshift(op, 7), 31)
+    --     if x == 0 then x = nil end
+    --   elseif p == "u" then
+    --     x = band(rshift(op, 7), 31)
+    --     if band(op, 0x40) == 0 then
+    --   if x == 0 then x = nil else x = "lsl #"..x end
+    --     else
+    --   if x == 0 then x = "asr #32" else x = "asr #"..x end
+    --     end
+    --   elseif p == "v" then
+    --     x = band(rshift(op, 7), 31)
+    --   elseif p == "w" then
+    --     x = band(rshift(op, 16), 31)
+    --   elseif p == "x" then
+    --     x = band(rshift(op, 16), 31) + 1
+    --   elseif p == "X" then
+    --     x = band(rshift(op, 16), 31) - last + 1
+    --   elseif p == "Y" then
+    --     x = band(rshift(op, 12), 0xf0) + band(op, 0x0f)
+    --   elseif p == "K" then
+    --     x = "#0x"..tohex(band(rshift(op, 4), 0x0000fff0) + band(op, 15), 4)
+    --   elseif p == "s" then
+    --     if band(op, 0x00100000) ~= 0 then suffix = "s"..suffix end
+    --   else
+    --     assert(false)
+    --   end
+    --   if x then
+    --     last = x
+    --     if type(x) == "number" then x = "#"..x end
+    --     operands[#operands+1] = x
+    --   end
+    -- end
+  
+    -- return putop(ctx, name..suffix, operands)
+  end
+  
+  ------------------------------------------------------------------------------
+  
+  -- Disassemble a block of code.
+  local function disass_block(ctx, ofs, len)
+    if not ofs then ofs = 0 end
+    local stop = len and ofs+len or #ctx.code
+    ctx.pos = ofs
+    ctx.rel = nil
+    while ctx.pos < stop do disass_ins(ctx) end
+  end
+  
+  -- Extended API: create a disassembler context. Then call ctx:disass(ofs, len).
+  local function create(code, addr, out)
+    local ctx = {}
+    ctx.code = code
+    ctx.addr = addr or 0
+    ctx.out = out or io.write
+    ctx.symtab = {}
+    ctx.disass = disass_block
+    ctx.hexdump = 8
+    return ctx
+  end
+  
+  -- Simple API: disassemble code (a string) at address and output via out.
+  local function disass(code, addr, out)
+    create(code, addr, out):disass()
+  end
+  
+  -- Return register name for RID.
+  local function regname(r)
+    if r < 16 then return map_gpr[r] end
+    return "d"..(r-16)
+  end
+  
+  -- Public module functions.
+  return {
+    create = create,
+    disass = disass,
+    regname = regname
+  }
diff --git a/lib/luajit-3065c9/src/jit/dis_x64.lua b/lib/luajit2/src/jit/dis_x64.lua
similarity index 91%
rename from lib/luajit-3065c9/src/jit/dis_x64.lua
rename to lib/luajit2/src/jit/dis_x64.lua
index d076c6aee..eb21f0449 100644
--- a/lib/luajit-3065c9/src/jit/dis_x64.lua
+++ b/lib/luajit2/src/jit/dis_x64.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT x64 disassembler wrapper module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This module just exports the 64 bit functions from the combined
diff --git a/lib/luajit-3065c9/src/jit/dis_x86.lua b/lib/luajit2/src/jit/dis_x86.lua
similarity index 99%
rename from lib/luajit-3065c9/src/jit/dis_x86.lua
rename to lib/luajit2/src/jit/dis_x86.lua
index 84492fff3..40b8218e9 100644
--- a/lib/luajit-3065c9/src/jit/dis_x86.lua
+++ b/lib/luajit2/src/jit/dis_x86.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT x86/x64 disassembler module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 -- This is a helper module used by the LuaJIT machine code dumper module.
diff --git a/lib/luajit-3065c9/src/jit/dump.lua b/lib/luajit2/src/jit/dump.lua
similarity index 99%
rename from lib/luajit-3065c9/src/jit/dump.lua
rename to lib/luajit2/src/jit/dump.lua
index 18e7a4b7a..2d1cc53be 100644
--- a/lib/luajit-3065c9/src/jit/dump.lua
+++ b/lib/luajit2/src/jit/dump.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT compiler dump module.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 --
@@ -55,7 +55,6 @@
 
 -- Cache some library functions and objects.
 local jit = require("jit")
-assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
 local jutil = require("jit.util")
 local vmdef = require("jit.vmdef")
 local funcinfo, funcbc = jutil.funcinfo, jutil.funcbc
@@ -603,6 +602,9 @@ local function dump_record(tr, func, pc, depth)
   if pc >= 0 then
     line = bcline(func, pc, recprefix)
     if dumpmode.H then line = gsub(line, "[<>&]", html_escape) end
+    if pc > 0 then
+      line = sub(line, 1, -2) .. "       (" .. fmtfunc(func, pc) .. ")\n"
+    end
   else
     line = "0000 "..recprefix.." FUNCC      \n"
   end
diff --git a/lib/luajit-3065c9/src/jit/p.lua b/lib/luajit2/src/jit/p.lua
similarity index 98%
rename from lib/luajit-3065c9/src/jit/p.lua
rename to lib/luajit2/src/jit/p.lua
index f225c312b..36f836c51 100644
--- a/lib/luajit-3065c9/src/jit/p.lua
+++ b/lib/luajit2/src/jit/p.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT profiler.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 --
@@ -41,7 +41,6 @@
 
 -- Cache some library functions and objects.
 local jit = require("jit")
-assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
 local profile = require("jit.profile")
 local vmdef = require("jit.vmdef")
 local math = math
diff --git a/lib/luajit-3065c9/src/jit/v.lua b/lib/luajit2/src/jit/v.lua
similarity index 97%
rename from lib/luajit-3065c9/src/jit/v.lua
rename to lib/luajit2/src/jit/v.lua
index ac8b19dbe..8e91f4942 100644
--- a/lib/luajit-3065c9/src/jit/v.lua
+++ b/lib/luajit2/src/jit/v.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- Verbose mode of the LuaJIT compiler.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 --
@@ -59,7 +59,6 @@
 
 -- Cache some library functions and objects.
 local jit = require("jit")
-assert(jit.version_num == 20100, "LuaJIT core/library version mismatch")
 local jutil = require("jit.util")
 local vmdef = require("jit.vmdef")
 local funcinfo, traceinfo = jutil.funcinfo, jutil.traceinfo
diff --git a/lib/luajit-3065c9/src/jit/zone.lua b/lib/luajit2/src/jit/zone.lua
similarity index 94%
rename from lib/luajit-3065c9/src/jit/zone.lua
rename to lib/luajit2/src/jit/zone.lua
index 1308cb74e..55dc76d36 100644
--- a/lib/luajit-3065c9/src/jit/zone.lua
+++ b/lib/luajit2/src/jit/zone.lua
@@ -1,7 +1,7 @@
 ----------------------------------------------------------------------------
 -- LuaJIT profiler zones.
 --
--- Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+-- Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 -- Released under the MIT license. See Copyright Notice in luajit.h
 ----------------------------------------------------------------------------
 --
diff --git a/lib/luajit-3065c9/src/lauxlib.h b/lib/luajit2/src/lauxlib.h
similarity index 100%
rename from lib/luajit-3065c9/src/lauxlib.h
rename to lib/luajit2/src/lauxlib.h
diff --git a/lib/luajit-3065c9/src/lib_aux.c b/lib/luajit2/src/lib_aux.c
similarity index 90%
rename from lib/luajit-3065c9/src/lib_aux.c
rename to lib/luajit2/src/lib_aux.c
index b8e564362..7e81ac302 100644
--- a/lib/luajit-3065c9/src/lib_aux.c
+++ b/lib/luajit2/src/lib_aux.c
@@ -1,6 +1,6 @@
 /*
 ** Auxiliary library for the Lua/C API.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major parts taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -21,6 +21,7 @@
 #include "lj_state.h"
 #include "lj_trace.h"
 #include "lj_lib.h"
+#include "lj_vmevent.h"
 
 #if LJ_TARGET_POSIX
 #include <sys/wait.h>
@@ -318,6 +319,18 @@ static int panic(lua_State *L)
   return 0;
 }
 
+#ifndef LUAJIT_DISABLE_VMEVENT
+static int error_finalizer(lua_State *L)
+{
+  const char *s = lua_tostring(L, -1);
+  fputs("ERROR in finalizer: ", stderr);
+  fputs(s ? s : "?", stderr);
+  fputc('\n', stderr);
+  fflush(stderr);
+  return 0;
+}
+#endif
+
 #ifdef LUAJIT_USE_SYSMALLOC
 
 #if LJ_64 && !LJ_GC64 && !defined(LUAJIT_USE_VALGRIND)
@@ -339,7 +352,16 @@ static void *mem_alloc(void *ud, void *ptr, size_t osize, size_t nsize)
 LUALIB_API lua_State *luaL_newstate(void)
 {
   lua_State *L = lua_newstate(mem_alloc, NULL);
-  if (L) G(L)->panic = panic;
+  if (L) {
+    G(L)->panic = panic;
+#ifndef LUAJIT_DISABLE_VMEVENT
+    luaL_findtable(L, LUA_REGISTRYINDEX, LJ_VMEVENTS_REGKEY, LJ_VMEVENTS_HSIZE);
+    lua_pushcfunction(L, error_finalizer);
+    lua_rawseti(L, -2, VMEVENT_HASH(LJ_VMEVENT_ERRFIN));
+    G(L)->vmevmask = VMEVENT_MASK(LJ_VMEVENT_ERRFIN);
+    L->top--;
+#endif
+  }
   return L;
 }
 
@@ -353,7 +375,16 @@ LUALIB_API lua_State *luaL_newstate(void)
 #else
   L = lua_newstate(LJ_ALLOCF_INTERNAL, NULL);
 #endif
-  if (L) G(L)->panic = panic;
+  if (L) {
+    G(L)->panic = panic;
+#ifndef LUAJIT_DISABLE_VMEVENT
+    luaL_findtable(L, LUA_REGISTRYINDEX, LJ_VMEVENTS_REGKEY, LJ_VMEVENTS_HSIZE);
+    lua_pushcfunction(L, error_finalizer);
+    lua_rawseti(L, -2, VMEVENT_HASH(LJ_VMEVENT_ERRFIN));
+    G(L)->vmevmask = VMEVENT_MASK(LJ_VMEVENT_ERRFIN);
+    L->top--;
+#endif
+  }
   return L;
 }
 
diff --git a/lib/luajit-3065c9/src/lib_base.c b/lib/luajit2/src/lib_base.c
similarity index 89%
rename from lib/luajit-3065c9/src/lib_base.c
rename to lib/luajit2/src/lib_base.c
index 98ec67c7c..cff9f7d90 100644
--- a/lib/luajit-3065c9/src/lib_base.c
+++ b/lib/luajit2/src/lib_base.c
@@ -1,6 +1,6 @@
 /*
 ** Base and coroutine library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2011 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -36,6 +36,7 @@
 #include "lj_strscan.h"
 #include "lj_strfmt.h"
 #include "lj_lib.h"
+#include "lj_cdata.h"
 
 /* -- Base library: checks ------------------------------------------------ */
 
@@ -303,7 +304,7 @@ LJLIB_ASM(tonumber)		LJLIB_REC(.)
 	while (lj_char_isspace((unsigned char)(*ep))) ep++;
 	if (*ep == '\0') {
 	  if (LJ_DUALNUM && LJ_LIKELY(ul < 0x80000000u+neg)) {
-	    if (neg) ul = (unsigned long)-(long)ul;
+	    if (neg) ul = ~ul+1u;
 	    setintV(L->base-1-LJ_FR2, (int32_t)ul);
 	  } else {
 	    lua_Number n = (lua_Number)ul;
@@ -360,7 +361,11 @@ LJLIB_ASM_(xpcall)		LJLIB_REC(.)
 static int load_aux(lua_State *L, int status, int envarg)
 {
   if (status == LUA_OK) {
-    if (tvistab(L->base+envarg-1)) {
+    /*
+    ** Set environment table for top-level function.
+    ** Don't do this for non-native bytecode, which returns a prototype.
+    */
+    if (tvistab(L->base+envarg-1) && tvisfunc(L->top-1)) {
       GCfunc *fn = funcV(L->top-1);
       GCtab *t = tabV(L->base+envarg-1);
       setgcref(fn->c.env, obj2gco(t));
@@ -616,7 +621,10 @@ static int ffh_resume(lua_State *L, lua_State *co, int wrap)
     setstrV(L, L->base-LJ_FR2, lj_err_str(L, em));
     return FFH_RES(2);
   }
-  lj_state_growstack(co, (MSize)(L->top - L->base));
+  if (lj_state_cpgrowstack(co, (MSize)(L->top - L->base)) != LUA_OK) {
+    cTValue *msg = --co->top;
+    lj_err_callermsg(L, strVdata(msg));
+  }
   return FFH_RETRY;
 }
 
@@ -669,6 +677,52 @@ static void setpc_wrap_aux(lua_State *L, GCfunc *fn)
   setmref(fn->c.pc, &L2GG(L)->bcff[lj_lib_init_coroutine[1]+2]);
 }
 
+#if LJ_HASFFI
+LJLIB_NOREG LJLIB_CF(thread_exdata) LJLIB_REC(.)
+{
+  ptrdiff_t nargs = L->top - L->base;
+  GCcdata *cd;
+
+  if (nargs == 0) {
+    CTState *cts = ctype_ctsG(G(L));
+    if (cts == NULL)
+      lj_err_caller(L, LJ_ERR_FFI_NOTLOAD);
+    cts->L = L;  /* Save L for errors and allocations. */
+
+    cd = lj_cdata_new(cts, CTID_P_VOID, CTSIZE_PTR);
+    cdata_setptr(cdataptr(cd), CTSIZE_PTR, L->exdata);
+    setcdataV(L, L->top++, cd);
+    return 1;
+  }
+
+  cd = lj_lib_checkcdata(L, 1);
+  L->exdata = cdata_getptr(cdataptr(cd), CTSIZE_PTR);
+  return 0;
+}
+
+LJLIB_NOREG LJLIB_CF(thread_exdata2) LJLIB_REC(.)
+{
+  ptrdiff_t nargs = L->top - L->base;
+  GCcdata *cd;
+
+  if (nargs == 0) {
+    CTState *cts = ctype_ctsG(G(L));
+    if (cts == NULL)
+      lj_err_caller(L, LJ_ERR_FFI_NOTLOAD);
+    cts->L = L;  /* Save L for errors and allocations. */
+
+    cd = lj_cdata_new(cts, CTID_P_VOID, CTSIZE_PTR);
+    cdata_setptr(cdataptr(cd), CTSIZE_PTR, L->exdata2);
+    setcdataV(L, L->top++, cd);
+    return 1;
+  }
+
+  cd = lj_lib_checkcdata(L, 1);
+  L->exdata2 = cdata_getptr(cdataptr(cd), CTSIZE_PTR);
+  return 0;
+}
+#endif
+
 /* ------------------------------------------------------------------------ */
 
 static void newproxy_weaktable(lua_State *L)
@@ -682,6 +736,18 @@ static void newproxy_weaktable(lua_State *L)
   t->nomm = (uint8_t)(~(1u<<MM_mode));
 }
 
+#if LJ_HASFFI
+static int luaopen_thread_exdata(lua_State *L)
+{
+  return lj_lib_postreg(L, lj_cf_thread_exdata, FF_thread_exdata, "exdata");
+}
+
+static int luaopen_thread_exdata2(lua_State *L)
+{
+  return lj_lib_postreg(L, lj_cf_thread_exdata2, FF_thread_exdata2, "exdata2");
+}
+#endif
+
 LUALIB_API int luaopen_base(lua_State *L)
 {
   /* NOBARRIER: Table and value are the same. */
@@ -691,6 +757,12 @@ LUALIB_API int luaopen_base(lua_State *L)
   newproxy_weaktable(L);  /* top-2. */
   LJ_LIB_REG(L, "_G", base);
   LJ_LIB_REG(L, LUA_COLIBNAME, coroutine);
+
+#if LJ_HASFFI
+  lj_lib_prereg(L, LUA_THRLIBNAME ".exdata", luaopen_thread_exdata, env);
+  lj_lib_prereg(L, LUA_THRLIBNAME ".exdata2", luaopen_thread_exdata2, env);
+#endif
+
   return 2;
 }
 
diff --git a/lib/luajit-3065c9/src/lib_bit.c b/lib/luajit2/src/lib_bit.c
similarity index 96%
rename from lib/luajit-3065c9/src/lib_bit.c
rename to lib/luajit2/src/lib_bit.c
index 38c0f578a..ce40e2983 100644
--- a/lib/luajit-3065c9/src/lib_bit.c
+++ b/lib/luajit2/src/lib_bit.c
@@ -1,6 +1,6 @@
 /*
 ** Bit manipulation library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lib_bit_c
@@ -155,7 +155,8 @@ LJLIB_CF(bit_tohex)		LJLIB_REC(.)
 #endif
   SBuf *sb = lj_buf_tmp_(L);
   SFormat sf = (STRFMT_UINT|STRFMT_T_HEX);
-  if (n < 0) { n = -n; sf |= STRFMT_F_UPPER; }
+  if (n < 0) { n = (int32_t)(~(uint32_t)n+1u); sf |= STRFMT_F_UPPER; }
+  if ((uint32_t)n > 254) n = 254;
   sf |= ((SFormat)((n+1)&255) << STRFMT_SH_PREC);
 #if LJ_HASFFI
   if (n < 16) b &= ((uint64_t)1 << 4*n)-1;
diff --git a/lib/luajit-3065c9/src/lib_buffer.c b/lib/luajit2/src/lib_buffer.c
similarity index 96%
rename from lib/luajit-3065c9/src/lib_buffer.c
rename to lib/luajit2/src/lib_buffer.c
index e3d24504b..e4ec9d9dd 100644
--- a/lib/luajit-3065c9/src/lib_buffer.c
+++ b/lib/luajit2/src/lib_buffer.c
@@ -1,6 +1,6 @@
 /*
 ** Buffer library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lib_buffer_c
@@ -128,7 +128,7 @@ LJLIB_CF(buffer_method_put)		LJLIB_REC(.)
       lj_strfmt_putfnum((SBuf *)sbx, STRFMT_G14, numV(o));
     } else if (tvisbuf(o)) {
       SBufExt *sbx2 = bufV(o);
-      if (sbx2 == sbx) lj_err_arg(L, arg+1, LJ_ERR_BUFFER_SELF);
+      if (sbx2 == sbx) lj_err_arg(L, (int)(arg+1), LJ_ERR_BUFFER_SELF);
       lj_buf_putmem((SBuf *)sbx, sbx2->r, sbufxlen(sbx2));
     } else if (!mo && !tvisnil(mo = lj_meta_lookup(L, o, MM_tostring))) {
       /* Call __tostring metamethod inline. */
@@ -140,7 +140,7 @@ LJLIB_CF(buffer_method_put)		LJLIB_REC(.)
       L->top = L->base + narg;
       goto retry;  /* Retry with the result. */
     } else {
-      lj_err_argtype(L, arg+1, "string/number/__tostring");
+      lj_err_argtype(L, (int)(arg+1), "string/number/__tostring");
     }
     /* Probably not useful to inline other __tostring MMs, e.g. FFI numbers. */
   }
@@ -169,7 +169,7 @@ LJLIB_CF(buffer_method_get)		LJLIB_REC(.)
   for (arg = 1; arg < narg; arg++) {
     TValue *o = &L->base[arg];
     MSize n = tvisnil(o) ? LJ_MAX_BUF :
-	      (MSize) lj_lib_checkintrange(L, arg+1, 0, LJ_MAX_BUF);
+	      (MSize) lj_lib_checkintrange(L, (int)(arg+1), 0, LJ_MAX_BUF);
     MSize len = sbufxlen(sbx);
     if (n > len) n = len;
     setstrV(L, o, lj_str_new(L, sbx->r, n));
@@ -177,7 +177,7 @@ LJLIB_CF(buffer_method_get)		LJLIB_REC(.)
   }
   if (sbx->r == sbx->w && !sbufiscow(sbx)) sbx->r = sbx->w = sbx->b;
   lj_gc_check(L);
-  return narg-1;
+  return (int)(narg-1);
 }
 
 #if LJ_HASFFI
@@ -323,6 +323,7 @@ LJLIB_CF(buffer_new)
   setgcref(sbx->dict_str, obj2gco(dict_str));
   setgcref(sbx->dict_mt, obj2gco(dict_mt));
   if (sz > 0) lj_buf_need2((SBuf *)sbx, sz);
+  lj_gc_check(L);
   return 1;
 }
 
@@ -339,6 +340,7 @@ LJLIB_CF(buffer_decode)			LJLIB_REC(.)
   GCstr *str = lj_lib_checkstrx(L, 1);
   setnilV(L->top++);
   lj_serialize_decode(L, L->top-1, str);
+  lj_gc_check(L);
   return 1;
 }
 
diff --git a/lib/luajit-3065c9/src/lib_debug.c b/lib/luajit2/src/lib_debug.c
similarity index 99%
rename from lib/luajit-3065c9/src/lib_debug.c
rename to lib/luajit2/src/lib_debug.c
index 3af7a353a..2ad51a74e 100644
--- a/lib/luajit-3065c9/src/lib_debug.c
+++ b/lib/luajit2/src/lib_debug.c
@@ -1,6 +1,6 @@
 /*
 ** Debug library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
diff --git a/lib/luajit-3065c9/src/lib_ffi.c b/lib/luajit2/src/lib_ffi.c
similarity index 99%
rename from lib/luajit-3065c9/src/lib_ffi.c
rename to lib/luajit2/src/lib_ffi.c
index 2295cf15d..ba7831738 100644
--- a/lib/luajit-3065c9/src/lib_ffi.c
+++ b/lib/luajit2/src/lib_ffi.c
@@ -1,6 +1,6 @@
 /*
 ** FFI library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lib_ffi_c
@@ -745,6 +745,9 @@ LJLIB_CF(ffi_abi)	LJLIB_REC(.)
 #if LJ_ABI_WIN
     "\003win"
 #endif
+#if LJ_ABI_PAUTH
+    "\005pauth"
+#endif
 #if LJ_TARGET_UWP
     "\003uwp"
 #endif
@@ -776,7 +779,7 @@ LJLIB_CF(ffi_metatype)
   if (!(ctype_isstruct(ct->info) || ctype_iscomplex(ct->info) ||
 	ctype_isvector(ct->info)))
     lj_err_arg(L, 1, LJ_ERR_FFI_INVTYPE);
-  tv = lj_tab_setinth(L, t, -(int32_t)id);
+  tv = lj_tab_setinth(L, t, -(int32_t)ctype_typeid(cts, ct));
   if (!tvisnil(tv))
     lj_err_caller(L, LJ_ERR_PROTMT);
   settabV(L, tv, mt);
diff --git a/lib/luajit-3065c9/src/lib_init.c b/lib/luajit2/src/lib_init.c
similarity index 95%
rename from lib/luajit-3065c9/src/lib_init.c
rename to lib/luajit2/src/lib_init.c
index 35e06fe2b..41299f55e 100644
--- a/lib/luajit-3065c9/src/lib_init.c
+++ b/lib/luajit2/src/lib_init.c
@@ -1,6 +1,6 @@
 /*
 ** Library initialization.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major parts taken verbatim from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
diff --git a/lib/luajit-3065c9/src/lib_io.c b/lib/luajit2/src/lib_io.c
similarity index 99%
rename from lib/luajit-3065c9/src/lib_io.c
rename to lib/luajit2/src/lib_io.c
index c22faa24e..a13d43150 100644
--- a/lib/luajit-3065c9/src/lib_io.c
+++ b/lib/luajit2/src/lib_io.c
@@ -1,6 +1,6 @@
 /*
 ** I/O library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2011 Lua.org, PUC-Rio. See Copyright Notice in lua.h
diff --git a/lib/luajit-3065c9/src/lib_jit.c b/lib/luajit2/src/lib_jit.c
similarity index 89%
rename from lib/luajit-3065c9/src/lib_jit.c
rename to lib/luajit2/src/lib_jit.c
index 2867d4206..d1f0213ae 100644
--- a/lib/luajit-3065c9/src/lib_jit.c
+++ b/lib/luajit2/src/lib_jit.c
@@ -1,6 +1,6 @@
 /*
 ** JIT library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lib_jit_c
@@ -148,6 +148,66 @@ LJLIB_CF(jit_attach)
   return 0;
 }
 
+LJLIB_CF(jit_prngstate)
+{
+  GCtab *cur = lj_tab_new(L, 8, 0);
+
+#if LJ_HASJIT
+  int i;
+  jit_State *J = L2J(L);
+
+  /* The old state. */
+  for (i = 1; i <= 4; i++) {
+    setintV(lj_tab_setint(L, cur, i*2-1), J->prng.u[i-1] & 0xffffffff);
+    setintV(lj_tab_setint(L, cur, i*2), J->prng.u[i-1] >> 32);
+  }
+
+  /* We need to set new state using the input array. */
+  if (L->base < L->top && !tvisnil(L->base)) {
+    PRNGState prng;
+    if (tvisnumber(L->base)) {
+      TValue *o = L->base;
+
+      if (!tvisint(o) && ((double)(uint32_t)numV(o) != numV(o)))
+        lj_err_arg(L, 1, LJ_ERR_PRNGSTATE);
+
+      prng.u[0] = numberVint(o);
+      for (i = 1; i < 4; i++)
+        prng.u[i] = 0;
+    } else {
+      GCtab *t = lj_lib_checktab(L, 1);
+      int i = 1, len = lj_tab_len(t);
+
+      /* The input array must have at most 8 elements. */
+      if (len > 8)
+        lj_err_arg(L, 1, LJ_ERR_PRNGSTATE);
+
+      for (i = 1; i <= len; i++) {
+        cTValue *v = lj_tab_getint(t, i);
+
+        if (!tvisint(v) && (!tvisnum(v) || (double)(uint32_t)numV(v) != numV(v)))
+          lj_err_arg(L, 1, LJ_ERR_PRNGSTATE);
+
+        if (i & 1)
+          prng.u[(i-1)/2] = numberVint(v);
+        else
+          prng.u[(i-1)/2] = prng.u[(i-1)/2] | ((uint64_t)numberVint(v) << 32);
+      }
+      for (i /= 2; i < 4; i++)
+        prng.u[i] = 0;
+    }
+
+    /* Re-initialize the JIT prng. */
+    J->prng = prng;
+  }
+#else
+  for (int i = 1; i <= 8; i++)
+    setintV(lj_tab_setint(L, cur, i), 0);
+#endif
+  settabV(L, L->top++, cur);
+  return 1;
+}
+
 LJLIB_PUSH(top-5) LJLIB_SET(os)
 LJLIB_PUSH(top-4) LJLIB_SET(arch)
 LJLIB_PUSH(top-3) LJLIB_SET(version_num)
@@ -161,24 +221,6 @@ LJLIB_PUSH(top-2) LJLIB_SET(version)
 
 /* -- Reflection API for Lua functions ------------------------------------ */
 
-/* Return prototype of first argument (Lua function or prototype object) */
-static GCproto *check_Lproto(lua_State *L, int nolua)
-{
-  TValue *o = L->base;
-  if (L->top > o) {
-    if (tvisproto(o)) {
-      return protoV(o);
-    } else if (tvisfunc(o)) {
-      if (isluafunc(funcV(o)))
-	return funcproto(funcV(o));
-      else if (nolua)
-	return NULL;
-    }
-  }
-  lj_err_argt(L, 1, LUA_TFUNCTION);
-  return NULL;  /* unreachable */
-}
-
 static void setintfield(lua_State *L, GCtab *t, const char *name, int32_t val)
 {
   setintV(lj_tab_setstr(L, t, lj_str_newz(L, name)), val);
@@ -187,7 +229,7 @@ static void setintfield(lua_State *L, GCtab *t, const char *name, int32_t val)
 /* local info = jit.util.funcinfo(func [,pc]) */
 LJLIB_CF(jit_util_funcinfo)
 {
-  GCproto *pt = check_Lproto(L, 1);
+  GCproto *pt = lj_lib_checkLproto(L, 1, 1);
   if (pt) {
     BCPos pc = (BCPos)lj_lib_optint(L, 2, 0);
     GCtab *t;
@@ -229,8 +271,9 @@ LJLIB_CF(jit_util_funcinfo)
 /* local ins, m = jit.util.funcbc(func, pc) */
 LJLIB_CF(jit_util_funcbc)
 {
-  GCproto *pt = check_Lproto(L, 0);
+  GCproto *pt = lj_lib_checkLproto(L, 1, 0);
   BCPos pc = (BCPos)lj_lib_checkint(L, 2);
+  int lineinfo = lj_lib_optint(L, 3, 0);
   if (pc < pt->sizebc) {
     BCIns ins = proto_bc(pt)[pc];
     BCOp op = bc_op(ins);
@@ -238,6 +281,11 @@ LJLIB_CF(jit_util_funcbc)
     setintV(L->top, ins);
     setintV(L->top+1, lj_bc_mode[op]);
     L->top += 2;
+    if (lineinfo) {
+      setintV(L->top, lj_debug_line(pt, pc));
+      L->top += 1;
+      return 3;
+    }
     return 2;
   }
   return 0;
@@ -246,7 +294,7 @@ LJLIB_CF(jit_util_funcbc)
 /* local k = jit.util.funck(func, idx) */
 LJLIB_CF(jit_util_funck)
 {
-  GCproto *pt = check_Lproto(L, 0);
+  GCproto *pt = lj_lib_checkLproto(L, 1, 0);
   ptrdiff_t idx = (ptrdiff_t)lj_lib_checkint(L, 2);
   if (idx >= 0) {
     if (idx < (ptrdiff_t)pt->sizekn) {
@@ -266,7 +314,7 @@ LJLIB_CF(jit_util_funck)
 /* local name = jit.util.funcuvname(func, idx) */
 LJLIB_CF(jit_util_funcuvname)
 {
-  GCproto *pt = check_Lproto(L, 0);
+  GCproto *pt = lj_lib_checkLproto(L, 1, 0);
   uint32_t idx = (uint32_t)lj_lib_checkint(L, 2);
   if (idx < pt->sizeuv) {
     setstrV(L, L->top-1, lj_str_newz(L, lj_debug_uvname(pt, idx)));
@@ -422,7 +470,8 @@ LJLIB_CF(jit_util_ircalladdr)
 {
   uint32_t idx = (uint32_t)lj_lib_checkint(L, 1);
   if (idx < IRCALL__MAX) {
-    setintptrV(L->top-1, (intptr_t)(void *)lj_ir_callinfo[idx].func);
+    ASMFunction func = lj_ir_callinfo[idx].func;
+    setintptrV(L->top-1, (intptr_t)(void *)lj_ptr_strip(func));
     return 1;
   }
   return 0;
@@ -718,7 +767,8 @@ static uint32_t jit_cpudetect(void)
     if (x) flags |= JIT_F_MIPSXXR2;  /* Either 0x80000000 (R2) or 0 (R1). */
   }
 #endif
-
+#elif LJ_TARGET_S390X
+  /* No optional CPU features to detect (for now). */
 #else
 #error "Missing CPU detection for this architecture"
 #endif
@@ -742,7 +792,7 @@ LUALIB_API int luaopen_jit(lua_State *L)
 #endif
   lua_pushliteral(L, LJ_OS_NAME);
   lua_pushliteral(L, LJ_ARCH_NAME);
-  lua_pushinteger(L, LUAJIT_VERSION_NUM);
+  lua_pushinteger(L, LUAJIT_VERSION_NUM);  /* Deprecated. */
   lua_pushliteral(L, LUAJIT_VERSION);
   LJ_LIB_REG(L, LUA_JITLIBNAME, jit);
 #if LJ_HASPROFILE
diff --git a/lib/luajit-3065c9/src/lib_math.c b/lib/luajit2/src/lib_math.c
similarity index 98%
rename from lib/luajit-3065c9/src/lib_math.c
rename to lib/luajit2/src/lib_math.c
index b677bbcd5..4539f8044 100644
--- a/lib/luajit-3065c9/src/lib_math.c
+++ b/lib/luajit2/src/lib_math.c
@@ -1,6 +1,6 @@
 /*
 ** Math library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include <math.h>
diff --git a/lib/luajit-3065c9/src/lib_os.c b/lib/luajit2/src/lib_os.c
similarity index 98%
rename from lib/luajit-3065c9/src/lib_os.c
rename to lib/luajit2/src/lib_os.c
index 6bcd0147d..d9dda8534 100644
--- a/lib/luajit-3065c9/src/lib_os.c
+++ b/lib/luajit2/src/lib_os.c
@@ -1,6 +1,6 @@
 /*
 ** OS library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -185,6 +185,7 @@ LJLIB_CF(os_date)
 #endif
   } else {
 #if LJ_TARGET_POSIX
+    tzset();
     stm = localtime_r(&t, &rtm);
 #else
     stm = localtime(&t);
diff --git a/lib/luajit-3065c9/src/lib_package.c b/lib/luajit2/src/lib_package.c
similarity index 99%
rename from lib/luajit-3065c9/src/lib_package.c
rename to lib/luajit2/src/lib_package.c
index 1f8b06771..7e24afa5a 100644
--- a/lib/luajit-3065c9/src/lib_package.c
+++ b/lib/luajit2/src/lib_package.c
@@ -1,6 +1,6 @@
 /*
 ** Package library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2012 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -57,7 +57,7 @@ static lua_CFunction ll_sym(lua_State *L, void *lib, const char *sym)
 
 static const char *ll_bcsym(void *lib, const char *sym)
 {
-#if defined(RTLD_DEFAULT)
+#if defined(RTLD_DEFAULT) && !defined(NO_RTLD_DEFAULT)
   if (lib == NULL) lib = RTLD_DEFAULT;
 #elif LJ_TARGET_OSX || LJ_TARGET_BSD
   if (lib == NULL) lib = (void *)(intptr_t)-2;
diff --git a/lib/luajit-3065c9/src/lib_string.c b/lib/luajit2/src/lib_string.c
similarity index 96%
rename from lib/luajit-3065c9/src/lib_string.c
rename to lib/luajit2/src/lib_string.c
index 79aeddfc0..255689ced 100644
--- a/lib/luajit-3065c9/src/lib_string.c
+++ b/lib/luajit2/src/lib_string.c
@@ -1,6 +1,6 @@
 /*
 ** String library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -122,11 +122,25 @@ static int writer_buf(lua_State *L, const void *p, size_t size, void *sb)
 
 LJLIB_CF(string_dump)
 {
-  GCfunc *fn = lj_lib_checkfunc(L, 1);
-  int strip = L->base+1 < L->top && tvistruecond(L->base+1);
-  SBuf *sb = lj_buf_tmp_(L);  /* Assumes lj_bcwrite() doesn't use tmpbuf. */
+  GCproto *pt = lj_lib_checkLproto(L, 1, 1);
+  uint32_t flags = 0;
+  SBuf *sb;
+  TValue *o = L->base+1;
+  if (o < L->top) {
+    if (tvisstr(o)) {
+      const char *mode = strVdata(o);
+      char c;
+      while ((c = *mode++)) {
+	if (c == 's') flags |= BCDUMP_F_STRIP;
+	if (c == 'd') flags |= BCDUMP_F_DETERMINISTIC;
+      }
+    } else if (tvistruecond(o)) {
+      flags |= BCDUMP_F_STRIP;
+    }
+  }
+  sb = lj_buf_tmp_(L);  /* Assumes lj_bcwrite() doesn't use tmpbuf. */
   L->top = L->base+1;
-  if (!isluafunc(fn) || lj_bcwrite(L, funcproto(fn), writer_buf, sb, strip))
+  if (!pt || lj_bcwrite(L, pt, writer_buf, sb, flags))
     lj_err_caller(L, LJ_ERR_STRDUMP);
   setstrV(L, L->top-1, lj_buf_str(L, sb));
   lj_gc_check(L);
diff --git a/lib/luajit-3065c9/src/lib_table.c b/lib/luajit2/src/lib_table.c
similarity index 83%
rename from lib/luajit-3065c9/src/lib_table.c
rename to lib/luajit2/src/lib_table.c
index a723326a1..a1cc07703 100644
--- a/lib/luajit-3065c9/src/lib_table.c
+++ b/lib/luajit2/src/lib_table.c
@@ -1,6 +1,6 @@
 /*
 ** Table library.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -169,6 +169,47 @@ LJLIB_CF(table_concat)		LJLIB_REC(.)
   return 1;
 }
 
+LJLIB_NOREG LJLIB_CF(table_clone) LJLIB_REC(.)
+{
+  GCtab *src = lj_lib_checktab(L, 1);
+  GCtab *dup = lj_tab_dup(L, src);
+
+  settabV(L, L->base, dup);
+  L->top = L->base+1;
+
+  return 1;
+}
+
+LJLIB_NOREG LJLIB_CF(table_isarray) LJLIB_REC(.)
+{
+  GCtab *src = lj_lib_checktab(L, 1);
+
+  setboolV(L->base, lj_tab_isarray(src));
+  L->top = L->base+1;
+
+  return 1;
+}
+
+LJLIB_NOREG LJLIB_CF(table_nkeys) LJLIB_REC(.)
+{
+  GCtab *src = lj_lib_checktab(L, 1);
+
+  setintV(L->base, lj_tab_nkeys(src));
+  L->top = L->base+1;
+
+  return 1;
+}
+
+LJLIB_NOREG LJLIB_CF(table_isempty) LJLIB_REC(.)
+{
+  GCtab *src = lj_lib_checktab(L, 1);
+
+  setboolV(L->base, lj_tab_isempty(src));
+  L->top = L->base+1;
+
+  return 1;
+}
+
 /* ------------------------------------------------------------------------ */
 
 static void set2(lua_State *L, int i, int j)
@@ -304,6 +345,26 @@ static int luaopen_table_new(lua_State *L)
   return lj_lib_postreg(L, lj_cf_table_new, FF_table_new, "new");
 }
 
+static int luaopen_table_clone(lua_State *L)
+{
+  return lj_lib_postreg(L, lj_cf_table_clone, FF_table_clone, "clone");
+}
+
+static int luaopen_table_nkeys(lua_State *L)
+{
+  return lj_lib_postreg(L, lj_cf_table_nkeys, FF_table_nkeys, "nkeys");
+}
+
+static int luaopen_table_isarray(lua_State *L)
+{
+  return lj_lib_postreg(L, lj_cf_table_isarray, FF_table_isarray, "isarray");
+}
+
+static int luaopen_table_isempty(lua_State *L)
+{
+  return lj_lib_postreg(L, lj_cf_table_isempty, FF_table_isempty, "isempty");
+}
+
 static int luaopen_table_clear(lua_State *L)
 {
   return lj_lib_postreg(L, lj_cf_table_clear, FF_table_clear, "clear");
@@ -321,6 +382,10 @@ LUALIB_API int luaopen_table(lua_State *L)
   lua_setfield(L, -2, "unpack");
 #endif
   lj_lib_prereg(L, LUA_TABLIBNAME ".new", luaopen_table_new, tabV(L->top-1));
+  lj_lib_prereg(L, LUA_TABLIBNAME ".clone", luaopen_table_clone, tabV(L->top-1));
+  lj_lib_prereg(L, LUA_TABLIBNAME ".isarray", luaopen_table_isarray, tabV(L->top-1));
+  lj_lib_prereg(L, LUA_TABLIBNAME ".nkeys", luaopen_table_nkeys, tabV(L->top-1));
+  lj_lib_prereg(L, LUA_TABLIBNAME ".isempty", luaopen_table_isempty, tabV(L->top-1));
   lj_lib_prereg(L, LUA_TABLIBNAME ".clear", luaopen_table_clear, tabV(L->top-1));
   return 1;
 }
diff --git a/lib/luajit-3065c9/src/lj_alloc.c b/lib/luajit2/src/lj_alloc.c
similarity index 100%
rename from lib/luajit-3065c9/src/lj_alloc.c
rename to lib/luajit2/src/lj_alloc.c
diff --git a/lib/luajit-3065c9/src/lj_alloc.h b/lib/luajit2/src/lj_alloc.h
similarity index 100%
rename from lib/luajit-3065c9/src/lj_alloc.h
rename to lib/luajit2/src/lj_alloc.h
diff --git a/lib/luajit-3065c9/src/lj_api.c b/lib/luajit2/src/lj_api.c
similarity index 96%
rename from lib/luajit-3065c9/src/lj_api.c
rename to lib/luajit2/src/lj_api.c
index d869ebf8f..00fc0f1d4 100644
--- a/lib/luajit-3065c9/src/lj_api.c
+++ b/lib/luajit2/src/lj_api.c
@@ -1,6 +1,6 @@
 /*
 ** Public Lua/C API.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -104,7 +104,12 @@ LUA_API int lua_checkstack(lua_State *L, int size)
   if (size > LUAI_MAXCSTACK || (L->top - L->base + size) > LUAI_MAXCSTACK) {
     return 0;  /* Stack overflow. */
   } else if (size > 0) {
-    lj_state_checkstack(L, (MSize)size);
+    int avail = (int)(mref(L->maxstack, TValue) - L->top);
+    if (size > avail &&
+	lj_state_cpgrowstack(L, (MSize)(size - avail)) != LUA_OK) {
+      L->top--;
+      return 0;  /* Out of memory. */
+    }
   }
   return 1;
 }
@@ -779,7 +784,7 @@ LUA_API void lua_concat(lua_State *L, int n)
 	L->top -= n;
 	break;
       }
-      n -= (int)(L->top - top);
+      n -= (int)(L->top - (top - 2*LJ_FR2));
       L->top = top+2;
       lj_vm_call(L, top, 1+1);
       L->top -= 1+LJ_FR2;
@@ -1047,6 +1052,7 @@ LUA_API int lua_setmetatable(lua_State *L, int idx)
     /* Flush cache, since traces specialize to basemt. But not during __gc. */
     if (lj_trace_flushall(L))
       lj_err_caller(L, LJ_ERR_NOGCMM);
+    o = index2adr(L, idx);  /* Stack may have been reallocated. */
     if (tvisbool(o)) {
       /* NOBARRIER: basemt is a GC root. */
       setgcref(basemt_it(g, LJ_TTRUE), obj2gco(mt));
@@ -1195,6 +1201,36 @@ LUA_API int lua_isyieldable(lua_State *L)
   return cframe_canyield(L->cframe);
 }
 
+LUA_API void lua_resetthread(lua_State *L, lua_State *th)
+{
+  TValue *stend, *st;
+
+  th->dummy_ffid = FF_C;
+  th->status = LUA_OK;
+
+  setmrefr(th->glref, L->glref);
+  setgcrefr(th->env, L->env);
+
+  th->cframe = NULL;
+
+  st = tvref(th->stack);
+
+  if (st != NULL) {
+    lj_state_relimitstack(th);
+
+    stend = st + th->stacksize;
+    st++; /* Needed for curr_funcisL() on empty stack. */
+    if (LJ_FR2) st++;
+    th->base = th->top = st;
+    lj_func_closeuv(L, st);
+    while (st < stend)  /* Clear new slots. */
+      setnilV(st++);
+  }
+
+  th->exdata = L->exdata;
+  th->exdata2 = L->exdata2;
+}
+
 LUA_API int lua_yield(lua_State *L, int nresults)
 {
   void *cf = L->cframe;
@@ -1311,3 +1347,22 @@ LUA_API void lua_setallocf(lua_State *L, lua_Alloc f, void *ud)
   g->allocf = f;
 }
 
+LUA_API void lua_setexdata(lua_State *L, void *exdata)
+{
+  L->exdata = exdata;
+}
+
+LUA_API void *lua_getexdata(lua_State *L)
+{
+  return L->exdata;
+}
+
+LUA_API void lua_setexdata2(lua_State *L, void *exdata2)
+{
+  L->exdata2 = exdata2;
+}
+
+LUA_API void *lua_getexdata2(lua_State *L)
+{
+  return L->exdata2;
+}
diff --git a/lib/luajit-3065c9/src/lj_arch.h b/lib/luajit2/src/lj_arch.h
similarity index 89%
rename from lib/luajit-3065c9/src/lj_arch.h
rename to lib/luajit2/src/lj_arch.h
index 882c99cb2..fbd18b366 100644
--- a/lib/luajit-3065c9/src/lj_arch.h
+++ b/lib/luajit2/src/lj_arch.h
@@ -1,6 +1,6 @@
 /*
 ** Target architecture selection.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_ARCH_H
@@ -31,6 +31,8 @@
 #define LUAJIT_ARCH_mips32	6
 #define LUAJIT_ARCH_MIPS64	7
 #define LUAJIT_ARCH_mips64	7
+#define LUAJIT_ARCH_S390X	8
+#define LUAJIT_ARCH_s390x	8
 
 /* Target OS. */
 #define LUAJIT_OS_OTHER		0
@@ -57,8 +59,10 @@
 #define LUAJIT_TARGET	LUAJIT_ARCH_X64
 #elif defined(__arm__) || defined(__arm) || defined(__ARM__) || defined(__ARM)
 #define LUAJIT_TARGET	LUAJIT_ARCH_ARM
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(_M_ARM64)
 #define LUAJIT_TARGET	LUAJIT_ARCH_ARM64
+#elif defined(__s390x__) || defined(__s390x)
+#define LUAJIT_TARGET	LUAJIT_ARCH_S390X
 #elif defined(__ppc__) || defined(__ppc) || defined(__PPC__) || defined(__PPC) || defined(__powerpc__) || defined(__powerpc) || defined(__POWERPC__) || defined(__POWERPC) || defined(_M_PPC)
 #define LUAJIT_TARGET	LUAJIT_ARCH_PPC
 #elif defined(__mips64__) || defined(__mips64) || defined(__MIPS64__) || defined(__MIPS64)
@@ -66,7 +70,7 @@
 #elif defined(__mips__) || defined(__mips) || defined(__MIPS__) || defined(__MIPS)
 #define LUAJIT_TARGET	LUAJIT_ARCH_MIPS32
 #else
-#error "No support for this architecture (yet)"
+#error "Architecture not supported (in this version), see: https://luajit.org/status.html#architectures"
 #endif
 
 #endif
@@ -93,6 +97,9 @@
 #elif defined(__CYGWIN__)
 #define LJ_TARGET_CYGWIN	1
 #define LUAJIT_OS	LUAJIT_OS_POSIX
+#elif defined(__QNX__)
+#define LJ_TARGET_QNX		1
+#define LUAJIT_OS	LUAJIT_OS_POSIX
 #else
 #define LUAJIT_OS	LUAJIT_OS_OTHER
 #endif
@@ -213,6 +220,10 @@
 #error "macOS requires GC64 -- don't disable it"
 #endif
 
+#ifdef __GNUC__
+#define LJ_HAS_OPTIMISED_HASH  1
+#endif
+
 #elif LUAJIT_TARGET == LUAJIT_ARCH_ARM
 
 #define LJ_ARCH_NAME		"arm"
@@ -234,7 +245,7 @@
 #define LJ_TARGET_UNIFYROT	2	/* Want only IR_BROR. */
 #define LJ_ARCH_NUMMODE		LJ_NUMMODE_DUAL
 
-#if __ARM_ARCH == 8 || __ARM_ARCH_8__ || __ARM_ARCH_8A__
+#if __ARM_ARCH >= 8 || __ARM_ARCH_8__ || __ARM_ARCH_8A__
 #define LJ_ARCH_VERSION		80
 #elif __ARM_ARCH == 7 || __ARM_ARCH_7__ || __ARM_ARCH_7A__ || __ARM_ARCH_7R__ || __ARM_ARCH_7S__ || __ARM_ARCH_7VE__
 #define LJ_ARCH_VERSION		70
@@ -256,6 +267,9 @@
 #define LJ_ARCH_NAME		"arm64"
 #define LJ_ARCH_ENDIAN		LUAJIT_LE
 #endif
+#if !defined(LJ_ABI_PAUTH) && defined(__arm64e__)
+#define LJ_ABI_PAUTH		1
+#endif
 #define LJ_TARGET_ARM64		1
 #define LJ_TARGET_EHRETREG	0
 #define LJ_TARGET_EHRAREG	30
@@ -290,7 +304,7 @@
 #define LJ_ARCH_NAME		"ppc"
 
 #if !defined(LJ_ARCH_HASFPU)
-#if defined(_SOFT_FLOAT) || defined(_SOFT_DOUBLE)
+#if defined(_SOFT_FLOAT) || defined(_SOFT_DOUBLE) || defined(__NO_FPRS__)
 #define LJ_ARCH_HASFPU		0
 #else
 #define LJ_ARCH_HASFPU		1
@@ -298,7 +312,7 @@
 #endif
 
 #if !defined(LJ_ABI_SOFTFP)
-#if defined(_SOFT_FLOAT) || defined(_SOFT_DOUBLE)
+#if defined(_SOFT_FLOAT) || defined(_SOFT_DOUBLE) || defined(__NO_FPRS__)
 #define LJ_ABI_SOFTFP		1
 #else
 #define LJ_ABI_SOFTFP		0
@@ -323,8 +337,18 @@
 #if LJ_TARGET_CONSOLE
 #define LJ_ARCH_PPC32ON64	1
 #define LJ_ARCH_NOFFI		1
+#if LJ_TARGET_PS3
+#define LJ_ARCH_PPC_OPD		1
+#endif
 #elif LJ_ARCH_BITS == 64
-#error "No support for PPC64"
+#define LJ_ARCH_PPC32ON64	1
+#define LJ_ARCH_NOJIT		1	/* NYI */
+#if _CALL_ELF == 2
+#define LJ_ARCH_PPC_ELFV2	1
+#else
+#define LJ_ARCH_PPC_OPD		1
+#define LJ_ARCH_PPC_OPDENV	1
+#endif
 #endif
 
 #if _ARCH_PWR7
@@ -432,6 +456,21 @@
 #define LJ_ARCH_VERSION		10
 #endif
 
+#elif LUAJIT_TARGET == LUAJIT_ARCH_S390X
+
+#define LJ_ARCH_NAME		"s390x"
+#define LJ_ARCH_BITS		64
+#define LJ_ARCH_ENDIAN		LUAJIT_BE
+#define LJ_TARGET_S390X		1
+#define LJ_TARGET_EHRETREG	0xe
+#define LJ_TARGET_JUMPRANGE	32	/* +-2^32 = +-4GB (32-bit, halfword aligned) */
+#define LJ_TARGET_MASKSHIFT	1
+#define LJ_TARGET_MASKROT	1
+#define LJ_TARGET_UNALIGNED	1
+#define LJ_ARCH_NUMMODE		LJ_NUMMODE_DUAL
+#define LJ_TARGET_GC64		1
+#define LJ_ARCH_NOJIT		1	/* NYI */
+
 #else
 #error "No target architecture defined"
 #endif
@@ -445,7 +484,7 @@
 #error "Need at least GCC 3.4 or newer"
 #endif
 #elif LJ_TARGET_X64
-#if __GNUC__ < 4
+#if 0 && __GNUC__ < 4
 #error "Need at least GCC 4.0 or newer"
 #endif
 #elif LJ_TARGET_ARM
@@ -463,11 +502,17 @@
 #endif
 #endif
 #elif !LJ_TARGET_PS3
+#if __clang__
+#if ((__clang_major__ < 3) || ((__clang_major__ == 3) && __clang_minor__ < 5))
+#error "Need at least Clang 3.5 or newer"
+#endif
+#else
 #if (__GNUC__ < 4) || ((__GNUC__ == 4) && __GNUC_MINOR__ < 3)
 #error "Need at least GCC 4.3 or newer"
 #endif
 #endif
 #endif
+#endif
 
 /* Check target-specific constraints. */
 #ifndef _BUILDVM_H
@@ -478,36 +523,36 @@
 #elif LJ_TARGET_ARM
 #if defined(__ARMEB__)
 #error "No support for big-endian ARM"
+#undef LJ_TARGET_ARM
 #endif
 #if __ARM_ARCH_6M__ || __ARM_ARCH_7M__ || __ARM_ARCH_7EM__
 #error "No support for Cortex-M CPUs"
+#undef LJ_TARGET_ARM
 #endif
 #if !(__ARM_EABI__ || LJ_TARGET_IOS)
 #error "Only ARM EABI or iOS 3.0+ ABI is supported"
+#undef LJ_TARGET_ARM
 #endif
 #elif LJ_TARGET_ARM64
 #if defined(_ILP32)
 #error "No support for ILP32 model on ARM64"
-#endif
-#elif LJ_TARGET_PPC
-#if defined(_LITTLE_ENDIAN) && (!defined(_BYTE_ORDER) || (_BYTE_ORDER == _LITTLE_ENDIAN))
-#error "No support for little-endian PPC32"
-#endif
-#if defined(__NO_FPRS__) && !defined(_SOFT_FLOAT)
-#error "No support for PPC/e500 anymore (use LuaJIT 2.0)"
+#undef LJ_TARGET_ARM64
 #endif
 #elif LJ_TARGET_MIPS32
 #if !((defined(_MIPS_SIM_ABI32) && _MIPS_SIM == _MIPS_SIM_ABI32) || (defined(_ABIO32) && _MIPS_SIM == _ABIO32))
 #error "Only o32 ABI supported for MIPS32"
+#undef LJ_TARGET_MIPS
 #endif
 #if LJ_TARGET_MIPSR6
 /* Not that useful, since most available r6 CPUs are 64 bit. */
 #error "No support for MIPS32R6"
+#undef LJ_TARGET_MIPS
 #endif
 #elif LJ_TARGET_MIPS64
 #if !((defined(_MIPS_SIM_ABI64) && _MIPS_SIM == _MIPS_SIM_ABI64) || (defined(_ABI64) && _MIPS_SIM == _ABI64))
 /* MIPS32ON64 aka n32 ABI support might be desirable, but difficult. */
 #error "Only n64 ABI supported for MIPS64"
+#undef LJ_TARGET_MIPS
 #endif
 #endif
 #endif
@@ -594,6 +639,10 @@
 #define LJ_SOFTFP		(!LJ_ARCH_HASFPU)
 #define LJ_SOFTFP32		(LJ_SOFTFP && LJ_32)
 
+#ifndef LJ_ABI_PAUTH
+#define LJ_ABI_PAUTH		0
+#endif
+
 #if LJ_ARCH_ENDIAN == LUAJIT_BE
 #define LJ_LE			0
 #define LJ_BE			1
@@ -648,6 +697,10 @@ extern void *LJ_WIN_LOADLIBA(const char *path);
 #endif
 #endif
 
+#if LUAJIT_TARGET == LUAJIT_ARCH_PPC && LJ_ARCH_ENDIAN == LUAJIT_LE
+#define LJ_NO_UNWIND            0
+#define LJ_UNWIND_EXT           0
+#else
 #if defined(LUAJIT_NO_UNWIND) || __GNU_COMPACT_EH__ || defined(__symbian__) || LJ_TARGET_IOS || LJ_TARGET_PS3 || LJ_TARGET_PS4 || LJ_TARGET_PS5
 #define LJ_NO_UNWIND		1
 #endif
@@ -657,6 +710,7 @@ extern void *LJ_WIN_LOADLIBA(const char *path);
 #else
 #define LJ_UNWIND_EXT		0
 #endif
+#endif  //#if LUAJIT_TARGET == LUAJIT_ARCH_PPC && LJ_ARCH_ENDIAN == LUAJIT_LE
 
 #if LJ_UNWIND_EXT && LJ_HASJIT && !LJ_TARGET_ARM && !(LJ_ABI_WIN && LJ_TARGET_X86)
 #define LJ_UNWIND_JIT		1
diff --git a/lib/luajit-3065c9/src/lj_asm.c b/lib/luajit2/src/lj_asm.c
similarity index 97%
rename from lib/luajit-3065c9/src/lj_asm.c
rename to lib/luajit2/src/lj_asm.c
index 6f5e0c45b..b710ca3f5 100644
--- a/lib/luajit-3065c9/src/lj_asm.c
+++ b/lib/luajit2/src/lj_asm.c
@@ -1,6 +1,6 @@
 /*
 ** IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_asm_c
@@ -29,6 +29,7 @@
 #include "lj_dispatch.h"
 #include "lj_vm.h"
 #include "lj_target.h"
+#include "lj_prng.h"
 
 #ifdef LUA_USE_ASSERT
 #include <stdio.h>
@@ -93,6 +94,12 @@ typedef struct ASMState {
   MCode *flagmcp;	/* Pending opportunity to merge flag setting ins. */
   MCode *realign;	/* Realign loop if not NULL. */
 
+#ifdef LUAJIT_RANDOM_RA
+  /* Randomize register allocation. OK for fuzz testing, not for production. */
+  uint64_t prngbits;
+  PRNGState prngstate;
+#endif
+
 #ifdef RID_NUM_KREF
   intptr_t krefk[RID_NUM_KREF];
 #endif
@@ -173,6 +180,41 @@ IRFLDEF(FLOFS)
   0
 };
 
+#ifdef LUAJIT_RANDOM_RA
+/* Return a fixed number of random bits from the local PRNG state. */
+static uint32_t ra_random_bits(ASMState *as, uint32_t nbits) {
+  uint64_t b = as->prngbits;
+  uint32_t res = (1u << nbits) - 1u;
+  if (b <= res) b = lj_prng_u64(&as->prngstate) | (1ull << 63);
+  res &= (uint32_t)b;
+  as->prngbits = b >> nbits;
+  return res;
+}
+
+/* Pick a random register from a register set. */
+static Reg rset_pickrandom(ASMState *as, RegSet rs)
+{
+  Reg r = rset_pickbot_(rs);
+  rs >>= r;
+  if (rs > 1) {  /* More than one bit set? */
+    while (1) {
+      /* We need to sample max. the GPR or FPR half of the set. */
+      uint32_t d = ra_random_bits(as, RSET_BITS-1);
+      if ((rs >> d) & 1) {
+	r += d;
+	break;
+      }
+    }
+  }
+  return r;
+}
+#define rset_picktop(rs)	rset_pickrandom(as, rs)
+#define rset_pickbot(rs)	rset_pickrandom(as, rs)
+#else
+#define rset_picktop(rs)	rset_picktop_(rs)
+#define rset_pickbot(rs)	rset_pickbot_(rs)
+#endif
+
 /* -- Target-specific instruction emitter --------------------------------- */
 
 #if LJ_TARGET_X86ORX64
@@ -564,7 +606,11 @@ static Reg ra_allock(ASMState *as, intptr_t k, RegSet allow)
 	IRIns *ir = IR(ref);
 	if ((ir->o == IR_KINT64 && k == (int64_t)ir_kint64(ir)->u64) ||
 #if LJ_GC64
+#if LJ_TARGET_ARM64
+	    (ir->o == IR_KINT && (uint64_t)k == (uint32_t)ir->i) ||
+#else
 	    (ir->o == IR_KINT && k == ir->i) ||
+#endif
 	    (ir->o == IR_KGC && k == (intptr_t)ir_kgc(ir)) ||
 	    ((ir->o == IR_KPTR || ir->o == IR_KKPTR) &&
 	     k == (intptr_t)ir_kptr(ir))
@@ -1662,6 +1708,8 @@ static void asm_loop(ASMState *as)
 #include "lj_asm_ppc.h"
 #elif LJ_TARGET_MIPS
 #include "lj_asm_mips.h"
+#elif LJ_TARGET_S390X
+#include "lj_asm_s390x.h"
 #else
 #error "Missing assembler for target CPU"
 #endif
@@ -1888,6 +1936,8 @@ static void asm_head_side(ASMState *as)
   IRRef1 sloadins[RID_MAX];
   RegSet allow = RSET_ALL;  /* Inverse of all coalesced registers. */
   RegSet live = RSET_EMPTY;  /* Live parent registers. */
+  RegSet pallow = RSET_GPR;  /* Registers needed by the parent stack check. */
+  Reg pbase;
   IRIns *irp = &as->parent->ir[REF_BASE];  /* Parent base. */
   int32_t spadj, spdelta;
   int pass2 = 0;
@@ -1898,7 +1948,11 @@ static void asm_head_side(ASMState *as)
     /* Force snap #0 alloc to prevent register overwrite in stack check. */
     asm_snap_alloc(as, 0);
   }
-  allow = asm_head_side_base(as, irp, allow);
+  pbase = asm_head_side_base(as, irp);
+  if (pbase != RID_NONE) {
+    rset_clear(allow, pbase);
+    rset_clear(pallow, pbase);
+  }
 
   /* Scan all parent SLOADs and collect register dependencies. */
   for (i = as->stopins; i > REF_BASE; i--) {
@@ -1928,6 +1982,7 @@ static void asm_head_side(ASMState *as)
       sloadins[rs] = (IRRef1)i;
       rset_set(live, rs);  /* Block live parent register. */
     }
+    if (!ra_hasspill(regsp_spill(rs))) rset_clear(pallow, regsp_reg(rs));
   }
 
   /* Calculate stack frame adjustment. */
@@ -2044,7 +2099,7 @@ static void asm_head_side(ASMState *as)
     ExitNo exitno = as->J->exitno;
 #endif
     as->T->topslot = (uint8_t)as->topslot;  /* Remember for child traces. */
-    asm_stack_check(as, as->topslot, irp, allow & RSET_GPR, exitno);
+    asm_stack_check(as, as->topslot, irp, pallow, exitno);
   }
 }
 
@@ -2435,6 +2490,9 @@ void lj_asm_trace(jit_State *J, GCtrace *T)
   as->realign = NULL;
   as->loopinv = 0;
   as->parent = J->parent ? traceref(J, J->parent) : NULL;
+#ifdef LUAJIT_RANDOM_RA
+  (void)lj_prng_u64(&J2G(J)->prng);  /* Ensure PRNG step between traces. */
+#endif
 
   /* Reserve MCode memory. */
   as->mctop = as->mctoporig = lj_mcode_reserve(J, &as->mcbot);
@@ -2476,6 +2534,10 @@ void lj_asm_trace(jit_State *J, GCtrace *T)
 #endif
     as->ir = J->curfinal->ir;  /* Use the copied IR. */
     as->curins = J->cur.nins = as->orignins;
+#ifdef LUAJIT_RANDOM_RA
+    as->prngstate = J2G(J)->prng;  /* Must (re)start from identical state. */
+    as->prngbits = 0;
+#endif
 
     RA_DBG_START();
     RA_DBGX((as, "===== STOP ====="));
diff --git a/lib/luajit-3065c9/src/lj_asm.h b/lib/luajit2/src/lj_asm.h
similarity index 82%
rename from lib/luajit-3065c9/src/lj_asm.h
rename to lib/luajit2/src/lj_asm.h
index f0a4f2d0c..5eb396b1b 100644
--- a/lib/luajit-3065c9/src/lj_asm.h
+++ b/lib/luajit2/src/lj_asm.h
@@ -1,6 +1,6 @@
 /*
 ** IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_ASM_H
diff --git a/lib/luajit-3065c9/src/lj_asm_arm.h b/lib/luajit2/src/lj_asm_arm.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_asm_arm.h
rename to lib/luajit2/src/lj_asm_arm.h
index 326330f47..bd5fbeb18 100644
--- a/lib/luajit-3065c9/src/lj_asm_arm.h
+++ b/lib/luajit2/src/lj_asm_arm.h
@@ -1,6 +1,6 @@
 /*
 ** ARM IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Register allocator extensions --------------------------------------- */
@@ -313,7 +313,11 @@ static void asm_fusexref(ASMState *as, ARMIns ai, Reg rd, IRRef ref,
 }
 
 #if !LJ_SOFTFP
-/* Fuse to multiply-add/sub instruction. */
+/*
+** Fuse to multiply-add/sub instruction.
+** VMLA rounds twice (UMA, not FMA) -- no need to check for JIT_F_OPT_FMA.
+** VFMA needs VFPv4, which is uncommon on the remaining ARM32 targets.
+*/
 static int asm_fusemadd(ASMState *as, IRIns *ir, ARMIns ai, ARMIns air)
 {
   IRRef lref = ir->op1, rref = ir->op2;
@@ -965,24 +969,32 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
 static void asm_uref(ASMState *as, IRIns *ir)
 {
   Reg dest = ra_dest(as, ir, RSET_GPR);
-  if (irref_isk(ir->op1)) {
+  int guarded = (irt_t(ir->t) & (IRT_GUARD|IRT_TYPE)) == (IRT_GUARD|IRT_PGC);
+  if (irref_isk(ir->op1) && !guarded) {
     GCfunc *fn = ir_kfunc(IR(ir->op1));
     MRef *v = &gcref(fn->l.uvptr[(ir->op2 >> 8)])->uv.v;
     emit_lsptr(as, ARMI_LDR, dest, v);
   } else {
-    Reg uv = ra_scratch(as, RSET_GPR);
-    Reg func = ra_alloc1(as, ir->op1, RSET_GPR);
-    if (ir->o == IR_UREFC) {
-      asm_guardcc(as, CC_NE);
+    if (guarded) {
+      asm_guardcc(as, ir->o == IR_UREFC ? CC_NE : CC_EQ);
       emit_n(as, ARMI_CMP|ARMI_K12|1, RID_TMP);
-      emit_opk(as, ARMI_ADD, dest, uv,
+    }
+    if (ir->o == IR_UREFC)
+      emit_opk(as, ARMI_ADD, dest, dest,
 	       (int32_t)offsetof(GCupval, tv), RSET_GPR);
-      emit_lso(as, ARMI_LDRB, RID_TMP, uv, (int32_t)offsetof(GCupval, closed));
+    else
+      emit_lso(as, ARMI_LDR, dest, dest, (int32_t)offsetof(GCupval, v));
+    if (guarded)
+      emit_lso(as, ARMI_LDRB, RID_TMP, dest,
+	       (int32_t)offsetof(GCupval, closed));
+    if (irref_isk(ir->op1)) {
+      GCfunc *fn = ir_kfunc(IR(ir->op1));
+      int32_t k = (int32_t)gcrefu(fn->l.uvptr[(ir->op2 >> 8)]);
+      emit_loadi(as, dest, k);
     } else {
-      emit_lso(as, ARMI_LDR, dest, uv, (int32_t)offsetof(GCupval, v));
+      emit_lso(as, ARMI_LDR, dest, ra_alloc1(as, ir->op1, RSET_GPR),
+	       (int32_t)offsetof(GCfuncL, uvptr) + 4*(int32_t)(ir->op2 >> 8));
     }
-    emit_lso(as, ARMI_LDR, uv, func,
-	     (int32_t)offsetof(GCfuncL, uvptr) + 4*(int32_t)(ir->op2 >> 8));
   }
 }
 
@@ -1986,6 +1998,7 @@ static void asm_prof(ASMState *as, IRIns *ir)
 static void asm_stack_check(ASMState *as, BCReg topslot,
 			    IRIns *irp, RegSet allow, ExitNo exitno)
 {
+  int savereg = 0;
   Reg pbase;
   uint32_t k;
   if (irp) {
@@ -1996,12 +2009,14 @@ static void asm_stack_check(ASMState *as, BCReg topslot,
       pbase = rset_pickbot(allow);
     } else {
       pbase = RID_RET;
-      emit_lso(as, ARMI_LDR, RID_RET, RID_SP, 0);  /* Restore temp. register. */
+      savereg = 1;
     }
   } else {
     pbase = RID_BASE;
   }
   emit_branch(as, ARMF_CC(ARMI_BL, CC_LS), exitstub_addr(as->J, exitno));
+  if (savereg)
+    emit_lso(as, ARMI_LDR, RID_RET, RID_SP, 0);  /* Restore temp. register. */
   k = emit_isk12(0, (int32_t)(8*topslot));
   lj_assertA(k, "slot offset %d does not fit in K12", 8*topslot);
   emit_n(as, ARMI_CMP^k, RID_TMP);
@@ -2013,7 +2028,7 @@ static void asm_stack_check(ASMState *as, BCReg topslot,
     if (ra_hasspill(irp->s))
       emit_lso(as, ARMI_LDR, pbase, RID_SP, sps_scale(irp->s));
     emit_lso(as, ARMI_LDR, RID_TMP, RID_TMP, (i & 4095));
-    if (ra_hasspill(irp->s) && !allow)
+    if (savereg)
       emit_lso(as, ARMI_STR, RID_RET, RID_SP, 0);  /* Save temp. register. */
     emit_loadi(as, RID_TMP, (i & ~4095));
   } else {
@@ -2027,11 +2042,12 @@ static void asm_stack_restore(ASMState *as, SnapShot *snap)
   SnapEntry *map = &as->T->snapmap[snap->mapofs];
   SnapEntry *flinks = &as->T->snapmap[snap_nextofs(as->T, snap)-1];
   MSize n, nent = snap->nent;
+  int32_t bias = 0;
   /* Store the value of all modified slots to the Lua stack. */
   for (n = 0; n < nent; n++) {
     SnapEntry sn = map[n];
     BCReg s = snap_slot(sn);
-    int32_t ofs = 8*((int32_t)s-1);
+    int32_t ofs = 8*((int32_t)s-1) - bias;
     IRRef ref = snap_ref(sn);
     IRIns *ir = IR(ref);
     if ((sn & SNAP_NORESTORE))
@@ -2050,6 +2066,12 @@ static void asm_stack_restore(ASMState *as, SnapShot *snap)
       emit_lso(as, ARMI_STR, tmp, RID_BASE, ofs+4);
 #else
       Reg src = ra_alloc1(as, ref, RSET_FPR);
+      if (LJ_UNLIKELY(ofs < -1020 || ofs > 1020)) {
+	int32_t adj = ofs & 0xffffff00;  /* K12-friendly. */
+	bias += adj;
+	ofs -= adj;
+	emit_addptr(as, RID_BASE, -adj);
+      }
       emit_vlso(as, ARMI_VSTR_D, src, RID_BASE, ofs);
 #endif
     } else {
@@ -2078,6 +2100,7 @@ static void asm_stack_restore(ASMState *as, SnapShot *snap)
     }
     checkmclim(as);
   }
+  emit_addptr(as, RID_BASE, bias);
   lj_assertA(map + nent == flinks, "inconsistent frames in snapshot");
 }
 
@@ -2163,7 +2186,7 @@ static void asm_head_root_base(ASMState *as)
 }
 
 /* Coalesce BASE register for a side trace. */
-static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
+static Reg asm_head_side_base(ASMState *as, IRIns *irp)
 {
   IRIns *ir;
   asm_head_lreg(as);
@@ -2171,16 +2194,15 @@ static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
   if (ra_hasreg(ir->r) && (rset_test(as->modset, ir->r) || irt_ismarked(ir->t)))
     ra_spill(as, ir);
   if (ra_hasspill(irp->s)) {
-    rset_clear(allow, ra_dest(as, ir, allow));
+    return ra_dest(as, ir, RSET_GPR);
   } else {
     Reg r = irp->r;
     lj_assertA(ra_hasreg(r), "base reg lost");
-    rset_clear(allow, r);
     if (r != ir->r && !rset_test(as->freeset, r))
       ra_restore(as, regcost_ref(as->cost[r]));
     ra_destreg(as, ir, r);
+    return r;
   }
-  return allow;
 }
 
 /* -- Tail of trace ------------------------------------------------------- */
@@ -2249,7 +2271,7 @@ static Reg asm_setup_call_slots(ASMState *as, IRIns *ir, const CCallInfo *ci)
   }
   if (nslots > as->evenspill)  /* Leave room for args in stack slots. */
     as->evenspill = nslots;
-  return REGSP_HINT(RID_RET);
+  return REGSP_HINT(irt_isfp(ir->t) ? RID_FPRET : RID_RET);
 }
 
 static void asm_setup_target(ASMState *as)
diff --git a/lib/luajit-3065c9/src/lj_asm_arm64.h b/lib/luajit2/src/lj_asm_arm64.h
similarity index 84%
rename from lib/luajit-3065c9/src/lj_asm_arm64.h
rename to lib/luajit2/src/lj_asm_arm64.h
index 1f44d023d..4b81a15ee 100644
--- a/lib/luajit-3065c9/src/lj_asm_arm64.h
+++ b/lib/luajit2/src/lj_asm_arm64.h
@@ -1,6 +1,6 @@
 /*
 ** ARM64 IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Contributed by Djordje Kovacevic and Stefan Pejic from RT-RK.com.
 ** Sponsored by Cisco Systems, Inc.
@@ -84,18 +84,23 @@ static void asm_guardcc(ASMState *as, A64CC cc)
   emit_cond_branch(as, cc, target);
 }
 
-/* Emit test and branch instruction to exit for guard. */
-static void asm_guardtnb(ASMState *as, A64Ins ai, Reg r, uint32_t bit)
+/* Emit test and branch instruction to exit for guard, if in range. */
+static int asm_guardtnb(ASMState *as, A64Ins ai, Reg r, uint32_t bit)
 {
   MCode *target = asm_exitstub_addr(as, as->snapno);
   MCode *p = as->mcp;
+  ptrdiff_t delta = target - p;
   if (LJ_UNLIKELY(p == as->invmcp)) {
+    if (as->orignins > 1023) return 0;  /* Delta might end up too large. */
     as->loopinv = 1;
-    *p = A64I_B | A64F_S26(target-p);
-    emit_tnb(as, ai^0x01000000u, r, bit, p-1);
-    return;
+    *p = A64I_B | A64F_S26(delta);
+    ai ^= 0x01000000u;
+    target = p-1;
+  } else if (LJ_UNLIKELY(delta >= 0x1fff)) {
+    return 0;
   }
   emit_tnb(as, ai, r, bit, target);
+  return 1;
 }
 
 /* Emit compare and branch instruction to exit for guard. */
@@ -211,16 +216,14 @@ static Reg asm_fuseahuref(ASMState *as, IRRef ref, int32_t *ofsp, RegSet allow,
 static uint32_t asm_fuseopm(ASMState *as, A64Ins ai, IRRef ref, RegSet allow)
 {
   IRIns *ir = IR(ref);
+  int logical = (ai & 0x1f000000) == 0x0a000000;
   if (ra_hasreg(ir->r)) {
     ra_noweak(as, ir->r);
     return A64F_M(ir->r);
   } else if (irref_isk(ref)) {
-    uint32_t m;
     int64_t k = get_k64val(as, ref);
-    if ((ai & 0x1f000000) == 0x0a000000)
-      m = emit_isk13(k, irt_is64(ir->t));
-    else
-      m = emit_isk12(k);
+    uint32_t m = logical ? emit_isk13(k, irt_is64(ir->t)) :
+			   emit_isk12(irt_is64(ir->t) ? k : (int32_t)k);
     if (m)
       return m;
   } else if (mayfuse(as, ref)) {
@@ -232,7 +235,7 @@ static uint32_t asm_fuseopm(ASMState *as, A64Ins ai, IRRef ref, RegSet allow)
 		    (IR(ir->op2)->i & (irt_is64(ir->t) ? 63 : 31));
       IRIns *irl = IR(ir->op1);
       if (sh == A64SH_LSL &&
-	  irl->o == IR_CONV &&
+	  irl->o == IR_CONV && !logical &&
 	  irl->op2 == ((IRT_I64<<IRCONV_DSH)|IRT_INT|IRCONV_SEXT) &&
 	  shift <= 4 &&
 	  canfuse(as, irl)) {
@@ -242,7 +245,11 @@ static uint32_t asm_fuseopm(ASMState *as, A64Ins ai, IRRef ref, RegSet allow)
 	Reg m = ra_alloc1(as, ir->op1, allow);
 	return A64F_M(m) | A64F_SH(sh, shift);
       }
-    } else if (ir->o == IR_CONV &&
+    } else if (ir->o == IR_BROR && logical && irref_isk(ir->op2)) {
+      Reg m = ra_alloc1(as, ir->op1, allow);
+      int shift = (IR(ir->op2)->i & (irt_is64(ir->t) ? 63 : 31));
+      return A64F_M(m) | A64F_SH(A64SH_ROR, shift);
+    } else if (ir->o == IR_CONV && !logical &&
 	       ir->op2 == ((IRT_I64<<IRCONV_DSH)|IRT_INT|IRCONV_SEXT)) {
       Reg m = ra_alloc1(as, ir->op1, allow);
       return A64F_M(m) | A64F_EX(A64EX_SXTW);
@@ -337,7 +344,8 @@ static int asm_fusemadd(ASMState *as, IRIns *ir, A64Ins ai, A64Ins air)
 {
   IRRef lref = ir->op1, rref = ir->op2;
   IRIns *irm;
-  if (lref != rref &&
+  if ((as->flags & JIT_F_OPT_FMA) &&
+      lref != rref &&
       ((mayfuse(as, lref) && (irm = IR(lref), irm->o == IR_MUL) &&
        ra_noreg(irm->r)) ||
        (mayfuse(as, rref) && (irm = IR(rref), irm->o == IR_MUL) &&
@@ -353,6 +361,35 @@ static int asm_fusemadd(ASMState *as, IRIns *ir, A64Ins ai, A64Ins air)
   return 0;
 }
 
+/* Fuse FP neg-multiply-add/sub. */
+static int asm_fusenmadd(ASMState *as, IRIns *ir, A64Ins ai, A64Ins air)
+{
+  IRRef ref = ir->op1;
+  IRIns *irn = IR(ref);
+  if (irn->o != IR_ADD && irn->o != IR_SUB)
+    return 0;
+
+  if (!mayfuse(as, ref))
+    return 0;
+
+  IRRef lref = irn->op1, rref = irn->op2;
+  IRIns *irm;
+  if (lref != rref &&
+      ((mayfuse(as, lref) && (irm = IR(lref), irm->o == IR_MUL) &&
+       ra_noreg(irm->r)) ||
+       (mayfuse(as, rref) && (irm = IR(rref), irm->o == IR_MUL) &&
+       (rref = lref, ra_noreg(irm->r))))) {
+    Reg dest = ra_dest(as, ir, RSET_FPR);
+    Reg add = ra_hintalloc(as, rref, dest, RSET_FPR);
+    Reg left = ra_alloc2(as, irm,
+			 rset_exclude(rset_exclude(RSET_FPR, dest), add));
+    Reg right = (left >> 8); left &= 255;
+    emit_dnma(as, (irn->o == IR_ADD ? ai : air), (dest & 31), (left & 31), (right & 31), (add & 31));
+    return 1;
+  }
+  return 0;
+}
+
 /* Fuse BAND + BSHL/BSHR into UBFM. */
 static int asm_fuseandshift(ASMState *as, IRIns *ir)
 {
@@ -418,13 +455,18 @@ static int asm_fuseorshift(ASMState *as, IRIns *ir)
 static void asm_gencall(ASMState *as, const CCallInfo *ci, IRRef *args)
 {
   uint32_t n, nargs = CCI_XNARGS(ci);
-  int32_t ofs = 0;
+  int32_t spofs = 0, spalign = LJ_HASFFI && LJ_TARGET_OSX ? 0 : 7;
   Reg gpr, fpr = REGARG_FIRSTFPR;
-  if ((void *)ci->func)
-    emit_call(as, (void *)ci->func);
+  if (ci->func)
+    emit_call(as, ci->func);
   for (gpr = REGARG_FIRSTGPR; gpr <= REGARG_LASTGPR; gpr++)
     as->cost[gpr] = REGCOST(~0u, ASMREF_L);
   gpr = REGARG_FIRSTGPR;
+#if LJ_HASFFI && LJ_ABI_WIN
+  if ((ci->flags & CCI_VARARG)) {
+    fpr = REGARG_LASTFPR+1;
+  }
+#endif
   for (n = 0; n < nargs; n++) { /* Setup args. */
     IRRef ref = args[n];
     IRIns *ir = IR(ref);
@@ -435,10 +477,21 @@ static void asm_gencall(ASMState *as, const CCallInfo *ci, IRRef *args)
 		     "reg %d not free", fpr);  /* Must have been evicted. */
 	  ra_leftov(as, fpr, ref);
 	  fpr++;
+#if LJ_HASFFI && LJ_ABI_WIN
+	} else if ((ci->flags & CCI_VARARG) && (gpr <= REGARG_LASTGPR)) {
+	  Reg rf = ra_alloc1(as, ref, RSET_FPR);
+	  emit_dn(as, A64I_FMOV_R_D, gpr++, rf & 31);
+#endif
 	} else {
 	  Reg r = ra_alloc1(as, ref, RSET_FPR);
-	  emit_spstore(as, ir, r, ofs + ((LJ_BE && !irt_isnum(ir->t)) ? 4 : 0));
-	  ofs += 8;
+	  int32_t al = spalign;
+#if LJ_HASFFI && LJ_TARGET_OSX
+	  al |= irt_isnum(ir->t) ? 7 : 3;
+#endif
+	  spofs = (spofs + al) & ~al;
+	  if (LJ_BE && al >= 7 && !irt_isnum(ir->t)) spofs += 4, al -= 4;
+	  emit_spstore(as, ir, r, spofs);
+	  spofs += al + 1;
 	}
       } else {
 	if (gpr <= REGARG_LASTGPR) {
@@ -448,10 +501,27 @@ static void asm_gencall(ASMState *as, const CCallInfo *ci, IRRef *args)
 	  gpr++;
 	} else {
 	  Reg r = ra_alloc1(as, ref, RSET_GPR);
-	  emit_spstore(as, ir, r, ofs + ((LJ_BE && !irt_is64(ir->t)) ? 4 : 0));
-	  ofs += 8;
+	  int32_t al = spalign;
+#if LJ_HASFFI && LJ_TARGET_OSX
+	  al |= irt_size(ir->t) - 1;
+#endif
+	  spofs = (spofs + al) & ~al;
+	  if (al >= 3) {
+	    if (LJ_BE && al >= 7 && !irt_is64(ir->t)) spofs += 4, al -= 4;
+	    emit_spstore(as, ir, r, spofs);
+	  } else {
+	    lj_assertA(al == 0 || al == 1, "size %d unexpected", al + 1);
+	    emit_lso(as, al ? A64I_STRH : A64I_STRB, r, RID_SP, spofs);
+	  }
+	  spofs += al + 1;
 	}
       }
+#if LJ_HASFFI && LJ_TARGET_OSX
+    } else {  /* Marker for start of varargs. */
+      gpr = REGARG_LASTGPR+1;
+      fpr = REGARG_LASTFPR+1;
+      spalign = 7;
+#endif
     }
   }
 }
@@ -500,7 +570,7 @@ static void asm_callx(ASMState *as, IRIns *ir)
     ci.func = (ASMFunction)(ir_k64(irf)->u64);
   } else {  /* Need a non-argument register for indirect calls. */
     Reg freg = ra_alloc1(as, func, RSET_RANGE(RID_X8, RID_MAX_GPR)-RSET_FIXED);
-    emit_n(as, A64I_BLR, freg);
+    emit_n(as, A64I_BLR_AUTH, freg);
     ci.func = (ASMFunction)(void *)0;
   }
   asm_gencall(as, &ci, args);
@@ -517,8 +587,6 @@ static void asm_retf(ASMState *as, IRIns *ir)
   as->topslot -= (BCReg)delta;
   if ((int32_t)as->topslot < 0) as->topslot = 0;
   irt_setmark(IR(REF_BASE)->t);  /* Children must not coalesce with BASE reg. */
-  /* Need to force a spill on REF_BASE now to update the stack slot. */
-  emit_lso(as, A64I_STRx, base, RID_SP, ra_spill(as, IR(REF_BASE)));
   emit_setgl(as, base, jit_base);
   emit_addptr(as, base, -8*delta);
   asm_guardcc(as, CC_NE);
@@ -642,25 +710,22 @@ static void asm_strto(ASMState *as, IRIns *ir)
 {
   const CCallInfo *ci = &lj_ir_callinfo[IRCALL_lj_strscan_num];
   IRRef args[2];
-  Reg dest = 0, tmp;
-  int destused = ra_used(ir);
+  Reg tmp;
   int32_t ofs = 0;
   ra_evictset(as, RSET_SCRATCH);
-  if (destused) {
+  if (ra_used(ir)) {
     if (ra_hasspill(ir->s)) {
       ofs = sps_scale(ir->s);
-      destused = 0;
       if (ra_hasreg(ir->r)) {
 	ra_free(as, ir->r);
 	ra_modified(as, ir->r);
 	emit_spload(as, ir, ir->r, ofs);
       }
     } else {
-      dest = ra_dest(as, ir, RSET_FPR);
+      Reg dest = ra_dest(as, ir, RSET_FPR);
+      emit_lso(as, A64I_LDRd, (dest & 31), RID_SP, 0);
     }
   }
-  if (destused)
-    emit_lso(as, A64I_LDRd, (dest & 31), RID_SP, 0);
   asm_guardcnb(as, A64I_CBZ, RID_RET);
   args[0] = ir->op1; /* GCstr *str */
   args[1] = ASMREF_TMP1; /* TValue *n  */
@@ -751,113 +816,75 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
   int destused = ra_used(ir);
   Reg dest = ra_dest(as, ir, allow);
   Reg tab = ra_alloc1(as, ir->op1, rset_clear(allow, dest));
-  Reg key = 0, tmp = RID_TMP;
-  Reg ftmp = RID_NONE, type = RID_NONE, scr = RID_NONE, tisnum = RID_NONE;
+  Reg tmp = RID_TMP, type = RID_NONE, key, tkey;
   IRRef refkey = ir->op2;
   IRIns *irkey = IR(refkey);
-  int isk = irref_isk(ir->op2);
+  int isk = irref_isk(refkey);
   IRType1 kt = irkey->t;
   uint32_t k = 0;
   uint32_t khash;
-  MCLabel l_end, l_loop, l_next;
+  MCLabel l_end, l_loop;
   rset_clear(allow, tab);
 
-  if (!isk) {
-    key = ra_alloc1(as, ir->op2, irt_isnum(kt) ? RSET_FPR : allow);
-    rset_clear(allow, key);
-    if (!irt_isstr(kt)) {
-      tmp = ra_scratch(as, allow);
-      rset_clear(allow, tmp);
-    }
-  } else if (irt_isnum(kt)) {
-    int64_t val = (int64_t)ir_knum(irkey)->u64;
-    if (!(k = emit_isk12(val))) {
-      key = ra_allock(as, val, allow);
-      rset_clear(allow, key);
-    }
-  } else if (!irt_ispri(kt)) {
-    if (!(k = emit_isk12(irkey->i))) {
-      key = ra_alloc1(as, refkey, allow);
-      rset_clear(allow, key);
-    }
-  }
-
-  /* Allocate constants early. */
-  if (irt_isnum(kt)) {
-    if (!isk) {
-      tisnum = ra_allock(as, LJ_TISNUM << 15, allow);
-      ftmp = ra_scratch(as, rset_exclude(RSET_FPR, key));
-      rset_clear(allow, tisnum);
-    }
-  } else if (irt_isaddr(kt)) {
-    if (isk) {
-      int64_t kk = ((int64_t)irt_toitype(kt) << 47) | irkey[1].tv.u64;
-      scr = ra_allock(as, kk, allow);
+  /* Allocate register for tkey outside of the loop. */
+  if (isk) {
+    int64_t kk;
+    if (irt_isaddr(kt)) {
+      kk = ((int64_t)irt_toitype(kt) << 47) | irkey[1].tv.u64;
+    } else if (irt_isnum(kt)) {
+      kk = (int64_t)ir_knum(irkey)->u64;
+      /* Assumes -0.0 is already canonicalized to +0.0. */
     } else {
-      scr = ra_scratch(as, allow);
+      lj_assertA(irt_ispri(kt) && !irt_isnil(kt), "bad HREF key type");
+      kk = ~((int64_t)~irt_toitype(kt) << 47);
     }
-    rset_clear(allow, scr);
+    k = emit_isk12(kk);
+    tkey = k ? 0 : ra_allock(as, kk, allow);
   } else {
-    lj_assertA(irt_ispri(kt) && !irt_isnil(kt), "bad HREF key type");
-    type = ra_allock(as, ~((int64_t)~irt_toitype(kt) << 47), allow);
-    scr = ra_scratch(as, rset_clear(allow, type));
-    rset_clear(allow, scr);
+    tkey = ra_scratch(as, allow);
   }
 
   /* Key not found in chain: jump to exit (if merged) or load niltv. */
   l_end = emit_label(as);
   as->invmcp = NULL;
-  if (merge == IR_NE)
+  if (merge == IR_NE) {
     asm_guardcc(as, CC_AL);
-  else if (destused)
-    emit_loada(as, dest, niltvg(J2G(as->J)));
+  } else if (destused) {
+    uint32_t k12 = emit_isk12(offsetof(global_State, nilnode.val));
+    lj_assertA(k12 != 0, "Cannot k12 encode niltv(L)");
+    emit_dn(as, A64I_ADDx^k12, dest, RID_GL);
+  }
 
   /* Follow hash chain until the end. */
   l_loop = --as->mcp;
-  emit_n(as, A64I_CMPx^A64I_K12^0, dest);
-  emit_lso(as, A64I_LDRx, dest, dest, offsetof(Node, next));
-  l_next = emit_label(as);
+  if (destused)
+    emit_lso(as, A64I_LDRx, dest, dest, offsetof(Node, next));
 
   /* Type and value comparison. */
   if (merge == IR_EQ)
     asm_guardcc(as, CC_EQ);
   else
     emit_cond_branch(as, CC_EQ, l_end);
+  emit_nm(as, A64I_CMPx^k, tmp, tkey);
+  if (!destused)
+    emit_lso(as, A64I_LDRx, dest, dest, offsetof(Node, next));
+  emit_lso(as, A64I_LDRx, tmp, dest, offsetof(Node, key));
+  *l_loop = A64I_X | A64I_CBNZ | A64F_S19(as->mcp - l_loop) | dest;
 
-  if (irt_isnum(kt)) {
-    if (isk) {
-      /* Assumes -0.0 is already canonicalized to +0.0. */
-      if (k)
-	emit_n(as, A64I_CMPx^k, tmp);
-      else
-	emit_nm(as, A64I_CMPx, key, tmp);
-      emit_lso(as, A64I_LDRx, tmp, dest, offsetof(Node, key.u64));
-    } else {
-      emit_nm(as, A64I_FCMPd, key, ftmp);
-      emit_dn(as, A64I_FMOV_D_R, (ftmp & 31), (tmp & 31));
-      emit_cond_branch(as, CC_LO, l_next);
-      emit_nm(as, A64I_CMPx | A64F_SH(A64SH_LSR, 32), tisnum, tmp);
-      emit_lso(as, A64I_LDRx, tmp, dest, offsetof(Node, key.n));
-    }
-  } else if (irt_isaddr(kt)) {
-    if (isk) {
-      emit_nm(as, A64I_CMPx, scr, tmp);
-      emit_lso(as, A64I_LDRx, tmp, dest, offsetof(Node, key.u64));
+  /* Construct tkey as canonicalized or tagged key. */
+  if (!isk) {
+    if (irt_isnum(kt)) {
+      key = ra_alloc1(as, refkey, RSET_FPR);
+      emit_dnm(as, A64I_CSELx | A64F_CC(CC_EQ), tkey, RID_ZERO, tkey);
+      /* A64I_FMOV_R_D from key to tkey done below. */
     } else {
-      emit_nm(as, A64I_CMPx, tmp, scr);
-      emit_lso(as, A64I_LDRx, scr, dest, offsetof(Node, key.u64));
+      lj_assertA(irt_isaddr(kt), "bad HREF key type");
+      key = ra_alloc1(as, refkey, allow);
+      type = ra_allock(as, irt_toitype(kt) << 15, rset_clear(allow, key));
+      emit_dnm(as, A64I_ADDx | A64F_SH(A64SH_LSL, 32), tkey, key, type);
     }
-  } else {
-    emit_nm(as, A64I_CMPx, scr, type);
-    emit_lso(as, A64I_LDRx, scr, dest, offsetof(Node, key));
   }
 
-  *l_loop = A64I_BCC | A64F_S19(as->mcp - l_loop) | CC_NE;
-  if (!isk && irt_isaddr(kt)) {
-    type = ra_allock(as, (int32_t)irt_toitype(kt), allow);
-    emit_dnm(as, A64I_ADDx | A64F_SH(A64SH_LSL, 47), tmp, key, type);
-    rset_clear(allow, type);
-  }
   /* Load main position relative to tab->node into dest. */
   khash = isk ? ir_khash(as, irkey) : 1;
   if (khash == 0) {
@@ -871,7 +898,6 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
       emit_dnm(as, A64I_ANDw, dest, dest, tmphash);
       emit_lso(as, A64I_LDRw, dest, tab, offsetof(GCtab, hmask));
     } else if (irt_isstr(kt)) {
-      /* Fetch of str->sid is cheaper than ra_allock. */
       emit_dnm(as, A64I_ANDw, dest, dest, tmp);
       emit_lso(as, A64I_LDRw, tmp, key, offsetof(GCstr, sid));
       emit_lso(as, A64I_LDRw, dest, tab, offsetof(GCtab, hmask));
@@ -880,23 +906,18 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
       emit_lso(as, A64I_LDRw, tmp, tab, offsetof(GCtab, hmask));
       emit_dnm(as, A64I_SUBw, dest, dest, tmp);
       emit_dnm(as, A64I_EXTRw | (A64F_IMMS(32-HASH_ROT3)), tmp, tmp, tmp);
-      emit_dnm(as, A64I_EORw, dest, dest, tmp);
-      emit_dnm(as, A64I_EXTRw | (A64F_IMMS(32-HASH_ROT2)), dest, dest, dest);
+      emit_dnm(as, A64I_EORw | A64F_SH(A64SH_ROR, 32-HASH_ROT2), dest, tmp, dest);
       emit_dnm(as, A64I_SUBw, tmp, tmp, dest);
       emit_dnm(as, A64I_EXTRw | (A64F_IMMS(32-HASH_ROT1)), dest, dest, dest);
-      emit_dnm(as, A64I_EORw, tmp, tmp, dest);
       if (irt_isnum(kt)) {
+	emit_dnm(as, A64I_EORw, tmp, tkey, dest);
 	emit_dnm(as, A64I_ADDw, dest, dest, dest);
-	emit_dn(as, A64I_LSRx | A64F_IMMR(32)|A64F_IMMS(32), dest, dest);
-	emit_dm(as, A64I_MOVw, tmp, dest);
-	emit_dn(as, A64I_FMOV_R_D, dest, (key & 31));
+	emit_dn(as, A64I_LSRx | A64F_IMMR(32)|A64F_IMMS(32), dest, tkey);
+	emit_nm(as, A64I_FCMPZd, (key & 31), 0);
+	emit_dn(as, A64I_FMOV_R_D, tkey, (key & 31));
       } else {
-	checkmclim(as);
-	emit_dm(as, A64I_MOVw, tmp, key);
-	emit_dnm(as, A64I_EORw, dest, dest,
-		 ra_allock(as, irt_toitype(kt) << 15, allow));
-	emit_dn(as, A64I_LSRx | A64F_IMMR(32)|A64F_IMMS(32), dest, dest);
-	emit_dm(as, A64I_MOVx, dest, key);
+	emit_dnm(as, A64I_EORw, tmp, key, dest);
+	emit_dnm(as, A64I_EORx | A64F_SH(A64SH_LSR, 32), dest, type, key);
       }
     }
   }
@@ -908,10 +929,10 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
   IRIns *irkey = IR(kslot->op1);
   int32_t ofs = (int32_t)(kslot->op2 * sizeof(Node));
   int32_t kofs = ofs + (int32_t)offsetof(Node, key);
-  int bigofs = !emit_checkofs(A64I_LDRx, ofs);
+  int bigofs = !emit_checkofs(A64I_LDRx, kofs);
   Reg dest = (ra_used(ir) || bigofs) ? ra_dest(as, ir, RSET_GPR) : RID_NONE;
   Reg node = ra_alloc1(as, ir->op1, RSET_GPR);
-  Reg key, idx = node;
+  Reg idx = node;
   RegSet allow = rset_exclude(RSET_GPR, node);
   uint64_t k;
   lj_assertA(ofs % sizeof(Node) == 0, "unaligned HREFK slot");
@@ -930,34 +951,39 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
   } else {
     k = ((uint64_t)irt_toitype(irkey->t) << 47) | (uint64_t)ir_kgc(irkey);
   }
-  key = ra_scratch(as, allow);
-  emit_nm(as, A64I_CMPx, key, ra_allock(as, k, rset_exclude(allow, key)));
-  emit_lso(as, A64I_LDRx, key, idx, kofs);
+  emit_nm(as, A64I_CMPx, RID_TMP, ra_allock(as, k, allow));
+  emit_lso(as, A64I_LDRx, RID_TMP, idx, kofs);
   if (bigofs)
-    emit_opk(as, A64I_ADDx, dest, node, ofs, RSET_GPR);
+    emit_opk(as, A64I_ADDx, dest, node, ofs, rset_exclude(RSET_GPR, node));
 }
 
 static void asm_uref(ASMState *as, IRIns *ir)
 {
   Reg dest = ra_dest(as, ir, RSET_GPR);
-  if (irref_isk(ir->op1)) {
+  int guarded = (irt_t(ir->t) & (IRT_GUARD|IRT_TYPE)) == (IRT_GUARD|IRT_PGC);
+  if (irref_isk(ir->op1) && !guarded) {
     GCfunc *fn = ir_kfunc(IR(ir->op1));
     MRef *v = &gcref(fn->l.uvptr[(ir->op2 >> 8)])->uv.v;
     emit_lsptr(as, A64I_LDRx, dest, v);
   } else {
-    Reg uv = ra_scratch(as, RSET_GPR);
-    Reg func = ra_alloc1(as, ir->op1, RSET_GPR);
-    if (ir->o == IR_UREFC) {
-      asm_guardcc(as, CC_NE);
-      emit_n(as, (A64I_CMPx^A64I_K12) | A64F_U12(1), RID_TMP);
-      emit_opk(as, A64I_ADDx, dest, uv,
+    if (guarded)
+      asm_guardcnb(as, ir->o == IR_UREFC ? A64I_CBZ : A64I_CBNZ, RID_TMP);
+    if (ir->o == IR_UREFC)
+      emit_opk(as, A64I_ADDx, dest, dest,
 	       (int32_t)offsetof(GCupval, tv), RSET_GPR);
-      emit_lso(as, A64I_LDRB, RID_TMP, uv, (int32_t)offsetof(GCupval, closed));
+    else
+      emit_lso(as, A64I_LDRx, dest, dest, (int32_t)offsetof(GCupval, v));
+    if (guarded)
+      emit_lso(as, A64I_LDRB, RID_TMP, dest,
+	       (int32_t)offsetof(GCupval, closed));
+    if (irref_isk(ir->op1)) {
+      GCfunc *fn = ir_kfunc(IR(ir->op1));
+      uint64_t k = gcrefu(fn->l.uvptr[(ir->op2 >> 8)]);
+      emit_loadu64(as, dest, k);
     } else {
-      emit_lso(as, A64I_LDRx, dest, uv, (int32_t)offsetof(GCupval, v));
+      emit_lso(as, A64I_LDRx, dest, ra_alloc1(as, ir->op1, RSET_GPR),
+	       (int32_t)offsetof(GCfuncL, uvptr) + 8*(int32_t)(ir->op2 >> 8));
     }
-    emit_lso(as, A64I_LDRx, uv, func,
-	     (int32_t)offsetof(GCfuncL, uvptr) + 8*(int32_t)(ir->op2 >> 8));
   }
 }
 
@@ -1051,10 +1077,30 @@ static void asm_xload(ASMState *as, IRIns *ir)
   asm_fusexref(as, asm_fxloadins(ir), dest, ir->op1, RSET_GPR);
 }
 
+static int maybe_zero_val(ASMState *as, IRRef ref)
+{
+  IRIns *ir = IR(ref);
+
+  switch(ir->o) {
+  case IR_KNULL:
+    return 1;
+  case IR_KINT:
+    return 0 == ir->i;
+  case IR_KINT64:
+    return 0 == ir_kint64(ir)->u64;
+  }
+
+  return 0;
+}
+
 static void asm_xstore(ASMState *as, IRIns *ir)
 {
   if (ir->r != RID_SINK) {
-    Reg src = ra_alloc1(as, ir->op2, irt_isfp(ir->t) ? RSET_FPR : RSET_GPR);
+    Reg src;
+    if (irref_isk(ir->op2) && maybe_zero_val(as, ir->op2))
+      src = RID_ZERO;
+    else
+      src = ra_alloc1(as, ir->op2, irt_isfp(ir->t) ? RSET_FPR : RSET_GPR);
     asm_fusexref(as, asm_fxstoreins(ir), src, ir->op1,
 		 rset_exclude(RSET_GPR, src));
   }
@@ -1062,7 +1108,7 @@ static void asm_xstore(ASMState *as, IRIns *ir)
 
 static void asm_ahuvload(ASMState *as, IRIns *ir)
 {
-  Reg idx, tmp, type;
+  Reg idx, tmp;
   int32_t ofs = 0;
   RegSet gpr = RSET_GPR, allow = irt_isnum(ir->t) ? RSET_FPR : RSET_GPR;
   lj_assertA(irt_isnum(ir->t) || irt_ispri(ir->t) || irt_isaddr(ir->t) ||
@@ -1081,8 +1127,9 @@ static void asm_ahuvload(ASMState *as, IRIns *ir)
   } else {
     tmp = ra_scratch(as, gpr);
   }
-  type = ra_scratch(as, rset_clear(gpr, tmp));
-  idx = asm_fuseahuref(as, ir->op1, &ofs, rset_clear(gpr, type), A64I_LDRx);
+  idx = asm_fuseahuref(as, ir->op1, &ofs, rset_clear(gpr, tmp), A64I_LDRx);
+  rset_clear(gpr, idx);
+  if (ofs & FUSE_REG) rset_clear(gpr, ofs & 31);
   if (ir->o == IR_VLOAD) ofs += 8 * ir->op2;
   /* Always do the type check, even if the load result is unused. */
   asm_guardcc(as, irt_isnum(ir->t) ? CC_LS : CC_NE);
@@ -1090,10 +1137,10 @@ static void asm_ahuvload(ASMState *as, IRIns *ir)
     lj_assertA(irt_isinteger(ir->t) || irt_isnum(ir->t),
 	       "bad load type %d", irt_type(ir->t));
     emit_nm(as, A64I_CMPx | A64F_SH(A64SH_LSR, 32),
-	    ra_allock(as, LJ_TISNUM << 15, rset_exclude(gpr, idx)), tmp);
+	    ra_allock(as, LJ_TISNUM << 15, gpr), tmp);
   } else if (irt_isaddr(ir->t)) {
-    emit_n(as, (A64I_CMNx^A64I_K12) | A64F_U12(-irt_toitype(ir->t)), type);
-    emit_dn(as, A64I_ASRx | A64F_IMMR(47), type, tmp);
+    emit_n(as, (A64I_CMNx^A64I_K12) | A64F_U12(-irt_toitype(ir->t)), RID_TMP);
+    emit_dn(as, A64I_ASRx | A64F_IMMR(47), RID_TMP, tmp);
   } else if (irt_isnil(ir->t)) {
     emit_n(as, (A64I_CMNx^A64I_K12) | A64F_U12(1), tmp);
   } else {
@@ -1201,7 +1248,7 @@ dotypecheck:
       tmp = ra_scratch(as, allow);
       rset_clear(allow, tmp);
     }
-    if (irt_isnum(t) && !(ir->op2 & IRSLOAD_CONVERT))
+    if (ra_hasreg(dest) && tmp != dest)
       emit_dn(as, A64I_FMOV_D_R, (dest & 31), tmp);
     /* Need type check, even if the load result is unused. */
     asm_guardcc(as, irt_isnum(t) ? CC_LS : CC_NE);
@@ -1216,9 +1263,8 @@ dotypecheck:
       emit_nm(as, A64I_CMPx,
 	      ra_allock(as, ~((int64_t)~irt_toitype(t) << 47) , allow), tmp);
     } else {
-      Reg type = ra_scratch(as, allow);
-      emit_n(as, (A64I_CMNx^A64I_K12) | A64F_U12(-irt_toitype(t)), type);
-      emit_dn(as, A64I_ASRx | A64F_IMMR(47), type, tmp);
+      emit_n(as, (A64I_CMNx^A64I_K12) | A64F_U12(-irt_toitype(t)), RID_TMP);
+      emit_dn(as, A64I_ASRx | A64F_IMMR(47), RID_TMP, tmp);
     }
     emit_lso(as, A64I_LDRx, tmp, base, ofs);
     return;
@@ -1250,7 +1296,12 @@ static void asm_cnew(ASMState *as, IRIns *ir)
   /* Initialize immutable cdata object. */
   if (ir->o == IR_CNEWI) {
     int32_t ofs = sizeof(GCcdata);
-    Reg r = ra_alloc1(as, ir->op2, allow);
+    Reg r;
+    if (irref_isk(ir->op2) && maybe_zero_val(as, ir->op2))
+      r = RID_ZERO;
+    else
+      r = ra_alloc1(as, ir->op2, allow);
+
     lj_assertA(sz == 4 || sz == 8, "bad CNEWI size %d", sz);
     emit_lso(as, sz == 8 ? A64I_STRx : A64I_STRw, r, RID_RET, ofs);
   } else if (ir->op2 != REF_NIL) {  /* Create VLA/VLS/aligned cdata. */
@@ -1266,7 +1317,7 @@ static void asm_cnew(ASMState *as, IRIns *ir)
 
   /* Initialize gct and ctypeid. lj_mem_newgco() already sets marked. */
   {
-    Reg r = (id < 65536) ? RID_X1 : ra_allock(as, id, allow);
+    Reg r = id == 0 ? RID_ZERO : (id < 65536) ? RID_X1 : ra_allock(as, id, allow);
     emit_lso(as, A64I_STRB, RID_TMP, RID_RET, offsetof(GCcdata, gct));
     emit_lso(as, A64I_STRH, r, RID_RET, offsetof(GCcdata, ctypeid));
     emit_d(as, A64I_MOVZw | A64F_U16(~LJ_TCDATA), RID_TMP);
@@ -1288,8 +1339,9 @@ static void asm_tbar(ASMState *as, IRIns *ir)
   Reg link = ra_scratch(as, rset_exclude(RSET_GPR, tab));
   Reg mark = RID_TMP;
   MCLabel l_end = emit_label(as);
-  emit_lso(as, A64I_STRx, link, tab, (int32_t)offsetof(GCtab, gclist));
   emit_lso(as, A64I_STRB, mark, tab, (int32_t)offsetof(GCtab, marked));
+  /* Keep STRx in the middle to avoid LDP/STP fusion with surrounding code. */
+  emit_lso(as, A64I_STRx, link, tab, (int32_t)offsetof(GCtab, gclist));
   emit_setgl(as, tab, gc.grayagain);
   emit_dn(as, A64I_ANDw^emit_isk13(~LJ_GC_BLACK, 0), mark, mark);
   emit_getgl(as, link, gc.grayagain);
@@ -1303,7 +1355,6 @@ static void asm_obar(ASMState *as, IRIns *ir)
   const CCallInfo *ci = &lj_ir_callinfo[IRCALL_lj_gc_barrieruv];
   IRRef args[2];
   MCLabel l_end;
-  RegSet allow = RSET_GPR;
   Reg obj, val, tmp;
   /* No need for other object barriers (yet). */
   lj_assertA(IR(ir->op1)->o == IR_UREFC, "bad OBAR type");
@@ -1314,14 +1365,13 @@ static void asm_obar(ASMState *as, IRIns *ir)
   asm_gencall(as, ci, args);
   emit_dm(as, A64I_MOVx, ra_releasetmp(as, ASMREF_TMP1), RID_GL);
   obj = IR(ir->op1)->r;
-  tmp = ra_scratch(as, rset_exclude(allow, obj));
-  emit_cond_branch(as, CC_EQ, l_end);
-  emit_n(as, A64I_TSTw^emit_isk13(LJ_GC_BLACK, 0), tmp);
+  tmp = ra_scratch(as, rset_exclude(RSET_GPR, obj));
+  emit_tnb(as, A64I_TBZ, tmp, lj_ffs(LJ_GC_BLACK), l_end);
   emit_cond_branch(as, CC_EQ, l_end);
   emit_n(as, A64I_TSTw^emit_isk13(LJ_GC_WHITES, 0), RID_TMP);
   val = ra_alloc1(as, ir->op2, rset_exclude(RSET_GPR, obj));
   emit_lso(as, A64I_LDRB, tmp, obj,
-     (int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv));
+	   (int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv));
   emit_lso(as, A64I_LDRB, RID_TMP, val, (int32_t)offsetof(GChead, marked));
 }
 
@@ -1363,12 +1413,12 @@ static int asm_swapops(ASMState *as, IRRef lref, IRRef rref)
   if (irref_isk(lref))
     return 1;  /* But swap constants to the right. */
   ir = IR(rref);
-  if ((ir->o >= IR_BSHL && ir->o <= IR_BSAR) ||
+  if ((ir->o >= IR_BSHL && ir->o <= IR_BROR) ||
       (ir->o == IR_ADD && ir->op1 == ir->op2) ||
       (ir->o == IR_CONV && ir->op2 == ((IRT_I64<<IRCONV_DSH)|IRT_INT|IRCONV_SEXT)))
     return 0;  /* Don't swap fusable operands to the left. */
   ir = IR(lref);
-  if ((ir->o >= IR_BSHL && ir->o <= IR_BSAR) ||
+  if ((ir->o >= IR_BSHL && ir->o <= IR_BROR) ||
       (ir->o == IR_ADD && ir->op1 == ir->op2) ||
       (ir->o == IR_CONV && ir->op2 == ((IRT_I64<<IRCONV_DSH)|IRT_INT|IRCONV_SEXT)))
     return 1;  /* But swap fusable operands to the right. */
@@ -1414,13 +1464,12 @@ static void asm_intneg(ASMState *as, IRIns *ir)
 static void asm_intmul(ASMState *as, IRIns *ir)
 {
   Reg dest = ra_dest(as, ir, RSET_GPR);
-  Reg left = ra_alloc1(as, ir->op1, rset_exclude(RSET_GPR, dest));
+  Reg left = ra_alloc1(as, ir->op1, RSET_GPR);
   Reg right = ra_alloc1(as, ir->op2, rset_exclude(RSET_GPR, left));
   if (irt_isguard(ir->t)) {  /* IR_MULOV */
     asm_guardcc(as, CC_NE);
     emit_dm(as, A64I_MOVw, dest, dest);  /* Zero-extend. */
-    emit_nm(as, A64I_CMPw | A64F_SH(A64SH_ASR, 31), RID_TMP, dest);
-    emit_dn(as, A64I_ASRx | A64F_IMMR(32), RID_TMP, dest);
+    emit_nm(as, A64I_CMPx | A64F_EX(A64EX_SXTW), dest, dest);
     emit_dnm(as, A64I_SMULL, dest, right, left);
   } else {
     emit_dnm(as, irt_is64(ir->t) ? A64I_MULx : A64I_MULw, dest, left, right);
@@ -1466,7 +1515,8 @@ static void asm_mul(ASMState *as, IRIns *ir)
 static void asm_neg(ASMState *as, IRIns *ir)
 {
   if (irt_isnum(ir->t)) {
-    asm_fpunary(as, ir, A64I_FNEGd);
+    if (!asm_fusenmadd(as, ir, A64I_FNMADDd, A64I_FNMSUBd))
+      asm_fpunary(as, ir, A64I_FNEGd);
     return;
   }
   asm_intneg(as, ir);
@@ -1680,16 +1730,15 @@ static void asm_intcomp(ASMState *as, IRIns *ir)
       if (asm_swapops(as, blref, brref)) {
 	Reg tmp = blref; blref = brref; brref = tmp;
       }
+      bleft = ra_alloc1(as, blref, RSET_GPR);
       if (irref_isk(brref)) {
 	uint64_t k = get_k64val(as, brref);
-	if (k && !(k & (k-1)) && (cc == CC_EQ || cc == CC_NE)) {
-	  asm_guardtnb(as, cc == CC_EQ ? A64I_TBZ : A64I_TBNZ,
-		       ra_alloc1(as, blref, RSET_GPR), emit_ctz64(k));
+	if (k && !(k & (k-1)) && (cc == CC_EQ || cc == CC_NE) &&
+	    asm_guardtnb(as, cc == CC_EQ ? A64I_TBZ : A64I_TBNZ, bleft,
+			 emit_ctz64(k)))
 	  return;
-	}
 	m2 = emit_isk13(k, irt_is64(irl->t));
       }
-      bleft = ra_alloc1(as, blref, RSET_GPR);
       ai = (irt_is64(irl->t) ? A64I_TSTx : A64I_TSTw);
       if (!m2)
 	m2 = asm_fuseopm(as, ai, brref, rset_exclude(RSET_GPR, bleft));
@@ -1764,37 +1813,28 @@ static void asm_prof(ASMState *as, IRIns *ir)
 static void asm_stack_check(ASMState *as, BCReg topslot,
 			    IRIns *irp, RegSet allow, ExitNo exitno)
 {
-  Reg pbase;
   uint32_t k;
+  Reg pbase = RID_BASE;
   if (irp) {
-    if (!ra_hasspill(irp->s)) {
-      pbase = irp->r;
-      lj_assertA(ra_hasreg(pbase), "base reg lost");
-    } else if (allow) {
-      pbase = rset_pickbot(allow);
-    } else {
-      pbase = RID_RET;
-      emit_lso(as, A64I_LDRx, RID_RET, RID_SP, 0);  /* Restore temp register. */
-    }
-  } else {
-    pbase = RID_BASE;
+    pbase = irp->r;
+    if (!ra_hasreg(pbase))
+      pbase = allow ? (0x40 | rset_pickbot(allow)) : (0xC0 | RID_RET);
   }
   emit_cond_branch(as, CC_LS, asm_exitstub_addr(as, exitno));
+  if (pbase & 0x80)  /* Restore temp. register. */
+    emit_lso(as, A64I_LDRx, (pbase & 31), RID_SP, 0);
   k = emit_isk12((8*topslot));
   lj_assertA(k, "slot offset %d does not fit in K12", 8*topslot);
   emit_n(as, A64I_CMPx^k, RID_TMP);
-  emit_dnm(as, A64I_SUBx, RID_TMP, RID_TMP, pbase);
+  emit_dnm(as, A64I_SUBx, RID_TMP, RID_TMP, (pbase & 31));
   emit_lso(as, A64I_LDRx, RID_TMP, RID_TMP,
 	   (int32_t)offsetof(lua_State, maxstack));
-  if (irp) {  /* Must not spill arbitrary registers in head of side trace. */
-    if (ra_hasspill(irp->s))
-      emit_lso(as, A64I_LDRx, pbase, RID_SP, sps_scale(irp->s));
-    emit_lso(as, A64I_LDRx, RID_TMP, RID_GL, glofs(as, &J2G(as->J)->cur_L));
-    if (ra_hasspill(irp->s) && !allow)
-      emit_lso(as, A64I_STRx, RID_RET, RID_SP, 0);  /* Save temp register. */
-  } else {
-    emit_getgl(as, RID_TMP, cur_L);
+  if (pbase & 0x40) {
+    emit_getgl(as, (pbase & 31), jit_base);
+    if (pbase & 0x80)  /* Save temp register. */
+      emit_lso(as, A64I_STRx, (pbase & 31), RID_SP, 0);
   }
+  emit_getgl(as, RID_TMP, cur_L);
 }
 
 /* Restore Lua stack from on-trace state. */
@@ -1836,7 +1876,7 @@ static void asm_stack_restore(ASMState *as, SnapShot *snap)
 
 /* Marker to prevent patching the GC check exit. */
 #define ARM64_NOPATCH_GC_CHECK \
-  (A64I_ORRx|A64F_D(RID_TMP)|A64F_M(RID_TMP)|A64F_N(RID_TMP))
+  (A64I_ORRx|A64F_D(RID_ZERO)|A64F_M(RID_ZERO)|A64F_N(RID_ZERO))
 
 /* Check GC threshold and do one or more GC steps. */
 static void asm_gc_check(ASMState *as)
@@ -1891,47 +1931,40 @@ static void asm_loop_tail_fixup(ASMState *as)
 
 /* -- Head of trace ------------------------------------------------------- */
 
-/* Reload L register from g->cur_L. */
-static void asm_head_lreg(ASMState *as)
-{
-  IRIns *ir = IR(ASMREF_L);
-  if (ra_used(ir)) {
-    Reg r = ra_dest(as, ir, RSET_GPR);
-    emit_getgl(as, r, cur_L);
-    ra_evictk(as);
-  }
-}
-
 /* Coalesce BASE register for a root trace. */
 static void asm_head_root_base(ASMState *as)
 {
-  IRIns *ir;
-  asm_head_lreg(as);
-  ir = IR(REF_BASE);
-  if (ra_hasreg(ir->r) && (rset_test(as->modset, ir->r) || irt_ismarked(ir->t)))
-    ra_spill(as, ir);
-  ra_destreg(as, ir, RID_BASE);
+  IRIns *ir = IR(REF_BASE);
+  Reg r = ir->r;
+  if (ra_hasreg(r)) {
+    ra_free(as, r);
+    if (rset_test(as->modset, r) || irt_ismarked(ir->t))
+      ir->r = RID_INIT;  /* No inheritance for modified BASE register. */
+    if (r != RID_BASE)
+      emit_movrr(as, ir, r, RID_BASE);
+  }
 }
 
 /* Coalesce BASE register for a side trace. */
-static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
-{
-  IRIns *ir;
-  asm_head_lreg(as);
-  ir = IR(REF_BASE);
-  if (ra_hasreg(ir->r) && (rset_test(as->modset, ir->r) || irt_ismarked(ir->t)))
-    ra_spill(as, ir);
-  if (ra_hasspill(irp->s)) {
-    rset_clear(allow, ra_dest(as, ir, allow));
-  } else {
-    Reg r = irp->r;
-    lj_assertA(ra_hasreg(r), "base reg lost");
-    rset_clear(allow, r);
-    if (r != ir->r && !rset_test(as->freeset, r))
-      ra_restore(as, regcost_ref(as->cost[r]));
-    ra_destreg(as, ir, r);
+static Reg asm_head_side_base(ASMState *as, IRIns *irp)
+{
+  IRIns *ir = IR(REF_BASE);
+  Reg r = ir->r;
+  if (ra_hasreg(r)) {
+    ra_free(as, r);
+    if (rset_test(as->modset, r) || irt_ismarked(ir->t))
+      ir->r = RID_INIT;  /* No inheritance for modified BASE register. */
+    if (irp->r == r) {
+      return r;  /* Same BASE register already coalesced. */
+    } else if (ra_hasreg(irp->r) && rset_test(as->freeset, irp->r)) {
+      /* Move from coalesced parent reg. */
+      emit_movrr(as, ir, r, irp->r);
+      return irp->r;
+    } else {
+      emit_getgl(as, r, jit_base);  /* Otherwise reload BASE. */
+    }
   }
-  return allow;
+  return RID_NONE;
 }
 
 /* -- Tail of trace ------------------------------------------------------- */
@@ -1975,20 +2008,47 @@ static void asm_tail_prep(ASMState *as)
 /* Ensure there are enough stack slots for call arguments. */
 static Reg asm_setup_call_slots(ASMState *as, IRIns *ir, const CCallInfo *ci)
 {
-  IRRef args[CCI_NARGS_MAX*2];
+#if LJ_HASFFI
   uint32_t i, nargs = CCI_XNARGS(ci);
-  int nslots = 0, ngpr = REGARG_NUMGPR, nfpr = REGARG_NUMFPR;
-  asm_collectargs(as, ir, ci, args);
-  for (i = 0; i < nargs; i++) {
-    if (args[i] && irt_isfp(IR(args[i])->t)) {
-      if (nfpr > 0) nfpr--; else nslots += 2;
-    } else {
-      if (ngpr > 0) ngpr--; else nslots += 2;
+  if (nargs > (REGARG_NUMGPR < REGARG_NUMFPR ? REGARG_NUMGPR : REGARG_NUMFPR) ||
+      (LJ_TARGET_OSX && (ci->flags & CCI_VARARG))) {
+    IRRef args[CCI_NARGS_MAX*2];
+    int ngpr = REGARG_NUMGPR, nfpr = REGARG_NUMFPR;
+    int spofs = 0, spalign = LJ_TARGET_OSX ? 0 : 7, nslots;
+    asm_collectargs(as, ir, ci, args);
+#if LJ_ABI_WIN
+    if ((ci->flags & CCI_VARARG)) nfpr = 0;
+#endif
+    for (i = 0; i < nargs; i++) {
+      int al = spalign;
+      if (!args[i]) {
+#if LJ_TARGET_OSX
+	/* Marker for start of varaargs. */
+	nfpr = 0;
+	ngpr = 0;
+	spalign = 7;
+#endif
+      } else if (irt_isfp(IR(args[i])->t)) {
+	if (nfpr > 0) { nfpr--; continue; }
+#if LJ_ABI_WIN
+	if ((ci->flags & CCI_VARARG) && ngpr > 0) { ngpr--; continue; }
+#elif LJ_TARGET_OSX
+	al |= irt_isnum(IR(args[i])->t) ? 7 : 3;
+#endif
+      } else {
+	if (ngpr > 0) { ngpr--; continue; }
+#if LJ_TARGET_OSX
+	al |= irt_size(IR(args[i])->t) - 1;
+#endif
+      }
+      spofs = (spofs + 2*al+1) & ~al;  /* Align and bump stack pointer. */
     }
+    nslots = (spofs + 3) >> 2;
+    if (nslots > as->evenspill)  /* Leave room for args in stack slots. */
+      as->evenspill = nslots;
   }
-  if (nslots > as->evenspill)  /* Leave room for args in stack slots. */
-    as->evenspill = nslots;
-  return REGSP_HINT(RID_RET);
+#endif
+  return REGSP_HINT(irt_isfp(ir->t) ? RID_FPRET : RID_RET);
 }
 
 static void asm_setup_target(ASMState *as)
diff --git a/lib/luajit-3065c9/src/lj_asm_mips.h b/lib/luajit2/src/lj_asm_mips.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_asm_mips.h
rename to lib/luajit2/src/lj_asm_mips.h
index 1686b40f6..5b83e34d0 100644
--- a/lib/luajit-3065c9/src/lj_asm_mips.h
+++ b/lib/luajit2/src/lj_asm_mips.h
@@ -1,6 +1,6 @@
 /*
 ** MIPS IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Register allocator extensions --------------------------------------- */
@@ -653,11 +653,11 @@ static void asm_conv(ASMState *as, IRIns *ir)
 		     rset_exclude(RSET_GPR, dest));
 	  emit_fg(as, MIPSI_TRUNC_L_D, tmp, left);  /* Delay slot. */
 #if !LJ_TARGET_MIPSR6
-	 emit_branch(as, MIPSI_BC1T, 0, 0, l_end);
-	 emit_fgh(as, MIPSI_C_OLT_D, 0, left, tmp);
+	emit_branch(as, MIPSI_BC1T, 0, 0, l_end);
+	emit_fgh(as, MIPSI_C_OLT_D, 0, left, tmp);
 #else
-	 emit_branch(as, MIPSI_BC1NEZ, 0, (left&31), l_end);
-	 emit_fgh(as, MIPSI_CMP_LT_D, left, left, tmp);
+	emit_branch(as, MIPSI_BC1NEZ, 0, (tmp&31), l_end);
+	emit_fgh(as, MIPSI_CMP_LT_D, tmp, left, tmp);
 #endif
 	  emit_lsptr(as, MIPSI_LDC1, (tmp & 31),
 		     (void *)&as->J->k64[LJ_K64_2P63],
@@ -670,11 +670,11 @@ static void asm_conv(ASMState *as, IRIns *ir)
 		     rset_exclude(RSET_GPR, dest));
 	  emit_fg(as, MIPSI_TRUNC_L_S, tmp, left);  /* Delay slot. */
 #if !LJ_TARGET_MIPSR6
-	 emit_branch(as, MIPSI_BC1T, 0, 0, l_end);
-	 emit_fgh(as, MIPSI_C_OLT_S, 0, left, tmp);
+	emit_branch(as, MIPSI_BC1T, 0, 0, l_end);
+	emit_fgh(as, MIPSI_C_OLT_S, 0, left, tmp);
 #else
-	 emit_branch(as, MIPSI_BC1NEZ, 0, (left&31), l_end);
-	 emit_fgh(as, MIPSI_CMP_LT_S, left, left, tmp);
+	emit_branch(as, MIPSI_BC1NEZ, 0, (tmp&31), l_end);
+	emit_fgh(as, MIPSI_CMP_LT_S, tmp, left, tmp);
 #endif
 	  emit_lsptr(as, MIPSI_LWC1, (tmp & 31),
 		     (void *)&as->J->k32[LJ_K32_2P63],
@@ -690,8 +690,8 @@ static void asm_conv(ASMState *as, IRIns *ir)
 	MIPSIns mi = irt_is64(ir->t) ?
 	  (st == IRT_NUM ? MIPSI_TRUNC_L_D : MIPSI_TRUNC_L_S) :
 	  (st == IRT_NUM ? MIPSI_TRUNC_W_D : MIPSI_TRUNC_W_S);
-	emit_tg(as, irt_is64(ir->t) ? MIPSI_DMFC1 : MIPSI_MFC1, dest, left);
-	emit_fg(as, mi, left, left);
+	emit_tg(as, irt_is64(ir->t) ? MIPSI_DMFC1 : MIPSI_MFC1, dest, tmp);
+	emit_fg(as, mi, tmp, left);
 #endif
       }
     }
@@ -1207,22 +1207,29 @@ nolo:
 static void asm_uref(ASMState *as, IRIns *ir)
 {
   Reg dest = ra_dest(as, ir, RSET_GPR);
-  if (irref_isk(ir->op1)) {
+  int guarded = (irt_t(ir->t) & (IRT_GUARD|IRT_TYPE)) == (IRT_GUARD|IRT_PGC);
+  if (irref_isk(ir->op1) && !guarded) {
     GCfunc *fn = ir_kfunc(IR(ir->op1));
     MRef *v = &gcref(fn->l.uvptr[(ir->op2 >> 8)])->uv.v;
     emit_lsptr(as, MIPSI_AL, dest, v, RSET_GPR);
   } else {
-    Reg uv = ra_scratch(as, RSET_GPR);
-    Reg func = ra_alloc1(as, ir->op1, RSET_GPR);
-    if (ir->o == IR_UREFC) {
-      asm_guard(as, MIPSI_BEQ, RID_TMP, RID_ZERO);
-      emit_tsi(as, MIPSI_AADDIU, dest, uv, (int32_t)offsetof(GCupval, tv));
-      emit_tsi(as, MIPSI_LBU, RID_TMP, uv, (int32_t)offsetof(GCupval, closed));
+    if (guarded)
+      asm_guard(as, ir->o == IR_UREFC ? MIPSI_BEQ : MIPSI_BNE, RID_TMP, RID_ZERO);
+    if (ir->o == IR_UREFC)
+      emit_tsi(as, MIPSI_AADDIU, dest, dest, (int32_t)offsetof(GCupval, tv));
+    else
+      emit_tsi(as, MIPSI_AL, dest, dest, (int32_t)offsetof(GCupval, v));
+    if (guarded)
+      emit_tsi(as, MIPSI_LBU, RID_TMP, dest, (int32_t)offsetof(GCupval, closed));
+    if (irref_isk(ir->op1)) {
+      GCfunc *fn = ir_kfunc(IR(ir->op1));
+      GCobj *o = gcref(fn->l.uvptr[(ir->op2 >> 8)]);
+      emit_loada(as, dest, o);
     } else {
-      emit_tsi(as, MIPSI_AL, dest, uv, (int32_t)offsetof(GCupval, v));
+      emit_tsi(as, MIPSI_AL, dest, ra_alloc1(as, ir->op1, RSET_GPR),
+	       (int32_t)offsetof(GCfuncL, uvptr) +
+	       (int32_t)sizeof(MRef) * (int32_t)(ir->op2 >> 8));
     }
-    emit_tsi(as, MIPSI_AL, uv, func, (int32_t)offsetof(GCfuncL, uvptr) +
-	     (int32_t)sizeof(MRef) * (int32_t)(ir->op2 >> 8));
   }
 }
 
@@ -1337,8 +1344,8 @@ static void asm_fload(ASMState *as, IRIns *ir)
       }
     }
     ofs = field_ofs[ir->op2];
+    lj_assertA(!irt_isfp(ir->t), "bad FP FLOAD");
   }
-  lj_assertA(!irt_isfp(ir->t), "bad FP FLOAD");
   emit_tsi(as, mi, dest, idx, ofs);
 }
 
@@ -1894,7 +1901,7 @@ static void asm_arithov(ASMState *as, IRIns *ir)
   lj_assertA(!irt_is64(ir->t), "bad usage");
   if (irref_isk(ir->op2)) {
     int k = IR(ir->op2)->i;
-    if (ir->o == IR_SUBOV) k = -k;
+    if (ir->o == IR_SUBOV) k = (int)(~(unsigned int)k+1u);
     if (checki16(k)) {  /* (dest < left) == (k >= 0 ? 1 : 0) */
       left = ra_alloc1(as, ir->op1, RSET_GPR);
       asm_guard(as, k >= 0 ? MIPSI_BNE : MIPSI_BEQ, RID_TMP, RID_ZERO);
@@ -2667,7 +2674,7 @@ static void asm_head_root_base(ASMState *as)
 }
 
 /* Coalesce BASE register for a side trace. */
-static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
+static Reg asm_head_side_base(ASMState *as, IRIns *irp)
 {
   IRIns *ir = IR(REF_BASE);
   Reg r = ir->r;
@@ -2676,15 +2683,15 @@ static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
     if (rset_test(as->modset, r) || irt_ismarked(ir->t))
       ir->r = RID_INIT;  /* No inheritance for modified BASE register. */
     if (irp->r == r) {
-      rset_clear(allow, r);  /* Mark same BASE register as coalesced. */
+      return r;  /* Same BASE register already coalesced. */
     } else if (ra_hasreg(irp->r) && rset_test(as->freeset, irp->r)) {
-      rset_clear(allow, irp->r);
       emit_move(as, r, irp->r);  /* Move from coalesced parent reg. */
+      return irp->r;
     } else {
       emit_getgl(as, r, jit_base);  /* Otherwise reload BASE. */
     }
   }
-  return allow;
+  return RID_NONE;
 }
 
 /* -- Tail of trace ------------------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_asm_ppc.h b/lib/luajit2/src/lj_asm_ppc.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_asm_ppc.h
rename to lib/luajit2/src/lj_asm_ppc.h
index 546b8e5dc..8e9a92a43 100644
--- a/lib/luajit-3065c9/src/lj_asm_ppc.h
+++ b/lib/luajit2/src/lj_asm_ppc.h
@@ -1,6 +1,6 @@
 /*
 ** PPC IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Register allocator extensions --------------------------------------- */
@@ -235,7 +235,8 @@ static int asm_fusemadd(ASMState *as, IRIns *ir, PPCIns pi, PPCIns pir)
 {
   IRRef lref = ir->op1, rref = ir->op2;
   IRIns *irm;
-  if (lref != rref &&
+  if ((as->flags & JIT_F_OPT_FMA) &&
+      lref != rref &&
       ((mayfuse(as, lref) && (irm = IR(lref), irm->o == IR_MUL) &&
 	ra_noreg(irm->r)) ||
        (mayfuse(as, rref) && (irm = IR(rref), irm->o == IR_MUL) &&
@@ -839,23 +840,30 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
 static void asm_uref(ASMState *as, IRIns *ir)
 {
   Reg dest = ra_dest(as, ir, RSET_GPR);
-  if (irref_isk(ir->op1)) {
+  int guarded = (irt_t(ir->t) & (IRT_GUARD|IRT_TYPE)) == (IRT_GUARD|IRT_PGC);
+  if (irref_isk(ir->op1) && !guarded) {
     GCfunc *fn = ir_kfunc(IR(ir->op1));
     MRef *v = &gcref(fn->l.uvptr[(ir->op2 >> 8)])->uv.v;
     emit_lsptr(as, PPCI_LWZ, dest, v, RSET_GPR);
   } else {
-    Reg uv = ra_scratch(as, RSET_GPR);
-    Reg func = ra_alloc1(as, ir->op1, RSET_GPR);
-    if (ir->o == IR_UREFC) {
-      asm_guardcc(as, CC_NE);
+    if (guarded) {
+      asm_guardcc(as, ir->o == IR_UREFC ? CC_NE : CC_EQ);
       emit_ai(as, PPCI_CMPWI, RID_TMP, 1);
-      emit_tai(as, PPCI_ADDI, dest, uv, (int32_t)offsetof(GCupval, tv));
-      emit_tai(as, PPCI_LBZ, RID_TMP, uv, (int32_t)offsetof(GCupval, closed));
+    }
+    if (ir->o == IR_UREFC)
+      emit_tai(as, PPCI_ADDI, dest, dest, (int32_t)offsetof(GCupval, tv));
+    else
+      emit_tai(as, PPCI_LWZ, dest, dest, (int32_t)offsetof(GCupval, v));
+    if (guarded)
+      emit_tai(as, PPCI_LBZ, RID_TMP, dest, (int32_t)offsetof(GCupval, closed));
+    if (irref_isk(ir->op1)) {
+      GCfunc *fn = ir_kfunc(IR(ir->op1));
+      int32_t k = (int32_t)gcrefu(fn->l.uvptr[(ir->op2 >> 8)]);
+      emit_loadi(as, dest, k);
     } else {
-      emit_tai(as, PPCI_LWZ, dest, uv, (int32_t)offsetof(GCupval, v));
+      emit_tai(as, PPCI_LWZ, dest, ra_alloc1(as, ir->op1, RSET_GPR),
+	       (int32_t)offsetof(GCfuncL, uvptr) + 4*(int32_t)(ir->op2 >> 8));
     }
-    emit_tai(as, PPCI_LWZ, uv, func,
-	     (int32_t)offsetof(GCfuncL, uvptr) + 4*(int32_t)(ir->op2 >> 8));
   }
 }
 
@@ -2185,7 +2193,7 @@ static void asm_head_root_base(ASMState *as)
 }
 
 /* Coalesce BASE register for a side trace. */
-static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
+static Reg asm_head_side_base(ASMState *as, IRIns *irp)
 {
   IRIns *ir = IR(REF_BASE);
   Reg r = ir->r;
@@ -2194,15 +2202,15 @@ static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
     if (rset_test(as->modset, r) || irt_ismarked(ir->t))
       ir->r = RID_INIT;  /* No inheritance for modified BASE register. */
     if (irp->r == r) {
-      rset_clear(allow, r);  /* Mark same BASE register as coalesced. */
+      return r;  /* Same BASE register already coalesced. */
     } else if (ra_hasreg(irp->r) && rset_test(as->freeset, irp->r)) {
-      rset_clear(allow, irp->r);
       emit_mr(as, r, irp->r);  /* Move from coalesced parent reg. */
+      return irp->r;
     } else {
       emit_getgl(as, r, jit_base);  /* Otherwise reload BASE. */
     }
   }
-  return allow;
+  return RID_NONE;
 }
 
 /* -- Tail of trace ------------------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_asm_x86.h b/lib/luajit2/src/lj_asm_x86.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_asm_x86.h
rename to lib/luajit2/src/lj_asm_x86.h
index 4465efa2b..9bfdd5da9 100644
--- a/lib/luajit-3065c9/src/lj_asm_x86.h
+++ b/lib/luajit2/src/lj_asm_x86.h
@@ -1,6 +1,6 @@
 /*
 ** x86/x64 IR assembler (SSA IR -> machine code).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Guard handling ------------------------------------------------------ */
@@ -109,7 +109,7 @@ static int asm_isk32(ASMState *as, IRRef ref, int32_t *k)
 /* Check if there's no conflicting instruction between curins and ref.
 ** Also avoid fusing loads if there are multiple references.
 */
-static int noconflict(ASMState *as, IRRef ref, IROp conflict, int noload)
+static int noconflict(ASMState *as, IRRef ref, IROp conflict, int check)
 {
   IRIns *ir = as->ir;
   IRRef i = as->curins;
@@ -118,7 +118,9 @@ static int noconflict(ASMState *as, IRRef ref, IROp conflict, int noload)
   while (--i > ref) {
     if (ir[i].o == conflict)
       return 0;  /* Conflict found. */
-    else if (!noload && (ir[i].op1 == ref || ir[i].op2 == ref))
+    else if ((check & 1) && (ir[i].o == IR_NEWREF || ir[i].o == IR_CALLS))
+      return 0;
+    else if ((check & 2) && (ir[i].op1 == ref || ir[i].op2 == ref))
       return 0;
   }
   return 1;  /* Ok, no conflict. */
@@ -134,13 +136,14 @@ static IRRef asm_fuseabase(ASMState *as, IRRef ref)
     lj_assertA(irb->op2 == IRFL_TAB_ARRAY, "expected FLOAD TAB_ARRAY");
     /* We can avoid the FLOAD of t->array for colocated arrays. */
     if (ira->o == IR_TNEW && ira->op1 <= LJ_MAX_COLOSIZE &&
-	!neverfuse(as) && noconflict(as, irb->op1, IR_NEWREF, 1)) {
+	!neverfuse(as) && noconflict(as, irb->op1, IR_NEWREF, 0)) {
       as->mrm.ofs = (int32_t)sizeof(GCtab);  /* Ofs to colocated array. */
       return irb->op1;  /* Table obj. */
     }
   } else if (irb->o == IR_ADD && irref_isk(irb->op2)) {
     /* Fuse base offset (vararg load). */
-    as->mrm.ofs = IR(irb->op2)->i;
+    IRIns *irk = IR(irb->op2);
+    as->mrm.ofs = irk->o == IR_KINT ? irk->i : (int32_t)ir_kint64(irk)->u64;
     return irb->op1;
   }
   return ref;  /* Otherwise use the given array base. */
@@ -455,7 +458,7 @@ static Reg asm_fuseload(ASMState *as, IRRef ref, RegSet allow)
     RegSet xallow = (allow & RSET_GPR) ? allow : RSET_GPR;
     if (ir->o == IR_SLOAD) {
       if (!(ir->op2 & (IRSLOAD_PARENT|IRSLOAD_CONVERT)) &&
-	  noconflict(as, ref, IR_RETF, 0) &&
+	  noconflict(as, ref, IR_RETF, 2) &&
 	  !(LJ_GC64 && irt_isaddr(ir->t))) {
 	as->mrm.base = (uint8_t)ra_alloc1(as, REF_BASE, xallow);
 	as->mrm.ofs = 8*((int32_t)ir->op1-1-LJ_FR2) +
@@ -466,12 +469,12 @@ static Reg asm_fuseload(ASMState *as, IRRef ref, RegSet allow)
     } else if (ir->o == IR_FLOAD) {
       /* Generic fusion is only ok for 32 bit operand (but see asm_comp). */
       if ((irt_isint(ir->t) || irt_isu32(ir->t) || irt_isaddr(ir->t)) &&
-	  noconflict(as, ref, IR_FSTORE, 0)) {
+	  noconflict(as, ref, IR_FSTORE, 2)) {
 	asm_fusefref(as, ir, xallow);
 	return RID_MRM;
       }
     } else if (ir->o == IR_ALOAD || ir->o == IR_HLOAD || ir->o == IR_ULOAD) {
-      if (noconflict(as, ref, ir->o + IRDELTA_L2S, 0) &&
+      if (noconflict(as, ref, ir->o + IRDELTA_L2S, 2+(ir->o != IR_ULOAD)) &&
 	  !(LJ_GC64 && irt_isaddr(ir->t))) {
 	asm_fuseahuref(as, ir->op1, xallow);
 	return RID_MRM;
@@ -481,11 +484,12 @@ static Reg asm_fuseload(ASMState *as, IRRef ref, RegSet allow)
       ** Fusing unaligned memory operands is ok on x86 (except for SIMD types).
       */
       if ((!irt_typerange(ir->t, IRT_I8, IRT_U16)) &&
-	  noconflict(as, ref, IR_XSTORE, 0)) {
+	  noconflict(as, ref, IR_XSTORE, 2)) {
 	asm_fusexref(as, ir->op1, xallow);
 	return RID_MRM;
       }
-    } else if (ir->o == IR_VLOAD && !(LJ_GC64 && irt_isaddr(ir->t))) {
+    } else if (ir->o == IR_VLOAD && IR(ir->op1)->o == IR_AREF &&
+	       !(LJ_GC64 && irt_isaddr(ir->t))) {
       asm_fuseahuref(as, ir->op1, xallow);
       as->mrm.ofs += 8 * ir->op2;
       return RID_MRM;
@@ -813,6 +817,7 @@ static void asm_tointg(ASMState *as, IRIns *ir, Reg left)
   emit_rr(as, XO_UCOMISD, left, tmp);
   emit_rr(as, XO_CVTSI2SD, tmp, dest);
   emit_rr(as, XO_XORPS, tmp, tmp);  /* Avoid partial register stall. */
+  checkmclim(as);
   emit_rr(as, XO_CVTTSD2SI, dest, left);
   /* Can't fuse since left is needed twice. */
 }
@@ -855,6 +860,7 @@ static void asm_conv(ASMState *as, IRIns *ir)
       emit_rr(as, XO_SUBSD, dest, bias);  /* Subtract 2^52+2^51 bias. */
       emit_rr(as, XO_XORPS, dest, bias);  /* Merge bias and integer. */
       emit_rma(as, XO_MOVSD, bias, k);
+      checkmclim(as);
       emit_mrm(as, XO_MOVD, dest, asm_fuseload(as, lref, RSET_GPR));
       return;
     } else {  /* Integer to FP conversion. */
@@ -1171,6 +1177,7 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
     asm_guardcc(as, CC_E);
   else
     emit_sjcc(as, CC_E, l_end);
+  checkmclim(as);
   if (irt_isnum(kt)) {
     if (isk) {
       /* Assumes -0.0 is already canonicalized to +0.0. */
@@ -1230,7 +1237,6 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
 #endif
   }
   emit_sfixup(as, l_loop);
-  checkmclim(as);
 #if LJ_GC64
   if (!isk && irt_isaddr(kt)) {
     emit_rr(as, XO_OR, tmp|REX_64, key);
@@ -1257,6 +1263,7 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
       emit_rr(as, XO_ARITH(XOg_SUB), dest, tmp);
       emit_shifti(as, XOg_ROL, tmp, HASH_ROT3);
       emit_rr(as, XO_ARITH(XOg_XOR), dest, tmp);
+      checkmclim(as);
       emit_shifti(as, XOg_ROL, dest, HASH_ROT2);
       emit_rr(as, XO_ARITH(XOg_SUB), tmp, dest);
       emit_shifti(as, XOg_ROL, dest, HASH_ROT1);
@@ -1274,7 +1281,6 @@ static void asm_href(ASMState *as, IRIns *ir, IROp merge)
       } else {
 	emit_rr(as, XO_MOV, tmp, key);
 #if LJ_GC64
-	checkmclim(as);
 	emit_gri(as, XG_ARITHi(XOg_XOR), dest, irt_toitype(kt) << 15);
 	if ((as->flags & JIT_F_BMI2)) {
 	  emit_i8(as, 32);
@@ -1298,7 +1304,7 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
   int32_t ofs = (int32_t)(kslot->op2 * sizeof(Node));
   Reg dest = ra_used(ir) ? ra_dest(as, ir, RSET_GPR) : RID_NONE;
   Reg node = ra_alloc1(as, ir->op1, RSET_GPR);
-#if !LJ_64
+#if !LJ_64 || (defined(LUAJIT_USE_VALGRIND) && !LJ_GC64)
   MCLabel l_exit;
 #endif
   lj_assertA(ofs % sizeof(Node) == 0, "unaligned HREFK slot");
@@ -1313,7 +1319,7 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
     }
   }
   asm_guardcc(as, CC_NE);
-#if LJ_64
+#if LJ_64 && (!defined(LUAJIT_USE_VALGRIND) || LJ_GC64)
   if (!irt_ispri(irkey->t)) {
     Reg key = ra_scratch(as, rset_exclude(RSET_GPR, node));
     emit_rmro(as, XO_CMP, key|REX_64, node,
@@ -1371,24 +1377,31 @@ static void asm_hrefk(ASMState *as, IRIns *ir)
 static void asm_uref(ASMState *as, IRIns *ir)
 {
   Reg dest = ra_dest(as, ir, RSET_GPR);
-  if (irref_isk(ir->op1)) {
+  int guarded = (irt_t(ir->t) & (IRT_GUARD|IRT_TYPE)) == (IRT_GUARD|IRT_PGC);
+  if (irref_isk(ir->op1) && !guarded) {
     GCfunc *fn = ir_kfunc(IR(ir->op1));
     MRef *v = &gcref(fn->l.uvptr[(ir->op2 >> 8)])->uv.v;
     emit_rma(as, XO_MOV, dest|REX_GC64, v);
   } else {
     Reg uv = ra_scratch(as, RSET_GPR);
-    Reg func = ra_alloc1(as, ir->op1, RSET_GPR);
-    if (ir->o == IR_UREFC) {
+    if (ir->o == IR_UREFC)
       emit_rmro(as, XO_LEA, dest|REX_GC64, uv, offsetof(GCupval, tv));
-      asm_guardcc(as, CC_NE);
-      emit_i8(as, 1);
+    else
+      emit_rmro(as, XO_MOV, dest|REX_GC64, uv, offsetof(GCupval, v));
+    if (guarded) {
+      asm_guardcc(as, ir->o == IR_UREFC ? CC_E : CC_NE);
+      emit_i8(as, 0);
       emit_rmro(as, XO_ARITHib, XOg_CMP, uv, offsetof(GCupval, closed));
+    }
+    if (irref_isk(ir->op1)) {
+      GCfunc *fn = ir_kfunc(IR(ir->op1));
+      GCobj *o = gcref(fn->l.uvptr[(ir->op2 >> 8)]);
+      emit_loada(as, uv, o);
     } else {
-      emit_rmro(as, XO_MOV, dest|REX_GC64, uv, offsetof(GCupval, v));
+      emit_rmro(as, XO_MOV, uv|REX_GC64, ra_alloc1(as, ir->op1, RSET_GPR),
+	        (int32_t)offsetof(GCfuncL, uvptr) +
+	        (int32_t)sizeof(MRef) * (int32_t)(ir->op2 >> 8));
     }
-    emit_rmro(as, XO_MOV, uv|REX_GC64, func,
-	      (int32_t)offsetof(GCfuncL, uvptr) +
-	      (int32_t)sizeof(MRef) * (int32_t)(ir->op2 >> 8));
   }
 }
 
@@ -1545,6 +1558,7 @@ static void asm_ahuvload(ASMState *as, IRIns *ir)
   if (irt_islightud(ir->t)) {
     Reg dest = asm_load_lightud64(as, ir, 1);
     if (ra_hasreg(dest)) {
+      checkmclim(as);
       asm_fuseahuref(as, ir->op1, RSET_GPR);
       if (ir->o == IR_VLOAD) as->mrm.ofs += 8 * ir->op2;
       emit_mrm(as, XO_MOV, dest|REX_64, RID_MRM);
@@ -1592,6 +1606,7 @@ static void asm_ahuvload(ASMState *as, IRIns *ir)
   if (LJ_64 && irt_type(ir->t) >= IRT_NUM) {
     lj_assertA(irt_isinteger(ir->t) || irt_isnum(ir->t),
 	       "bad load type %d", irt_type(ir->t));
+    checkmclim(as);
 #if LJ_GC64
     emit_u32(as, LJ_TISNUM << 15);
 #else
@@ -2876,7 +2891,7 @@ static void asm_head_root_base(ASMState *as)
 }
 
 /* Coalesce or reload BASE register for a side trace. */
-static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
+static Reg asm_head_side_base(ASMState *as, IRIns *irp)
 {
   IRIns *ir = IR(REF_BASE);
   Reg r = ir->r;
@@ -2885,16 +2900,16 @@ static RegSet asm_head_side_base(ASMState *as, IRIns *irp, RegSet allow)
     if (rset_test(as->modset, r) || irt_ismarked(ir->t))
       ir->r = RID_INIT;  /* No inheritance for modified BASE register. */
     if (irp->r == r) {
-      rset_clear(allow, r);  /* Mark same BASE register as coalesced. */
+      return r;  /* Same BASE register already coalesced. */
     } else if (ra_hasreg(irp->r) && rset_test(as->freeset, irp->r)) {
       /* Move from coalesced parent reg. */
-      rset_clear(allow, irp->r);
       emit_rr(as, XO_MOV, r|REX_GC64, irp->r);
+      return irp->r;
     } else {
       emit_getgl(as, r, jit_base);  /* Otherwise reload BASE. */
     }
   }
-  return allow;
+  return RID_NONE;
 }
 
 /* -- Tail of trace ------------------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_assert.c b/lib/luajit2/src/lj_assert.c
similarity index 89%
rename from lib/luajit-3065c9/src/lj_assert.c
rename to lib/luajit2/src/lj_assert.c
index 4b713b2b0..5c948b41e 100644
--- a/lib/luajit-3065c9/src/lj_assert.c
+++ b/lib/luajit2/src/lj_assert.c
@@ -1,6 +1,6 @@
 /*
 ** Internal assertions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_assert_c
diff --git a/lib/luajit-3065c9/src/lj_bc.c b/lib/luajit2/src/lj_bc.c
similarity index 75%
rename from lib/luajit-3065c9/src/lj_bc.c
rename to lib/luajit2/src/lj_bc.c
index b692cb54a..23ac76bc9 100644
--- a/lib/luajit-3065c9/src/lj_bc.c
+++ b/lib/luajit2/src/lj_bc.c
@@ -1,6 +1,6 @@
 /*
 ** Bytecode instruction modes.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_bc_c
diff --git a/lib/luajit-3065c9/src/lj_bc.h b/lib/luajit2/src/lj_bc.h
similarity index 99%
rename from lib/luajit-3065c9/src/lj_bc.h
rename to lib/luajit2/src/lj_bc.h
index 02356e5b3..97e19a1b4 100644
--- a/lib/luajit-3065c9/src/lj_bc.h
+++ b/lib/luajit2/src/lj_bc.h
@@ -1,6 +1,6 @@
 /*
 ** Bytecode instruction format.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_BC_H
diff --git a/lib/luajit-3065c9/src/lj_bcdump.h b/lib/luajit2/src/lj_bcdump.h
similarity index 92%
rename from lib/luajit-3065c9/src/lj_bcdump.h
rename to lib/luajit2/src/lj_bcdump.h
index 69da16e98..3e56e39c6 100644
--- a/lib/luajit-3065c9/src/lj_bcdump.h
+++ b/lib/luajit2/src/lj_bcdump.h
@@ -1,6 +1,6 @@
 /*
 ** Bytecode dump definitions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_BCDUMP_H
@@ -46,6 +46,8 @@
 
 #define BCDUMP_F_KNOWN		(BCDUMP_F_FR2*2-1)
 
+#define BCDUMP_F_DETERMINISTIC	0x80000000
+
 /* Type codes for the GC constants of a prototype. Plus length for strings. */
 enum {
   BCDUMP_KGC_CHILD, BCDUMP_KGC_TAB, BCDUMP_KGC_I64, BCDUMP_KGC_U64,
@@ -61,7 +63,7 @@ enum {
 /* -- Bytecode reader/writer ---------------------------------------------- */
 
 LJ_FUNC int lj_bcwrite(lua_State *L, GCproto *pt, lua_Writer writer,
-		       void *data, int strip);
+		       void *data, uint32_t flags);
 LJ_FUNC GCproto *lj_bcread_proto(LexState *ls);
 LJ_FUNC GCproto *lj_bcread(LexState *ls);
 
diff --git a/lib/luajit-3065c9/src/lj_bcread.c b/lib/luajit2/src/lj_bcread.c
similarity index 97%
rename from lib/luajit-3065c9/src/lj_bcread.c
rename to lib/luajit2/src/lj_bcread.c
index 2ce057074..637ef0679 100644
--- a/lib/luajit-3065c9/src/lj_bcread.c
+++ b/lib/luajit2/src/lj_bcread.c
@@ -1,6 +1,6 @@
 /*
 ** Bytecode reader.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_bcread_c
@@ -281,8 +281,11 @@ static void bcread_knum(LexState *ls, GCproto *pt, MSize sizekn)
 static void bcread_bytecode(LexState *ls, GCproto *pt, MSize sizebc)
 {
   BCIns *bc = proto_bc(pt);
-  bc[0] = BCINS_AD((pt->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,
-		   pt->framesize, 0);
+  BCIns op;
+  if (ls->fr2 != LJ_FR2) op = BC_NOT;  /* Mark non-native prototype. */
+  else if ((pt->flags & PROTO_VARARG)) op = BC_FUNCV;
+  else op = BC_FUNCF;
+  bc[0] = BCINS_AD(op, pt->framesize, 0);
   bcread_block(ls, bc+1, (sizebc-1)*(MSize)sizeof(BCIns));
   /* Swap bytecode instructions if the endianess differs. */
   if (bcread_swap(ls)) {
@@ -395,7 +398,7 @@ static int bcread_header(LexState *ls)
       bcread_byte(ls) != BCDUMP_VERSION) return 0;
   bcread_flags(ls) = flags = bcread_uleb128(ls);
   if ((flags & ~(BCDUMP_F_KNOWN)) != 0) return 0;
-  if ((flags & BCDUMP_F_FR2) != LJ_FR2*BCDUMP_F_FR2) return 0;
+  if ((flags & BCDUMP_F_FR2) != (uint32_t)ls->fr2*BCDUMP_F_FR2) return 0;
   if ((flags & BCDUMP_F_FFI)) {
 #if LJ_HASFFI
     lua_State *L = ls->L;
diff --git a/lib/luajit-3065c9/src/lj_bcwrite.c b/lib/luajit2/src/lj_bcwrite.c
similarity index 76%
rename from lib/luajit-3065c9/src/lj_bcwrite.c
rename to lib/luajit2/src/lj_bcwrite.c
index 2c70ff470..ddfa46c56 100644
--- a/lib/luajit-3065c9/src/lj_bcwrite.c
+++ b/lib/luajit2/src/lj_bcwrite.c
@@ -1,6 +1,6 @@
 /*
 ** Bytecode writer.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_bcwrite_c
@@ -27,7 +27,9 @@ typedef struct BCWriteCtx {
   GCproto *pt;			/* Root prototype. */
   lua_Writer wfunc;		/* Writer callback. */
   void *wdata;			/* Writer callback data. */
-  int strip;			/* Strip debug info. */
+  TValue **heap;		/* Heap used for deterministic sorting. */
+  uint32_t heapsz;		/* Size of heap. */
+  uint32_t flags;		/* BCDUMP_F_* flags. */
   int status;			/* Status from writer callback. */
 #ifdef LUA_USE_ASSERT
   global_State *g;
@@ -76,6 +78,75 @@ static void bcwrite_ktabk(BCWriteCtx *ctx, cTValue *o, int narrow)
   ctx->sb.w = p;
 }
 
+/* Compare two template table keys. */
+static LJ_AINLINE int bcwrite_ktabk_lt(TValue *a, TValue *b)
+{
+  uint32_t at = itype(a), bt = itype(b);
+  if (at != bt) {  /* This also handles false and true keys. */
+    return at < bt;
+  } else if (at == LJ_TSTR) {
+    return lj_str_cmp(strV(a), strV(b)) < 0;
+  } else {
+    return a->u64 < b->u64;  /* This works for numbers and integers. */
+  }
+}
+
+/* Insert key into a sorted heap. */
+static void bcwrite_ktabk_heap_insert(TValue **heap, MSize idx, MSize end,
+				      TValue *key)
+{
+  MSize child;
+  while ((child = idx * 2 + 1) < end) {
+    /* Find lower of the two children. */
+    TValue *c0 = heap[child];
+    if (child + 1 < end) {
+      TValue *c1 = heap[child + 1];
+      if (bcwrite_ktabk_lt(c1, c0)) {
+	c0 = c1;
+	child++;
+      }
+    }
+    if (bcwrite_ktabk_lt(key, c0)) break;  /* Key lower? Found our position. */
+    heap[idx] = c0;  /* Move lower child up. */
+    idx = child;  /* Descend. */
+  }
+  heap[idx] = key;  /* Insert key here. */
+}
+
+/* Resize heap, dropping content. */
+static void bcwrite_heap_resize(BCWriteCtx *ctx, uint32_t nsz)
+{
+  lua_State *L = sbufL(&ctx->sb);
+  if (ctx->heapsz) {
+    lj_mem_freevec(G(L), ctx->heap, ctx->heapsz, TValue *);
+    ctx->heapsz = 0;
+  }
+  if (nsz) {
+    ctx->heap = lj_mem_newvec(L, nsz, TValue *);
+    ctx->heapsz = nsz;
+  }
+}
+
+/* Write hash part of template table in sorted order. */
+static void bcwrite_ktab_sorted_hash(BCWriteCtx *ctx, Node *node, MSize nhash)
+{
+  TValue **heap = ctx->heap;
+  MSize i = nhash;
+  for (;; node--) {  /* Build heap. */
+    if (!tvisnil(&node->key)) {
+      bcwrite_ktabk_heap_insert(heap, --i, nhash, &node->key);
+      if (i == 0) break;
+    }
+  }
+  do {  /* Drain heap. */
+    TValue *key = heap[0];  /* Output lowest key from top. */
+    bcwrite_ktabk(ctx, key, 0);
+    bcwrite_ktabk(ctx, (TValue *)((char *)key - offsetof(Node, key)), 1);
+    key = heap[--nhash];  /* Remove last key. */
+    bcwrite_ktabk_heap_insert(heap, 0, nhash, key);  /* Re-insert. */
+  } while (nhash);
+}
+
 /* Write a template table. */
 static void bcwrite_ktab(BCWriteCtx *ctx, char *p, const GCtab *t)
 {
@@ -92,7 +163,7 @@ static void bcwrite_ktab(BCWriteCtx *ctx, char *p, const GCtab *t)
     MSize i, hmask = t->hmask;
     Node *node = noderef(t->node);
     for (i = 0; i <= hmask; i++)
-      nhash += !tvisnil(&node[i].val);
+      nhash += !tvisnil(&node[i].key);
   }
   /* Write number of array slots and hash slots. */
   p = lj_strfmt_wuleb128(p, narray);
@@ -105,14 +176,20 @@ static void bcwrite_ktab(BCWriteCtx *ctx, char *p, const GCtab *t)
       bcwrite_ktabk(ctx, o, 1);
   }
   if (nhash) {  /* Write hash entries. */
-    MSize i = nhash;
     Node *node = noderef(t->node) + t->hmask;
-    for (;; node--)
-      if (!tvisnil(&node->val)) {
-	bcwrite_ktabk(ctx, &node->key, 0);
-	bcwrite_ktabk(ctx, &node->val, 1);
-	if (--i == 0) break;
-      }
+    if ((ctx->flags & BCDUMP_F_DETERMINISTIC) && nhash > 1) {
+      if (ctx->heapsz < nhash)
+	bcwrite_heap_resize(ctx, t->hmask + 1);
+      bcwrite_ktab_sorted_hash(ctx, node, nhash);
+    } else {
+      MSize i = nhash;
+      for (;; node--)
+	if (!tvisnil(&node->key)) {
+	  bcwrite_ktabk(ctx, &node->key, 0);
+	  bcwrite_ktabk(ctx, &node->val, 1);
+	  if (--i == 0) break;
+	}
+    }
   }
 }
 
@@ -189,7 +266,8 @@ static void bcwrite_knum(BCWriteCtx *ctx, GCproto *pt)
       goto save_int;
     } else {
       /* Write a 33 bit ULEB128 for the int (lsb=0) or loword (lsb=1). */
-      if (!LJ_DUALNUM) {  /* Narrow number constants to integers. */
+      if (!LJ_DUALNUM && o->u32.hi != LJ_KEYINDEX) {
+	/* Narrow number constants to integers. */
 	lua_Number num = numV(o);
 	k = lj_num2int(num);
 	if (num == (lua_Number)k) {  /* -0 is never a constant. */
@@ -268,7 +346,7 @@ static void bcwrite_proto(BCWriteCtx *ctx, GCproto *pt)
   p = lj_strfmt_wuleb128(p, pt->sizekgc);
   p = lj_strfmt_wuleb128(p, pt->sizekn);
   p = lj_strfmt_wuleb128(p, pt->sizebc-1);
-  if (!ctx->strip) {
+  if (!(ctx->flags & BCDUMP_F_STRIP)) {
     if (proto_lineinfo(pt))
       sizedbg = pt->sizept - (MSize)((char *)proto_lineinfo(pt) - (char *)pt);
     p = lj_strfmt_wuleb128(p, sizedbg);
@@ -316,11 +394,10 @@ static void bcwrite_header(BCWriteCtx *ctx)
   *p++ = BCDUMP_HEAD2;
   *p++ = BCDUMP_HEAD3;
   *p++ = BCDUMP_VERSION;
-  *p++ = (ctx->strip ? BCDUMP_F_STRIP : 0) +
+  *p++ = (ctx->flags & (BCDUMP_F_STRIP | BCDUMP_F_FR2)) +
 	 LJ_BE*BCDUMP_F_BE +
-	 ((ctx->pt->flags & PROTO_FFI) ? BCDUMP_F_FFI : 0) +
-	 LJ_FR2*BCDUMP_F_FR2;
-  if (!ctx->strip) {
+	 ((ctx->pt->flags & PROTO_FFI) ? BCDUMP_F_FFI : 0);
+  if (!(ctx->flags & BCDUMP_F_STRIP)) {
     p = lj_strfmt_wuleb128(p, len);
     p = lj_buf_wmem(p, name, len);
   }
@@ -351,14 +428,16 @@ static TValue *cpwriter(lua_State *L, lua_CFunction dummy, void *ud)
 
 /* Write bytecode for a prototype. */
 int lj_bcwrite(lua_State *L, GCproto *pt, lua_Writer writer, void *data,
-	      int strip)
+	      uint32_t flags)
 {
   BCWriteCtx ctx;
   int status;
   ctx.pt = pt;
   ctx.wfunc = writer;
   ctx.wdata = data;
-  ctx.strip = strip;
+  ctx.heapsz = 0;
+  if ((bc_op(proto_bc(pt)[0]) != BC_NOT) == LJ_FR2) flags |= BCDUMP_F_FR2;
+  ctx.flags = flags;
   ctx.status = 0;
 #ifdef LUA_USE_ASSERT
   ctx.g = G(L);
@@ -367,6 +446,7 @@ int lj_bcwrite(lua_State *L, GCproto *pt, lua_Writer writer, void *data,
   status = lj_vm_cpcall(L, NULL, &ctx, cpwriter);
   if (status == 0) status = ctx.status;
   lj_buf_free(G(sbufL(&ctx.sb)), &ctx.sb);
+  bcwrite_heap_resize(&ctx, 0);
   return status;
 }
 
diff --git a/lib/luajit-3065c9/src/lj_buf.c b/lib/luajit2/src/lj_buf.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_buf.c
rename to lib/luajit2/src/lj_buf.c
index cf268af22..ae2ccd82d 100644
--- a/lib/luajit-3065c9/src/lj_buf.c
+++ b/lib/luajit2/src/lj_buf.c
@@ -1,6 +1,6 @@
 /*
 ** Buffer handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_buf_c
diff --git a/lib/luajit-3065c9/src/lj_buf.h b/lib/luajit2/src/lj_buf.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_buf.h
rename to lib/luajit2/src/lj_buf.h
index 761142016..744e57477 100644
--- a/lib/luajit-3065c9/src/lj_buf.h
+++ b/lib/luajit2/src/lj_buf.h
@@ -1,6 +1,6 @@
 /*
 ** Buffer handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_BUF_H
diff --git a/lib/luajit-3065c9/src/lj_carith.c b/lib/luajit2/src/lj_carith.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_carith.c
rename to lib/luajit2/src/lj_carith.c
index 1a2a058f3..9bea0a333 100644
--- a/lib/luajit-3065c9/src/lj_carith.c
+++ b/lib/luajit2/src/lj_carith.c
@@ -1,6 +1,6 @@
 /*
 ** C data arithmetic.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
@@ -44,9 +44,13 @@ static int carith_checkarg(lua_State *L, CTState *cts, CDArith *ca)
 	p = (uint8_t *)cdata_getptr(p, ct->size);
 	if (ctype_isref(ct->info)) ct = ctype_rawchild(cts, ct);
       } else if (ctype_isfunc(ct->info)) {
+	CTypeID id0 = i ? ctype_typeid(cts, ca->ct[0]) : 0;
 	p = (uint8_t *)*(void **)p;
 	ct = ctype_get(cts,
 	  lj_ctype_intern(cts, CTINFO(CT_PTR, CTALIGN_PTR|id), CTSIZE_PTR));
+	if (i) {  /* cts->tab may have been reallocated. */
+	  ca->ct[0] = ctype_get(cts, id0);
+	}
       }
       if (ctype_isenum(ct->info)) ct = ctype_child(cts, ct);
       ca->ct[i] = ct;
@@ -207,7 +211,7 @@ static int carith_int64(lua_State *L, CTState *cts, CDArith *ca, MMS mm)
       else
 	*up = lj_carith_powu64(u0, u1);
       break;
-    case MM_unm: *up = (uint64_t)-(int64_t)u0; break;
+    case MM_unm: *up = ~u0+1u; break;
     default:
       lj_assertL(0, "bad metamethod %d", mm);
       break;
diff --git a/lib/luajit-3065c9/src/lj_carith.h b/lib/luajit2/src/lj_carith.h
similarity index 94%
rename from lib/luajit-3065c9/src/lj_carith.h
rename to lib/luajit2/src/lj_carith.h
index 9d6b1dc9b..f124c27c3 100644
--- a/lib/luajit-3065c9/src/lj_carith.h
+++ b/lib/luajit2/src/lj_carith.h
@@ -1,6 +1,6 @@
 /*
 ** C data arithmetic.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CARITH_H
diff --git a/lib/luajit-3065c9/src/lj_ccall.c b/lib/luajit2/src/lj_ccall.c
similarity index 80%
rename from lib/luajit-3065c9/src/lj_ccall.c
rename to lib/luajit2/src/lj_ccall.c
index 25f54deed..c613db2cc 100644
--- a/lib/luajit-3065c9/src/lj_ccall.c
+++ b/lib/luajit2/src/lj_ccall.c
@@ -1,6 +1,6 @@
 /*
 ** FFI C call handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
@@ -20,12 +20,15 @@
 #if LJ_TARGET_X86
 /* -- x86 calling conventions --------------------------------------------- */
 
+#define CCALL_PUSH(arg) \
+  *(GPRArg *)((uint8_t *)cc->stack + nsp) = (GPRArg)(arg), nsp += CTSIZE_PTR
+
 #if LJ_ABI_WIN
 
 #define CCALL_HANDLE_STRUCTRET \
   /* Return structs bigger than 8 by reference (on stack only). */ \
   cc->retref = (sz > 8); \
-  if (cc->retref) cc->stack[nsp++] = (GPRArg)dp;
+  if (cc->retref) CCALL_PUSH(dp);
 
 #define CCALL_HANDLE_COMPLEXRET CCALL_HANDLE_STRUCTRET
 
@@ -40,7 +43,7 @@
     if (ngpr < maxgpr) \
       cc->gpr[ngpr++] = (GPRArg)dp; \
     else \
-      cc->stack[nsp++] = (GPRArg)dp; \
+      CCALL_PUSH(dp); \
   } else {  /* Struct with single FP field ends up in FPR. */ \
     cc->resx87 = ccall_classify_struct(cts, ctr); \
   }
@@ -56,7 +59,7 @@
   if (ngpr < maxgpr) \
     cc->gpr[ngpr++] = (GPRArg)dp; \
   else \
-    cc->stack[nsp++] = (GPRArg)dp;
+    CCALL_PUSH(dp);
 
 #endif
 
@@ -67,7 +70,7 @@
     if (ngpr < maxgpr) \
       cc->gpr[ngpr++] = (GPRArg)dp; \
     else \
-      cc->stack[nsp++] = (GPRArg)dp; \
+      CCALL_PUSH(dp); \
   }
 
 #endif
@@ -278,8 +281,8 @@
   if (ngpr < maxgpr) { \
     dp = &cc->gpr[ngpr]; \
     if (ngpr + n > maxgpr) { \
-      nsp += ngpr + n - maxgpr;  /* Assumes contiguous gpr/stack fields. */ \
-      if (nsp > CCALL_MAXSTACK) goto err_nyi;  /* Too many arguments. */ \
+      nsp += (ngpr + n - maxgpr) * CTSIZE_PTR;  /* Assumes contiguous gpr/stack fields. */ \
+      if (nsp > CCALL_SIZE_STACK) goto err_nyi;  /* Too many arguments. */ \
       ngpr = maxgpr; \
     } else { \
       ngpr += n; \
@@ -345,7 +348,6 @@
       goto done; \
     } else { \
       nfpr = CCALL_NARG_FPR;  /* Prevent reordering. */ \
-      if (LJ_TARGET_OSX && d->size < 8) goto err_nyi; \
     } \
   } else {  /* Try to pass argument in GPRs. */ \
     if (!LJ_TARGET_OSX && (d->info & CTF_ALIGN) > CTALIGN_PTR) \
@@ -356,7 +358,6 @@
       goto done; \
     } else { \
       ngpr = maxgpr;  /* Prevent reordering. */ \
-      if (LJ_TARGET_OSX && d->size < 8) goto err_nyi; \
     } \
   }
 
@@ -370,21 +371,97 @@
 #elif LJ_TARGET_PPC
 /* -- PPC calling conventions --------------------------------------------- */
 
+#if LJ_ARCH_BITS == 64
+
+#if LJ_ARCH_PPC_ELFV2
+
+#define CCALL_HANDLE_STRUCTRET \
+  if (sz > 16 && ccall_classify_fp(cts, ctr) <= 0) { \
+    cc->retref = 1;  /* Return by reference. */ \
+    cc->gpr[ngpr++] = (GPRArg)dp; \
+  }
+
+#define CCALL_HANDLE_STRUCTRET2 \
+  int isfp = ccall_classify_fp(cts, ctr); \
+  int i; \
+  if (isfp == FTYPE_FLOAT) { \
+    for (i = 0; i < ctr->size / 4; i++) \
+      ((float *)dp)[i] = cc->fpr[i]; \
+  } else if (isfp == FTYPE_DOUBLE) { \
+    for (i = 0; i < ctr->size / 8; i++) \
+      ((double *)dp)[i] = cc->fpr[i]; \
+  } else { \
+    if (ctr->size < 8 && LJ_BE) { \
+      sp += 8 - ctr->size; \
+    } \
+    memcpy(dp, sp, ctr->size); \
+  }
+
+#else
+
 #define CCALL_HANDLE_STRUCTRET \
   cc->retref = 1;  /* Return all structs by reference. */ \
   cc->gpr[ngpr++] = (GPRArg)dp;
 
+#endif
+
 #define CCALL_HANDLE_COMPLEXRET \
   /* Complex values are returned in 2 or 4 GPRs. */ \
   cc->retref = 0;
 
+#define CCALL_HANDLE_STRUCTARG
+
 #define CCALL_HANDLE_COMPLEXRET2 \
-  memcpy(dp, sp, ctr->size);  /* Copy complex from GPRs. */
+  if (ctr->size == 2*sizeof(float)) {  /* Copy complex float from FPRs. */ \
+    ((float *)dp)[0] = cc->fpr[0]; \
+    ((float *)dp)[1] = cc->fpr[1]; \
+  } else {  /* Copy complex double from FPRs. */ \
+    ((double *)dp)[0] = cc->fpr[0]; \
+    ((double *)dp)[1] = cc->fpr[1]; \
+  }
+
+#define CCALL_HANDLE_COMPLEXARG \
+  isfp = 1; \
+  if (d->size == sizeof(float) * 2) { \
+    d = ctype_get(cts, CTID_COMPLEX_DOUBLE); \
+    isf32 = 1; \
+  }
+
+#define CCALL_HANDLE_REGARG \
+  if (isfp && d->size == sizeof(float)) { \
+    d = ctype_get(cts, CTID_DOUBLE); \
+    isf32 = 1; \
+  } \
+  if (ngpr < maxgpr) { \
+   dp = &cc->gpr[ngpr]; \
+   ngpr += n; \
+   if (ngpr > maxgpr) { \
+     nsp += ngpr - 8; \
+     ngpr = 8; \
+     if (nsp > CCALL_MAXSTACK) { \
+       goto err_nyi; \
+     } \
+   } \
+   goto done; \
+  }
+
+#else
+
+#define CCALL_HANDLE_STRUCTRET \
+  cc->retref = 1;  /* Return all structs by reference. */ \
+  cc->gpr[ngpr++] = (GPRArg)dp;
+
+#define CCALL_HANDLE_COMPLEXRET \
+  /* Complex values are returned in 2 or 4 GPRs. */ \
+  cc->retref = 0;
 
 #define CCALL_HANDLE_STRUCTARG \
   rp = cdataptr(lj_cdata_new(cts, did, sz)); \
   sz = CTSIZE_PTR;  /* Pass all structs by reference. */
 
+#define CCALL_HANDLE_COMPLEXRET2 \
+  memcpy(dp, sp, ctr->size);  /* Copy complex from GPRs. */
+
 #define CCALL_HANDLE_COMPLEXARG \
   /* Pass complex by value in 2 or 4 GPRs. */
 
@@ -420,6 +497,8 @@
   }
 #endif
 
+#endif
+
 #if !LJ_ABI_SOFTFP
 #define CCALL_HANDLE_RET \
   if (ctype_isfp(ctr->info) && ctr->size == sizeof(float)) \
@@ -471,8 +550,8 @@
   if (ngpr < maxgpr) { \
     dp = &cc->gpr[ngpr]; \
     if (ngpr + n > maxgpr) { \
-     nsp += ngpr + n - maxgpr;  /* Assumes contiguous gpr/stack fields. */ \
-     if (nsp > CCALL_MAXSTACK) goto err_nyi;  /* Too many arguments. */ \
+     nsp += (ngpr + n - maxgpr) * CTSIZE_PTR;  /* Assumes contiguous gpr/stack fields. */ \
+     if (nsp > CCALL_SIZE_STACK) goto err_nyi;  /* Too many arguments. */ \
      ngpr = maxgpr; \
     } else { \
      ngpr += n; \
@@ -565,8 +644,8 @@
   if (ngpr < maxgpr) { \
     dp = &cc->gpr[ngpr]; \
     if (ngpr + n > maxgpr) { \
-      nsp += ngpr + n - maxgpr;  /* Assumes contiguous gpr/stack fields. */ \
-      if (nsp > CCALL_MAXSTACK) goto err_nyi;  /* Too many arguments. */ \
+      nsp += (ngpr + n - maxgpr) * CTSIZE_PTR;  /* Assumes contiguous gpr/stack fields. */ \
+      if (nsp > CCALL_SIZE_STACK) goto err_nyi;  /* Too many arguments. */ \
       ngpr = maxgpr; \
     } else { \
       ngpr += n; \
@@ -574,6 +653,40 @@
     goto done; \
   }
 
+#elif LJ_TARGET_S390X
+/* -- POSIX/s390x calling conventions --------------------------------------- */
+
+#define CCALL_HANDLE_STRUCTRET \
+  cc->retref = 1;  /* Return all structs by reference. */ \
+  cc->gpr[ngpr++] = (GPRArg)dp;
+
+#define CCALL_HANDLE_COMPLEXRET \
+  cc->retref = 1;  /* Return all complex values by reference. */ \
+  cc->gpr[ngpr++] = (GPRArg)dp;
+
+#define CCALL_HANDLE_COMPLEXRET2 \
+  UNUSED(dp); /* Nothing to do. */
+
+#define CCALL_HANDLE_STRUCTARG \
+  /* Pass structs of size 1, 2, 4 or 8 in a GPR by value. */ \
+  if (!(sz == 1 || sz == 2 || sz == 4 || sz == 8)) { \
+    rp = cdataptr(lj_cdata_new(cts, did, sz)); \
+    sz = CTSIZE_PTR;  /* Pass all other structs by reference. */ \
+  }
+
+#define CCALL_HANDLE_COMPLEXARG \
+  /* Pass complex numbers by reference. */ \
+  /* TODO: not sure why this is different to structs. */ \
+  rp = cdataptr(lj_cdata_new(cts, did, sz)); \
+  sz = CTSIZE_PTR; \
+
+#define CCALL_HANDLE_REGARG \
+  if (isfp) { \
+    if (nfpr < CCALL_NARG_FPR) { dp = &cc->fpr[nfpr++]; goto done; } \
+  } else { \
+    if (ngpr < maxgpr) { dp = &cc->gpr[ngpr++]; goto done; } \
+  }
+
 #else
 #error "Missing calling convention definitions for this architecture"
 #endif
@@ -698,10 +811,11 @@ static int ccall_struct_arg(CCallState *cc, CTState *cts, CType *d, int *rcl,
   lj_cconv_ct_tv(cts, d, (uint8_t *)dp, o, CCF_ARG(narg));
   if (ccall_struct_reg(cc, cts, dp, rcl)) {
     /* Register overflow? Pass on stack. */
-    MSize nsp = cc->nsp, n = rcl[1] ? 2 : 1;
-    if (nsp + n > CCALL_MAXSTACK) return 1;  /* Too many arguments. */
-    cc->nsp = nsp + n;
-    memcpy(&cc->stack[nsp], dp, n*CTSIZE_PTR);
+    MSize nsp = cc->nsp, sz = rcl[1] ? 2*CTSIZE_PTR : CTSIZE_PTR;
+    if (nsp + sz > CCALL_SIZE_STACK)
+      return 1;  /* Too many arguments. */
+    cc->nsp = nsp + sz;
+    memcpy((uint8_t *)cc->stack + nsp, dp, sz);
   }
   return 0;  /* Ok. */
 }
@@ -816,6 +930,50 @@ noth:  /* Not a homogeneous float/double aggregate. */
 
 #endif
 
+/* -- PowerPC64 ELFv2 ABI struct classification ------------------- */
+
+#if LJ_ARCH_PPC_ELFV2
+
+#define FTYPE_FLOAT	1
+#define FTYPE_DOUBLE	2
+
+static unsigned int ccall_classify_fp(CTState *cts, CType *ct) {
+  if (ctype_isfp(ct->info)) {
+    if (ct->size == sizeof(float))
+      return FTYPE_FLOAT;
+    else
+      return FTYPE_DOUBLE;
+  } else if (ctype_iscomplex(ct->info)) {
+    if (ct->size == sizeof(float) * 2)
+      return FTYPE_FLOAT;
+    else
+      return FTYPE_DOUBLE;
+  } else if (ctype_isstruct(ct->info)) {
+    int res = -1;
+    int sz = ct->size;
+    while (ct->sib) {
+      ct = ctype_get(cts, ct->sib);
+      if (ctype_isfield(ct->info)) {
+        int sub = ccall_classify_fp(cts, ctype_rawchild(cts, ct));
+        if (res == -1)
+          res = sub;
+        if (sub != -1 && sub != res)
+          return 0;
+      } else if (ctype_isbitfield(ct->info) ||
+        ctype_isxattrib(ct->info, CTA_SUBTYPE)) {
+        return 0;
+      }
+    }
+    if (res > 0 && sz > res * 4 * 8)
+      return 0;
+    return res;
+  } else {
+    return 0;
+  }
+}
+
+#endif
+
 /* -- MIPS64 ABI struct classification ---------------------------- */
 
 #if LJ_TARGET_MIPS64
@@ -983,6 +1141,14 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
     fid = ctf->sib;
   }
 
+#if LJ_TARGET_ARM64 && LJ_ABI_WIN
+  if ((ct->info & CTF_VARARG)) {
+    nsp -= maxgpr * CTSIZE_PTR;  /* May end up with negative nsp. */
+    ngpr = maxgpr;
+    nfpr = CCALL_NARG_FPR;
+  }
+#endif
+
   /* Walk through all passed arguments. */
   for (o = L->base+1, narg = 1; o < top; o++, narg++) {
     CTypeID did;
@@ -990,6 +1156,13 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
     CTSize sz;
     MSize n, isfp = 0, isva = 0;
     void *dp, *rp = NULL;
+#if LJ_TARGET_PPC && LJ_ARCH_BITS == 64
+    int isf32 = 0;
+#endif
+
+#if LJ_TARGET_S390X
+    uint32_t onstack = 0;
+#endif
 
     if (fid) {  /* Get argument type from field. */
       CType *ctf = ctype_get(cts, fid);
@@ -1019,25 +1192,34 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
       CCALL_HANDLE_STRUCTARG
     } else if (ctype_iscomplex(d->info)) {
       CCALL_HANDLE_COMPLEXARG
-    } else {
+    } else if (!(CCALL_PACK_STACKARG && ctype_isenum(d->info))) {
       sz = CTSIZE_PTR;
     }
-    sz = (sz + CTSIZE_PTR-1) & ~(CTSIZE_PTR-1);
-    n = sz / CTSIZE_PTR;  /* Number of GPRs or stack slots needed. */
+    n = (sz + CTSIZE_PTR-1) / CTSIZE_PTR;  /* Number of GPRs or stack slots needed. */
 
     CCALL_HANDLE_REGARG  /* Handle register arguments. */
 
     /* Otherwise pass argument on stack. */
-    if (CCALL_ALIGN_STACKARG && !rp && (d->info & CTF_ALIGN) > CTALIGN_PTR) {
-      MSize align = (1u << ctype_align(d->info-CTALIGN_PTR)) -1;
-      nsp = (nsp + align) & ~align;  /* Align argument on stack. */
+#if LJ_TARGET_S390X
+    onstack = 1;
+#endif
+    if (CCALL_ALIGN_STACKARG) {  /* Align argument on stack. */
+      MSize align = (1u << ctype_align(d->info)) - 1;
+      if (rp || (CCALL_PACK_STACKARG && isva && align < CTSIZE_PTR-1))
+	align = CTSIZE_PTR-1;
+      nsp = (nsp + align) & ~align;
     }
-    if (nsp + n > CCALL_MAXSTACK) {  /* Too many arguments. */
+#if LJ_TARGET_ARM64 && LJ_ABI_WIN
+    /* A negative nsp points into cc->gpr. Blame MS for their messy ABI. */
+    dp = ((uint8_t *)cc->stack) + (int32_t)nsp;
+#else
+    dp = ((uint8_t *)cc->stack) + nsp;
+#endif
+    nsp += CCALL_PACK_STACKARG ? sz : n * CTSIZE_PTR;
+    if ((int32_t)nsp > CCALL_SIZE_STACK) {  /* Too many arguments. */
     err_nyi:
       lj_err_caller(L, LJ_ERR_FFI_NYICALL);
     }
-    dp = &cc->stack[nsp];
-    nsp += n;
     isva = 0;
 
   done:
@@ -1046,9 +1228,40 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
       *(void **)dp = rp;
       dp = rp;
     }
+#if LJ_TARGET_PPC && LJ_ARCH_BITS == 64 && LJ_BE
+    if (ctype_isstruct(d->info) && sz < CTSIZE_PTR) {
+      dp = (char *)dp + (CTSIZE_PTR - sz);
+    }
+#endif
     lj_cconv_ct_tv(cts, d, (uint8_t *)dp, o, CCF_ARG(narg));
+#if LJ_TARGET_PPC && LJ_ARCH_BITS == 64
+    if (isfp) {
+      int i;
+      for (i = 0; i < d->size / 8 && nfpr < CCALL_NARG_FPR; i++)
+        cc->fpr[nfpr++] = ((double *)dp)[i];
+    }
+    if (isf32) {
+      int i;
+      for (i = 0; i < d->size / 8; i++)
+        ((float *)dp)[i*2] = ((double *)dp)[i];
+    }
+#endif
+#if LJ_ARCH_PPC_ELFV2
+    if (ctype_isstruct(d->info)) {
+      isfp = ccall_classify_fp(cts, d);
+      int i;
+      if (isfp == FTYPE_FLOAT) {
+        for (i = 0; i < d->size / 4 && nfpr < CCALL_NARG_FPR; i++)
+          cc->fpr[nfpr++] = ((float *)dp)[i];
+      } else if (isfp == FTYPE_DOUBLE) {
+        for (i = 0; i < d->size / 8 && nfpr < CCALL_NARG_FPR; i++)
+          cc->fpr[nfpr++] = ((double *)dp)[i];
+      }
+    }
+#endif
     /* Extend passed integers to 32 bits at least. */
-    if (ctype_isinteger_or_bool(d->info) && d->size < 4) {
+    if (ctype_isinteger_or_bool(d->info) && d->size < 4 &&
+	(!CCALL_PACK_STACKARG || !((uintptr_t)dp & 3))) {  /* Assumes LJ_LE. */
       if (d->info & CTF_UNSIGNED)
 	*(uint32_t *)dp = d->size == 1 ? (uint32_t)*(uint8_t *)dp :
 					 (uint32_t)*(uint16_t *)dp;
@@ -1060,6 +1273,15 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
     if (isfp && d->size == sizeof(float))
       ((float *)dp)[1] = ((float *)dp)[0];  /* Floats occupy high slot. */
 #endif
+#if LJ_TARGET_PPC && LJ_ARCH_BITS == 64
+    if ((ctype_isinteger_or_bool(d->info) || ctype_isenum(d->info))
+	&& d->size <= 4) {
+      if (d->info & CTF_UNSIGNED)
+	*(uint64_t *)dp = (uint64_t)*(uint32_t *)dp;
+      else
+        *(int64_t *)dp = (int64_t)*(int32_t *)dp;
+    }
+#endif
 #if LJ_TARGET_MIPS64 || (LJ_TARGET_ARM64 && LJ_BE)
     if ((ctype_isinteger_or_bool(d->info) || ctype_isenum(d->info)
 #if LJ_TARGET_MIPS64
@@ -1069,6 +1291,16 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
       *(int64_t *)dp = (int64_t)*(int32_t *)dp;  /* Sign-extend to 64 bit. */
     }
 #endif
+#if LJ_TARGET_S390X
+    /* Arguments need to be sign-/zero-extended to 64-bits. */
+    if ((ctype_isinteger_or_bool(d->info) || ctype_isenum(d->info) ||
+          (isfp && onstack)) && d->size <= 4) {
+      if (d->info & CTF_UNSIGNED || isfp)
+        *(uint64_t *)dp = (uint64_t)*(uint32_t *)dp;
+      else
+        *(int64_t *)dp = (int64_t)*(int32_t *)dp;
+    }
+#endif
 #if LJ_TARGET_X64 && LJ_ABI_WIN
     if (isva) {  /* Windows/x64 mirrors varargs in both register sets. */
       if (nfpr == ngpr)
@@ -1095,14 +1327,17 @@ static int ccall_set_args(lua_State *L, CTState *cts, CType *ct,
 #endif
   }
   if (fid) lj_err_caller(L, LJ_ERR_FFI_NUMARG);  /* Too few arguments. */
+#if LJ_TARGET_ARM64 && LJ_ABI_WIN
+  if ((int32_t)nsp < 0) nsp = 0;
+#endif
 
 #if LJ_TARGET_X64 || (LJ_TARGET_PPC && !LJ_ABI_SOFTFP)
   cc->nfpr = nfpr;  /* Required for vararg functions. */
 #endif
-  cc->nsp = nsp;
-  cc->spadj = (CCALL_SPS_FREE + CCALL_SPS_EXTRA)*CTSIZE_PTR;
-  if (nsp > CCALL_SPS_FREE)
-    cc->spadj += (((nsp-CCALL_SPS_FREE)*CTSIZE_PTR + 15u) & ~15u);
+  cc->nsp = (nsp + CTSIZE_PTR-1) & ~(CTSIZE_PTR-1);
+  cc->spadj = (CCALL_SPS_FREE + CCALL_SPS_EXTRA) * CTSIZE_PTR;
+  if (cc->nsp > CCALL_SPS_FREE * CTSIZE_PTR)
+    cc->spadj += (((cc->nsp - CCALL_SPS_FREE * CTSIZE_PTR) + 15u) & ~15u);
   return gcsteps;
 }
 
@@ -1158,7 +1393,7 @@ int lj_ccall_func(lua_State *L, GCcdata *cd)
     ct = ctype_rawchild(cts, ct);
   }
   if (ctype_isfunc(ct->info)) {
-    CCallState cc;
+    CCallState cc = {0};
     int gcsteps, ret;
     cc.func = (void (*)(void))cdata_getptr(cdataptr(cd), sz);
     gcsteps = ccall_set_args(L, cts, ct, &cc);
diff --git a/lib/luajit-3065c9/src/lj_ccall.h b/lib/luajit2/src/lj_ccall.h
similarity index 81%
rename from lib/luajit-3065c9/src/lj_ccall.h
rename to lib/luajit2/src/lj_ccall.h
index 0b3c5244d..38d35dc52 100644
--- a/lib/luajit-3065c9/src/lj_ccall.h
+++ b/lib/luajit2/src/lj_ccall.h
@@ -1,6 +1,6 @@
 /*
 ** FFI C call handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CCALL_H
@@ -75,6 +75,9 @@ typedef union FPRArg {
 #define CCALL_NARG_FPR		8
 #define CCALL_NRET_FPR		4
 #define CCALL_SPS_FREE		0
+#if LJ_TARGET_OSX
+#define CCALL_PACK_STACKARG	1
+#endif
 
 typedef intptr_t GPRArg;
 typedef union FPRArg {
@@ -86,10 +89,23 @@ typedef union FPRArg {
 #elif LJ_TARGET_PPC
 
 #define CCALL_NARG_GPR		8
+#if LJ_ARCH_BITS == 64
+#define CCALL_NARG_FPR		13
+#if LJ_ARCH_PPC_ELFV2
+#define CCALL_NRET_GPR		2
+#define CCALL_NRET_FPR		8
+#define CCALL_SPS_EXTRA		14
+#else
+#define CCALL_NRET_GPR		1
+#define CCALL_NRET_FPR		2
+#define CCALL_SPS_EXTRA		16
+#endif
+#else
 #define CCALL_NARG_FPR		(LJ_ABI_SOFTFP ? 0 : 8)
 #define CCALL_NRET_GPR		4	/* For complex double. */
 #define CCALL_NRET_FPR		(LJ_ABI_SOFTFP ? 0 : 1)
 #define CCALL_SPS_EXTRA		4
+#endif
 #define CCALL_SPS_FREE		0
 
 typedef intptr_t GPRArg;
@@ -126,6 +142,21 @@ typedef union FPRArg {
   struct { LJ_ENDIAN_LOHI(float f; , float g;) };
 } FPRArg;
 
+#elif LJ_TARGET_S390X
+
+#define CCALL_NARG_GPR		5	/* GPR 2,3,4,5,6 */
+#define CCALL_NARG_FPR		4	/* FPR 0,2,4,8 */
+#define CCALL_NRET_GPR		1	/* GPR 2 */
+#define CCALL_NRET_FPR		1	/* FPR 0 */
+#define CCALL_SPS_EXTRA		20	/* 160-byte callee save area (not sure if this is the right place) */
+#define CCALL_SPS_FREE		0
+
+typedef intptr_t GPRArg;
+typedef union FPRArg {
+  double d;
+  float f;
+} FPRArg;
+
 #else
 #error "Missing calling convention definitions for this architecture"
 #endif
@@ -139,6 +170,9 @@ typedef union FPRArg {
 #ifndef CCALL_ALIGN_STACKARG
 #define CCALL_ALIGN_STACKARG	1
 #endif
+#ifndef CCALL_PACK_STACKARG
+#define CCALL_PACK_STACKARG	0
+#endif
 #ifndef CCALL_ALIGN_CALLSTATE
 #define CCALL_ALIGN_CALLSTATE	8
 #endif
@@ -147,19 +181,21 @@ typedef union FPRArg {
   (CCALL_NARG_GPR > CCALL_NRET_GPR ? CCALL_NARG_GPR : CCALL_NRET_GPR)
 #define CCALL_NUM_FPR \
   (CCALL_NARG_FPR > CCALL_NRET_FPR ? CCALL_NARG_FPR : CCALL_NRET_FPR)
+#define CCALL_MAXSTACK          32
 
 /* Check against constants in lj_ctype.h. */
 LJ_STATIC_ASSERT(CCALL_NUM_GPR <= CCALL_MAX_GPR);
 LJ_STATIC_ASSERT(CCALL_NUM_FPR <= CCALL_MAX_FPR);
 
-#define CCALL_MAXSTACK		32
+#define CCALL_NUM_STACK		31
+#define CCALL_SIZE_STACK	(CCALL_NUM_STACK * CTSIZE_PTR)
 
 /* -- C call state -------------------------------------------------------- */
 
 typedef LJ_ALIGN(CCALL_ALIGN_CALLSTATE) struct CCallState {
   void (*func)(void);		/* Pointer to called function. */
   uint32_t spadj;		/* Stack pointer adjustment. */
-  uint8_t nsp;			/* Number of stack slots. */
+  uint8_t nsp;			/* Number of bytes on stack. */
   uint8_t retref;		/* Return value by reference. */
 #if LJ_TARGET_X64
   uint8_t ngpr;			/* Number of arguments in GPRs. */
@@ -178,7 +214,7 @@ typedef LJ_ALIGN(CCALL_ALIGN_CALLSTATE) struct CCallState {
   FPRArg fpr[CCALL_NUM_FPR];	/* Arguments/results in FPRs. */
 #endif
   GPRArg gpr[CCALL_NUM_GPR];	/* Arguments/results in GPRs. */
-  GPRArg stack[CCALL_MAXSTACK];	/* Stack slots. */
+  GPRArg stack[CCALL_NUM_STACK];	/* Stack slots. */
 } CCallState;
 
 /* -- C call handling ----------------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_ccallback.c b/lib/luajit2/src/lj_ccallback.c
similarity index 89%
rename from lib/luajit-3065c9/src/lj_ccallback.c
rename to lib/luajit2/src/lj_ccallback.c
index 43e443055..ae0934587 100644
--- a/lib/luajit-3065c9/src/lj_ccallback.c
+++ b/lib/luajit2/src/lj_ccallback.c
@@ -1,6 +1,6 @@
 /*
 ** FFI C callback handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
@@ -21,6 +21,10 @@
 #include "lj_trace.h"
 #include "lj_vm.h"
 
+#if LJ_ARCH_PPC_ELFV2
+#include "lualib.h"
+#endif
+
 /* -- Target-specific handling of callback slots -------------------------- */
 
 #define CALLBACK_MCODE_SIZE	(LJ_PAGESIZE * LJ_NUM_CBPAGE)
@@ -61,8 +65,24 @@ static MSize CALLBACK_OFS2SLOT(MSize ofs)
 
 #elif LJ_TARGET_PPC
 
+#if LJ_ARCH_PPC_OPD
+
+#define CALLBACK_SLOT2OFS(slot)		(24*(slot))
+#define CALLBACK_OFS2SLOT(ofs)		((ofs)/24)
+#define CALLBACK_MAX_SLOT		(CALLBACK_OFS2SLOT(CALLBACK_MCODE_SIZE))
+
+#elif LJ_ARCH_PPC_ELFV2
+
+#define CALLBACK_SLOT2OFS(slot)		(4*(slot))
+#define CALLBACK_OFS2SLOT(ofs)		((ofs)/4)
+#define CALLBACK_MAX_SLOT		(CALLBACK_MCODE_SIZE/4 - 10)
+
+#else
+
 #define CALLBACK_MCODE_HEAD		24
 
+#endif
+
 #elif LJ_TARGET_MIPS32
 
 #define CALLBACK_MCODE_HEAD		20
@@ -171,13 +191,13 @@ static void *callback_mcode_init(global_State *g, uint32_t *page)
 static void *callback_mcode_init(global_State *g, uint32_t *page)
 {
   uint32_t *p = page;
-  void *target = (void *)lj_vm_ffi_callback;
+  ASMFunction target = lj_vm_ffi_callback;
   MSize slot;
   *p++ = A64I_LE(A64I_LDRLx | A64F_D(RID_X11) | A64F_S19(4));
   *p++ = A64I_LE(A64I_LDRLx | A64F_D(RID_X10) | A64F_S19(5));
-  *p++ = A64I_LE(A64I_BR | A64F_N(RID_X11));
+  *p++ = A64I_LE(A64I_BR_AUTH | A64F_N(RID_X11));
   *p++ = A64I_LE(A64I_NOP);
-  ((void **)p)[0] = target;
+  ((ASMFunction *)p)[0] = target;
   ((void **)p)[1] = g;
   p += 4;
   for (slot = 0; slot < CALLBACK_MAX_SLOT; slot++) {
@@ -188,24 +208,59 @@ static void *callback_mcode_init(global_State *g, uint32_t *page)
   return p;
 }
 #elif LJ_TARGET_PPC
+#if LJ_ARCH_PPC_OPD
+register void *vm_toc __asm__("r2");
+static void *callback_mcode_init(global_State *g, uint64_t *page)
+{
+  uint64_t *p = page;
+  void *target = (void *)lj_vm_ffi_callback;
+  MSize slot;
+  for (slot = 0; slot < CALLBACK_MAX_SLOT; slot++) {
+    *p++ = (uint64_t)target;
+    *p++ = (uint64_t)vm_toc;
+    *p++ = (uint64_t)g | ((uint64_t)slot << 47);
+  }
+  return p;
+}
+#else
 static void *callback_mcode_init(global_State *g, uint32_t *page)
 {
   uint32_t *p = page;
   void *target = (void *)lj_vm_ffi_callback;
   MSize slot;
+#if LJ_ARCH_PPC_ELFV2
+  // Needs to be in sync with lj_vm_ffi_callback.
+  lua_assert(CALLBACK_MCODE_SIZE == 4096);
+  for (slot = 0; slot < CALLBACK_MAX_SLOT; slot++) {
+    *p = PPCI_B | (((page+CALLBACK_MAX_SLOT-p) & 0x00ffffffu) << 2);
+    p++;
+  }
+  *p++ = PPCI_LI | PPCF_T(RID_SYS1) | ((((intptr_t)target) >> 32) & 0xffff);
+  *p++ = PPCI_LI | PPCF_T(RID_R11) | ((((intptr_t)g) >> 32) & 0xffff);
+  *p++ = PPCI_RLDICR | PPCF_T(RID_SYS1) | PPCF_A(RID_SYS1) | PPCF_SH(32) | PPCF_M6(63-32);  /* sldi */
+  *p++ = PPCI_RLDICR | PPCF_T(RID_R11) | PPCF_A(RID_R11) | PPCF_SH(32) | PPCF_M6(63-32);  /* sldi */
+  *p++ = PPCI_ORIS | PPCF_A(RID_SYS1) | PPCF_T(RID_SYS1) | ((((intptr_t)target) >> 16) & 0xffff);
+  *p++ = PPCI_ORIS | PPCF_A(RID_R11) | PPCF_T(RID_R11) | ((((intptr_t)g) >> 16) & 0xffff);
+  *p++ = PPCI_ORI | PPCF_A(RID_SYS1) | PPCF_T(RID_SYS1) | (((intptr_t)target) & 0xffff);
+  *p++ = PPCI_ORI | PPCF_A(RID_R11) | PPCF_T(RID_R11) | (((intptr_t)g) & 0xffff);
+  *p++ = PPCI_MTCTR | PPCF_T(RID_SYS1);
+  *p++ = PPCI_BCTR;
+#else
   *p++ = PPCI_LIS | PPCF_T(RID_TMP) | (u32ptr(target) >> 16);
-  *p++ = PPCI_LIS | PPCF_T(RID_R12) | (u32ptr(g) >> 16);
+  *p++ = PPCI_LIS | PPCF_T(RID_R11) | (u32ptr(g) >> 16);
   *p++ = PPCI_ORI | PPCF_A(RID_TMP)|PPCF_T(RID_TMP) | (u32ptr(target) & 0xffff);
-  *p++ = PPCI_ORI | PPCF_A(RID_R12)|PPCF_T(RID_R12) | (u32ptr(g) & 0xffff);
+  *p++ = PPCI_ORI | PPCF_A(RID_R11)|PPCF_T(RID_R11) | (u32ptr(g) & 0xffff);
   *p++ = PPCI_MTCTR | PPCF_T(RID_TMP);
   *p++ = PPCI_BCTR;
   for (slot = 0; slot < CALLBACK_MAX_SLOT; slot++) {
-    *p++ = PPCI_LI | PPCF_T(RID_R11) | slot;
+    *p++ = PPCI_LI | PPCF_T(RID_R12) | slot;
     *p = PPCI_B | (((page-p) & 0x00ffffffu) << 2);
     p++;
   }
+#endif
   return p;
 }
+#endif
 #elif LJ_TARGET_MIPS
 static void *callback_mcode_init(global_State *g, uint32_t *page)
 {
@@ -516,6 +571,15 @@ void lj_ccallback_mcode_free(CTState *cts)
   if (ctype_isfp(ctr->info) && ctr->size == sizeof(float)) \
     ((float *)dp)[1] = *(float *)dp;
 
+#elif LJ_TARGET_S390X
+
+#define CALLBACK_HANDLE_REGARG \
+  if (isfp) { \
+    if (nfpr < CCALL_NARG_FPR) { sp = &cts->cb.fpr[nfpr++]; goto done; } \
+  } else { \
+    if (ngpr < maxgpr) { sp = &cts->cb.gpr[ngpr++]; goto done; } \
+  }
+
 #else
 #error "Missing calling convention definitions for this architecture"
 #endif
@@ -662,6 +726,15 @@ static void callback_conv_result(CTState *cts, lua_State *L, TValue *o)
 	*(int32_t *)dp = ctr->size == 1 ? (int32_t)*(int8_t *)dp :
 					  (int32_t)*(int16_t *)dp;
     }
+#if LJ_TARGET_PPC && LJ_ARCH_BITS == 64
+    if (ctr->size <= 4 &&
+       (ctype_isinteger_or_bool(ctr->info) || ctype_isenum(ctr->info))) {
+      if (ctr->info & CTF_UNSIGNED)
+        *(uint64_t *)dp = (uint64_t)*(uint32_t *)dp;
+      else
+        *(int64_t *)dp = (int64_t)*(int32_t *)dp;
+    }
+#endif
 #if LJ_TARGET_MIPS64 || (LJ_TARGET_ARM64 && LJ_BE)
     /* Always sign-extend results to 64 bits. Even a soft-fp 'float'. */
     if (ctr->size <= 4 &&
diff --git a/lib/luajit-3065c9/src/lj_ccallback.h b/lib/luajit2/src/lj_ccallback.h
similarity index 89%
rename from lib/luajit-3065c9/src/lj_ccallback.h
rename to lib/luajit2/src/lj_ccallback.h
index 8a2c31df3..ea7f67a8b 100644
--- a/lib/luajit-3065c9/src/lj_ccallback.h
+++ b/lib/luajit2/src/lj_ccallback.h
@@ -1,6 +1,6 @@
 /*
 ** FFI C callback handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CCALLBACK_H
diff --git a/lib/luajit-3065c9/src/lj_cconv.c b/lib/luajit2/src/lj_cconv.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_cconv.c
rename to lib/luajit2/src/lj_cconv.c
index 3bbfd3f1c..419a8f45d 100644
--- a/lib/luajit-3065c9/src/lj_cconv.c
+++ b/lib/luajit2/src/lj_cconv.c
@@ -1,6 +1,6 @@
 /*
 ** C type conversions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
diff --git a/lib/luajit-3065c9/src/lj_cconv.h b/lib/luajit2/src/lj_cconv.h
similarity index 96%
rename from lib/luajit-3065c9/src/lj_cconv.h
rename to lib/luajit2/src/lj_cconv.h
index 45b0ca1ec..9da2c33c9 100644
--- a/lib/luajit-3065c9/src/lj_cconv.h
+++ b/lib/luajit2/src/lj_cconv.h
@@ -1,6 +1,6 @@
 /*
 ** C type conversions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CCONV_H
diff --git a/lib/luajit-3065c9/src/lj_cdata.c b/lib/luajit2/src/lj_cdata.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_cdata.c
rename to lib/luajit2/src/lj_cdata.c
index 01a74f5d8..77d9730f3 100644
--- a/lib/luajit-3065c9/src/lj_cdata.c
+++ b/lib/luajit2/src/lj_cdata.c
@@ -1,6 +1,6 @@
 /*
 ** C data management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
diff --git a/lib/luajit-3065c9/src/lj_cdata.h b/lib/luajit2/src/lj_cdata.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_cdata.h
rename to lib/luajit2/src/lj_cdata.h
index de52e8aa6..e6ab48ca8 100644
--- a/lib/luajit-3065c9/src/lj_cdata.h
+++ b/lib/luajit2/src/lj_cdata.h
@@ -1,6 +1,6 @@
 /*
 ** C data management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CDATA_H
diff --git a/lib/luajit-3065c9/src/lj_char.c b/lib/luajit2/src/lj_char.c
similarity index 100%
rename from lib/luajit-3065c9/src/lj_char.c
rename to lib/luajit2/src/lj_char.c
diff --git a/lib/luajit-3065c9/src/lj_char.h b/lib/luajit2/src/lj_char.h
similarity index 100%
rename from lib/luajit-3065c9/src/lj_char.h
rename to lib/luajit2/src/lj_char.h
diff --git a/lib/luajit-3065c9/src/lj_clib.c b/lib/luajit2/src/lj_clib.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_clib.c
rename to lib/luajit2/src/lj_clib.c
index 57669a147..513528ce6 100644
--- a/lib/luajit-3065c9/src/lj_clib.c
+++ b/lib/luajit2/src/lj_clib.c
@@ -1,6 +1,6 @@
 /*
 ** FFI C library loader.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
@@ -25,7 +25,7 @@
 #include <dlfcn.h>
 #include <stdio.h>
 
-#if defined(RTLD_DEFAULT)
+#if defined(RTLD_DEFAULT) && !defined(NO_RTLD_DEFAULT)
 #define CLIB_DEFHANDLE	RTLD_DEFAULT
 #elif LJ_TARGET_OSX || LJ_TARGET_BSD
 #define CLIB_DEFHANDLE	((void *)(intptr_t)-2)
diff --git a/lib/luajit-3065c9/src/lj_clib.h b/lib/luajit2/src/lj_clib.h
similarity index 91%
rename from lib/luajit-3065c9/src/lj_clib.h
rename to lib/luajit2/src/lj_clib.h
index 4429486e1..3a41a4d9b 100644
--- a/lib/luajit-3065c9/src/lj_clib.h
+++ b/lib/luajit2/src/lj_clib.h
@@ -1,6 +1,6 @@
 /*
 ** FFI C library loader.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CLIB_H
diff --git a/lib/luajit-3065c9/src/lj_cparse.c b/lib/luajit2/src/lj_cparse.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_cparse.c
rename to lib/luajit2/src/lj_cparse.c
index 7fd839976..9774f3a51 100644
--- a/lib/luajit-3065c9/src/lj_cparse.c
+++ b/lib/luajit2/src/lj_cparse.c
@@ -1,6 +1,6 @@
 /*
 ** C declaration parser.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
@@ -488,7 +488,7 @@ static void cp_expr_prefix(CPState *cp, CPValue *k)
   } else if (cp_opt(cp, '+')) {
     cp_expr_unary(cp, k);  /* Nothing to do (well, integer promotion). */
   } else if (cp_opt(cp, '-')) {
-    cp_expr_unary(cp, k); k->i32 = -k->i32;
+    cp_expr_unary(cp, k); k->i32 = (int32_t)(~(uint32_t)k->i32+1);
   } else if (cp_opt(cp, '~')) {
     cp_expr_unary(cp, k); k->i32 = ~k->i32;
   } else if (cp_opt(cp, '!')) {
@@ -1766,9 +1766,11 @@ static void cp_pragma(CPState *cp, BCLine pragmaline)
     cp_check(cp, '(');
     if (cp->tok == CTOK_IDENT) {
       if (cp_str_is(cp->str, "push")) {
-	if (cp->curpack < CPARSE_MAX_PACKSTACK) {
+	if (cp->curpack < CPARSE_MAX_PACKSTACK-1) {
 	  cp->packstack[cp->curpack+1] = cp->packstack[cp->curpack];
 	  cp->curpack++;
+	} else {
+	  cp_errmsg(cp, cp->tok, LJ_ERR_XLEVELS);
 	}
       } else if (cp_str_is(cp->str, "pop")) {
 	if (cp->curpack > 0) cp->curpack--;
diff --git a/lib/luajit-3065c9/src/lj_cparse.h b/lib/luajit2/src/lj_cparse.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_cparse.h
rename to lib/luajit2/src/lj_cparse.h
index c0f61edca..42f827a00 100644
--- a/lib/luajit-3065c9/src/lj_cparse.h
+++ b/lib/luajit2/src/lj_cparse.h
@@ -1,6 +1,6 @@
 /*
 ** C declaration parser.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CPARSE_H
diff --git a/lib/luajit-3065c9/src/lj_crecord.c b/lib/luajit2/src/lj_crecord.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_crecord.c
rename to lib/luajit2/src/lj_crecord.c
index bc21d8599..55d0b3ef6 100644
--- a/lib/luajit-3065c9/src/lj_crecord.c
+++ b/lib/luajit2/src/lj_crecord.c
@@ -1,6 +1,6 @@
 /*
 ** Trace recorder for C data operations.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_ffrecord_c
@@ -1118,6 +1118,8 @@ static TRef crec_call_args(jit_State *J, RecordFFData *rd,
     ngpr = 1;
   else if (ctype_cconv(ct->info) == CTCC_FASTCALL)
     ngpr = 2;
+#elif LJ_TARGET_ARM64 && LJ_TARGET_OSX
+  int ngpr = CCALL_NARG_GPR;
 #endif
 
   /* Skip initial attributes. */
@@ -1143,6 +1145,14 @@ static TRef crec_call_args(jit_State *J, RecordFFData *rd,
     } else {
       if (!(ct->info & CTF_VARARG))
 	lj_trace_err(J, LJ_TRERR_NYICALL);  /* Too many arguments. */
+#if LJ_TARGET_ARM64 && LJ_TARGET_OSX
+      if (ngpr >= 0) {
+	ngpr = -1;
+	args[n++] = TREF_NIL;  /* Marker for start of varargs. */
+	if (n >= CCI_NARGS_MAX)
+	  lj_trace_err(J, LJ_TRERR_NYICALL);
+      }
+#endif
       did = lj_ccall_ctid_vararg(cts, o);  /* Infer vararg type. */
     }
     d = ctype_raw(cts, did);
@@ -1151,6 +1161,15 @@ static TRef crec_call_args(jit_State *J, RecordFFData *rd,
       lj_trace_err(J, LJ_TRERR_NYICALL);
     tr = crec_ct_tv(J, d, 0, *base, o);
     if (ctype_isinteger_or_bool(d->info)) {
+#if LJ_TARGET_ARM64 && LJ_TARGET_OSX
+      if (!ngpr) {
+	/* Fixed args passed on the stack use their unpromoted size. */
+	if (d->size != lj_ir_type_size[tref_type(tr)]) {
+	  lj_assertJ(d->size == 1 || d->size==2, "unexpected size %d", d->size);
+	  tr = emitconv(tr, d->size==1 ? IRT_U8 : IRT_U16, tref_type(tr), 0);
+	}
+      } else
+#endif
       if (d->size < 4) {
 	if ((d->info & CTF_UNSIGNED))
 	  tr = emitconv(tr, IRT_INT, d->size==1 ? IRT_U8 : IRT_U16, 0);
@@ -1188,6 +1207,10 @@ static TRef crec_call_args(jit_State *J, RecordFFData *rd,
       }
     }
 #endif
+#elif LJ_TARGET_ARM64 && LJ_TARGET_OSX
+    if (!ctype_isfp(d->info) && ngpr) {
+      ngpr--;
+    }
 #endif
     args[n] = tr;
   }
@@ -1504,9 +1527,13 @@ void LJ_FASTCALL recff_cdata_arith(jit_State *J, RecordFFData *rd)
 	if (ctype_isenum(ct->info)) ct = ctype_child(cts, ct);
 	goto ok;
       } else if (ctype_isfunc(ct->info)) {
+	CTypeID id0 = i ? ctype_typeid(cts, s[0]) : 0;
 	tr = emitir(IRT(IR_FLOAD, IRT_PTR), tr, IRFL_CDATA_PTR);
 	ct = ctype_get(cts,
 	  lj_ctype_intern(cts, CTINFO(CT_PTR, CTALIGN_PTR|id), CTSIZE_PTR));
+	if (i) {
+	  s[0] = ctype_get(cts, id0);  /* cts->tab may have been reallocated. */
+	}
 	goto ok;
       } else {
 	tr = emitir(IRT(IR_ADD, IRT_PTR), tr, lj_ir_kintp(J, sizeof(GCcdata)));
@@ -1875,7 +1902,8 @@ TRef recff_bit64_tohex(jit_State *J, RecordFFData *rd, TRef hdr)
   } else {
     n = id ? 16 : 8;
   }
-  if (n < 0) { n = -n; sf |= STRFMT_F_UPPER; }
+  if (n < 0) { n = (int32_t)(~n+1u); sf |= STRFMT_F_UPPER; }
+  if ((uint32_t)n > 254) n = 254;
   sf |= ((SFormat)((n+1)&255) << STRFMT_SH_PREC);
   if (id) {
     tr = crec_ct_tv(J, ctype_get(cts, id), 0, J->base[0], &rd->argv[0]);
diff --git a/lib/luajit-3065c9/src/lj_crecord.h b/lib/luajit2/src/lj_crecord.h
similarity index 96%
rename from lib/luajit-3065c9/src/lj_crecord.h
rename to lib/luajit2/src/lj_crecord.h
index 2c8cf05c0..32973cf4d 100644
--- a/lib/luajit-3065c9/src/lj_crecord.h
+++ b/lib/luajit2/src/lj_crecord.h
@@ -1,6 +1,6 @@
 /*
 ** Trace recorder for C data operations.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CRECORD_H
diff --git a/lib/luajit-3065c9/src/lj_ctype.c b/lib/luajit2/src/lj_ctype.c
similarity index 97%
rename from lib/luajit-3065c9/src/lj_ctype.c
rename to lib/luajit2/src/lj_ctype.c
index 204be0347..8a4a55f8a 100644
--- a/lib/luajit-3065c9/src/lj_ctype.c
+++ b/lib/luajit2/src/lj_ctype.c
@@ -1,6 +1,6 @@
 /*
 ** C type management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include "lj_obj.h"
@@ -191,8 +191,20 @@ CTypeID lj_ctype_intern(CTState *cts, CTInfo info, CTSize size)
   }
   id = cts->top;
   if (LJ_UNLIKELY(id >= cts->sizetab)) {
+#ifdef LUAJIT_CTYPE_CHECK_ANCHOR
+    CType *ct;
+#endif
     if (id >= CTID_MAX) lj_err_msg(cts->L, LJ_ERR_TABOV);
+#ifdef LUAJIT_CTYPE_CHECK_ANCHOR
+    ct = lj_mem_newvec(cts->L, id+1, CType);
+    memcpy(ct, cts->tab, id*sizeof(CType));
+    memset(cts->tab, 0, id*sizeof(CType));
+    lj_mem_freevec(cts->g, cts->tab, cts->sizetab, CType);
+    cts->tab = ct;
+    cts->sizetab = id+1;
+#else
     lj_mem_growvec(cts->L, cts->tab, cts->sizetab, CTID_MAX, CType);
+#endif
   }
   cts->top = id+1;
   cts->tab[id].info = info;
@@ -570,7 +582,7 @@ GCstr *lj_ctype_repr_int64(lua_State *L, uint64_t n, int isunsigned)
   if (isunsigned) {
     *--p = 'U';
   } else if ((int64_t)n < 0) {
-    n = (uint64_t)-(int64_t)n;
+    n = ~n+1u;
     sign = 1;
   }
   do { *--p = (char)('0' + n % 10); } while (n /= 10);
diff --git a/lib/luajit-3065c9/src/lj_ctype.h b/lib/luajit2/src/lj_ctype.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_ctype.h
rename to lib/luajit2/src/lj_ctype.h
index 3dbcdbfb7..0ed02bc1d 100644
--- a/lib/luajit-3065c9/src/lj_ctype.h
+++ b/lib/luajit2/src/lj_ctype.h
@@ -1,6 +1,6 @@
 /*
 ** C type management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_CTYPE_H
@@ -153,7 +153,7 @@ typedef struct CType {
 
 /* Simplify target-specific configuration. Checked in lj_ccall.h. */
 #define CCALL_MAX_GPR		8
-#define CCALL_MAX_FPR		8
+#define CCALL_MAX_FPR		14
 
 typedef LJ_ALIGN(8) union FPRCBArg { double d; float f[2]; } FPRCBArg;
 
@@ -276,6 +276,8 @@ typedef struct CTState {
 #define CTTYDEFP(_)
 #endif
 
+#define CTF_LONG_IF8		(CTF_LONG * (sizeof(long) == 8))
+
 /* Common types. */
 #define CTTYDEF(_) \
   _(NONE,		0,	CT_ATTRIB, CTATTRIB(CTA_BAD)) \
@@ -289,8 +291,8 @@ typedef struct CTState {
   _(UINT16,		2,	CT_NUM, CTF_UNSIGNED|CTALIGN(1)) \
   _(INT32,		4,	CT_NUM, CTALIGN(2)) \
   _(UINT32,		4,	CT_NUM, CTF_UNSIGNED|CTALIGN(2)) \
-  _(INT64,		8,	CT_NUM, CTF_LONG|CTALIGN(3)) \
-  _(UINT64,		8,	CT_NUM, CTF_UNSIGNED|CTF_LONG|CTALIGN(3)) \
+  _(INT64,		8,	CT_NUM, CTF_LONG_IF8|CTALIGN(3)) \
+  _(UINT64,		8,	CT_NUM, CTF_UNSIGNED|CTF_LONG_IF8|CTALIGN(3)) \
   _(FLOAT,		4,	CT_NUM, CTF_FP|CTALIGN(2)) \
   _(DOUBLE,		8,	CT_NUM, CTF_FP|CTALIGN(3)) \
   _(COMPLEX_FLOAT,	8,	CT_ARRAY, CTF_COMPLEX|CTALIGN(2)|CTID_FLOAT) \
diff --git a/lib/luajit-3065c9/src/lj_debug.c b/lib/luajit2/src/lj_debug.c
similarity index 87%
rename from lib/luajit-3065c9/src/lj_debug.c
rename to lib/luajit2/src/lj_debug.c
index 112f53583..3aa799aa3 100644
--- a/lib/luajit-3065c9/src/lj_debug.c
+++ b/lib/luajit2/src/lj_debug.c
@@ -1,6 +1,6 @@
 /*
 ** Debugging and introspection.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_debug_c
@@ -64,6 +64,7 @@ static BCPos debug_framepc(lua_State *L, GCfunc *fn, cTValue *nextframe)
     if (cf == NULL || (char *)cframe_pc(cf) == (char *)cframe_L(cf))
       return NO_BCPOS;
     ins = cframe_pc(cf);  /* Only happens during error/hook handling. */
+    if (!ins) return NO_BCPOS;
   } else {
     if (frame_islua(nextframe)) {
       ins = frame_pc(nextframe);
@@ -101,14 +102,22 @@ static BCPos debug_framepc(lua_State *L, GCfunc *fn, cTValue *nextframe)
   pos = proto_bcpos(pt, ins) - 1;
 #if LJ_HASJIT
   if (pos > pt->sizebc) {  /* Undo the effects of lj_trace_exit for JLOOP. */
-    GCtrace *T = (GCtrace *)((char *)(ins-1) - offsetof(GCtrace, startins));
-    lj_assertL(bc_isret(bc_op(ins[-1])), "return bytecode expected");
-    pos = proto_bcpos(pt, mref(T->startpc, const BCIns));
+    if (bc_isret(bc_op(ins[-1]))) {
+      GCtrace *T = (GCtrace *)((char *)(ins-1) - offsetof(GCtrace, startins));
+      pos = proto_bcpos(pt, mref(T->startpc, const BCIns));
+    } else {
+      pos = NO_BCPOS;  /* Punt in case of stack overflow for stitched trace. */
+    }
   }
 #endif
   return pos;
 }
 
+LJ_FUNC BCPos lj_debug_framepc(lua_State *L, GCfunc *fn, cTValue *nextframe)
+{
+  return debug_framepc(L, fn, nextframe);
+}
+
 /* -- Line numbers -------------------------------------------------------- */
 
 /* Get line number for a bytecode position. */
@@ -703,3 +712,128 @@ LUALIB_API void luaL_traceback (lua_State *L, lua_State *L1, const char *msg,
   lua_concat(L, (int)(L->top - L->base) - top);
 }
 
+#ifdef LUA_USE_TRACE_LOGS
+
+#include "lj_dispatch.h"
+
+#define MAX_TRACE_EVENTS  64
+
+enum {
+    LJ_TRACE_EVENT_ENTER,
+    LJ_TRACE_EVENT_EXIT,
+    LJ_TRACE_EVENT_START
+};
+
+typedef struct {
+    int              event;
+    unsigned         traceno;
+    unsigned         exitno;
+    int              directexit;
+    const BCIns     *ins;
+    lua_State       *thread;
+    GCfunc          *fn;
+} lj_trace_event_record_t;
+
+static lj_trace_event_record_t lj_trace_events[MAX_TRACE_EVENTS];
+
+static int  rb_start = 0;
+static int  rb_end = 0;
+static int  rb_full = 0;
+
+static void
+lj_trace_log_event(lj_trace_event_record_t *rec)
+{
+  lj_trace_events[rb_end] = *rec;
+
+  if (rb_full) {
+    rb_end++;
+    if (rb_end == MAX_TRACE_EVENTS) {
+      rb_end = 0;
+    }
+    rb_start = rb_end;
+
+  } else {
+    rb_end++;
+    if (rb_end == MAX_TRACE_EVENTS) {
+      rb_end = 0;
+      rb_full = MAX_TRACE_EVENTS;
+    }
+  }
+}
+
+static GCfunc*
+lj_debug_top_frame_fn(lua_State *L, const BCIns *pc)
+{
+  int size;
+  cTValue *frame;
+
+  frame = lj_debug_frame(L, 0, &size);
+  if (frame == NULL) {
+    return NULL;
+  }
+
+  return frame_func(frame);
+}
+
+LJ_FUNC void LJ_FASTCALL
+lj_log_trace_start_record(lua_State *L, unsigned traceno, const BCIns *pc,
+  GCfunc *fn)
+{
+  lj_trace_event_record_t  r;
+
+  r.event = LJ_TRACE_EVENT_START;
+  r.thread = L;
+  r.ins = pc;
+  r.traceno = traceno;
+  r.fn = fn;
+
+  lj_trace_log_event(&r);
+}
+
+LJ_FUNC void LJ_FASTCALL
+lj_log_trace_entry(lua_State *L, unsigned traceno, const BCIns *pc)
+{
+  lj_trace_event_record_t  r;
+
+  r.event = LJ_TRACE_EVENT_ENTER;
+  r.thread = L;
+  r.ins = pc;
+  r.traceno = traceno;
+  r.fn = lj_debug_top_frame_fn(L, pc);
+
+  lj_trace_log_event(&r);
+}
+
+static void
+lj_log_trace_exit_helper(lua_State *L, int vmstate, const BCIns *pc, int direct)
+{
+  if (vmstate >= 0) {
+    lj_trace_event_record_t  r;
+
+    jit_State *J = L2J(L);
+
+    r.event = LJ_TRACE_EVENT_EXIT;
+    r.thread = L;
+    r.ins = pc;
+    r.traceno = vmstate;
+    r.exitno = J->exitno;
+    r.directexit = direct;
+    r.fn = lj_debug_top_frame_fn(L, pc);
+
+    lj_trace_log_event(&r);
+  }
+}
+
+LJ_FUNC void LJ_FASTCALL
+lj_log_trace_normal_exit(lua_State *L, int vmstate, const BCIns *pc)
+{
+  lj_log_trace_exit_helper(L, vmstate, pc, 0);
+}
+
+LJ_FUNC void LJ_FASTCALL
+lj_log_trace_direct_exit(lua_State *L, int vmstate, const BCIns *pc)
+{
+  lj_log_trace_exit_helper(L, vmstate, pc, 1);
+}
+
+#endif  /* LUA_USE_TRACE_LOGS */
diff --git a/lib/luajit-3065c9/src/lj_debug.h b/lib/luajit2/src/lj_debug.h
similarity index 76%
rename from lib/luajit-3065c9/src/lj_debug.h
rename to lib/luajit2/src/lj_debug.h
index 28127ae9d..1c7fc06e1 100644
--- a/lib/luajit-3065c9/src/lj_debug.h
+++ b/lib/luajit2/src/lj_debug.h
@@ -1,6 +1,6 @@
 /*
 ** Debugging and introspection.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_DEBUG_H
@@ -26,6 +26,7 @@ typedef struct lj_Debug {
   int isvararg;
 } lj_Debug;
 
+LJ_FUNC BCPos lj_debug_framepc(lua_State *L, GCfunc *fn, cTValue *nextframe);
 LJ_FUNC cTValue *lj_debug_frame(lua_State *L, int level, int *size);
 LJ_FUNC BCLine LJ_FASTCALL lj_debug_line(GCproto *pt, BCPos pc);
 LJ_FUNC const char *lj_debug_uvname(GCproto *pt, uint32_t idx);
@@ -63,4 +64,15 @@ enum {
   VARNAME__MAX
 };
 
+#ifdef LUA_USE_TRACE_LOGS
+LJ_FUNC void LJ_FASTCALL lj_log_trace_direct_exit(lua_State *L,
+  int vmstate, const BCIns *pc);
+LJ_FUNC void LJ_FASTCALL lj_log_trace_normal_exit(lua_State *L,
+  int vmstate, const BCIns *pc);
+LJ_FUNC void LJ_FASTCALL lj_log_trace_entry(lua_State *L,
+  unsigned traceno, const BCIns *pc);
+LJ_FUNC void LJ_FASTCALL lj_log_trace_start_record(lua_State *L, unsigned traceno,
+  const BCIns *pc, GCfunc *fn);
+#endif
+
 #endif
diff --git a/lib/luajit-3065c9/src/lj_def.h b/lib/luajit2/src/lj_def.h
similarity index 91%
rename from lib/luajit-3065c9/src/lj_def.h
rename to lib/luajit2/src/lj_def.h
index b61297aa7..71e50e35f 100644
--- a/lib/luajit-3065c9/src/lj_def.h
+++ b/lib/luajit2/src/lj_def.h
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT common internal definitions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_DEF_H
@@ -66,12 +66,16 @@ typedef unsigned int uintptr_t;
 #define LJ_MAX_BCINS	(1<<26)		/* Max. # of bytecode instructions. */
 #define LJ_MAX_SLOTS	250		/* Max. # of slots in a Lua func. */
 #define LJ_MAX_LOCVAR	200		/* Max. # of local variables. */
-#define LJ_MAX_UPVAL	60		/* Max. # of upvalues. */
+#define LJ_MAX_UPVAL	120		/* Max. # of upvalues. */
 
 #define LJ_MAX_IDXCHAIN	100		/* __index/__newindex chain limit. */
-#define LJ_STACK_EXTRA	(5+2*LJ_FR2)	/* Extra stack space (metamethods). */
+#define LJ_STACK_EXTRA	(5+3*LJ_FR2)	/* Extra stack space (metamethods). */
 
+#if defined(__powerpc64__) && _CALL_ELF != 2
+#define LJ_NUM_CBPAGE	4		/* Number of FFI callback pages. */
+#else
 #define LJ_NUM_CBPAGE	1		/* Number of FFI callback pages. */
+#endif
 
 /* Minimum table/buffer sizes. */
 #define LJ_MIN_GLOBAL	6		/* Min. global table size (hbits). */
@@ -107,7 +111,11 @@ typedef unsigned int uintptr_t;
 #define checkptr31(x)	(((uint64_t)(uintptr_t)(x) >> 31) == 0)
 #define checkptr32(x)	((uintptr_t)(x) == (uint32_t)(uintptr_t)(x))
 #define checkptr47(x)	(((uint64_t)(uintptr_t)(x) >> 47) == 0)
+#if defined(__powerpc64__) && _CALL_ELF == 2
+#define checkptrGC(x)   (LJ_GC64 ? checkptr47((x)) : LJ_64 ? checkptr32((x)) :1)
+#else
 #define checkptrGC(x)	(LJ_GC64 ? checkptr47((x)) : LJ_64 ? checkptr31((x)) :1)
+#endif
 
 /* Every half-decent C compiler transforms this into a rotate instruction. */
 #define lj_rol(x, n)	(((x)<<(n)) | ((x)>>(-(int)(n)&(8*sizeof(x)-1))))
@@ -146,15 +154,9 @@ typedef uintptr_t BloomFilter;
 #define LJ_UNLIKELY(x)	__builtin_expect(!!(x), 0)
 
 #define lj_ffs(x)	((uint32_t)__builtin_ctz(x))
-/* Don't ask ... */
-#if defined(__INTEL_COMPILER) && (defined(__i386__) || defined(__x86_64__))
-static LJ_AINLINE uint32_t lj_fls(uint32_t x)
-{
-  uint32_t r; __asm__("bsrl %1, %0" : "=r" (r) : "rm" (x) : "cc"); return r;
-}
-#else
 #define lj_fls(x)	((uint32_t)(__builtin_clz(x)^31))
-#endif
+#define lj_ffs64(x)	((uint32_t)__builtin_ctzll(x))
+#define lj_fls64(x)	((uint32_t)(__builtin_clzll(x)^63))
 
 #if defined(__arm__)
 static LJ_AINLINE uint32_t lj_bswap(uint32_t x)
@@ -277,6 +279,23 @@ static LJ_AINLINE uint32_t lj_fls(uint32_t x)
 {
   unsigned long r; _BitScanReverse(&r, x); return (uint32_t)r;
 }
+
+#if defined(_M_X64) || defined(_M_ARM64)
+unsigned char _BitScanForward64(unsigned long *, uint64_t);
+unsigned char _BitScanReverse64(unsigned long *, uint64_t);
+#pragma intrinsic(_BitScanForward64)
+#pragma intrinsic(_BitScanReverse64)
+
+static LJ_AINLINE uint32_t lj_ffs64(uint64_t x)
+{
+  unsigned long r; _BitScanForward64(&r, x); return (uint32_t)r;
+}
+
+static LJ_AINLINE uint32_t lj_fls64(uint64_t x)
+{
+  unsigned long r; _BitScanReverse64(&r, x); return (uint32_t)r;
+}
+#endif
 #endif
 
 unsigned long _byteswap_ulong(unsigned long);
diff --git a/lib/luajit-3065c9/src/lj_dispatch.c b/lib/luajit2/src/lj_dispatch.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_dispatch.c
rename to lib/luajit2/src/lj_dispatch.c
index ded382aa2..b9748bba7 100644
--- a/lib/luajit-3065c9/src/lj_dispatch.c
+++ b/lib/luajit2/src/lj_dispatch.c
@@ -1,6 +1,6 @@
 /*
 ** Instruction dispatch handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_dispatch_c
@@ -307,9 +307,9 @@ int luaJIT_setmode(lua_State *L, int idx, int mode)
       } else {
 	return 0;  /* Failed. */
       }
-      g->bc_cfunc_ext = BCINS_AD(BC_FUNCCW, 0, 0);
+      setbc_op(&g->bc_cfunc_ext, BC_FUNCCW);
     } else {
-      g->bc_cfunc_ext = BCINS_AD(BC_FUNCC, 0, 0);
+      setbc_op(&g->bc_cfunc_ext, BC_FUNCC);
     }
     break;
   default:
@@ -453,7 +453,7 @@ static int call_init(lua_State *L, GCfunc *fn)
     int numparams = pt->numparams;
     int gotparams = (int)(L->top - L->base);
     int need = pt->framesize;
-    if ((pt->flags & PROTO_VARARG)) need += 1+gotparams;
+    if ((pt->flags & PROTO_VARARG)) need += 1+LJ_FR2+gotparams;
     lj_state_checkstack(L, (MSize)need);
     numparams -= gotparams;
     return numparams >= 0 ? numparams : 0;
diff --git a/lib/luajit-3065c9/src/lj_dispatch.h b/lib/luajit2/src/lj_dispatch.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_dispatch.h
rename to lib/luajit2/src/lj_dispatch.h
index 52762eeaa..774bc4dc6 100644
--- a/lib/luajit-3065c9/src/lj_dispatch.h
+++ b/lib/luajit2/src/lj_dispatch.h
@@ -1,6 +1,6 @@
 /*
 ** Instruction dispatch handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_DISPATCH_H
diff --git a/lib/luajit-3065c9/src/lj_emit_arm.h b/lib/luajit2/src/lj_emit_arm.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_emit_arm.h
rename to lib/luajit2/src/lj_emit_arm.h
index cfb174f40..5dcea8399 100644
--- a/lib/luajit-3065c9/src/lj_emit_arm.h
+++ b/lib/luajit2/src/lj_emit_arm.h
@@ -1,6 +1,6 @@
 /*
 ** ARM instruction emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Constant encoding --------------------------------------------------- */
@@ -157,7 +157,7 @@ static int emit_kdelta2(ASMState *as, Reg rd, int32_t i)
       if (other) {
 	int32_t delta = i - other;
 	uint32_t sh, inv = 0, k2, k;
-	if (delta < 0) { delta = -delta; inv = ARMI_ADD^ARMI_SUB; }
+	if (delta < 0) { delta = (int32_t)(~(uint32_t)delta+1u); inv = ARMI_ADD^ARMI_SUB; }
 	sh = lj_ffs(delta) & ~1;
 	k2 = emit_isk12(0, delta & (255 << sh));
 	k = emit_isk12(0, delta & ~(255 << sh));
diff --git a/lib/luajit-3065c9/src/lj_emit_arm64.h b/lib/luajit2/src/lj_emit_arm64.h
similarity index 65%
rename from lib/luajit-3065c9/src/lj_emit_arm64.h
rename to lib/luajit2/src/lj_emit_arm64.h
index c4b4c147d..51d0c351e 100644
--- a/lib/luajit-3065c9/src/lj_emit_arm64.h
+++ b/lib/luajit2/src/lj_emit_arm64.h
@@ -1,6 +1,6 @@
 /*
 ** ARM64 instruction emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Contributed by Djordje Kovacevic and Stefan Pejic from RT-RK.com.
 ** Sponsored by Cisco Systems, Inc.
@@ -20,49 +20,41 @@ static uint64_t get_k64val(ASMState *as, IRRef ref)
   } else {
     lj_assertA(ir->o == IR_KINT || ir->o == IR_KNULL,
 	       "bad 64 bit const IR op %d", ir->o);
-    return ir->i;  /* Sign-extended. */
+    return (uint32_t)ir->i;  /* Zero-extended. */
   }
 }
 
 /* Encode constant in K12 format for data processing instructions. */
 static uint32_t emit_isk12(int64_t n)
 {
-  uint64_t k = (n < 0) ? -n : n;
-  uint32_t m = (n < 0) ? 0x40000000 : 0;
+  uint64_t k = n < 0 ? ~(uint64_t)n+1u : (uint64_t)n;
+  uint32_t m = n < 0 ? 0x40000000 : 0;
   if (k < 0x1000) {
-    return A64I_K12|m|A64F_U12(k);
+    return (uint32_t)(A64I_K12|m|A64F_U12(k));
   } else if ((k & 0xfff000) == k) {
-    return A64I_K12|m|0x400000|A64F_U12(k>>12);
+    return (uint32_t)(A64I_K12|m|0x400000|A64F_U12(k>>12));
   }
   return 0;
 }
 
-#define emit_clz64(n)	__builtin_clzll(n)
-#define emit_ctz64(n)	__builtin_ctzll(n)
+#define emit_clz64(n)	(lj_fls64(n)^63)
+#define emit_ctz64(n)	lj_ffs64(n)
 
 /* Encode constant in K13 format for logical data processing instructions. */
 static uint32_t emit_isk13(uint64_t n, int is64)
 {
-  int inv = 0, w = 128, lz, tz;
-  if (n & 1) { n = ~n; w = 64; inv = 1; }  /* Avoid wrap-around of ones. */
-  if (!n) return 0;  /* Neither all-zero nor all-ones are allowed. */
-  do {  /* Find the repeat width. */
-    if (is64 && (uint32_t)(n^(n>>32))) break;
-    n = (uint32_t)n;
-    if (!n) return 0;  /* Ditto when passing n=0xffffffff and is64=0. */
-    w = 32; if ((n^(n>>16)) & 0xffff) break;
-    n = n & 0xffff; w = 16; if ((n^(n>>8)) & 0xff) break;
-    n = n & 0xff; w = 8; if ((n^(n>>4)) & 0xf) break;
-    n = n & 0xf; w = 4; if ((n^(n>>2)) & 0x3) break;
-    n = n & 0x3; w = 2;
-  } while (0);
-  lz = emit_clz64(n);
-  tz = emit_ctz64(n);
-  if ((int64_t)(n << lz) >> (lz+tz) != -1ll) return 0; /* Non-contiguous? */
-  if (inv)
-    return A64I_K13 | (((lz-w) & 127) << 16) | (((lz+tz-w-1) & 63) << 10);
-  else
-    return A64I_K13 | ((w-tz) << 16) | (((63-lz-tz-w-w) & 63) << 10);
+  /* Thanks to: https://dougallj.wordpress.com/2021/10/30/ */
+  int rot, ones, size, immr, imms;
+  if (!is64) n = ((uint64_t)n << 32) | (uint32_t)n;
+  if ((n+1u) <= 1u) return 0;  /* Neither all-zero nor all-ones are allowed. */
+  rot = (n & (n+1u)) ? emit_ctz64(n & (n+1u)) : 64;
+  n = lj_ror(n, rot & 63);
+  ones = emit_ctz64(~n);
+  size = emit_clz64(n) + ones;
+  if (lj_ror(n, size & 63) != n) return 0;  /* Non-repeating? */
+  immr = -rot & (size - 1);
+  imms = (-(size << 1) | (ones - 1)) & 63;
+  return A64I_K13 | A64F_IMMR(immr | (size & 64)) | A64F_IMMS(imms);
 }
 
 static uint32_t emit_isfpk64(uint64_t n)
@@ -121,9 +113,20 @@ static int emit_checkofs(A64Ins ai, int64_t ofs)
   }
 }
 
-static void emit_lso(ASMState *as, A64Ins ai, Reg rd, Reg rn, int64_t ofs)
+static LJ_AINLINE uint32_t emit_lso_pair_candidate(A64Ins ai, int ofs, int sc)
 {
-  int ot = emit_checkofs(ai, ofs), sc = (ai >> 30) & 3;
+  if (ofs >= 0) {
+    return ai | A64F_U12(ofs>>sc);  /* Subsequent lj_ror checks ofs. */
+  } else if (ofs >= -256) {
+    return (ai^A64I_LS_U) | A64F_S9(ofs & 0x1ff);
+  } else {
+    return A64F_D(31);  /* Will mismatch prev. */
+  }
+}
+
+static void emit_lso(ASMState *as, A64Ins ai, Reg rd, Reg rn, int64_t ofs64)
+{
+  int ot = emit_checkofs(ai, ofs64), sc = (ai >> 30) & 3, ofs = (int)ofs64;
   lj_assertA(ot, "load/store offset %d out of range", ofs);
   /* Combine LDR/STR pairs to LDP/STP. */
   if ((sc == 2 || sc == 3) &&
@@ -132,18 +135,16 @@ static void emit_lso(ASMState *as, A64Ins ai, Reg rd, Reg rn, int64_t ofs)
     uint32_t prev = *as->mcp & ~A64F_D(31);
     int ofsm = ofs - (1<<sc), ofsp = ofs + (1<<sc);
     A64Ins aip;
-    if (prev == (ai | A64F_N(rn) | A64F_U12(ofsm>>sc)) ||
-	prev == ((ai^A64I_LS_U) | A64F_N(rn) | A64F_S9(ofsm&0x1ff))) {
+    if (prev == emit_lso_pair_candidate(ai | A64F_N(rn), ofsm, sc)) {
       aip = (A64F_A(rd) | A64F_D(*as->mcp & 31));
-    } else if (prev == (ai | A64F_N(rn) | A64F_U12(ofsp>>sc)) ||
-	       prev == ((ai^A64I_LS_U) | A64F_N(rn) | A64F_S9(ofsp&0x1ff))) {
+    } else if (prev == emit_lso_pair_candidate(ai | A64F_N(rn), ofsp, sc)) {
       aip = (A64F_D(rd) | A64F_A(*as->mcp & 31));
       ofsm = ofs;
     } else {
       goto nopair;
     }
-    if (ofsm >= (int)((unsigned int)-64<<sc) && ofsm <= (63<<sc)) {
-      *as->mcp = aip | A64F_N(rn) | ((ofsm >> sc) << 15) |
+    if (lj_ror((unsigned int)ofsm + (64u<<sc), sc) <= 127u) {
+      *as->mcp = aip | A64F_N(rn) | (((ofsm >> sc) & 0x7f) << 15) |
 	(ai ^ ((ai == A64I_LDRx || ai == A64I_STRx) ? 0x50000000 : 0x90000000));
       return;
     }
@@ -158,13 +159,12 @@ nopair:
 /* -- Emit loads/stores --------------------------------------------------- */
 
 /* Prefer rematerialization of BASE/L from global_State over spills. */
-#define emit_canremat(ref)	((ref) <= ASMREF_L)
+#define emit_canremat(ref)	((ref) <= REF_BASE)
 
-/* Try to find an N-step delta relative to other consts with N < lim. */
-static int emit_kdelta(ASMState *as, Reg rd, uint64_t k, int lim)
+/* Try to find a one-step delta relative to other consts. */
+static int emit_kdelta(ASMState *as, Reg rd, uint64_t k, int is64)
 {
   RegSet work = (~as->freeset & RSET_GPR) | RID2RSET(RID_GL);
-  if (lim <= 1) return 0;  /* Can't beat that. */
   while (work) {
     Reg r = rset_picktop(work);
     IRRef ref = regcost_ref(as->cost[r]);
@@ -173,13 +173,14 @@ static int emit_kdelta(ASMState *as, Reg rd, uint64_t k, int lim)
       uint64_t kx = ra_iskref(ref) ? (uint64_t)ra_krefk(as, ref) :
 				     get_k64val(as, ref);
       int64_t delta = (int64_t)(k - kx);
+      if (!is64) delta = (int64_t)(int32_t)delta;  /* Sign-extend. */
       if (delta == 0) {
-	emit_dm(as, A64I_MOVx, rd, r);
+	emit_dm(as, is64|A64I_MOVw, rd, r);
 	return 1;
       } else {
-	uint32_t k12 = emit_isk12(delta < 0 ? -delta : delta);
+	uint32_t k12 = emit_isk12(delta < 0 ? (int64_t)(~(uint64_t)delta+1u) : delta);
 	if (k12) {
-	  emit_dn(as, (delta < 0 ? A64I_SUBx : A64I_ADDx)^k12, rd, r);
+	  emit_dn(as, (delta < 0 ? A64I_SUBw : A64I_ADDw)^is64^k12, rd, r);
 	  return 1;
 	}
 	/* Do other ops or multi-step deltas pay off? Probably not.
@@ -192,79 +193,101 @@ static int emit_kdelta(ASMState *as, Reg rd, uint64_t k, int lim)
   return 0;  /* Failed. */
 }
 
-static void emit_loadk(ASMState *as, Reg rd, uint64_t u64, int is64)
+#define glofs(as, k) \
+  ((intptr_t)((uintptr_t)(k) - (uintptr_t)&J2GG(as->J)->g))
+#define mcpofs(as, k) \
+  ((intptr_t)((uintptr_t)(k) - (uintptr_t)(as->mcp - 1)))
+#define checkmcpofs(as, k) \
+  (A64F_S_OK(mcpofs(as, k)>>2, 19))
+
+/* Try to form a const as ADR or ADRP or ADRP + ADD. */
+static int emit_kadrp(ASMState *as, Reg rd, uint64_t k)
+{
+  A64Ins ai = A64I_ADR;
+  int64_t ofs = mcpofs(as, k);
+  if (!A64F_S_OK((uint64_t)ofs, 21)) {
+    uint64_t kpage = k & ~0xfffull;
+    MCode *adrp = as->mcp - 1 - (k != kpage);
+    ofs = (int64_t)(kpage - ((uint64_t)adrp & ~0xfffull)) >> 12;
+    if (!A64F_S_OK(ofs, 21))
+      return 0;  /* Failed. */
+    if (k != kpage)
+      emit_dn(as, (A64I_ADDx^A64I_K12)|A64F_U12(k - kpage), rd, rd);
+    ai = A64I_ADRP;
+  }
+  emit_d(as, ai|(((uint32_t)ofs&3)<<29)|A64F_S19(ofs>>2), rd);
+  return 1;
+}
+
+static void emit_loadk(ASMState *as, Reg rd, uint64_t u64)
 {
-  int i, zeros = 0, ones = 0, neg;
-  if (!is64) u64 = (int64_t)(int32_t)u64;  /* Sign-extend. */
-  /* Count homogeneous 16 bit fragments. */
-  for (i = 0; i < 4; i++) {
-    uint64_t frag = (u64 >> i*16) & 0xffff;
-    zeros += (frag == 0);
-    ones += (frag == 0xffff);
+  int zeros = 0, ones = 0, neg, lshift = 0;
+  int is64 = (u64 >> 32) ? A64I_X : 0, i = is64 ? 4 : 2;
+  /* Count non-homogeneous 16 bit fragments. */
+  while (--i >= 0) {
+    uint32_t frag = (u64 >> i*16) & 0xffff;
+    zeros += (frag != 0);
+    ones += (frag != 0xffff);
   }
-  neg = ones > zeros;  /* Use MOVN if it pays off. */
-  if ((neg ? ones : zeros) < 3) {  /* Need 2+ ins. Try shorter K13 encoding. */
+  neg = ones < zeros;  /* Use MOVN if it pays off. */
+  if ((neg ? ones : zeros) > 1) {  /* Need 2+ ins. Try 1 ins encodings. */
     uint32_t k13 = emit_isk13(u64, is64);
     if (k13) {
       emit_dn(as, (is64|A64I_ORRw)^k13, rd, RID_ZERO);
       return;
     }
-  }
-  if (!emit_kdelta(as, rd, u64, 4 - (neg ? ones : zeros))) {
-    int shift = 0, lshift = 0;
-    uint64_t n64 = neg ? ~u64 : u64;
-    if (n64 != 0) {
-      /* Find first/last fragment to be filled. */
-      shift = (63-emit_clz64(n64)) & ~15;
-      lshift = emit_ctz64(n64) & ~15;
+    if (emit_kdelta(as, rd, u64, is64)) {
+      return;
     }
-    /* MOVK requires the original value (u64). */
-    while (shift > lshift) {
-      uint32_t u16 = (u64 >> shift) & 0xffff;
-      /* Skip fragments that are correctly filled by MOVN/MOVZ. */
-      if (u16 != (neg ? 0xffff : 0))
-	emit_d(as, is64 | A64I_MOVKw | A64F_U16(u16) | A64F_LSL16(shift), rd);
-      shift -= 16;
+    if (emit_kadrp(as, rd, u64)) {  /* Either 1 or 2 ins. */
+      return;
     }
-    /* But MOVN needs an inverted value (n64). */
-    emit_d(as, (neg ? A64I_MOVNx : A64I_MOVZx) |
-	       A64F_U16((n64 >> lshift) & 0xffff) | A64F_LSL16(lshift), rd);
   }
+  if (neg) {
+    u64 = ~u64;
+    if (!is64) u64 = (uint32_t)u64;
+  }
+  if (u64) {
+    /* Find first/last fragment to be filled. */
+    int shift = (63-emit_clz64(u64)) & ~15;
+    lshift = emit_ctz64(u64) & ~15;
+    for (; shift > lshift; shift -= 16) {
+      uint32_t frag = (u64 >> shift) & 0xffff;
+      if (frag == 0) continue; /* Will be correctly filled by MOVN/MOVZ. */
+      if (neg) frag ^= 0xffff; /* MOVK requires the original value. */
+      emit_d(as, is64 | A64I_MOVKw | A64F_U16(frag) | A64F_LSL16(shift), rd);
+    }
+  }
+  /* But MOVN needs an inverted value. */
+  emit_d(as, is64 | (neg ? A64I_MOVNw : A64I_MOVZw) |
+	     A64F_U16((u64 >> lshift) & 0xffff) | A64F_LSL16(lshift), rd);
 }
 
 /* Load a 32 bit constant into a GPR. */
-#define emit_loadi(as, rd, i)	emit_loadk(as, rd, i, 0)
+#define emit_loadi(as, rd, i)	emit_loadk(as, rd, (uint32_t)i)
 
 /* Load a 64 bit constant into a GPR. */
-#define emit_loadu64(as, rd, i)	emit_loadk(as, rd, i, A64I_X)
-
-#define emit_loada(as, r, addr)	emit_loadu64(as, (r), (uintptr_t)(addr))
-
-#define glofs(as, k) \
-  ((intptr_t)((uintptr_t)(k) - (uintptr_t)&J2GG(as->J)->g))
-#define mcpofs(as, k) \
-  ((intptr_t)((uintptr_t)(k) - (uintptr_t)(as->mcp - 1)))
-#define checkmcpofs(as, k) \
-  (A64F_S_OK(mcpofs(as, k)>>2, 19))
+#define emit_loadu64(as, rd, i)	emit_loadk(as, rd, i)
 
 static Reg ra_allock(ASMState *as, intptr_t k, RegSet allow);
 
 /* Get/set from constant pointer. */
 static void emit_lsptr(ASMState *as, A64Ins ai, Reg r, void *p)
 {
-  /* First, check if ip + offset is in range. */
-  if ((ai & 0x00400000) && checkmcpofs(as, p)) {
+  Reg base = RID_GL;
+  int64_t ofs = glofs(as, p);
+  if (emit_checkofs(ai, ofs)) {
+    /* GL + offset, might subsequently fuse to LDP/STP. */
+  } else if (ai == A64I_LDRx && checkmcpofs(as, p)) {
+    /* IP + offset is cheaper than allock, but address must be in range. */
     emit_d(as, A64I_LDRLx | A64F_S19(mcpofs(as, p)>>2), r);
-  } else {
-    Reg base = RID_GL;  /* Next, try GL + offset. */
-    int64_t ofs = glofs(as, p);
-    if (!emit_checkofs(ai, ofs)) {  /* Else split up into base reg + offset. */
-      int64_t i64 = i64ptr(p);
-      base = ra_allock(as, (i64 & ~0x7fffull), rset_exclude(RSET_GPR, r));
-      ofs = i64 & 0x7fffull;
-    }
-    emit_lso(as, ai, r, base, ofs);
+    return;
+  } else {  /* Split up into base reg + offset. */
+    int64_t i64 = i64ptr(p);
+    base = ra_allock(as, (i64 & ~0x7fffull), rset_exclude(RSET_GPR, r));
+    ofs = i64 & 0x7fffull;
   }
+  emit_lso(as, ai, r, base, ofs);
 }
 
 /* Load 64 bit IR constant into register. */
@@ -348,16 +371,22 @@ static void emit_cnb(ASMState *as, A64Ins ai, Reg r, MCode *target)
 
 #define emit_jmp(as, target)	emit_branch(as, A64I_B, (target))
 
-static void emit_call(ASMState *as, void *target)
+static void emit_call(ASMState *as, ASMFunction target)
 {
   MCode *p = --as->mcp;
-  ptrdiff_t delta = (char *)target - (char *)p;
+#if LJ_ABI_PAUTH
+  char *targetp = ptrauth_auth_data((char *)target,
+				    ptrauth_key_function_pointer, 0);
+#else
+  char *targetp = (char *)target;
+#endif
+  ptrdiff_t delta = targetp - (char *)p;
   if (A64F_S_OK(delta>>2, 26)) {
     *p = A64I_BL | A64F_S26(delta>>2);
   } else {  /* Target out of range: need indirect call. But don't use R0-R7. */
     Reg r = ra_allock(as, i64ptr(target),
 		      RSET_RANGE(RID_X8, RID_MAX_GPR)-RSET_FIXED);
-    *p = A64I_BLR | A64F_N(r);
+    *p = A64I_BLR_AUTH | A64F_N(r);
   }
 }
 
@@ -417,7 +446,8 @@ static void emit_addptr(ASMState *as, Reg r, int32_t ofs)
 {
   if (ofs)
     emit_opk(as, ofs < 0 ? A64I_SUBx : A64I_ADDx, r, r,
-		 ofs < 0 ? -ofs : ofs, rset_exclude(RSET_GPR, r));
+		 ofs < 0 ? (int32_t)(~(uint32_t)ofs+1u) : ofs,
+		 rset_exclude(RSET_GPR, r));
 }
 
 #define emit_spsub(as, ofs)	emit_addptr(as, RID_SP, -(ofs))
diff --git a/lib/luajit-3065c9/src/lj_emit_mips.h b/lib/luajit2/src/lj_emit_mips.h
similarity index 99%
rename from lib/luajit-3065c9/src/lj_emit_mips.h
rename to lib/luajit2/src/lj_emit_mips.h
index 0cea54799..dda9092d0 100644
--- a/lib/luajit-3065c9/src/lj_emit_mips.h
+++ b/lib/luajit2/src/lj_emit_mips.h
@@ -1,6 +1,6 @@
 /*
 ** MIPS instruction emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #if LJ_64
diff --git a/lib/luajit-3065c9/src/lj_emit_ppc.h b/lib/luajit2/src/lj_emit_ppc.h
similarity index 99%
rename from lib/luajit-3065c9/src/lj_emit_ppc.h
rename to lib/luajit2/src/lj_emit_ppc.h
index 86760e78e..c34dcbe26 100644
--- a/lib/luajit-3065c9/src/lj_emit_ppc.h
+++ b/lib/luajit2/src/lj_emit_ppc.h
@@ -1,6 +1,6 @@
 /*
 ** PPC instruction emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Emit basic instructions --------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_emit_x86.h b/lib/luajit2/src/lj_emit_x86.h
similarity index 99%
rename from lib/luajit-3065c9/src/lj_emit_x86.h
rename to lib/luajit2/src/lj_emit_x86.h
index 3d3beda3b..d215402c9 100644
--- a/lib/luajit-3065c9/src/lj_emit_x86.h
+++ b/lib/luajit2/src/lj_emit_x86.h
@@ -1,6 +1,6 @@
 /*
 ** x86/x64 instruction emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* -- Emit basic instructions --------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_err.c b/lib/luajit2/src/lj_err.c
similarity index 91%
rename from lib/luajit-3065c9/src/lj_err.c
rename to lib/luajit2/src/lj_err.c
index 563c77062..413cc6b02 100644
--- a/lib/luajit-3065c9/src/lj_err.c
+++ b/lib/luajit2/src/lj_err.c
@@ -1,6 +1,6 @@
 /*
 ** Error handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_err_c
@@ -174,12 +174,15 @@ static void *err_unwind(lua_State *L, void *stopcf, int errcode)
     case FRAME_PCALL:  /* FF pcall() frame. */
     case FRAME_PCALLH:  /* FF pcall() frame inside hook. */
       if (errcode) {
+	global_State *g;
 	if (errcode == LUA_YIELD) {
 	  frame = frame_prevd(frame);
 	  break;
 	}
+	g = G(L);
+	setgcref(g->cur_L, obj2gco(L));
 	if (frame_typep(frame) == FRAME_PCALL)
-	  hook_leave(G(L));
+	  hook_leave(g);
 	L->base = frame_prevd(frame) + 1;
 	L->cframe = cf;
 	unwindstack(L, L->base);
@@ -209,11 +212,6 @@ static void *err_unwind(lua_State *L, void *stopcf, int errcode)
 ** from 3rd party docs or must be found by trial-and-error. They really
 ** don't want you to write your own language-specific exception handler
 ** or to interact gracefully with MSVC. :-(
-**
-** Apparently MSVC doesn't call C++ destructors for foreign exceptions
-** unless you compile your C++ code with /EHa. Unfortunately this means
-** catch (...) also catches things like access violations. The use of
-** _set_se_translator doesn't really help, because it requires /EHa, too.
 */
 
 #define WIN32_LEAN_AND_MEAN
@@ -261,6 +259,8 @@ LJ_FUNCA int lj_err_unwind_win(EXCEPTION_RECORD *rec,
 {
 #if LJ_TARGET_X86
   void *cf = (char *)f - CFRAME_OFS_SEH;
+#elif LJ_TARGET_ARM64
+  void *cf = (char *)f - CFRAME_SIZE;
 #else
   void *cf = f;
 #endif
@@ -268,11 +268,25 @@ LJ_FUNCA int lj_err_unwind_win(EXCEPTION_RECORD *rec,
   int errcode = LJ_EXCODE_CHECK(rec->ExceptionCode) ?
 		LJ_EXCODE_ERRCODE(rec->ExceptionCode) : LUA_ERRRUN;
   if ((rec->ExceptionFlags & 6)) {  /* EH_UNWINDING|EH_EXIT_UNWIND */
+    if (rec->ExceptionCode == STATUS_LONGJUMP &&
+	rec->ExceptionRecord &&
+	LJ_EXCODE_CHECK(rec->ExceptionRecord->ExceptionCode)) {
+      errcode = LJ_EXCODE_ERRCODE(rec->ExceptionRecord->ExceptionCode);
+      if ((rec->ExceptionFlags & 0x20)) {  /* EH_TARGET_UNWIND */
+	/* Unwinding is about to finish; revert the ExceptionCode so that
+	** RtlRestoreContext does not try to restore from a _JUMP_BUFFER.
+	*/
+	rec->ExceptionCode = 0;
+      }
+    }
     /* Unwind internal frames. */
     err_unwind(L, cf, errcode);
   } else {
     void *cf2 = err_unwind(L, cf, 0);
     if (cf2) {  /* We catch it, so start unwinding the upper frames. */
+#if !LJ_TARGET_X86
+      EXCEPTION_RECORD rec2;
+#endif
       if (rec->ExceptionCode == LJ_MSVC_EXCODE ||
 	  rec->ExceptionCode == LJ_GCC_EXCODE) {
 #if !LJ_TARGET_CYGWIN
@@ -295,14 +309,29 @@ LJ_FUNCA int lj_err_unwind_win(EXCEPTION_RECORD *rec,
 	(void *)lj_vm_unwind_ff : (void *)lj_vm_unwind_c, errcode);
       /* lj_vm_rtlunwind does not return. */
 #else
+      if (LJ_EXCODE_CHECK(rec->ExceptionCode)) {
+	/* For unwind purposes, wrap the EXCEPTION_RECORD in something that
+	** looks like a longjmp, so that MSVC will execute C++ destructors in
+	** the frames we unwind over. ExceptionInformation[0] should really
+	** contain a _JUMP_BUFFER*, but hopefully nobody is looking too closely
+	** at this point.
+	*/
+	rec2.ExceptionCode = STATUS_LONGJUMP;
+	rec2.ExceptionRecord = rec;
+	rec2.ExceptionAddress = 0;
+	rec2.NumberParameters = 1;
+	rec2.ExceptionInformation[0] = (ULONG_PTR)ctx;
+	rec = &rec2;
+      }
       /* Unwind the stack and call all handlers for all lower C frames
       ** (including ourselves) again with EH_UNWINDING set. Then set
-      ** stack pointer = cf, result = errcode and jump to the specified target.
+      ** stack pointer = f, result = errcode and jump to the specified target.
       */
-      RtlUnwindEx(cf, (void *)((cframe_unwind_ff(cf2) && errcode != LUA_YIELD) ?
-			       lj_vm_unwind_ff_eh :
-			       lj_vm_unwind_c_eh),
-		  rec, (void *)(uintptr_t)errcode, ctx, dispatch->HistoryTable);
+      RtlUnwindEx(f, (void *)((cframe_unwind_ff(cf2) && errcode != LUA_YIELD) ?
+			      lj_vm_unwind_ff_eh :
+			      lj_vm_unwind_c_eh),
+		  rec, (void *)(uintptr_t)errcode, dispatch->ContextRecord,
+		  dispatch->HistoryTable);
       /* RtlUnwindEx should never return. */
 #endif
     }
@@ -329,12 +358,12 @@ static void err_unwind_win_jit(global_State *g, int errcode)
   memset(&hist, 0, sizeof(hist));
   RtlCaptureContext(&ctx);
   while (1) {
-    uintptr_t frame, base, addr = ctx.CONTEXT_REG_PC;
+    DWORD64 frame, base, addr = ctx.CONTEXT_REG_PC;
     void *hdata;
     PRUNTIME_FUNCTION func = RtlLookupFunctionEntry(addr, &base, &hist);
     if (!func) {  /* Found frame without .pdata: must be JIT-compiled code. */
       ExitNo exitno;
-      uintptr_t stub = lj_trace_unwind(G2J(g), addr - sizeof(MCode), &exitno);
+      uintptr_t stub = lj_trace_unwind(G2J(g), (uintptr_t)(addr - sizeof(MCode)), &exitno);
       if (stub) {  /* Jump to side exit to unwind the trace. */
 	ctx.CONTEXT_REG_PC = stub;
 	G2J(g)->exitcode = errcode;
@@ -419,6 +448,9 @@ LJ_FUNCA int lj_err_unwind_dwarf(int version, int actions,
   if (version != 1)
     return _URC_FATAL_PHASE1_ERROR;
   cf = (void *)_Unwind_GetCFA(ctx);
+#ifdef LJ_TARGET_S390X
+  cf -= 160; /* CFA points 160 bytes above r15. */
+#endif
   L = cframe_L(cf);
   if ((actions & _UA_SEARCH_PHASE)) {
 #if LJ_UNWIND_EXT
@@ -444,10 +476,10 @@ LJ_FUNCA int lj_err_unwind_dwarf(int version, int actions,
     if ((actions & _UA_FORCE_UNWIND)) {
       return _URC_CONTINUE_UNWIND;
     } else if (cf) {
+      ASMFunction ip;
       _Unwind_SetGR(ctx, LJ_TARGET_EHRETREG, errcode);
-      _Unwind_SetIP(ctx, (uintptr_t)(cframe_unwind_ff(cf) ?
-				     lj_vm_unwind_ff_eh :
-				     lj_vm_unwind_c_eh));
+      ip = cframe_unwind_ff(cf) ? lj_vm_unwind_ff_eh : lj_vm_unwind_c_eh;
+      _Unwind_SetIP(ctx, (uintptr_t)lj_ptr_strip(ip));
       return _URC_INSTALL_CONTEXT;
     }
 #if LJ_TARGET_X86ORX64
@@ -580,9 +612,17 @@ extern void __deregister_frame(const void *);
 
 uint8_t *lj_err_register_mcode(void *base, size_t sz, uint8_t *info)
 {
-  void **handler;
+  ASMFunction handler = (ASMFunction)err_unwind_jit;
   memcpy(info, err_frame_jit_template, sizeof(err_frame_jit_template));
-  handler = (void *)err_unwind_jit;
+#if LJ_ABI_PAUTH
+#if LJ_TARGET_ARM64
+  handler = ptrauth_auth_and_resign(handler,
+    ptrauth_key_function_pointer, 0,
+    ptrauth_key_process_independent_code, info + ERR_FRAME_JIT_OFS_HANDLER);
+#else
+#error "missing pointer authentication support for this architecture"
+#endif
+#endif
   memcpy(info + ERR_FRAME_JIT_OFS_HANDLER, &handler, sizeof(handler));
   *(uint32_t *)(info + ERR_FRAME_JIT_OFS_CODE_SIZE) =
     (uint32_t)(sz - sizeof(err_frame_jit_template) - (info - (uint8_t *)base));
@@ -753,6 +793,7 @@ LJ_NOINLINE void LJ_FASTCALL lj_err_throw(lua_State *L, int errcode)
     G(L)->panic(L);
 #else
 #if LJ_HASJIT
+  g->saved_jit_base = g->jit_base;
   setmref(g->jit_base, NULL);
 #endif
   {
@@ -777,6 +818,18 @@ LJ_NOINLINE void lj_err_mem(lua_State *L)
 {
   if (L->status == LUA_ERRERR+1)  /* Don't touch the stack during lua_open. */
     lj_vm_unwind_c(L->cframe, LUA_ERRMEM);
+  if (LJ_HASJIT) {
+    TValue *base = tvref(G(L)->jit_base);
+    if (base) L->base = base;
+  }
+  if (curr_funcisL(L)) {
+    L->top = curr_topL(L);
+    if (LJ_UNLIKELY(L->top > tvref(L->maxstack))) {
+      /* The current Lua frame violates the stack. Replace it with a dummy. */
+      L->top = L->base;
+      setframe_gc(L->base - 1 - LJ_FR2, obj2gco(L), LJ_TTHREAD);
+    }
+  }
   setstrV(L, L->top++, lj_err_str(L, LJ_ERR_ERRMEM));
   lj_err_throw(L, LUA_ERRMEM);
 }
@@ -837,9 +890,11 @@ LJ_NOINLINE void LJ_FASTCALL lj_err_run(lua_State *L)
 {
   ptrdiff_t ef = (LJ_HASJIT && tvref(G(L)->jit_base)) ? 0 : finderrfunc(L);
   if (ef) {
-    TValue *errfunc = restorestack(L, ef);
-    TValue *top = L->top;
+    TValue *errfunc, *top;
+    lj_state_checkstack(L, LUA_MINSTACK * 2);  /* Might raise new error. */
     lj_trace_abort(G(L));
+    errfunc = restorestack(L, ef);
+    top = L->top;
     if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
       setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
       lj_err_throw(L, LUA_ERRERR);
@@ -854,7 +909,15 @@ LJ_NOINLINE void LJ_FASTCALL lj_err_run(lua_State *L)
   lj_err_throw(L, LUA_ERRRUN);
 }
 
+/* Stack overflow error. */
+void LJ_FASTCALL lj_err_stkov(lua_State *L)
+{
+  lj_debug_addloc(L, err2msg(LJ_ERR_STKOV), L->base-1, NULL);
+  lj_err_run(L);
+}
+
 #if LJ_HASJIT
+/* Rethrow error after doing a trace exit. */
 LJ_NOINLINE void LJ_FASTCALL lj_err_trace(lua_State *L, int errcode)
 {
   if (errcode == LUA_ERRRUN)
@@ -870,6 +933,10 @@ LJ_NORET LJ_NOINLINE static void err_msgv(lua_State *L, ErrMsg em, ...)
   const char *msg;
   va_list argp;
   va_start(argp, em);
+  if (LJ_HASJIT) {
+    TValue *base = tvref(G(L)->jit_base);
+    if (base) L->base = base;
+  }
   if (curr_funcisL(L)) L->top = curr_topL(L);
   msg = lj_strfmt_pushvf(L, err2msg(em), argp);
   va_end(argp);
diff --git a/lib/luajit-3065c9/src/lj_err.h b/lib/luajit2/src/lj_err.h
similarity index 94%
rename from lib/luajit-3065c9/src/lj_err.h
rename to lib/luajit2/src/lj_err.h
index bd4de9aef..67686cb77 100644
--- a/lib/luajit-3065c9/src/lj_err.h
+++ b/lib/luajit2/src/lj_err.h
@@ -1,6 +1,6 @@
 /*
 ** Error handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_ERR_H
@@ -23,6 +23,7 @@ LJ_DATA const char *lj_err_allmsg;
 LJ_FUNC GCstr *lj_err_str(lua_State *L, ErrMsg em);
 LJ_FUNCA_NORET void LJ_FASTCALL lj_err_throw(lua_State *L, int errcode);
 LJ_FUNC_NORET void lj_err_mem(lua_State *L);
+LJ_FUNC_NORET void LJ_FASTCALL lj_err_stkov(lua_State *L);
 LJ_FUNC_NORET void LJ_FASTCALL lj_err_run(lua_State *L);
 #if LJ_HASJIT
 LJ_FUNCA_NORET void LJ_FASTCALL lj_err_trace(lua_State *L, int errcode);
diff --git a/lib/luajit-3065c9/src/lj_errmsg.h b/lib/luajit2/src/lj_errmsg.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_errmsg.h
rename to lib/luajit2/src/lj_errmsg.h
index 2e5c776a8..9d43d75ae 100644
--- a/lib/luajit-3065c9/src/lj_errmsg.h
+++ b/lib/luajit2/src/lj_errmsg.h
@@ -1,6 +1,6 @@
 /*
 ** VM error messages.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* This file may be included multiple times with different ERRDEF macros. */
@@ -109,6 +109,8 @@ ERRDEF(NOJIT,	"no JIT compiler for this architecture (yet)")
 ERRDEF(NOJIT,	"JIT compiler permanently disabled by build option")
 #endif
 ERRDEF(JITOPT,	"unknown or malformed optimization flag " LUA_QS)
+ERRDEF(PRNGSTATE,     "PRNG state must be an array with up to 8 integers "
+                  "or an integer")
 
 /* Lexer/parser errors. */
 ERRDEF(XMODE,	"attempt to load chunk with wrong mode")
@@ -178,6 +180,7 @@ ERRDEF(FFI_CBACKOV,	"too many callbacks")
 #endif
 ERRDEF(FFI_NYIPACKBIT,	"NYI: packed bit fields")
 ERRDEF(FFI_NYICALL,	"NYI: cannot call this C function (yet)")
+ERRDEF(FFI_NOTLOAD,	"ffi module not loaded (yet)")
 #endif
 
 #if LJ_HASBUFFER
diff --git a/lib/luajit-3065c9/src/lj_ff.h b/lib/luajit2/src/lj_ff.h
similarity index 82%
rename from lib/luajit-3065c9/src/lj_ff.h
rename to lib/luajit2/src/lj_ff.h
index d00c32fc1..34fb74371 100644
--- a/lib/luajit-3065c9/src/lj_ff.h
+++ b/lib/luajit2/src/lj_ff.h
@@ -1,6 +1,6 @@
 /*
 ** Fast function IDs.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_FF_H
diff --git a/lib/luajit-3065c9/src/lj_ffrecord.c b/lib/luajit2/src/lj_ffrecord.c
similarity index 92%
rename from lib/luajit-3065c9/src/lj_ffrecord.c
rename to lib/luajit2/src/lj_ffrecord.c
index 60c1d84fa..396183a07 100644
--- a/lib/luajit-3065c9/src/lj_ffrecord.c
+++ b/lib/luajit2/src/lj_ffrecord.c
@@ -1,6 +1,6 @@
 /*
 ** Fast function call recorder.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_ffrecord_c
@@ -29,6 +29,7 @@
 #include "lj_vm.h"
 #include "lj_strscan.h"
 #include "lj_strfmt.h"
+#include "lj_cdata.h"
 #include "lj_serialize.h"
 
 /* Some local macros to save typing. Undef'd at the end. */
@@ -98,6 +99,14 @@ static ptrdiff_t results_wanted(jit_State *J)
     return -1;
 }
 
+static TValue *rec_stop_stitch_cp(lua_State *L, lua_CFunction dummy, void *ud)
+{
+  jit_State *J = (jit_State *)ud;
+  lj_record_stop(J, LJ_TRLINK_STITCH, 0);
+  UNUSED(L); UNUSED(dummy);
+  return NULL;
+}
+
 /* Trace stitching: add continuation below frame to start a new trace. */
 static void recff_stitch(jit_State *J)
 {
@@ -108,10 +117,7 @@ static void recff_stitch(jit_State *J)
   TValue *nframe = base + 1 + LJ_FR2;
   const BCIns *pc = frame_pc(base-1);
   TValue *pframe = frame_prevl(base-1);
-
-  /* Check for this now. Throwing in lj_record_stop messes up the stack. */
-  if (J->cur.nsnap >= (MSize)J->param[JIT_P_maxsnap])
-    lj_trace_err(J, LJ_TRERR_SNAPOV);
+  int errcode;
 
   /* Move func + args up in Lua stack and insert continuation. */
   memmove(&base[1], &base[-1-LJ_FR2], sizeof(TValue)*nslot);
@@ -136,13 +142,19 @@ static void recff_stitch(jit_State *J)
   J->baseslot += 2 + LJ_FR2;
   J->framedepth++;
 
-  lj_record_stop(J, LJ_TRLINK_STITCH, 0);
+  errcode = lj_vm_cpcall(L, NULL, J, rec_stop_stitch_cp);
 
   /* Undo Lua stack changes. */
   memmove(&base[-1-LJ_FR2], &base[1], sizeof(TValue)*nslot);
   setframe_pc(base-1, pc);
   L->base -= 2 + LJ_FR2;
   L->top -= 2 + LJ_FR2;
+
+  if (errcode) {
+    if (errcode == LUA_ERRRUN)
+      copyTV(L, L->top-1, L->top + (1 + LJ_FR2));
+    lj_err_throw(L, errcode);  /* Propagate errors. */
+  }
 }
 
 /* Fallback handler for fast functions that are not recorded (yet). */
@@ -1117,7 +1129,7 @@ static LJ_AINLINE TRef recff_sbufx_len(jit_State *J, TRef trr, TRef trw)
 }
 
 /* Emit typecheck for string buffer. */
-static TRef recff_sbufx_check(jit_State *J, RecordFFData *rd, int arg)
+static TRef recff_sbufx_check(jit_State *J, RecordFFData *rd, ptrdiff_t arg)
 {
   TRef trtype, ud = J->base[arg];
   if (!tvisbuf(&rd->argv[arg])) lj_trace_err(J, LJ_TRERR_BADTYPE);
@@ -1130,12 +1142,12 @@ static TRef recff_sbufx_check(jit_State *J, RecordFFData *rd, int arg)
 /* Emit BUFHDR for write to extended string buffer. */
 static TRef recff_sbufx_write(jit_State *J, TRef ud)
 {
-  TRef trbuf = emitir(IRT(IR_ADD, IRT_PGC), ud, lj_ir_kint(J, sizeof(GCudata)));
+  TRef trbuf = emitir(IRT(IR_ADD, IRT_PGC), ud, lj_ir_kintpgc(J, sizeof(GCudata)));
   return emitir(IRT(IR_BUFHDR, IRT_PGC), trbuf, IRBUFHDR_WRITE);
 }
 
 /* Check for integer in range for the buffer API. */
-static TRef recff_sbufx_checkint(jit_State *J, RecordFFData *rd, int arg)
+static TRef recff_sbufx_checkint(jit_State *J, RecordFFData *rd, ptrdiff_t arg)
 {
   TRef tr = J->base[arg];
   TRef trlim = lj_ir_kint(J, LJ_MAX_BUF);
@@ -1164,20 +1176,19 @@ static void LJ_FASTCALL recff_buffer_method_reset(jit_State *J, RecordFFData *rd
   SBufExt *sbx = bufV(&rd->argv[0]);
   int iscow = (int)sbufiscow(sbx);
   TRef trl = recff_sbufx_get_L(J, ud);
-  TRef trcow = emitir(IRT(IR_BAND, IRT_IGC), trl, lj_ir_kint(J, SBUF_FLAG_COW));
-  TRef zero = lj_ir_kint(J, 0);
-  emitir(IRTG(iscow ? IR_NE : IR_EQ, IRT_IGC), trcow, zero);
+  TRef trcow = emitir(IRT(IR_BAND, IRT_IGC), trl, lj_ir_kintpgc(J, SBUF_FLAG_COW));
+  TRef zeropgc = lj_ir_kintpgc(J, 0);
+  emitir(IRTG(iscow ? IR_NE : IR_EQ, IRT_IGC), trcow, zeropgc);
   if (iscow) {
-    trl = emitir(IRT(IR_BXOR, IRT_IGC), trl,
-		 LJ_GC64 ? lj_ir_kint64(J, SBUF_FLAG_COW) :
-			   lj_ir_kint(J, SBUF_FLAG_COW));
-    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_W, zero);
-    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_E, zero);
-    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_B, zero);
+    TRef zerop = lj_ir_kintp(J, 0);
+    trl = emitir(IRT(IR_BXOR, IRT_IGC), trl, lj_ir_kintpgc(J, SBUF_FLAG_COW));
+    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_W, zerop);
+    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_E, zerop);
+    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_B, zerop);
     recff_sbufx_set_L(J, ud, trl);
     emitir(IRT(IR_FSTORE, IRT_PGC),
-	   emitir(IRT(IR_FREF, IRT_PGC), ud, IRFL_SBUF_REF), zero);
-    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_R, zero);
+	   emitir(IRT(IR_FREF, IRT_PGC), ud, IRFL_SBUF_REF), zeropgc);
+    recff_sbufx_set_ptr(J, ud, IRFL_SBUF_R, zerop);
   } else {
     TRef trb = recff_sbufx_get_ptr(J, ud, IRFL_SBUF_B);
     recff_sbufx_set_ptr(J, ud, IRFL_SBUF_W, trb);
@@ -1205,6 +1216,12 @@ static void LJ_FASTCALL recff_buffer_method_set(jit_State *J, RecordFFData *rd)
   if (tref_isstr(tr)) {
     TRef trp = emitir(IRT(IR_STRREF, IRT_PGC), tr, lj_ir_kint(J, 0));
     TRef len = emitir(IRTI(IR_FLOAD), tr, IRFL_STR_LEN);
+    IRIns *irp = IR(tref_ref(trp));
+    /* trp must point into the anchored obj, even after folding. */
+    if (irp->o == IR_STRREF)
+      tr = irp->op1;
+    else if (!tref_isk(tr))
+      trp = emitir(IRT(IR_ADD, IRT_PGC), tr, lj_ir_kintpgc(J, sizeof(GCstr)));
     lj_ir_call(J, IRCALL_lj_bufx_set, trbuf, trp, len, tr);
 #if LJ_HASFFI
   } else if (tref_iscdata(tr)) {
@@ -1445,6 +1462,15 @@ static void LJ_FASTCALL recff_table_new(jit_State *J, RecordFFData *rd)
 {
   TRef tra = lj_opt_narrow_toint(J, J->base[0]);
   TRef trh = lj_opt_narrow_toint(J, J->base[1]);
+  if (tref_isk(tra) && tref_isk(trh)) {
+    int32_t a = IR(tref_ref(tra))->i;
+    if (a < 0x7fff) {
+      uint32_t hbits = hsize2hbits(IR(tref_ref(trh))->i);
+      a = a > 0 ? a+1 : 0;
+      J->base[0] = emitir(IRTG(IR_TNEW, IRT_TAB), (uint32_t)a, hbits);
+      return;
+    }
+  }
   J->base[0] = lj_ir_call(J, IRCALL_lj_tab_new_ah, tra, trh);
   UNUSED(rd);
 }
@@ -1459,6 +1485,77 @@ static void LJ_FASTCALL recff_table_clear(jit_State *J, RecordFFData *rd)
   }  /* else: Interpreter will throw. */
 }
 
+static void LJ_FASTCALL recff_table_clone(jit_State *J, RecordFFData *rd)
+{
+  TRef src = J->base[0];
+  J->base[0] = lj_ir_call(J, IRCALL_lj_tab_clone, src);
+  UNUSED(rd);
+}
+
+static void LJ_FASTCALL recff_table_isarray(jit_State *J, RecordFFData *rd)
+{
+  TRef src = J->base[0];
+  if (LJ_LIKELY(tref_istab(src))) {
+    TRef trres = lj_ir_call(J, IRCALL_lj_tab_isarray, src);
+    GCtab *t = tabV(&rd->argv[0]);
+    int isarr = lj_tab_isarray(t);
+    TRef tr0 = lj_ir_kint(J, 0);
+    emitir(isarr ? IRTGI(IR_NE) : IRTGI(IR_EQ), trres, tr0);
+    J->base[0] = isarr ? TREF_TRUE : TREF_FALSE;
+  }  /* else: Interpreter will throw. */
+}
+
+static void LJ_FASTCALL recff_table_nkeys(jit_State *J, RecordFFData *rd)
+{
+  TRef src = J->base[0];
+  if (LJ_LIKELY(tref_istab(src))) {
+    J->base[0] = lj_ir_call(J, IRCALL_lj_tab_nkeys, src);
+  }  /* else: Interpreter will throw. */
+}
+
+static void LJ_FASTCALL recff_table_isempty(jit_State *J, RecordFFData *rd)
+{
+  TRef src = J->base[0];
+  if (LJ_LIKELY(tref_istab(src))) {
+    TRef trres = lj_ir_call(J, IRCALL_lj_tab_isempty, src);
+    GCtab *t = tabV(&rd->argv[0]);
+    int isempty = lj_tab_isempty(t);
+    TRef tr0 = lj_ir_kint(J, 0);
+    emitir(isempty ? IRTGI(IR_NE) : IRTGI(IR_EQ), trres, tr0);
+    J->base[0] = isempty ? TREF_TRUE : TREF_FALSE;
+  }  /* else: Interpreter will throw. */
+}
+
+/* -- thread library fast functions ------------------------------------------ */
+
+#if LJ_HASFFI
+void LJ_FASTCALL recff_thread_exdata(jit_State *J, RecordFFData *rd)
+{
+  TRef tr = J->base[0];
+  if (!tr) {
+    TRef trl = emitir(IRT(IR_LREF, IRT_THREAD), 0, 0);
+    TRef trp = emitir(IRT(IR_FLOAD, IRT_PTR), trl, IRFL_THREAD_EXDATA);
+    TRef trid = lj_ir_kint(J, CTID_P_VOID);
+    J->base[0] = emitir(IRTG(IR_CNEWI, IRT_CDATA), trid, trp);
+    return;
+  }
+  recff_nyiu(J, rd);  /* this case is too rare to be interesting */
+}
+
+void LJ_FASTCALL recff_thread_exdata2(jit_State *J, RecordFFData *rd)
+{
+  TRef tr = J->base[0];
+  if (!tr) {
+    TRef trl = emitir(IRT(IR_LREF, IRT_THREAD), 0, 0);
+    TRef trp = emitir(IRT(IR_FLOAD, IRT_PTR), trl, IRFL_THREAD_EXDATA2);
+    TRef trid = lj_ir_kint(J, CTID_P_VOID);
+    J->base[0] = emitir(IRTG(IR_CNEWI, IRT_CDATA), trid, trp);
+    return;
+  }
+  recff_nyiu(J, rd);  /* this case is too rare to be interesting */
+}
+#endif
+
 /* -- I/O library fast functions ------------------------------------------ */
 
 /* Get FILE* for I/O function. Any I/O error aborts recording, so there's
diff --git a/lib/luajit-3065c9/src/lj_ffrecord.h b/lib/luajit2/src/lj_ffrecord.h
similarity index 89%
rename from lib/luajit-3065c9/src/lj_ffrecord.h
rename to lib/luajit2/src/lj_ffrecord.h
index 0acb8ed59..24e1d7cab 100644
--- a/lib/luajit-3065c9/src/lj_ffrecord.h
+++ b/lib/luajit2/src/lj_ffrecord.h
@@ -1,6 +1,6 @@
 /*
 ** Fast function call recorder.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_FFRECORD_H
diff --git a/lib/luajit-3065c9/src/lj_frame.h b/lib/luajit2/src/lj_frame.h
similarity index 92%
rename from lib/luajit-3065c9/src/lj_frame.h
rename to lib/luajit2/src/lj_frame.h
index aa1dc11a8..2fb1b2f3e 100644
--- a/lib/luajit-3065c9/src/lj_frame.h
+++ b/lib/luajit2/src/lj_frame.h
@@ -1,6 +1,6 @@
 /*
 ** Stack frames.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_FRAME_H
@@ -210,6 +210,15 @@ enum { LJ_CONT_TAILCALL, LJ_CONT_FFI_CALLBACK };  /* Special continuations. */
 #define CFRAME_OFS_MULTRES	408
 #define CFRAME_SIZE		384
 #define CFRAME_SHIFT_MULTRES	3
+#elif LJ_ARCH_PPC_ELFV2
+#define CFRAME_OFS_ERRF		360
+#define CFRAME_OFS_NRES		356
+#define CFRAME_OFS_PREV		336
+#define CFRAME_OFS_L		352
+#define CFRAME_OFS_PC		348
+#define CFRAME_OFS_MULTRES	344
+#define CFRAME_SIZE		368
+#define CFRAME_SHIFT_MULTRES	3
 #elif LJ_ARCH_PPC32ON64
 #define CFRAME_OFS_ERRF		472
 #define CFRAME_OFS_NRES		468
@@ -264,6 +273,20 @@ enum { LJ_CONT_TAILCALL, LJ_CONT_FFI_CALLBACK };  /* Special continuations. */
 #endif
 #define CFRAME_OFS_MULTRES	0
 #define CFRAME_SHIFT_MULTRES	3
+#elif LJ_TARGET_S390X
+#define CFRAME_OFS_ERRF		280
+#define CFRAME_OFS_NRES		272
+#define CFRAME_OFS_PREV		264
+#define CFRAME_OFS_L		256
+#define CFRAME_OFS_PC		168
+#define CFRAME_OFS_MULTRES	160
+#define CFRAME_SIZE		240
+/*
+** TODO: it would be good if we always decoded param*8 like
+** the RISC architectures do. If so then SHIFT_MULTRES will
+** need to change to 3.
+*/
+#define CFRAME_SHIFT_MULTRES	0
 #else
 #error "Missing CFRAME_* definitions for this architecture"
 #endif
diff --git a/lib/luajit-3065c9/src/lj_func.c b/lib/luajit2/src/lj_func.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_func.c
rename to lib/luajit2/src/lj_func.c
index 9795a7715..6a5376492 100644
--- a/lib/luajit-3065c9/src/lj_func.c
+++ b/lib/luajit2/src/lj_func.c
@@ -1,6 +1,6 @@
 /*
 ** Function handling (prototypes, functions and upvalues).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
diff --git a/lib/luajit-3065c9/src/lj_func.h b/lib/luajit2/src/lj_func.h
similarity index 91%
rename from lib/luajit-3065c9/src/lj_func.h
rename to lib/luajit2/src/lj_func.h
index 44df4deba..96994ebf1 100644
--- a/lib/luajit-3065c9/src/lj_func.h
+++ b/lib/luajit2/src/lj_func.h
@@ -1,6 +1,6 @@
 /*
 ** Function handling (prototypes, functions and upvalues).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_FUNC_H
diff --git a/lib/luajit-3065c9/src/lj_gc.c b/lib/luajit2/src/lj_gc.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_gc.c
rename to lib/luajit2/src/lj_gc.c
index b35a0d44a..eebc751b2 100644
--- a/lib/luajit-3065c9/src/lj_gc.c
+++ b/lib/luajit2/src/lj_gc.c
@@ -1,6 +1,6 @@
 /*
 ** Garbage collector.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -27,6 +27,7 @@
 #include "lj_trace.h"
 #include "lj_dispatch.h"
 #include "lj_vm.h"
+#include "lj_vmevent.h"
 
 #define GCSTEPSIZE	1024u
 #define GCSWEEPMAX	40
@@ -107,6 +108,9 @@ static void gc_mark_start(global_State *g)
   gc_markobj(g, tabref(mainthread(g)->env));
   gc_marktv(g, &g->registrytv);
   gc_mark_gcroot(g);
+#if LJ_HASFFI
+  if (ctype_ctsG(g)) gc_markobj(g, ctype_ctsG(g)->finalizer);
+#endif
   g->gc.state = GCSpropagate;
 }
 
@@ -521,8 +525,13 @@ static void gc_call_finalizer(global_State *g, lua_State *L,
   hook_restore(g, oldh);
   if (LJ_HASPROFILE && (oldh & HOOK_PROFILE)) lj_dispatch_update(g);
   g->gc.threshold = oldt;  /* Restore GC threshold. */
-  if (errcode)
-    lj_err_throw(L, errcode);  /* Propagate errors. */
+  if (errcode) {
+    ptrdiff_t errobj = savestack(L, L->top-1);  /* Stack may be resized. */
+    lj_vmevent_send(L, ERRFIN,
+      copyTV(L, L->top++, restorestack(L, errobj));
+    );
+    L->top--;
+  }
 }
 
 /* Finalize one userdata or cdata object from the mmudata list. */
@@ -700,9 +709,12 @@ static size_t gc_onestep(lua_State *L)
     }
   case GCSfinalize:
     if (gcref(g->gc.mmudata) != NULL) {
+      GCSize old = g->gc.total;
       if (tvref(g->jit_base))  /* Don't call finalizers on trace. */
 	return LJ_MAX_MEM;
       gc_finalize(L);  /* Finalize one userdata object. */
+      if (old >= g->gc.total && g->gc.estimate > old - g->gc.total)
+	g->gc.estimate -= old - g->gc.total;
       if (g->gc.estimate > GCFINALIZECOST)
 	g->gc.estimate -= GCFINALIZECOST;
       return GCFINALIZECOST;
diff --git a/lib/luajit-3065c9/src/lj_gc.h b/lib/luajit2/src/lj_gc.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_gc.h
rename to lib/luajit2/src/lj_gc.h
index 0df7dee6c..3ed790ca5 100644
--- a/lib/luajit-3065c9/src/lj_gc.h
+++ b/lib/luajit2/src/lj_gc.h
@@ -1,6 +1,6 @@
 /*
 ** Garbage collector.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_GC_H
diff --git a/lib/luajit-3065c9/src/lj_gdbjit.c b/lib/luajit2/src/lj_gdbjit.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_gdbjit.c
rename to lib/luajit2/src/lj_gdbjit.c
index c50d0d4c9..56094cf10 100644
--- a/lib/luajit-3065c9/src/lj_gdbjit.c
+++ b/lib/luajit2/src/lj_gdbjit.c
@@ -1,6 +1,6 @@
 /*
 ** Client for the GDB JIT API.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_gdbjit_c
@@ -637,7 +637,7 @@ static void LJ_FASTCALL gdbjit_debugabbrev(GDBJITctx *ctx)
   DUV(DW_AT_low_pc);	DUV(DW_FORM_addr);
   DUV(DW_AT_high_pc);	DUV(DW_FORM_addr);
   DUV(DW_AT_stmt_list);	DUV(DW_FORM_data4);
-  DB(0); DB(0);
+  DB(0); DB(0); DB(0);
 
   ctx->p = p;
 }
diff --git a/lib/luajit-3065c9/src/lj_gdbjit.h b/lib/luajit2/src/lj_gdbjit.h
similarity index 86%
rename from lib/luajit-3065c9/src/lj_gdbjit.h
rename to lib/luajit2/src/lj_gdbjit.h
index f531be619..3962a6656 100644
--- a/lib/luajit-3065c9/src/lj_gdbjit.h
+++ b/lib/luajit2/src/lj_gdbjit.h
@@ -1,6 +1,6 @@
 /*
 ** Client for the GDB JIT API.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_GDBJIT_H
diff --git a/lib/luajit2/src/lj_init.c b/lib/luajit2/src/lj_init.c
new file mode 100644
index 000000000..a6816e1e6
--- /dev/null
+++ b/lib/luajit2/src/lj_init.c
@@ -0,0 +1,69 @@
+#include <stdint.h>
+#include "lj_arch.h"
+#include "lj_jit.h"
+#include "lj_vm.h"
+#include "lj_str.h"
+
+#if LJ_TARGET_ARM && LJ_TARGET_LINUX
+#include <sys/utsname.h>
+#endif
+
+#ifdef _MSC_VER
+/*
+** Append a function pointer to the static constructor table executed by
+** the C runtime.
+** Based on https://stackoverflow.com/questions/1113409/attribute-constructor-equivalent-in-vc
+** see also https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-initialization.
+*/
+#pragma section(".CRT$XCU",read)
+#define LJ_INITIALIZER2_(f,p) \
+        static void f(void); \
+        __declspec(allocate(".CRT$XCU")) void (*f##_)(void) = f; \
+        __pragma(comment(linker,"/include:" p #f "_")) \
+        static void f(void)
+#ifdef _WIN64
+#define LJ_INITIALIZER(f) LJ_INITIALIZER2_(f,"")
+#else
+#define LJ_INITIALIZER(f) LJ_INITIALIZER2_(f,"_")
+#endif
+
+#else
+#define LJ_INITIALIZER(f) static void __attribute__((constructor)) f(void)
+#endif
+
+
+#ifdef LJ_HAS_OPTIMISED_HASH
+static void str_hash_init(uint32_t flags)
+{
+  if (flags & JIT_F_SSE4_2)
+    str_hash_init_sse42 ();
+}
+
+/* CPU detection for interpreter features such as string hash function
+   selection.  We choose to cherry-pick from lj_cpudetect and not have a single
+   initializer to make sure that merges with LuaJIT/LuaJIT remain
+   convenient. */
+LJ_INITIALIZER(lj_init_cpuflags)
+{
+  uint32_t flags = 0;
+#if LJ_TARGET_X86ORX64
+
+  uint32_t vendor[4];
+  uint32_t features[4];
+  if (lj_vm_cpuid(0, vendor) && lj_vm_cpuid(1, features)) {
+    flags |= ((features[2] >> 0)&1) * JIT_F_SSE3;
+    flags |= ((features[2] >> 19)&1) * JIT_F_SSE4_1;
+    flags |= ((features[2] >> 20)&1) * JIT_F_SSE4_2;
+    if (vendor[0] >= 7) {
+      uint32_t xfeatures[4];
+      lj_vm_cpuid(7, xfeatures);
+      flags |= ((xfeatures[1] >> 8)&1) * JIT_F_BMI2;
+    }
+  }
+
+#endif
+
+  /* The reason why we initialized early: select our string hash functions.  */
+  str_hash_init (flags);
+}
+#endif
diff --git a/lib/luajit-3065c9/src/lj_ir.c b/lib/luajit2/src/lj_ir.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_ir.c
rename to lib/luajit2/src/lj_ir.c
index 65901510c..631b7cbc6 100644
--- a/lib/luajit-3065c9/src/lj_ir.c
+++ b/lib/luajit2/src/lj_ir.c
@@ -1,6 +1,6 @@
 /*
 ** SSA IR (Intermediate Representation) emitter.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_ir_c
diff --git a/lib/luajit-3065c9/src/lj_ir.h b/lib/luajit2/src/lj_ir.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_ir.h
rename to lib/luajit2/src/lj_ir.h
index ed492e932..939211ffb 100644
--- a/lib/luajit-3065c9/src/lj_ir.h
+++ b/lib/luajit2/src/lj_ir.h
@@ -1,6 +1,6 @@
 /*
 ** SSA IR (Intermediate Representation) format.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_IR_H
@@ -76,8 +76,8 @@
   \
   _(ABS,	N , ref, ref) \
   _(LDEXP,	N , ref, ref) \
-  _(MIN,	C , ref, ref) \
-  _(MAX,	C , ref, ref) \
+  _(MIN,	N , ref, ref) \
+  _(MAX,	N , ref, ref) \
   _(FPMATH,	N , ref, lit) \
   \
   /* Overflow-checking arithmetic ops. */ \
@@ -196,6 +196,8 @@ IRFPMDEF(FPMENUM)
   _(FUNC_PC,	offsetof(GCfunc, l.pc)) \
   _(FUNC_FFID,	offsetof(GCfunc, l.ffid)) \
   _(THREAD_ENV,	offsetof(lua_State, env)) \
+  _(THREAD_EXDATA,	offsetof(lua_State, exdata)) \
+  _(THREAD_EXDATA2,	offsetof(lua_State, exdata2)) \
   _(TAB_META,	offsetof(GCtab, metatable)) \
   _(TAB_ARRAY,	offsetof(GCtab, array)) \
   _(TAB_NODE,	offsetof(GCtab, node)) \
@@ -383,6 +385,7 @@ typedef struct IRType1 { uint8_t irt; } IRType1;
 #define irt_isu32(t)		(irt_type(t) == IRT_U32)
 #define irt_isi64(t)		(irt_type(t) == IRT_I64)
 #define irt_isu64(t)		(irt_type(t) == IRT_U64)
+#define irt_isp32(t)		(irt_type(t) == IRT_P32)
 
 #define irt_isfp(t)		(irt_isnum(t) || irt_isfloat(t))
 #define irt_isinteger(t)	(irt_typerange((t), IRT_I8, IRT_INT))
diff --git a/lib/luajit-3065c9/src/lj_ircall.h b/lib/luajit2/src/lj_ircall.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_ircall.h
rename to lib/luajit2/src/lj_ircall.h
index 67fb58ae3..0d4688feb 100644
--- a/lib/luajit-3065c9/src/lj_ircall.h
+++ b/lib/luajit2/src/lj_ircall.h
@@ -1,6 +1,6 @@
 /*
 ** IR CALL* instruction definitions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_IRCALL_H
@@ -63,7 +63,7 @@ typedef struct CCallInfo {
 /* Helpers for conditional function definitions. */
 #define IRCALLCOND_ANY(x)		x
 
-#if LJ_TARGET_X86ORX64
+#if LJ_TARGET_X86ORX64 || LJ_TARGET_ARM64
 #define IRCALLCOND_FPMATH(x)		NULL
 #else
 #define IRCALLCOND_FPMATH(x)		x
@@ -190,6 +190,10 @@ typedef struct CCallInfo {
   _(ANY,	lj_tab_keyindex,	2,  FL, INT, 0) \
   _(ANY,	lj_vm_next,		2,  FL, PTR, 0) \
   _(ANY,	lj_tab_len,		1,  FL, INT, 0) \
+  _(ANY,	lj_tab_clone,		2,  FS, TAB, CCI_L) \
+  _(ANY,	lj_tab_isarray,		1,  FL, INT, 0) \
+  _(ANY,	lj_tab_nkeys,		1,  FL, INT, 0) \
+  _(ANY,	lj_tab_isempty,		1,  FL, INT, 0) \
   _(ANY,	lj_tab_len_hint,	2,  FL, INT, 0) \
   _(ANY,	lj_gc_step_jit,		2,  FS, NIL, CCI_L) \
   _(ANY,	lj_gc_barrieruv,	2,  FS, NIL, 0) \
diff --git a/lib/luajit-3065c9/src/lj_iropt.h b/lib/luajit2/src/lj_iropt.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_iropt.h
rename to lib/luajit2/src/lj_iropt.h
index d239f173a..a71a717b9 100644
--- a/lib/luajit-3065c9/src/lj_iropt.h
+++ b/lib/luajit2/src/lj_iropt.h
@@ -1,6 +1,6 @@
 /*
 ** Common header for IR emitter and optimizations.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_IROPT_H
@@ -56,6 +56,12 @@ LJ_FUNC TRef lj_ir_ktrace(jit_State *J);
 #define lj_ir_kintp(J, k)	lj_ir_kint(J, (int32_t)(k))
 #endif
 
+#if LJ_GC64
+#define lj_ir_kintpgc		lj_ir_kintp
+#else
+#define lj_ir_kintpgc		lj_ir_kint
+#endif
+
 static LJ_AINLINE TRef lj_ir_knum(jit_State *J, lua_Number n)
 {
   TValue tv;
diff --git a/lib/luajit-3065c9/src/lj_jit.h b/lib/luajit2/src/lj_jit.h
similarity index 95%
rename from lib/luajit-3065c9/src/lj_jit.h
rename to lib/luajit2/src/lj_jit.h
index 32b3861a1..a60a9aea7 100644
--- a/lib/luajit-3065c9/src/lj_jit.h
+++ b/lib/luajit2/src/lj_jit.h
@@ -1,6 +1,6 @@
 /*
 ** Common definitions for the JIT compiler.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_JIT_H
@@ -23,6 +23,7 @@
 #define JIT_F_SSE3		(JIT_F_CPU << 0)
 #define JIT_F_SSE4_1		(JIT_F_CPU << 1)
 #define JIT_F_BMI2		(JIT_F_CPU << 2)
+#define JIT_F_SSE4_2		(JIT_F_CPU << 3)
 
 
 #define JIT_F_CPUSTRING		"\4SSE3\6SSE4.1\4BMI2"
@@ -87,10 +88,11 @@
 #define JIT_F_OPT_ABC		(JIT_F_OPT << 7)
 #define JIT_F_OPT_SINK		(JIT_F_OPT << 8)
 #define JIT_F_OPT_FUSE		(JIT_F_OPT << 9)
+#define JIT_F_OPT_FMA		(JIT_F_OPT << 10)
 
 /* Optimizations names for -O. Must match the order above. */
 #define JIT_F_OPTSTRING	\
-  "\4fold\3cse\3dce\3fwd\3dse\6narrow\4loop\3abc\4sink\4fuse"
+  "\4fold\3cse\3dce\3fwd\3dse\6narrow\4loop\3abc\4sink\4fuse\3fma"
 
 /* Optimization levels set a fixed combination of flags. */
 #define JIT_F_OPT_0	0
@@ -99,11 +101,12 @@
 #define JIT_F_OPT_3	(JIT_F_OPT_2|\
   JIT_F_OPT_FWD|JIT_F_OPT_DSE|JIT_F_OPT_ABC|JIT_F_OPT_SINK|JIT_F_OPT_FUSE)
 #define JIT_F_OPT_DEFAULT	JIT_F_OPT_3
+/* Note: FMA is not set by default. */
 
 /* -- JIT engine parameters ----------------------------------------------- */
 
 #if LJ_TARGET_WINDOWS || LJ_64
-/* See: http://blogs.msdn.com/oldnewthing/archive/2003/10/08/55239.aspx */
+/* See: https://devblogs.microsoft.com/oldnewthing/20031008-00/?p=42223 */
 #define JIT_P_sizemcode_DEFAULT		64
 #else
 /* Could go as low as 4K, but the mmap() overhead would be rather high. */
@@ -112,12 +115,12 @@
 
 /* Optimization parameters and their defaults. Length is a char in octal! */
 #define JIT_PARAMDEF(_) \
-  _(\010, maxtrace,	1000)	/* Max. # of traces in cache. */ \
-  _(\011, maxrecord,	4000)	/* Max. # of recorded IR instructions. */ \
+  _(\010, maxtrace,	8000)	/* Max. # of traces in cache. */ \
+  _(\011, maxrecord,	16000)	/* Max. # of recorded IR instructions. */ \
   _(\012, maxirconst,	500)	/* Max. # of IR constants of a trace. */ \
   _(\007, maxside,	100)	/* Max. # of side traces of a root trace. */ \
   _(\007, maxsnap,	500)	/* Max. # of snapshots for a trace. */ \
-  _(\011, minstitch,	0)	/* Min. # of IR ins for a stitched trace. */ \
+  _(\011, minstitch,	3)	/* Min. # of IR ins for a stitched trace. */ \
   \
   _(\007, hotloop,	56)	/* # of iter. to detect a hot loop/call. */ \
   _(\007, hotexit,	10)	/* # of taken exits to start a side trace. */ \
@@ -131,7 +134,7 @@
   /* Size of each machine code area (in KBytes). */ \
   _(\011, sizemcode,	JIT_P_sizemcode_DEFAULT) \
   /* Max. total size of all machine code areas (in KBytes). */ \
-  _(\010, maxmcode,	512) \
+  _(\010, maxmcode,	40960) \
   /* End of list. */
 
 enum {
@@ -271,6 +274,9 @@ typedef struct GCtrace {
   BCIns startins;	/* Original bytecode of starting instruction. */
   MSize szmcode;	/* Size of machine code. */
   MCode *mcode;		/* Start of machine code. */
+#if LJ_ABI_PAUTH
+  ASMFunction mcauth;	/* Start of machine code, with ptr auth applied. */
+#endif
   MSize mcloop;		/* Offset of loop start in machine code. */
   uint16_t nchild;	/* Number of child traces (root trace only). */
   uint16_t spadjust;	/* Stack pointer adjustment (offset in bytes). */
@@ -516,6 +522,8 @@ typedef struct jit_State {
   BCLine prev_line;	/* Previous line. */
   int prof_mode;	/* Profiling mode: 0, 'f', 'l'. */
 #endif
+  PRNGState prng;	/* PRNG state for the JIT compiler, defaults to prng in
+			   global_State. */
 } jit_State;
 
 #ifdef LUA_USE_ASSERT
diff --git a/lib/luajit-3065c9/src/lj_lex.c b/lib/luajit2/src/lj_lex.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_lex.c
rename to lib/luajit2/src/lj_lex.c
index 463a87cef..bd81dc40e 100644
--- a/lib/luajit-3065c9/src/lj_lex.c
+++ b/lib/luajit2/src/lj_lex.c
@@ -1,6 +1,6 @@
 /*
 ** Lexical analyzer.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -411,6 +411,7 @@ int lj_lex_setup(lua_State *L, LexState *ls)
   ls->linenumber = 1;
   ls->lastline = 1;
   ls->endmark = 0;
+  ls->fr2 = LJ_FR2;  /* Generate native bytecode by default. */
   lex_next(ls);  /* Read-ahead first char. */
   if (ls->c == 0xef && ls->p + 2 <= ls->pe && (uint8_t)ls->p[0] == 0xbb &&
       (uint8_t)ls->p[1] == 0xbf) {  /* Skip UTF-8 BOM (if buffered). */
diff --git a/lib/luajit-3065c9/src/lj_lex.h b/lib/luajit2/src/lj_lex.h
similarity index 96%
rename from lib/luajit-3065c9/src/lj_lex.h
rename to lib/luajit2/src/lj_lex.h
index cb5b5769a..2ef7fc770 100644
--- a/lib/luajit-3065c9/src/lj_lex.h
+++ b/lib/luajit2/src/lj_lex.h
@@ -1,6 +1,6 @@
 /*
 ** Lexical analyzer.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_LEX_H
@@ -74,6 +74,7 @@ typedef struct LexState {
   MSize sizebcstack;	/* Size of bytecode stack. */
   uint32_t level;	/* Syntactical nesting level. */
   int endmark;		/* Trust bytecode end marker, even if not at EOF. */
+  int fr2;		/* Generate bytecode for LJ_FR2 mode. */
 } LexState;
 
 LJ_FUNC int lj_lex_setup(lua_State *L, LexState *ls);
diff --git a/lib/luajit-3065c9/src/lj_lib.c b/lib/luajit2/src/lj_lib.c
similarity index 93%
rename from lib/luajit-3065c9/src/lj_lib.c
rename to lib/luajit2/src/lj_lib.c
index 82a9e256c..fa45c804b 100644
--- a/lib/luajit-3065c9/src/lj_lib.c
+++ b/lib/luajit2/src/lj_lib.c
@@ -1,6 +1,6 @@
 /*
 ** Library function support.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_lib_c
@@ -62,6 +62,7 @@ static const uint8_t *lib_read_lfunc(lua_State *L, const uint8_t *p, GCtab *tab)
   ls.pe = (const char *)~(uintptr_t)0;
   ls.c = -1;
   ls.level = (BCDUMP_F_STRIP|(LJ_BE*BCDUMP_F_BE));
+  ls.fr2 = LJ_FR2;
   ls.chunkname = name;
   pt = lj_bcread_proto(&ls);
   pt->firstline = ~(BCLine)0;
@@ -266,6 +267,23 @@ GCfunc *lj_lib_checkfunc(lua_State *L, int narg)
   return funcV(o);
 }
 
+GCproto *lj_lib_checkLproto(lua_State *L, int narg, int nolua)
+{
+  TValue *o = L->base + narg-1;
+  if (L->top > o) {
+    if (tvisproto(o)) {
+      return protoV(o);
+    } else if (tvisfunc(o)) {
+      if (isluafunc(funcV(o)))
+	return funcproto(funcV(o));
+      else if (nolua)
+	return NULL;
+    }
+  }
+  lj_err_argt(L, narg, LUA_TFUNCTION);
+  return NULL;  /* unreachable */
+}
+
 GCtab *lj_lib_checktab(lua_State *L, int narg)
 {
   TValue *o = L->base + narg-1;
@@ -304,6 +322,14 @@ int lj_lib_checkopt(lua_State *L, int narg, int def, const char *lst)
   return def;
 }
 
+GCcdata *lj_lib_checkcdata(lua_State *L, int narg)
+{
+  TValue *o = L->base + narg-1;
+  if (!(o < L->top && tviscdata(o)))
+    lj_err_argt(L, narg, LUA_TCDATA);
+  return cdataV(o);
+}
+
 /* -- Strict type checks -------------------------------------------------- */
 
 /* The following type checks do not coerce between strings and numbers.
@@ -356,4 +382,3 @@ badtype:
   return 0;  /* unreachable */
 }
 #endif
-
diff --git a/lib/luajit-3065c9/src/lj_lib.h b/lib/luajit2/src/lj_lib.h
similarity index 95%
rename from lib/luajit-3065c9/src/lj_lib.h
rename to lib/luajit2/src/lj_lib.h
index a18f52bf8..93c98b895 100644
--- a/lib/luajit-3065c9/src/lj_lib.h
+++ b/lib/luajit2/src/lj_lib.h
@@ -1,6 +1,6 @@
 /*
 ** Library function support.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_LIB_H
@@ -42,9 +42,11 @@ LJ_FUNC lua_Number lj_lib_checknum(lua_State *L, int narg);
 LJ_FUNC int32_t lj_lib_checkint(lua_State *L, int narg);
 LJ_FUNC int32_t lj_lib_optint(lua_State *L, int narg, int32_t def);
 LJ_FUNC GCfunc *lj_lib_checkfunc(lua_State *L, int narg);
+LJ_FUNC GCproto *lj_lib_checkLproto(lua_State *L, int narg, int nolua);
 LJ_FUNC GCtab *lj_lib_checktab(lua_State *L, int narg);
 LJ_FUNC GCtab *lj_lib_checktabornil(lua_State *L, int narg);
 LJ_FUNC int lj_lib_checkopt(lua_State *L, int narg, int def, const char *lst);
+LJ_FUNC GCcdata *lj_lib_checkcdata(lua_State *L, int narg);
 
 #if LJ_HASBUFFER
 LJ_FUNC GCstr *lj_lib_checkstrx(lua_State *L, int narg);
diff --git a/lib/luajit-3065c9/src/lj_load.c b/lib/luajit2/src/lj_load.c
similarity index 81%
rename from lib/luajit-3065c9/src/lj_load.c
rename to lib/luajit2/src/lj_load.c
index 0aab48840..152ef6daa 100644
--- a/lib/luajit-3065c9/src/lj_load.c
+++ b/lib/luajit2/src/lj_load.c
@@ -1,6 +1,6 @@
 /*
 ** Load and dump code.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include <errno.h>
@@ -34,14 +34,28 @@ static TValue *cpparser(lua_State *L, lua_CFunction dummy, void *ud)
   UNUSED(dummy);
   cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
   bc = lj_lex_setup(L, ls);
-  if (ls->mode && !strchr(ls->mode, bc ? 'b' : 't')) {
-    setstrV(L, L->top++, lj_err_str(L, LJ_ERR_XMODE));
-    lj_err_throw(L, LUA_ERRSYNTAX);
+  if (ls->mode) {
+    int xmode = 1;
+    const char *mode = ls->mode;
+    char c;
+    while ((c = *mode++)) {
+      if (c == (bc ? 'b' : 't')) xmode = 0;
+      if (c == (LJ_FR2 ? 'W' : 'X')) ls->fr2 = !LJ_FR2;
+    }
+    if (xmode) {
+      setstrV(L, L->top++, lj_err_str(L, LJ_ERR_XMODE));
+      lj_err_throw(L, LUA_ERRSYNTAX);
+    }
   }
   pt = bc ? lj_bcread(ls) : lj_parse(ls);
-  fn = lj_func_newL_empty(L, pt, tabref(L->env));
-  /* Don't combine above/below into one statement. */
-  setfuncV(L, L->top++, fn);
+  if (ls->fr2 == LJ_FR2) {
+    fn = lj_func_newL_empty(L, pt, tabref(L->env));
+    /* Don't combine above/below into one statement. */
+    setfuncV(L, L->top++, fn);
+  } else {
+    /* Non-native generation returns a dumpable, but non-runnable prototype. */
+    setprotoV(L, L->top++, pt);
+  }
   return NULL;
 }
 
@@ -159,9 +173,10 @@ LUALIB_API int luaL_loadstring(lua_State *L, const char *s)
 LUA_API int lua_dump(lua_State *L, lua_Writer writer, void *data)
 {
   cTValue *o = L->top-1;
+  uint32_t flags = LJ_FR2*BCDUMP_F_FR2;  /* Default mode for legacy C API. */
   lj_checkapi(L->top > L->base, "top slot empty");
   if (tvisfunc(o) && isluafunc(funcV(o)))
-    return lj_bcwrite(L, funcproto(funcV(o)), writer, data, 0);
+    return lj_bcwrite(L, funcproto(funcV(o)), writer, data, flags);
   else
     return 1;
 }
diff --git a/lib/luajit-3065c9/src/lj_mcode.c b/lib/luajit2/src/lj_mcode.c
similarity index 96%
rename from lib/luajit-3065c9/src/lj_mcode.c
rename to lib/luajit2/src/lj_mcode.c
index 163aada43..0f87caf75 100644
--- a/lib/luajit-3065c9/src/lj_mcode.c
+++ b/lib/luajit2/src/lj_mcode.c
@@ -1,6 +1,6 @@
 /*
 ** Machine code management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_mcode_c
@@ -29,6 +29,11 @@
 #include <valgrind/valgrind.h>
 #endif
 
+#if LJ_TARGET_WINDOWS
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
 #if LJ_TARGET_IOS
 void sys_icache_invalidate(void *start, size_t len);
 #endif
@@ -41,6 +46,8 @@ void lj_mcode_sync(void *start, void *end)
 #endif
 #if LJ_TARGET_X86ORX64
   UNUSED(start); UNUSED(end);
+#elif LJ_TARGET_WINDOWS
+  FlushInstructionCache(GetCurrentProcess(), start, (char *)end-(char *)start);
 #elif LJ_TARGET_IOS
   sys_icache_invalidate(start, (char *)end-(char *)start);
 #elif LJ_TARGET_PPC
@@ -58,9 +65,6 @@ void lj_mcode_sync(void *start, void *end)
 
 #if LJ_TARGET_WINDOWS
 
-#define WIN32_LEAN_AND_MEAN
-#include <windows.h>
-
 #define MCPROT_RW	PAGE_READWRITE
 #define MCPROT_RX	PAGE_EXECUTE_READ
 #define MCPROT_RWX	PAGE_EXECUTE_READWRITE
@@ -231,7 +235,7 @@ static void *mcode_alloc(jit_State *J, size_t sz)
     }
     /* Next try probing 64K-aligned pseudo-random addresses. */
     do {
-      hint = lj_prng_u64(&J2G(J)->prng) & ((1u<<LJ_TARGET_JUMPRANGE)-0x10000);
+      hint = lj_prng_u64(&J->prng) & ((1u<<LJ_TARGET_JUMPRANGE)-0x10000);
     } while (!(hint + sz < range+range));
     hint = target + hint - range;
   }
@@ -363,7 +367,7 @@ void lj_mcode_limiterr(jit_State *J, size_t need)
   sizemcode = (size_t)J->param[JIT_P_sizemcode] << 10;
   sizemcode = (sizemcode + LJ_PAGESIZE-1) & ~(size_t)(LJ_PAGESIZE - 1);
   maxmcode = (size_t)J->param[JIT_P_maxmcode] << 10;
-  if ((size_t)need > sizemcode)
+  if (need * sizeof(MCode) > sizemcode)
     lj_trace_err(J, LJ_TRERR_MCODEOV);  /* Too long for any area. */
   if (J->szallmcarea + sizemcode > maxmcode)
     lj_trace_err(J, LJ_TRERR_MCODEAL);
diff --git a/lib/luajit-3065c9/src/lj_mcode.h b/lib/luajit2/src/lj_mcode.h
similarity index 90%
rename from lib/luajit-3065c9/src/lj_mcode.h
rename to lib/luajit2/src/lj_mcode.h
index be35925ff..b88be93ee 100644
--- a/lib/luajit-3065c9/src/lj_mcode.h
+++ b/lib/luajit2/src/lj_mcode.h
@@ -1,6 +1,6 @@
 /*
 ** Machine code management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_MCODE_H
diff --git a/lib/luajit-3065c9/src/lj_meta.c b/lib/luajit2/src/lj_meta.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_meta.c
rename to lib/luajit2/src/lj_meta.c
index 5324c6663..5940097e8 100644
--- a/lib/luajit-3065c9/src/lj_meta.c
+++ b/lib/luajit2/src/lj_meta.c
@@ -1,6 +1,6 @@
 /*
 ** Metamethod handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
diff --git a/lib/luajit-3065c9/src/lj_meta.h b/lib/luajit2/src/lj_meta.h
similarity index 95%
rename from lib/luajit-3065c9/src/lj_meta.h
rename to lib/luajit2/src/lj_meta.h
index 3a6eaac2f..f067cf59c 100644
--- a/lib/luajit-3065c9/src/lj_meta.h
+++ b/lib/luajit2/src/lj_meta.h
@@ -1,6 +1,6 @@
 /*
 ** Metamethod handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_META_H
diff --git a/lib/luajit-3065c9/src/lj_obj.c b/lib/luajit2/src/lj_obj.c
similarity index 95%
rename from lib/luajit-3065c9/src/lj_obj.c
rename to lib/luajit2/src/lj_obj.c
index 65cbe1a17..cd4ca50a0 100644
--- a/lib/luajit-3065c9/src/lj_obj.c
+++ b/lib/luajit2/src/lj_obj.c
@@ -1,6 +1,6 @@
 /*
 ** Miscellaneous object handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_obj_c
diff --git a/lib/luajit-3065c9/src/lj_obj.h b/lib/luajit2/src/lj_obj.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_obj.h
rename to lib/luajit2/src/lj_obj.h
index 67e411817..434805d38 100644
--- a/lib/luajit-3065c9/src/lj_obj.h
+++ b/lib/luajit2/src/lj_obj.h
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT VM tags, values and objects.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -413,7 +413,7 @@ typedef struct GCproto {
 #define PROTO_UV_IMMUTABLE	0x4000	/* Immutable upvalue. */
 
 #define proto_kgc(pt, idx) \
-  check_exp((uintptr_t)(intptr_t)(idx) >= (uintptr_t)-(intptr_t)(pt)->sizekgc, \
+  check_exp((uintptr_t)(intptr_t)(idx) >= ~(uintptr_t)(pt)->sizekgc+1u, \
 	    gcref(mref((pt)->k, GCRef)[(idx)]))
 #define proto_knumtv(pt, idx) \
   check_exp((uintptr_t)(idx) < (pt)->sizekn, &mref((pt)->k, TValue)[(idx)])
@@ -657,6 +657,7 @@ typedef struct global_State {
   MRef ctype_state;	/* Pointer to C type state. */
   PRNGState prng;	/* Global PRNG state. */
   GCRef gcroot[GCROOT_MAX];  /* GC roots. */
+  MRef saved_jit_base;  /* saved jit_base for lj_err_throw */
 } global_State;
 
 #define mainthread(g)	(&gcref(g->mainthref)->th)
@@ -697,6 +698,12 @@ struct lua_State {
   GCRef env;		/* Thread environment (table of globals). */
   void *cframe;		/* End of C stack frame chain. */
   MSize stacksize;	/* True stack size (incl. LJ_STACK_EXTRA). */
+  void *exdata;	        /* user extra data pointer. added by OpenResty */
+  void *exdata2;	/* the 2nd user extra data pointer. added by OpenResty */
+#if LJ_TARGET_ARM
+  uint32_t unused1;
+  uint32_t unused2;
+#endif
 };
 
 #define G(L)			(mref(L->glref, global_State))
@@ -1042,4 +1049,18 @@ LJ_DATA const char *const lj_obj_itypename[~LJ_TNUMX+1];
 LJ_FUNC int LJ_FASTCALL lj_obj_equal(cTValue *o1, cTValue *o2);
 LJ_FUNC const void * LJ_FASTCALL lj_obj_ptr(global_State *g, cTValue *o);
 
+#if LJ_ABI_PAUTH
+#if LJ_TARGET_ARM64
+#include <ptrauth.h>
+#define lj_ptr_sign(ptr, ctx) \
+  ptrauth_sign_unauthenticated((ptr), ptrauth_key_function_pointer, (ctx))
+#define lj_ptr_strip(ptr) ptrauth_strip((ptr), ptrauth_key_function_pointer)
+#else
+#error "No support for pointer authentication for this architecture"
+#endif
+#else
+#define lj_ptr_sign(ptr, ctx) (ptr)
+#define lj_ptr_strip(ptr) (ptr)
+#endif
+
 #endif
diff --git a/lib/luajit-3065c9/src/lj_opt_dce.c b/lib/luajit2/src/lj_opt_dce.c
similarity index 94%
rename from lib/luajit-3065c9/src/lj_opt_dce.c
rename to lib/luajit2/src/lj_opt_dce.c
index cff54a8b8..e6fcc552c 100644
--- a/lib/luajit-3065c9/src/lj_opt_dce.c
+++ b/lib/luajit2/src/lj_opt_dce.c
@@ -1,6 +1,6 @@
 /*
 ** DCE: Dead Code Elimination. Pre-LOOP only -- ASM already performs DCE.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_dce_c
@@ -44,12 +44,12 @@ static void dce_propagate(jit_State *J)
     IRIns *ir = IR(ins);
     if (irt_ismarked(ir->t)) {
       irt_clearmark(ir->t);
-      pchain[ir->o] = &ir->prev;
     } else if (!ir_sideeff(ir)) {
       *pchain[ir->o] = ir->prev;  /* Reroute original instruction chain. */
       lj_ir_nop(ir);
       continue;
     }
+    pchain[ir->o] = &ir->prev;
     if (ir->op1 >= REF_FIRST) irt_setmark(IR(ir->op1)->t);
     if (ir->op2 >= REF_FIRST) irt_setmark(IR(ir->op2)->t);
   }
diff --git a/lib/luajit-3065c9/src/lj_opt_fold.c b/lib/luajit2/src/lj_opt_fold.c
similarity index 97%
rename from lib/luajit-3065c9/src/lj_opt_fold.c
rename to lib/luajit2/src/lj_opt_fold.c
index 7ef09a1f7..ce78505b1 100644
--- a/lib/luajit-3065c9/src/lj_opt_fold.c
+++ b/lib/luajit2/src/lj_opt_fold.c
@@ -2,7 +2,7 @@
 ** FOLD: Constant Folding, Algebraic Simplifications and Reassociation.
 ** ABCelim: Array Bounds Check Elimination.
 ** CSE: Common-Subexpression Elimination.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_fold_c
@@ -267,7 +267,7 @@ static int32_t kfold_intop(int32_t k1, int32_t k2, IROp op)
   case IR_SUB: k1 -= k2; break;
   case IR_MUL: k1 *= k2; break;
   case IR_MOD: k1 = lj_vm_modi(k1, k2); break;
-  case IR_NEG: k1 = -k1; break;
+  case IR_NEG: k1 = (int32_t)(~(uint32_t)k1+1u); break;
   case IR_BAND: k1 &= k2; break;
   case IR_BOR: k1 |= k2; break;
   case IR_BXOR: k1 ^= k2; break;
@@ -377,10 +377,10 @@ static uint64_t kfold_int64arith(jit_State *J, uint64_t k1, uint64_t k2,
   case IR_BOR: k1 |= k2; break;
   case IR_BXOR: k1 ^= k2; break;
   case IR_BSHL: k1 <<= (k2 & 63); break;
-  case IR_BSHR: k1 = (int32_t)((uint32_t)k1 >> (k2 & 63)); break;
-  case IR_BSAR: k1 >>= (k2 & 63); break;
-  case IR_BROL: k1 = (int32_t)lj_rol((uint32_t)k1, (k2 & 63)); break;
-  case IR_BROR: k1 = (int32_t)lj_ror((uint32_t)k1, (k2 & 63)); break;
+  case IR_BSHR: k1 >>= (k2 & 63); break;
+  case IR_BSAR: k1 = (uint64_t)((int64_t)k1 >> (k2 & 63)); break;
+  case IR_BROL: k1 = lj_rol(k1, (k2 & 63)); break;
+  case IR_BROR: k1 = lj_ror(k1, (k2 & 63)); break;
   default: lj_assertJ(0, "bad IR op %d", op); break;
   }
 #else
@@ -1366,7 +1366,7 @@ LJFOLDF(simplify_intsub_k)
   if (fright->i == 0)  /* i - 0 ==> i */
     return LEFTFOLD;
   fins->o = IR_ADD;  /* i - k ==> i + (-k) */
-  fins->op2 = (IRRef1)lj_ir_kint(J, -fright->i);  /* Overflow for -2^31 ok. */
+  fins->op2 = (IRRef1)lj_ir_kint(J, (int32_t)(~(uint32_t)fright->i+1u));  /* Overflow for -2^31 ok. */
   return RETRYFOLD;
 }
 
@@ -1397,7 +1397,7 @@ LJFOLDF(simplify_intsub_k64)
   if (k == 0)  /* i - 0 ==> i */
     return LEFTFOLD;
   fins->o = IR_ADD;  /* i - k ==> i + (-k) */
-  fins->op2 = (IRRef1)lj_ir_kint64(J, (uint64_t)-(int64_t)k);
+  fins->op2 = (IRRef1)lj_ir_kint64(J, ~k+1u);
   return RETRYFOLD;
 }
 
@@ -1972,7 +1972,10 @@ LJFOLD(NE any any)
 LJFOLDF(comm_equal)
 {
   /* For non-numbers only: x == x ==> drop; x ~= x ==> fail */
-  if (fins->op1 == fins->op2 && !irt_isnum(fins->t))
+  if (fins->op1 == fins->op2 &&
+      (!irt_isnum(fins->t) ||
+       (fleft->o == IR_CONV &&  /* Converted integers cannot be NaN. */
+	(uint32_t)(fleft->op2 & IRCONV_SRCMASK) - (uint32_t)IRT_I8 <= (uint32_t)(IRT_U64 - IRT_U8))))
     return CONDFOLD(fins->o == IR_EQ);
   return fold_comm_swap(J);
 }
@@ -2131,8 +2134,26 @@ LJFOLDX(lj_opt_fwd_uload)
 LJFOLD(ALEN any any)
 LJFOLDX(lj_opt_fwd_alen)
 
+/* Try to merge UREFO/UREFC into referenced instruction. */
+static TRef merge_uref(jit_State *J, IRRef ref, IRIns* ir)
+{
+  if (ir->o == IR_UREFO && irt_isguard(ir->t)) {
+    /* Might be pointing to some other coroutine's stack.
+    ** And GC might shrink said stack, thereby repointing the upvalue.
+    ** GC might even collect said coroutine, thereby closing the upvalue.
+    */
+    if (gcstep_barrier(J, ref))
+      return EMITFOLD;  /* So cannot merge. */
+    /* Current fins wants a check, but ir doesn't have one. */
+    if ((irt_t(fins->t) & (IRT_GUARD|IRT_TYPE)) == (IRT_GUARD|IRT_PGC) &&
+	irt_type(ir->t) == IRT_IGC)
+      ir->t.irt += IRT_PGC-IRT_IGC;  /* So install a check. */
+  }
+  return ref;  /* Not a TRef, but the caller doesn't care. */
+}
+
 /* Upvalue refs are really loads, but there are no corresponding stores.
-** So CSE is ok for them, except for UREFO across a GC step (see below).
+** So CSE is ok for them, except for guarded UREFO across a GC step.
 ** If the referenced function is const, its upvalue addresses are const, too.
 ** This can be used to improve CSE by looking for the same address,
 ** even if the upvalues originate from a different function.
@@ -2150,9 +2171,7 @@ LJFOLDF(cse_uref)
       if (irref_isk(ir->op1)) {
 	GCfunc *fn2 = ir_kfunc(IR(ir->op1));
 	if (gco2uv(gcref(fn2->l.uvptr[(ir->op2 >> 8)])) == uv) {
-	  if (fins->o == IR_UREFO && gcstep_barrier(J, ref))
-	    break;
-	  return ref;
+	  return merge_uref(J, ref, ir);
 	}
       }
       ref = ir->prev;
@@ -2161,6 +2180,24 @@ LJFOLDF(cse_uref)
   return EMITFOLD;
 }
 
+/* Custom CSE for UREFO. */
+LJFOLD(UREFO any any)
+LJFOLDF(cse_urefo)
+{
+  if (LJ_LIKELY(J->flags & JIT_F_OPT_CSE)) {
+    IRRef ref = J->chain[IR_UREFO];
+    IRRef lim = fins->op1;
+    IRRef2 op12 = (IRRef2)fins->op1 + ((IRRef2)fins->op2 << 16);
+    while (ref > lim) {
+      IRIns *ir = IR(ref);
+      if (ir->op12 == op12)
+	return merge_uref(J, ref, ir);
+      ref = ir->prev;
+    }
+  }
+  return EMITFOLD;
+}
+
 LJFOLD(HREFK any any)
 LJFOLDX(lj_opt_fwd_hrefk)
 
@@ -2381,14 +2418,9 @@ LJFOLDF(fold_base)
 
 /* Write barriers are amenable to CSE, but not across any incremental
 ** GC steps.
-**
-** The same logic applies to open upvalue references, because a stack
-** may be resized during a GC step (not the current stack, but maybe that
-** of a coroutine).
 */
 LJFOLD(TBAR any)
 LJFOLD(OBAR any any)
-LJFOLD(UREFO any any)
 LJFOLDF(barrier_tab)
 {
   TRef tr = lj_opt_cse(J);
diff --git a/lib/luajit-3065c9/src/lj_opt_loop.c b/lib/luajit2/src/lj_opt_loop.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_opt_loop.c
rename to lib/luajit2/src/lj_opt_loop.c
index ee3ee0499..01c2b3060 100644
--- a/lib/luajit-3065c9/src/lj_opt_loop.c
+++ b/lib/luajit2/src/lj_opt_loop.c
@@ -1,6 +1,6 @@
 /*
 ** LOOP: Loop Optimizations.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_loop_c
diff --git a/lib/luajit-3065c9/src/lj_opt_mem.c b/lib/luajit2/src/lj_opt_mem.c
similarity index 96%
rename from lib/luajit-3065c9/src/lj_opt_mem.c
rename to lib/luajit2/src/lj_opt_mem.c
index 09de2f051..1fd7ce137 100644
--- a/lib/luajit-3065c9/src/lj_opt_mem.c
+++ b/lib/luajit2/src/lj_opt_mem.c
@@ -3,7 +3,7 @@
 ** AA: Alias Analysis using high-level semantic disambiguation.
 ** FWD: Load Forwarding (L2L) + Store Forwarding (S2L).
 ** DSE: Dead-Store Elimination.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_mem_c
@@ -186,6 +186,7 @@ static TRef fwd_ahload(jit_State *J, IRRef xref)
 	fwd_aa_tab_clear(J, tab, tab)) {
       /* A NEWREF with a number key may end up pointing to the array part.
       ** But it's referenced from HSTORE and not found in the ASTORE chain.
+      ** Or a NEWREF may rehash the table and move unrelated number keys.
       ** For now simply consider this a conflict without forwarding anything.
       */
       if (xr->o == IR_AREF) {
@@ -196,6 +197,11 @@ static TRef fwd_ahload(jit_State *J, IRRef xref)
 	    goto cselim;
 	  ref2 = newref->prev;
 	}
+      } else {
+	IRIns *key = IR(xr->op2);
+	if (key->o == IR_KSLOT) key = IR(key->op1);
+	if (irt_isnum(key->t) && J->chain[IR_NEWREF] > tab)
+	  goto cselim;
       }
       /* NEWREF inhibits CSE for HREF, and dependent FLOADs from HREFK/AREF.
       ** But the above search for conflicting stores was limited by xref.
@@ -211,25 +217,23 @@ static TRef fwd_ahload(jit_State *J, IRRef xref)
 	}
 	ref = store->prev;
       }
-      if (ir->o == IR_TNEW && !irt_isnil(fins->t))
-	return 0;  /* Type instability in loop-carried dependency. */
-      if (irt_ispri(fins->t)) {
-	return TREF_PRI(irt_type(fins->t));
-      } else if (irt_isnum(fins->t) || (LJ_DUALNUM && irt_isint(fins->t)) ||
-		 irt_isstr(fins->t)) {
+      /* Simplified here: let loop_unroll() figure out any type instability. */
+      if (ir->o == IR_TNEW) {
+	return TREF_NIL;
+      } else {
 	TValue keyv;
 	cTValue *tv;
 	IRIns *key = IR(xr->op2);
 	if (key->o == IR_KSLOT) key = IR(key->op1);
 	lj_ir_kvalue(J->L, &keyv, key);
 	tv = lj_tab_get(J->L, ir_ktab(IR(ir->op1)), &keyv);
-	lj_assertJ(itype2irt(tv) == irt_type(fins->t),
-		   "mismatched type in constant table");
-	if (irt_isnum(fins->t))
+	if (tvispri(tv))
+	  return TREF_PRI(itype2irt(tv));
+	else if (tvisnum(tv))
 	  return lj_ir_knum_u64(J, tv->u64);
-	else if (LJ_DUALNUM && irt_isint(fins->t))
+	else if (tvisint(tv))
 	  return lj_ir_kint(J, intV(tv));
-	else
+	else if (tvisgcv(tv))
 	  return lj_ir_kstr(J, strV(tv));
       }
       /* Othwerwise: don't intern as a constant. */
@@ -370,7 +374,9 @@ TRef LJ_FASTCALL lj_opt_dse_ahstore(jit_State *J)
 	** since they are followed by at least one guarded VLOAD.
 	*/
 	for (ir = IR(J->cur.nins-1); ir > store; ir--)
-	  if (irt_isguard(ir->t) || ir->o == IR_ALEN)
+	  if (irt_isguard(ir->t) || ir->o == IR_ALEN ||
+              (ir->o == IR_CALLL && ir->op2 == IRCALL_lj_tab_nkeys) ||
+              (ir->o == IR_CALLS && ir->op2 == IRCALL_lj_tab_clone))
 	    goto doemit;  /* No elimination possible. */
 	/* Remove redundant store from chain and replace with NOP. */
 	*refp = store->prev;
@@ -458,18 +464,23 @@ doemit:
 */
 static AliasRet aa_uref(IRIns *refa, IRIns *refb)
 {
-  if (refa->o != refb->o)
-    return ALIAS_NO;  /* Different UREFx type. */
   if (refa->op1 == refb->op1) {  /* Same function. */
     if (refa->op2 == refb->op2)
       return ALIAS_MUST;  /* Same function, same upvalue idx. */
     else
       return ALIAS_NO;  /* Same function, different upvalue idx. */
   } else {  /* Different functions, check disambiguation hash values. */
-    if (((refa->op2 ^ refb->op2) & 0xff))
+    if (((refa->op2 ^ refb->op2) & 0xff)) {
       return ALIAS_NO;  /* Upvalues with different hash values cannot alias. */
-    else
-      return ALIAS_MAY;  /* No conclusion can be drawn for same hash value. */
+    } else if (refa->o != refb->o) {
+      /* Different UREFx type, but need to confirm the UREFO really is open. */
+      if (irt_type(refa->t) == IRT_IGC) refa->t.irt += IRT_PGC-IRT_IGC;
+      else if (irt_type(refb->t) == IRT_IGC) refb->t.irt += IRT_PGC-IRT_IGC;
+      return ALIAS_NO;
+    } else {
+      /* No conclusion can be drawn for same hash value and same UREFx type. */
+      return ALIAS_MAY;
+    }
   }
 }
 
@@ -951,6 +962,8 @@ int lj_opt_fwd_wasnonnil(jit_State *J, IROpT loadop, IRRef xref)
 	if (skref == xkref || !irref_isk(skref) || !irref_isk(xkref))
 	  return 0;  /* A nil store with same const key or var key MAY alias. */
 	/* Different const keys CANNOT alias. */
+      } else if (irt_isp32(IR(skref)->t) != irt_isp32(IR(xkref)->t)) {
+	return 0;  /* HREF and HREFK MAY alias. */
       }  /* Different key types CANNOT alias. */
     }  /* Other non-nil stores MAY alias. */
     ref = store->prev;
diff --git a/lib/luajit-3065c9/src/lj_opt_narrow.c b/lib/luajit2/src/lj_opt_narrow.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_opt_narrow.c
rename to lib/luajit2/src/lj_opt_narrow.c
index 586f1bc7f..1172df2b4 100644
--- a/lib/luajit-3065c9/src/lj_opt_narrow.c
+++ b/lib/luajit2/src/lj_opt_narrow.c
@@ -1,7 +1,7 @@
 /*
 ** NARROW: Narrowing of numbers to integers (double to int32_t).
 ** STRIPOV: Stripping of overflow checks.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_narrow_c
diff --git a/lib/luajit-3065c9/src/lj_opt_sink.c b/lib/luajit2/src/lj_opt_sink.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_opt_sink.c
rename to lib/luajit2/src/lj_opt_sink.c
index 4b9008be0..642ed7502 100644
--- a/lib/luajit-3065c9/src/lj_opt_sink.c
+++ b/lib/luajit2/src/lj_opt_sink.c
@@ -1,6 +1,6 @@
 /*
 ** SINK: Allocation Sinking and Store Sinking.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_sink_c
diff --git a/lib/luajit-3065c9/src/lj_opt_split.c b/lib/luajit2/src/lj_opt_split.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_opt_split.c
rename to lib/luajit2/src/lj_opt_split.c
index 506b98143..338a61a2d 100644
--- a/lib/luajit-3065c9/src/lj_opt_split.c
+++ b/lib/luajit2/src/lj_opt_split.c
@@ -1,6 +1,6 @@
 /*
 ** SPLIT: Split 64 bit IR instructions into 32 bit IR instructions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_opt_split_c
diff --git a/lib/luajit-3065c9/src/lj_parse.c b/lib/luajit2/src/lj_parse.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_parse.c
rename to lib/luajit2/src/lj_parse.c
index 9ddf60eda..423ad29e0 100644
--- a/lib/luajit-3065c9/src/lj_parse.c
+++ b/lib/luajit2/src/lj_parse.c
@@ -1,6 +1,6 @@
 /*
 ** Lua parser (source code -> bytecode).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -667,19 +667,20 @@ static void bcemit_store(FuncState *fs, ExpDesc *var, ExpDesc *e)
 /* Emit method lookup expression. */
 static void bcemit_method(FuncState *fs, ExpDesc *e, ExpDesc *key)
 {
-  BCReg idx, func, obj = expr_toanyreg(fs, e);
+  BCReg idx, func, fr2, obj = expr_toanyreg(fs, e);
   expr_free(fs, e);
   func = fs->freereg;
-  bcemit_AD(fs, BC_MOV, func+1+LJ_FR2, obj);  /* Copy object to 1st argument. */
+  fr2 = fs->ls->fr2;
+  bcemit_AD(fs, BC_MOV, func+1+fr2, obj);  /* Copy object to 1st argument. */
   lj_assertFS(expr_isstrk(key), "bad usage");
   idx = const_str(fs, key);
   if (idx <= BCMAX_C) {
-    bcreg_reserve(fs, 2+LJ_FR2);
+    bcreg_reserve(fs, 2+fr2);
     bcemit_ABC(fs, BC_TGETS, func, obj, idx);
   } else {
-    bcreg_reserve(fs, 3+LJ_FR2);
-    bcemit_AD(fs, BC_KSTR, func+2+LJ_FR2, idx);
-    bcemit_ABC(fs, BC_TGETV, func, obj, func+2+LJ_FR2);
+    bcreg_reserve(fs, 3+fr2);
+    bcemit_AD(fs, BC_KSTR, func+2+fr2, idx);
+    bcemit_ABC(fs, BC_TGETV, func, obj, func+2+fr2);
     fs->freereg--;
   }
   e->u.s.info = func;
@@ -964,22 +965,22 @@ static void bcemit_unop(FuncState *fs, BCOp op, ExpDesc *e)
 #if LJ_HASFFI
       if (e->k == VKCDATA) {  /* Fold in-place since cdata is not interned. */
 	GCcdata *cd = cdataV(&e->u.nval);
-	int64_t *p = (int64_t *)cdataptr(cd);
+	uint64_t *p = (uint64_t *)cdataptr(cd);
 	if (cd->ctypeid == CTID_COMPLEX_DOUBLE)
-	  p[1] ^= (int64_t)U64x(80000000,00000000);
+	  p[1] ^= U64x(80000000,00000000);
 	else
-	  *p = -*p;
+	  *p = ~*p+1u;
 	return;
       } else
 #endif
       if (expr_isnumk(e) && !expr_numiszero(e)) {  /* Avoid folding to -0. */
 	TValue *o = expr_numtv(e);
 	if (tvisint(o)) {
-	  int32_t k = intV(o);
-	  if (k == -k)
+	  int32_t k = intV(o), negk = (int32_t)(~(uint32_t)k+1u);
+	  if (k == negk)
 	    setnumV(o, -(lua_Number)k);
 	  else
-	    setintV(o, -k);
+	    setintV(o, negk);
 	  return;
 	} else {
 	  o->u64 ^= U64x(80000000,00000000);
@@ -1326,9 +1327,12 @@ static void fs_fixup_bc(FuncState *fs, GCproto *pt, BCIns *bc, MSize n)
 {
   BCInsLine *base = fs->bcbase;
   MSize i;
+  BCIns op;
   pt->sizebc = n;
-  bc[0] = BCINS_AD((fs->flags & PROTO_VARARG) ? BC_FUNCV : BC_FUNCF,
-		   fs->framesize, 0);
+  if (fs->ls->fr2 != LJ_FR2) op = BC_NOT;  /* Mark non-native prototype. */
+  else if ((fs->flags & PROTO_VARARG)) op = BC_FUNCV;
+  else op = BC_FUNCF;
+  bc[0] = BCINS_AD(op, fs->framesize, 0);
   for (i = 1; i < n; i++)
     bc[i] = base[i].ins;
 }
@@ -1752,7 +1756,8 @@ static void expr_table(LexState *ls, ExpDesc *e)
     expr(ls, &val);
     if (expr_isk(&key) && key.k != VKNIL &&
 	(key.k == VKSTR || expr_isk_nojump(&val))) {
-      TValue k, *v;
+      TValue k = {0};
+      TValue *v;
       if (!t) {  /* Create template table on demand. */
 	BCReg kidx;
 	t = lj_tab_new(fs->L, needarr ? narr : 0, hsize2hbits(nhash));
@@ -1936,11 +1941,11 @@ static void parse_args(LexState *ls, ExpDesc *e)
   lj_assertFS(e->k == VNONRELOC, "bad expr type %d", e->k);
   base = e->u.s.info;  /* Base register for call. */
   if (args.k == VCALL) {
-    ins = BCINS_ABC(BC_CALLM, base, 2, args.u.s.aux - base - 1 - LJ_FR2);
+    ins = BCINS_ABC(BC_CALLM, base, 2, args.u.s.aux - base - 1 - ls->fr2);
   } else {
     if (args.k != VVOID)
       expr_tonextreg(fs, &args);
-    ins = BCINS_ABC(BC_CALL, base, 2, fs->freereg - base - LJ_FR2);
+    ins = BCINS_ABC(BC_CALL, base, 2, fs->freereg - base - ls->fr2);
   }
   expr_init(e, VCALL, bcemit_INS(fs, ins));
   e->u.s.aux = base;
@@ -1980,7 +1985,7 @@ static void expr_primary(LexState *ls, ExpDesc *v)
       parse_args(ls, v);
     } else if (ls->tok == '(' || ls->tok == TK_string || ls->tok == '{') {
       expr_tonextreg(fs, v);
-      if (LJ_FR2) bcreg_reserve(fs, 1);
+      if (ls->fr2) bcreg_reserve(fs, 1);
       parse_args(ls, v);
     } else {
       break;
@@ -2513,11 +2518,14 @@ static void parse_for_num(LexState *ls, GCstr *varname, BCLine line)
 */
 static int predict_next(LexState *ls, FuncState *fs, BCPos pc)
 {
-  BCIns ins = fs->bcbase[pc].ins;
+  BCIns ins;
   GCstr *name;
   cTValue *o;
+  if (pc >= fs->bclim) return 0;
+  ins = fs->bcbase[pc].ins;
   switch (bc_op(ins)) {
   case BC_MOV:
+    if (bc_d(ins) >= fs->nactvar) return 0;
     name = gco2str(gcref(var_get(ls, fs, bc_d(ins)).name));
     break;
   case BC_UGET:
@@ -2562,7 +2570,7 @@ static void parse_for_iter(LexState *ls, GCstr *indexname)
   line = ls->linenumber;
   assign_adjust(ls, 3, expr_list(ls, &e), &e);
   /* The iterator needs another 3 [4] slots (func [pc] | state ctl). */
-  bcreg_bump(fs, 3+LJ_FR2);
+  bcreg_bump(fs, 3+ls->fr2);
   isnext = (nvars <= 5 && predict_next(ls, fs, exprpc));
   var_add(ls, 3);  /* Hidden control variables. */
   lex_check(ls, TK_do);
diff --git a/lib/luajit-3065c9/src/lj_parse.h b/lib/luajit2/src/lj_parse.h
similarity index 84%
rename from lib/luajit-3065c9/src/lj_parse.h
rename to lib/luajit2/src/lj_parse.h
index 4206f00e8..503dba086 100644
--- a/lib/luajit-3065c9/src/lj_parse.h
+++ b/lib/luajit2/src/lj_parse.h
@@ -1,6 +1,6 @@
 /*
 ** Lua parser (source code -> bytecode).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_PARSE_H
diff --git a/lib/luajit-3065c9/src/lj_prng.c b/lib/luajit2/src/lj_prng.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_prng.c
rename to lib/luajit2/src/lj_prng.c
index 9e57505e8..326b41e60 100644
--- a/lib/luajit-3065c9/src/lj_prng.c
+++ b/lib/luajit2/src/lj_prng.c
@@ -1,6 +1,6 @@
 /*
 ** Pseudo-random number generation.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_prng_c
@@ -125,7 +125,7 @@ static PRGR libfunc_rgr;
 #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 101200
 #define LJ_TARGET_HAS_GETENTROPY	1
 #endif
-#elif (LJ_TARGET_BSD && !defined(__NetBSD__)) || LJ_TARGET_SOLARIS || LJ_TARGET_CYGWIN
+#elif (LJ_TARGET_BSD && !defined(__NetBSD__)) || LJ_TARGET_SOLARIS || LJ_TARGET_CYGWIN || LJ_TARGET_QNX
 #define LJ_TARGET_HAS_GETENTROPY	1
 #endif
 
diff --git a/lib/luajit-3065c9/src/lj_prng.h b/lib/luajit2/src/lj_prng.h
similarity index 90%
rename from lib/luajit-3065c9/src/lj_prng.h
rename to lib/luajit2/src/lj_prng.h
index bdc958ab1..3dd9dbc00 100644
--- a/lib/luajit-3065c9/src/lj_prng.h
+++ b/lib/luajit2/src/lj_prng.h
@@ -1,6 +1,6 @@
 /*
 ** Pseudo-random number generation.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_PRNG_H
diff --git a/lib/luajit-3065c9/src/lj_profile.c b/lib/luajit2/src/lj_profile.c
similarity index 98%
rename from lib/luajit-3065c9/src/lj_profile.c
rename to lib/luajit2/src/lj_profile.c
index f0af91cb2..8cefd5fb3 100644
--- a/lib/luajit-3065c9/src/lj_profile.c
+++ b/lib/luajit2/src/lj_profile.c
@@ -1,6 +1,6 @@
 /*
 ** Low-overhead profiling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_profile_c
@@ -185,7 +185,11 @@ static void profile_timer_start(ProfileState *ps)
   tm.it_value.tv_sec = tm.it_interval.tv_sec = interval / 1000;
   tm.it_value.tv_usec = tm.it_interval.tv_usec = (interval % 1000) * 1000;
   setitimer(ITIMER_PROF, &tm, NULL);
+#if LJ_TARGET_QNX
+  sa.sa_flags = 0;
+#else
   sa.sa_flags = SA_RESTART;
+#endif
   sa.sa_handler = profile_signal;
   sigemptyset(&sa.sa_mask);
   sigaction(SIGPROF, &sa, &ps->oldsa);
diff --git a/lib/luajit-3065c9/src/lj_profile.h b/lib/luajit2/src/lj_profile.h
similarity index 85%
rename from lib/luajit-3065c9/src/lj_profile.h
rename to lib/luajit2/src/lj_profile.h
index 3969f8e84..68bb9a1f5 100644
--- a/lib/luajit-3065c9/src/lj_profile.h
+++ b/lib/luajit2/src/lj_profile.h
@@ -1,6 +1,6 @@
 /*
 ** Low-overhead profiling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_PROFILE_H
diff --git a/lib/luajit-3065c9/src/lj_record.c b/lib/luajit2/src/lj_record.c
similarity index 97%
rename from lib/luajit-3065c9/src/lj_record.c
rename to lib/luajit2/src/lj_record.c
index 92bdbfc95..5f36ab883 100644
--- a/lib/luajit-3065c9/src/lj_record.c
+++ b/lib/luajit2/src/lj_record.c
@@ -1,6 +1,6 @@
 /*
 ** Trace recorder (bytecode -> SSA IR).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_record_c
@@ -116,6 +116,7 @@ static void rec_check_slots(jit_State *J)
       cTValue *tv = &base[s];
       IRRef ref = tref_ref(tr);
       IRIns *ir = NULL;  /* Silence compiler. */
+      lj_assertJ(tv < J->L->top, "slot %d above top of Lua stack", s);
       if (!LJ_FR2 || ref || !(tr & (TREF_FRAME | TREF_CONT))) {
 	lj_assertJ(ref >= J->cur.nk && ref < J->cur.nins,
 		   "slot %d ref %04d out of range", s, ref - REF_BIAS);
@@ -624,7 +625,7 @@ static void rec_loop_interp(jit_State *J, const BCIns *pc, LoopEvent ev)
       if (bc_j(*pc) != -1 && !innerloopleft(J, pc))
 	lj_trace_err(J, LJ_TRERR_LINNER);  /* Root trace hit an inner loop. */
       if ((ev != LOOPEV_ENTERLO &&
-	   J->loopref && J->cur.nins - J->loopref > 24) || --J->loopunroll < 0)
+	   J->loopref && J->cur.nins - J->loopref > 100) || --J->loopunroll < 0)
 	lj_trace_err(J, LJ_TRERR_LUNROLL);  /* Limit loop unrolling. */
       J->loopref = J->cur.nins;
     }
@@ -902,6 +903,7 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
 {
   TValue *frame = J->L->base - 1;
   ptrdiff_t i;
+  BCReg baseadj = 0;
   for (i = 0; i < gotresults; i++)
     (void)getslot(J, rbase+i);  /* Ensure all results have a reference. */
   while (frame_ispcall(frame)) {  /* Immediately resolve pcall() returns. */
@@ -910,6 +912,7 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
       lj_trace_err(J, LJ_TRERR_NYIRETL);
     lj_assertJ(J->baseslot > 1+LJ_FR2, "bad baseslot for return");
     gotresults++;
+    baseadj += cbase;
     rbase += cbase;
     J->baseslot -= (BCReg)cbase;
     J->base -= cbase;
@@ -934,6 +937,7 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
     if (--J->framedepth < 0)  /* NYI: return of vararg func to lower frame. */
       lj_trace_err(J, LJ_TRERR_NYIRETL);
     lj_assertJ(J->baseslot > 1+LJ_FR2, "bad baseslot for return");
+    baseadj += cbase;
     rbase += cbase;
     J->baseslot -= (BCReg)cbase;
     J->base -= cbase;
@@ -947,7 +951,7 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
     if ((pt->flags & PROTO_NOJIT))
       lj_trace_err(J, LJ_TRERR_CJITOFF);
     if (J->framedepth == 0 && J->pt && frame == J->L->base - 1) {
-      if (check_downrec_unroll(J, pt)) {
+      if (!J->cur.root && check_downrec_unroll(J, pt)) {
 	J->maxslot = (BCReg)(rbase + gotresults);
 	lj_snap_purge(J);
 	lj_record_stop(J, LJ_TRLINK_DOWNREC, J->cur.traceno);  /* Down-rec. */
@@ -969,12 +973,15 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
       lj_trace_err(J, LJ_TRERR_LLEAVE);
     } else if (J->needsnap) {  /* Tailcalled to ff with side-effects. */
       lj_trace_err(J, LJ_TRERR_NYIRETL);  /* No way to insert snapshot here. */
+    } else if (1 + pt->framesize >= LJ_MAX_JSLOTS) {
+      lj_trace_err(J, LJ_TRERR_STACKOV);
     } else {  /* Return to lower frame. Guard for the target we return to. */
       TRef trpt = lj_ir_kgc(J, obj2gco(pt), IRT_PROTO);
       TRef trpc = lj_ir_kptr(J, (void *)frame_pc(frame));
       emitir(IRTG(IR_RETF, IRT_PGC), trpt, trpc);
       J->retdepth++;
       J->needsnap = 1;
+      J->scev.idx = REF_NIL;
       lj_assertJ(J->baseslot == 1+LJ_FR2, "bad baseslot for return");
       /* Shift result slots up and clear the slots of the new frame below. */
       memmove(J->base + cbase, J->base-1-LJ_FR2, sizeof(TRef)*nresults);
@@ -1001,7 +1008,8 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
       BCReg bslot = bc_b(*(frame_contpc(frame)-1));
       TRef tr = gotresults ? J->base[cbase+rbase] : TREF_NIL;
       if (bslot != J->maxslot) {  /* Concatenate the remainder. */
-	TValue *b = J->L->base, save;  /* Simulate lower frame and result. */
+	/* Simulate lower frame and result. */
+	TValue *b = J->L->base - baseadj, save;
 	/* Can't handle MM_concat + CALLT + fast func side-effects. */
 	if (J->postproc != LJ_POST_NONE)
 	  lj_trace_err(J, LJ_TRERR_NYIRETL);
@@ -1014,7 +1022,7 @@ void lj_record_ret(jit_State *J, BCReg rbase, ptrdiff_t gotresults)
 	J->L->base = b - cbase;
 	tr = rec_cat(J, bslot, cbase-(2<<LJ_FR2));
 	b = J->L->base + cbase;  /* Undo. */
-	J->L->base = b;
+	J->L->base = b + baseadj;
 	copyTV(J->L, b-(2<<LJ_FR2), &save);
       }
       if (tr) {  /* Store final result. */
@@ -1598,8 +1606,16 @@ TRef lj_record_idx(jit_State *J, RecordIndex *ix)
       lj_assertJ(!hasmm, "inconsistent metamethod handling");
       if (oldv == niltvg(J2G(J))) {  /* Need to insert a new key. */
 	TRef key = ix->key;
-	if (tref_isinteger(key))  /* NEWREF needs a TValue as a key. */
+	if (tref_isinteger(key)) {  /* NEWREF needs a TValue as a key. */
 	  key = emitir(IRTN(IR_CONV), key, IRCONV_NUM_INT);
+	} else if (tref_isnum(key)) {
+	  if (tref_isk(key)) {
+	    if (tvismzero(&ix->keyv))
+	      key = lj_ir_knum_zero(J);  /* Canonicalize -0.0 to +0.0. */
+	  } else {
+	    emitir(IRTG(IR_EQ, IRT_NUM), key, key);  /* Check for !NaN. */
+	  }
+	}
 	xref = emitir(IRT(IR_NEWREF, IRT_PGC), ix->tab, key);
 	keybarrier = 0;  /* NEWREF already takes care of the key barrier. */
 #ifdef LUAJIT_ENABLE_TABLE_BUMP
@@ -1763,16 +1779,16 @@ noconstify:
   /* Note: this effectively limits LJ_MAX_UPVAL to 127. */
   uv = (uv << 8) | (hashrot(uvp->dhash, uvp->dhash + HASH_BIAS) & 0xff);
   if (!uvp->closed) {
-    uref = tref_ref(emitir(IRTG(IR_UREFO, IRT_PGC), fn, uv));
     /* In current stack? */
     if (uvval(uvp) >= tvref(J->L->stack) &&
 	uvval(uvp) < tvref(J->L->maxstack)) {
       int32_t slot = (int32_t)(uvval(uvp) - (J->L->base - J->baseslot));
       if (slot >= 0) {  /* Aliases an SSA slot? */
+	uref = tref_ref(emitir(IRT(IR_UREFO, IRT_PGC), fn, uv));
 	emitir(IRTG(IR_EQ, IRT_PGC),
 	       REF_BASE,
 	       emitir(IRT(IR_ADD, IRT_PGC), uref,
-		      lj_ir_kint(J, (slot - 1 - LJ_FR2) * -8)));
+		      lj_ir_kintpgc(J, (slot - 1 - LJ_FR2) * -8)));
 	slot -= (int32_t)J->baseslot;  /* Note: slot number may be negative! */
 	if (val == 0) {
 	  return getslot(J, slot);
@@ -1783,12 +1799,21 @@ noconstify:
 	}
       }
     }
+    /* IR_UREFO+IRT_IGC is not checked for open-ness at runtime.
+    ** Always marked as a guard, since it might get promoted to IRT_PGC later.
+    */
+    uref = emitir(IRTG(IR_UREFO, tref_isgcv(val) ? IRT_PGC : IRT_IGC), fn, uv);
+    uref = tref_ref(uref);
     emitir(IRTG(IR_UGT, IRT_PGC),
 	   emitir(IRT(IR_SUB, IRT_PGC), uref, REF_BASE),
-	   lj_ir_kint(J, (J->baseslot + J->maxslot) * 8));
+	   lj_ir_kintpgc(J, (J->baseslot + J->maxslot) * 8));
   } else {
+    /* If fn is constant, then so is the GCupval*, and the upvalue cannot
+    ** transition back to open, so no guard is required in this case.
+    */
+    IRType t = (tref_isk(fn) ? 0 : IRT_GUARD) | IRT_PGC;
+    uref = tref_ref(emitir(IRT(IR_UREFC, t), fn, uv));
     needbarrier = 1;
-    uref = tref_ref(emitir(IRTG(IR_UREFC, IRT_PGC), fn, uv));
   }
   if (val == 0) {  /* Upvalue load */
     IRType t = itype2irt(uvval(uvp));
@@ -1836,7 +1861,7 @@ static void check_call_unroll(jit_State *J, TraceNo lnk)
       if (lnk) {  /* Possible tail- or up-recursion. */
 	lj_trace_flush(J, lnk);  /* Flush trace that only returns. */
 	/* Set a small, pseudo-random hotcount for a quick retry of JFUNC*. */
-	hotcount_set(J2GG(J), J->pc+1, lj_prng_u64(&J2G(J)->prng) & 15u);
+	hotcount_set(J2GG(J), J->pc+1, lj_prng_u64(&J->prng) & 15u);
       }
       lj_trace_err(J, LJ_TRERR_CUNROLL);
     }
@@ -1939,12 +1964,14 @@ static void rec_varg(jit_State *J, BCReg dst, ptrdiff_t nresults)
   if (J->framedepth > 0) {  /* Simple case: varargs defined on-trace. */
     ptrdiff_t i;
     if (nvararg < 0) nvararg = 0;
-    if (nresults == -1) {
-      nresults = nvararg;
-      J->maxslot = dst + (BCReg)nvararg;
-    } else if (dst + nresults > J->maxslot) {
+    if (nresults != 1) {
+      if (nresults == -1) nresults = nvararg;
       J->maxslot = dst + (BCReg)nresults;
+    } else if (dst >= J->maxslot) {
+      J->maxslot = dst + 1;
     }
+    if (J->baseslot + J->maxslot >= LJ_MAX_JSLOTS)
+      lj_trace_err(J, LJ_TRERR_STACKOV);
     for (i = 0; i < nresults; i++)
       J->base[dst+i] = i < nvararg ? getslot(J, i - nvararg - 1 - LJ_FR2) : TREF_NIL;
   } else {  /* Unknown number of varargs passed to trace. */
@@ -1961,10 +1988,11 @@ static void rec_varg(jit_State *J, BCReg dst, ptrdiff_t nresults)
 	  emitir(IRTGI(IR_EQ), fr,
 		 lj_ir_kint(J, (int32_t)frame_ftsz(J->L->base-1)));
 	vbase = emitir(IRT(IR_SUB, IRT_IGC), REF_BASE, fr);
-	vbase = emitir(IRT(IR_ADD, IRT_PGC), vbase, lj_ir_kint(J, frofs-8*(1+LJ_FR2)));
+	vbase = emitir(IRT(IR_ADD, IRT_PGC), vbase,
+		       lj_ir_kintpgc(J, frofs-8*(1+LJ_FR2)));
 	for (i = 0; i < nload; i++) {
 	  IRType t = itype2irt(&J->L->base[i-1-LJ_FR2-nvararg]);
-	  J->base[dst+i] = lj_record_vload(J, vbase, i, t);
+	  J->base[dst+i] = lj_record_vload(J, vbase, (MSize)i, t);
 	}
       } else {
 	emitir(IRTGI(IR_LE), fr, lj_ir_kint(J, frofs));
@@ -1972,15 +2000,19 @@ static void rec_varg(jit_State *J, BCReg dst, ptrdiff_t nresults)
       }
       for (i = nvararg; i < nresults; i++)
 	J->base[dst+i] = TREF_NIL;
-      if (dst + (BCReg)nresults > J->maxslot)
+      if (nresults != 1 || dst >= J->maxslot) {
 	J->maxslot = dst + (BCReg)nresults;
+      }
     } else if (select_detect(J)) {  /* y = select(x, ...) */
       TRef tridx = J->base[dst-1];
       TRef tr = TREF_NIL;
       ptrdiff_t idx = lj_ffrecord_select_mode(J, tridx, &J->L->base[dst-1]);
       if (idx < 0) goto nyivarg;
-      if (idx != 0 && !tref_isinteger(tridx))
+      if (idx != 0 && !tref_isinteger(tridx)) {
+	if (tref_isstr(tridx))
+	  tridx = emitir(IRTG(IR_STRTO, IRT_NUM), tridx, 0);
 	tridx = emitir(IRTGI(IR_CONV), tridx, IRCONV_INT_NUM|IRCONV_INDEX);
+      }
       if (idx != 0 && tref_isk(tridx)) {
 	emitir(IRTGI(idx <= nvararg ? IR_GE : IR_LT),
 	       fr, lj_ir_kint(J, frofs+8*(int32_t)idx));
@@ -2008,7 +2040,7 @@ static void rec_varg(jit_State *J, BCReg dst, ptrdiff_t nresults)
 	IRType t;
 	TRef aref, vbase = emitir(IRT(IR_SUB, IRT_IGC), REF_BASE, fr);
 	vbase = emitir(IRT(IR_ADD, IRT_PGC), vbase,
-		       lj_ir_kint(J, frofs-(8<<LJ_FR2)));
+		       lj_ir_kintpgc(J, frofs-(8<<LJ_FR2)));
 	t = itype2irt(&J->L->base[idx-2-LJ_FR2-nvararg]);
 	aref = emitir(IRT(IR_AREF, IRT_PGC), vbase, tridx);
 	tr = lj_record_vload(J, aref, 0, t);
@@ -2022,8 +2054,6 @@ static void rec_varg(jit_State *J, BCReg dst, ptrdiff_t nresults)
       lj_trace_err_info(J, LJ_TRERR_NYIBC);
     }
   }
-  if (J->baseslot + J->maxslot >= LJ_MAX_JSLOTS)
-    lj_trace_err(J, LJ_TRERR_STACKOV);
 }
 
 /* -- Record allocations -------------------------------------------------- */
@@ -2475,6 +2505,7 @@ void lj_record_ins(jit_State *J)
 
   case BC_TSETM:
     rec_tsetm(J, ra, (BCReg)(J->L->top - J->L->base), (int32_t)rcv->u32.lo);
+    J->maxslot = ra;  /* The table slot at ra-1 is the highest used slot. */
     break;
 
   case BC_TNEW:
@@ -2572,7 +2603,8 @@ void lj_record_ins(jit_State *J)
     break;
   case BC_JLOOP:
     rec_loop_jit(J, rc, rec_loop(J, ra,
-				 !bc_isret(bc_op(traceref(J, rc)->startins))));
+				 !bc_isret(bc_op(traceref(J, rc)->startins)) &&
+				 bc_op(traceref(J, rc)->startins) != BC_ITERN));
     break;
 
   case BC_IFORL:
diff --git a/lib/luajit-3065c9/src/lj_record.h b/lib/luajit2/src/lj_record.h
similarity index 96%
rename from lib/luajit-3065c9/src/lj_record.h
rename to lib/luajit2/src/lj_record.h
index ab2f4c8db..61ccb3956 100644
--- a/lib/luajit-3065c9/src/lj_record.h
+++ b/lib/luajit2/src/lj_record.h
@@ -1,6 +1,6 @@
 /*
 ** Trace recorder (bytecode -> SSA IR).
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_RECORD_H
diff --git a/lib/luajit-3065c9/src/lj_serialize.c b/lib/luajit2/src/lj_serialize.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_serialize.c
rename to lib/luajit2/src/lj_serialize.c
index f7e518281..83881766c 100644
--- a/lib/luajit-3065c9/src/lj_serialize.c
+++ b/lib/luajit2/src/lj_serialize.c
@@ -1,6 +1,6 @@
 /*
 ** Object de/serialization.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_serialize_c
diff --git a/lib/luajit-3065c9/src/lj_serialize.h b/lib/luajit2/src/lj_serialize.h
similarity index 92%
rename from lib/luajit-3065c9/src/lj_serialize.h
rename to lib/luajit2/src/lj_serialize.h
index d3f4275ad..da8235736 100644
--- a/lib/luajit-3065c9/src/lj_serialize.h
+++ b/lib/luajit2/src/lj_serialize.h
@@ -1,6 +1,6 @@
 /*
 ** Object de/serialization.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_SERIALIZE_H
diff --git a/lib/luajit-3065c9/src/lj_snap.c b/lib/luajit2/src/lj_snap.c
similarity index 95%
rename from lib/luajit-3065c9/src/lj_snap.c
rename to lib/luajit2/src/lj_snap.c
index 4140fdb78..f3645e876 100644
--- a/lib/luajit-3065c9/src/lj_snap.c
+++ b/lib/luajit2/src/lj_snap.c
@@ -1,6 +1,6 @@
 /*
 ** Snapshot handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_snap_c
@@ -453,6 +453,7 @@ static TRef snap_replay_const(jit_State *J, IRIns *ir)
   case IR_KNUM: case IR_KINT64:
     return lj_ir_k64(J, (IROp)ir->o, ir_k64(ir)->u64);
   case IR_KPTR: return lj_ir_kptr(J, ir_kptr(ir));  /* Continuation. */
+  case IR_KNULL: return lj_ir_knull(J, irt_type(ir->t));
   default: lj_assertJ(0, "bad IR constant op %d", ir->o); return TREF_NIL;
   }
 }
@@ -557,13 +558,15 @@ void lj_snap_replay(jit_State *J, GCtrace *T)
       IRRef refp = snap_ref(sn);
       IRIns *ir = &T->ir[refp];
       if (regsp_reg(ir->r) == RID_SUNK) {
+	uint8_t m;
 	if (J->slot[snap_slot(sn)] != snap_slot(sn)) continue;
 	pass23 = 1;
 	lj_assertJ(ir->o == IR_TNEW || ir->o == IR_TDUP ||
 		   ir->o == IR_CNEW || ir->o == IR_CNEWI,
 		   "sunk parent IR %04d has bad op %d", refp - REF_BIAS, ir->o);
-	if (ir->op1 >= T->nk) snap_pref(J, T, map, nent, seen, ir->op1);
-	if (ir->op2 >= T->nk) snap_pref(J, T, map, nent, seen, ir->op2);
+	m = lj_ir_mode[ir->o];
+	if (irm_op1(m) == IRMref) snap_pref(J, T, map, nent, seen, ir->op1);
+	if (irm_op2(m) == IRMref) snap_pref(J, T, map, nent, seen, ir->op2);
 	if (LJ_HASFFI && ir->o == IR_CNEWI) {
 	  if (LJ_32 && refp+1 < T->nins && (ir+1)->o == IR_HIOP)
 	    snap_pref(J, T, map, nent, seen, (ir+1)->op2);
@@ -591,14 +594,16 @@ void lj_snap_replay(jit_State *J, GCtrace *T)
       IRIns *ir = &T->ir[refp];
       if (regsp_reg(ir->r) == RID_SUNK) {
 	TRef op1, op2;
+	uint8_t m;
 	if (J->slot[snap_slot(sn)] != snap_slot(sn)) {  /* De-dup allocs. */
 	  J->slot[snap_slot(sn)] = J->slot[J->slot[snap_slot(sn)]];
 	  continue;
 	}
 	op1 = ir->op1;
-	if (op1 >= T->nk) op1 = snap_pref(J, T, map, nent, seen, op1);
+	m = lj_ir_mode[ir->o];
+	if (irm_op1(m) == IRMref) op1 = snap_pref(J, T, map, nent, seen, op1);
 	op2 = ir->op2;
-	if (op2 >= T->nk) op2 = snap_pref(J, T, map, nent, seen, op2);
+	if (irm_op2(m) == IRMref) op2 = snap_pref(J, T, map, nent, seen, op2);
 	if (LJ_HASFFI && ir->o == IR_CNEWI) {
 	  if (LJ_32 && refp+1 < T->nins && (ir+1)->o == IR_HIOP) {
 	    lj_needsplit(J);  /* Emit joining HIOP. */
@@ -624,9 +629,25 @@ void lj_snap_replay(jit_State *J, GCtrace *T)
 		if (irr->o == IR_HREFK || irr->o == IR_AREF) {
 		  IRIns *irf = &T->ir[irr->op1];
 		  tmp = emitir(irf->ot, tmp, irf->op2);
+		} else if (irr->o == IR_NEWREF) {
+		  IRRef allocref = tref_ref(tr);
+		  IRRef keyref = tref_ref(key);
+		  IRRef newref_ref = J->chain[IR_NEWREF];
+		  IRIns *newref = &J->cur.ir[newref_ref];
+		  lj_assertJ(irref_isk(keyref),
+			     "sunk store for parent IR %04d with bad key %04d",
+			     refp - REF_BIAS, keyref - REF_BIAS);
+		  if (newref_ref > allocref && newref->op2 == keyref) {
+		    lj_assertJ(newref->op1 == allocref,
+			       "sunk store for parent IR %04d with bad tab %04d",
+			       refp - REF_BIAS, allocref - REF_BIAS);
+		    tmp = newref_ref;
+		    goto skip_newref;
+		  }
 		}
 	      }
 	      tmp = emitir(irr->ot, tmp, key);
+	    skip_newref:
 	      val = snap_pref(J, T, map, nent, seen, irs->op2);
 	      if (val == 0) {
 		IRIns *irc = &T->ir[irs->op2];
@@ -880,11 +901,23 @@ static void snap_unsink(jit_State *J, GCtrace *T, ExitState *ex,
 		   irs->o == IR_FSTORE,
 		   "sunk store with bad op %d", irs->o);
 	if (irk->o == IR_FREF) {
-	  lj_assertJ(irk->op2 == IRFL_TAB_META,
-		     "sunk store with bad field %d", irk->op2);
-	  snap_restoreval(J, T, ex, snapno, rfilt, irs->op2, &tmp);
-	  /* NOBARRIER: The table is new (marked white). */
-	  setgcref(t->metatable, obj2gco(tabV(&tmp)));
+	  switch (irk->op2) {
+	  case IRFL_TAB_META:
+	    if (T->ir[irs->op2].o == IR_KNULL) {
+	      setgcrefnull(t->metatable);
+	    } else {
+	      snap_restoreval(J, T, ex, snapno, rfilt, irs->op2, &tmp);
+	      /* NOBARRIER: The table is new (marked white). */
+	      setgcref(t->metatable, obj2gco(tabV(&tmp)));
+	    }
+	    break;
+	  case IRFL_TAB_NOMM:
+	    /* Negative metamethod cache invalidated by lj_tab_set() below. */
+	    break;
+	  default:
+	    lj_assertJ(0, "sunk store with bad field %d", irk->op2);
+	    break;
+	  }
 	} else {
 	  irk = &T->ir[irk->op2];
 	  if (irk->o == IR_KSLOT) irk = &T->ir[irk->op1];
diff --git a/lib/luajit-3065c9/src/lj_snap.h b/lib/luajit2/src/lj_snap.h
similarity index 93%
rename from lib/luajit-3065c9/src/lj_snap.h
rename to lib/luajit2/src/lj_snap.h
index b7dabed80..089d86bbc 100644
--- a/lib/luajit-3065c9/src/lj_snap.h
+++ b/lib/luajit2/src/lj_snap.h
@@ -1,6 +1,6 @@
 /*
 ** Snapshot handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_SNAP_H
diff --git a/lib/luajit-3065c9/src/lj_state.c b/lib/luajit2/src/lj_state.c
similarity index 80%
rename from lib/luajit-3065c9/src/lj_state.c
rename to lib/luajit2/src/lj_state.c
index 0b9c46baf..1b793da98 100644
--- a/lib/luajit-3065c9/src/lj_state.c
+++ b/lib/luajit2/src/lj_state.c
@@ -1,6 +1,6 @@
 /*
 ** State and stack handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -102,20 +102,49 @@ void lj_state_shrinkstack(lua_State *L, MSize used)
 /* Try to grow stack. */
 void LJ_FASTCALL lj_state_growstack(lua_State *L, MSize need)
 {
-  MSize n;
-  if (L->stacksize > LJ_STACK_MAXEX)  /* Overflow while handling overflow? */
-    lj_err_throw(L, LUA_ERRERR);
-  n = L->stacksize + need;
-  if (n > LJ_STACK_MAX) {
-    n += 2*LUA_MINSTACK;
-  } else if (n < 2*L->stacksize) {
-    n = 2*L->stacksize;
-    if (n >= LJ_STACK_MAX)
-      n = LJ_STACK_MAX;
+  MSize n = L->stacksize + need;
+  if (LJ_LIKELY(n < LJ_STACK_MAX)) {  /* The stack can grow as requested. */
+    if (n < 2 * L->stacksize) {  /* Try to double the size. */
+      n = 2 * L->stacksize;
+      if (n > LJ_STACK_MAX)
+	n = LJ_STACK_MAX;
+    }
+    resizestack(L, n);
+  } else {  /* Request would overflow. Raise a stack overflow error. */
+    if (LJ_HASJIT) {
+      TValue *base = tvref(G(L)->jit_base);
+      if (base) L->base = base;
+    }
+    if (curr_funcisL(L)) {
+      L->top = curr_topL(L);
+      if (L->top > tvref(L->maxstack)) {
+	/* The current Lua frame violates the stack, so replace it with a
+	** dummy. This can happen when BC_IFUNCF is trying to grow the stack.
+	*/
+	L->top = L->base;
+	setframe_gc(L->base - 1 - LJ_FR2, obj2gco(L), LJ_TTHREAD);
+      }
+    }
+    if (L->stacksize <= LJ_STACK_MAXEX) {
+      /* An error handler might want to inspect the stack overflow error, but
+      ** will need some stack space to run in. We give it a stack size beyond
+      ** the normal limit in order to do so, then rely on lj_state_relimitstack
+      ** calls during unwinding to bring us back to a convential stack size.
+      ** The + 1 is space for the error message, and 2 * LUA_MINSTACK is for
+      ** the lj_state_checkstack() call in lj_err_run().
+      */
+      resizestack(L, LJ_STACK_MAX + 1 + 2 * LUA_MINSTACK);
+      lj_err_stkov(L);  /* May invoke an error handler. */
+    } else {
+      /* If we're here, then the stack overflow error handler is requesting
+      ** to grow the stack even further. We have no choice but to abort the
+      ** error handler.
+      */
+      GCstr *em = lj_err_str(L, LJ_ERR_STKOV);  /* Might OOM. */
+      setstrV(L, L->top++, em);  /* There is always space to push an error. */
+      lj_err_throw(L, LUA_ERRERR);  /* Does not invoke an error handler. */
+    }
   }
-  resizestack(L, n);
-  if (L->stacksize > LJ_STACK_MAXEX)
-    lj_err_msg(L, LJ_ERR_STKOV);
 }
 
 void LJ_FASTCALL lj_state_growstack1(lua_State *L)
@@ -123,6 +152,18 @@ void LJ_FASTCALL lj_state_growstack1(lua_State *L)
   lj_state_growstack(L, 1);
 }
 
+static TValue *cpgrowstack(lua_State *co, lua_CFunction dummy, void *ud)
+{
+  UNUSED(dummy);
+  lj_state_growstack(co, *(MSize *)ud);
+  return NULL;
+}
+
+int LJ_FASTCALL lj_state_cpgrowstack(lua_State *L, MSize need)
+{
+  return lj_vm_cpcall(L, NULL, &need, cpgrowstack);
+}
+
 /* Allocate basic stack for new state. */
 static void stack_init(lua_State *L1, lua_State *L)
 {
@@ -260,6 +301,8 @@ LUA_API lua_State *lua_newstate(lua_Alloc allocf, void *allocd)
     return NULL;
   }
   L->status = LUA_OK;
+  L->exdata = NULL;
+  L->exdata2 = NULL;
   return L;
 }
 
@@ -319,6 +362,8 @@ lua_State *lj_state_new(lua_State *L)
   setgcrefr(L1->env, L->env);
   stack_init(L1, L);  /* init stack */
   lj_assertL(iswhite(obj2gco(L1)), "new thread object is not white");
+  L1->exdata = L->exdata;
+  L1->exdata2 = L->exdata2;
   return L1;
 }
 
@@ -327,8 +372,11 @@ void LJ_FASTCALL lj_state_free(global_State *g, lua_State *L)
   lj_assertG(L != mainthread(g), "free of main thread");
   if (obj2gco(L) == gcref(g->cur_L))
     setgcrefnull(g->cur_L);
-  lj_func_closeuv(L, tvref(L->stack));
-  lj_assertG(gcref(L->openupval) == NULL, "stale open upvalues");
+  if (gcref(L->openupval) != NULL) {
+    lj_func_closeuv(L, tvref(L->stack));
+    lj_trace_abort(g);  /* For aa_uref soundness. */
+    lj_assertG(gcref(L->openupval) == NULL, "stale open upvalues");
+  }
   lj_mem_freevec(g, tvref(L->stack), L->stacksize, TValue);
   lj_mem_freet(g, L);
 }
diff --git a/lib/luajit-3065c9/src/lj_state.h b/lib/luajit2/src/lj_state.h
similarity index 89%
rename from lib/luajit-3065c9/src/lj_state.h
rename to lib/luajit2/src/lj_state.h
index d22b7a6f5..3850e5a18 100644
--- a/lib/luajit-3065c9/src/lj_state.h
+++ b/lib/luajit2/src/lj_state.h
@@ -1,6 +1,6 @@
 /*
 ** State and stack handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_STATE_H
@@ -18,6 +18,7 @@ LJ_FUNC void lj_state_relimitstack(lua_State *L);
 LJ_FUNC void lj_state_shrinkstack(lua_State *L, MSize used);
 LJ_FUNCA void LJ_FASTCALL lj_state_growstack(lua_State *L, MSize need);
 LJ_FUNC void LJ_FASTCALL lj_state_growstack1(lua_State *L);
+LJ_FUNC int LJ_FASTCALL lj_state_cpgrowstack(lua_State *L, MSize need);
 
 static LJ_AINLINE void lj_state_checkstack(lua_State *L, MSize need)
 {
diff --git a/lib/luajit-3065c9/src/lj_str.c b/lib/luajit2/src/lj_str.c
similarity index 89%
rename from lib/luajit-3065c9/src/lj_str.c
rename to lib/luajit2/src/lj_str.c
index a5282da68..12556702b 100644
--- a/lib/luajit-3065c9/src/lj_str.c
+++ b/lib/luajit2/src/lj_str.c
@@ -1,6 +1,6 @@
 /*
 ** String handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_str_c
@@ -19,6 +19,15 @@
 int32_t LJ_FASTCALL lj_str_cmp(GCstr *a, GCstr *b)
 {
   MSize i, n = a->len > b->len ? b->len : a->len;
+#ifdef LUAJIT_USE_VALGRIND
+  for (i = 0; i < n; i++) {
+    uint8_t va = *(const uint8_t *)(strdata(a)+i);
+    uint8_t vb = *(const uint8_t *)(strdata(b)+i);
+    if (va != vb) {
+        return va < vb ? -1 : 1;
+    }
+  }
+#else
   for (i = 0; i < n; i += 4) {
     /* Note: innocuous access up to end of string + 3. */
     uint32_t va = *(const uint32_t *)(strdata(a)+i);
@@ -35,6 +44,7 @@ int32_t LJ_FASTCALL lj_str_cmp(GCstr *a, GCstr *b)
       return va < vb ? -1 : 1;
     }
   }
+#endif
   return (int32_t)(a->len - b->len);
 }
 
@@ -72,8 +82,22 @@ int lj_str_haspattern(GCstr *s)
 
 /* -- String hashing ------------------------------------------------------ */
 
+#ifdef LJ_HAS_OPTIMISED_HASH
+static StrHash hash_sparse_def (uint64_t, const char *, MSize);
+str_sparse_hashfn hash_sparse = hash_sparse_def;
+#if LUAJIT_SECURITY_STRHASH
+static StrHash hash_dense_def(uint64_t, StrHash, const char *, MSize);
+str_dense_hashfn hash_dense = hash_dense_def;
+#endif
+#else
+#define hash_sparse hash_sparse_def
+#if LUAJIT_SECURITY_STRHASH
+#define hash_dense hash_dense_def
+#endif
+#endif
+
 /* Keyed sparse ARX string hash. Constant time. */
-static StrHash hash_sparse(uint64_t seed, const char *str, MSize len)
+static StrHash hash_sparse_def(uint64_t seed, const char *str, MSize len)
 {
   /* Constants taken from lookup3 hash by Bob Jenkins. */
   StrHash a, b, h = len ^ (StrHash)seed;
@@ -97,8 +121,8 @@ static StrHash hash_sparse(uint64_t seed, const char *str, MSize len)
 
 #if LUAJIT_SECURITY_STRHASH
 /* Keyed dense ARX string hash. Linear time. */
-static LJ_NOINLINE StrHash hash_dense(uint64_t seed, StrHash h,
-				      const char *str, MSize len)
+static LJ_NOINLINE StrHash hash_dense_def(uint64_t seed, StrHash h,
+					  const char *str, MSize len)
 {
   StrHash b = lj_bswap(lj_rol(h ^ (StrHash)(seed >> 32), 4));
   if (len > 12) {
@@ -282,6 +306,17 @@ static GCstr *lj_str_alloc(lua_State *L, const char *str, MSize len,
   s->gct = ~LJ_TSTR;
   s->len = len;
   s->hash = hash;
+
+#ifdef LUAJIT_TEST_FIXED_ORDER
+  /* If you need predictable key iteration order in lua tables (eg: in data driven test),
+   * build with
+   * "XCFLAGS=-DLUAJIT_TEST_FIXED_ORDER=1 -DLUAJIT_SECURITY_STRID=0
+   * -DLUAJIT_SECURITY_STRHASH=0 -DLUAJIT_SECURITY_PRNG=0 -DLUAJIT_SECURITY_MCODE=0"
+   *
+   * This is for testing only. Please don't use it in production builds.
+   */
+  s->sid = hash;
+#else
 #ifndef STRID_RESEED_INTERVAL
   s->sid = g->str.id++;
 #elif STRID_RESEED_INTERVAL
@@ -293,6 +328,7 @@ static GCstr *lj_str_alloc(lua_State *L, const char *str, MSize len,
   s->sid = g->str.id++;
 #else
   s->sid = (StrID)lj_prng_u64(&g->prng);
+#endif
 #endif
   s->reserved = 0;
   s->hashalg = (uint8_t)hashalg;
diff --git a/lib/luajit-3065c9/src/lj_str.h b/lib/luajit2/src/lj_str.h
similarity index 68%
rename from lib/luajit-3065c9/src/lj_str.h
rename to lib/luajit2/src/lj_str.h
index 28edb5a5e..94537b407 100644
--- a/lib/luajit-3065c9/src/lj_str.h
+++ b/lib/luajit2/src/lj_str.h
@@ -1,6 +1,6 @@
 /*
 ** String handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_STR_H
@@ -28,4 +28,16 @@ LJ_FUNC void LJ_FASTCALL lj_str_init(lua_State *L);
 #define lj_str_newlit(L, s)	(lj_str_new(L, "" s, sizeof(s)-1))
 #define lj_str_size(len)	(sizeof(GCstr) + (((len)+4) & ~(MSize)3))
 
+#ifdef LJ_HAS_OPTIMISED_HASH
+typedef StrHash (*str_sparse_hashfn) (uint64_t, const char *, MSize);
+extern str_sparse_hashfn hash_sparse;
+
+#if LUAJIT_SECURITY_STRHASH
+typedef StrHash (*str_dense_hashfn) (uint64_t, StrHash, const char *, MSize);
+extern str_dense_hashfn hash_dense;
+#endif
+
+extern void str_hash_init_sse42 (void);
+#endif
+
 #endif
diff --git a/lib/luajit2/src/lj_str_hash.c b/lib/luajit2/src/lj_str_hash.c
new file mode 100644
index 000000000..0ee4b5f6a
--- /dev/null
+++ b/lib/luajit2/src/lj_str_hash.c
@@ -0,0 +1,309 @@
+/*
+ * This file defines string hash function using CRC32. It takes advantage of
+ * Intel hardware support (crc32 instruction, SSE 4.2) to speedup the CRC32
+ * computation. The hash functions try to compute CRC32 of length and up
+ * to 128 bytes of given string.
+ */
+
+#include "lj_arch.h"
+
+#if LJ_HAS_OPTIMISED_HASH == 1 || defined(SMOKETEST)
+#include <stdint.h>
+#include <sys/types.h>
+#include <time.h>
+#include <smmintrin.h>
+
+#if defined(_MSC_VER)
+#include <process.h>
+/* Silence deprecated name warning */
+#define getpid _getpid
+#else
+#include <unistd.h>
+#endif
+
+#include "lj_def.h"
+#include "lj_str.h"
+#include "lj_jit.h"
+
+
+#if defined(_MSC_VER)
+/*
+ *  MSVC doesn't seem to restrict intrinsics used based on /arch: value set
+ *  while clang-cl will error on it.
+ */
+#if defined(__clang__) && !defined(__SSE4_2__)
+#error "This file must be built with /arch:AVX1 or higher"
+#endif
+#else
+#if !defined(__SSE4_2__)
+#error "This file must be built with -msse4.2"
+#endif
+#endif
+
+#define lj_crc32_u32 _mm_crc32_u32
+#define lj_crc32_u64 _mm_crc32_u64
+
+#undef LJ_AINLINE
+#define LJ_AINLINE
+
+#if defined(__MINGW32__) || defined(_MSC_VER)
+#define random()  ((long) rand())
+#define srandom(seed)  srand(seed)
+#endif
+
+static const uint64_t* cast_uint64p(const char* str)
+{
+  return (const uint64_t*)(void*)str;
+}
+
+static const uint32_t* cast_uint32p(const char* str)
+{
+  return (const uint32_t*)(void*)str;
+}
+
+/* hash string with len in [1, 4) */
+static LJ_AINLINE uint32_t hash_sparse_1_4(uint64_t seed, const char* str,
+					   uint32_t len)
+{
+#if 0
+  /* TODO: The if-1 part (i.e the original algorithm) is working better when
+   * the load-factor is high, as revealed by conflict benchmark (via
+   * 'make benchmark' command); need to understand why it's so.
+   */
+  uint32_t v = str[0];
+  v = (v << 8) | str[len >> 1];
+  v = (v << 8) | str[len - 1];
+  v = (v << 8) | len;
+  return lj_crc32_u32(0, v);
+#else
+  uint32_t a, b, h = len ^ seed;
+
+  a = *(const uint8_t *)str;
+  h ^= *(const uint8_t *)(str+len-1);
+  b = *(const uint8_t *)(str+(len>>1));
+  h ^= b; h -= lj_rol(b, 14);
+
+  a ^= h; a -= lj_rol(h, 11);
+  b ^= a; b -= lj_rol(a, 25);
+  h ^= b; h -= lj_rol(b, 16);
+
+  return h;
+#endif
+}
+
+/* hash string with len in [4, 16) */
+static LJ_AINLINE uint32_t hash_sparse_4_16(uint64_t seed, const char* str,
+					    uint32_t len)
+{
+  uint64_t v1, v2, h;
+
+  if (len >= 8) {
+    v1 = *cast_uint64p(str);
+    v2 = *cast_uint64p(str + len - 8);
+  } else {
+    v1 = *cast_uint32p(str);
+    v2 = *cast_uint32p(str + len - 4);
+  }
+
+  h = lj_crc32_u32(0, len ^ seed);
+  h = lj_crc32_u64(h, v1);
+  h = lj_crc32_u64(h, v2);
+  return h;
+}
+
+/* hash string with length in [16, 128) */
+static uint32_t hash_16_128(uint64_t seed, const char* str,
+				   uint32_t len)
+{
+  uint64_t h1, h2;
+  uint32_t i;
+
+  h1 = lj_crc32_u32(0, len ^ seed);
+  h2 = 0;
+
+  for (i = 0; i < len - 16; i += 16) {
+    h1 += lj_crc32_u64(h1, *cast_uint64p(str + i));
+    h2 += lj_crc32_u64(h2, *cast_uint64p(str + i + 8));
+  };
+
+  h1 = lj_crc32_u64(h1, *cast_uint64p(str + len - 16));
+  h2 = lj_crc32_u64(h2, *cast_uint64p(str + len - 8));
+
+  return lj_crc32_u32(h1, h2);
+}
+
+/* **************************************************************************
+ *
+ *  Following is code about hashing string with length >= 128
+ *
+ * **************************************************************************
+ */
+static uint32_t random_pos[32][2];
+static const int8_t log2_tab[128] = { -1,0,1,1,2,2,2,2,3,3,3,3,3,3,3,3,4,4,
+  4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
+  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,
+  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6 };
+
+/* return floor(log2(n)) */
+static LJ_AINLINE uint32_t log2_floor(uint32_t n)
+{
+  if (n <= 127) {
+    return log2_tab[n];
+  }
+
+  if ((n >> 8) <= 127) {
+    return log2_tab[n >> 8] + 8;
+  }
+
+  if ((n >> 16) <= 127) {
+    return log2_tab[n >> 16] + 16;
+  }
+
+  if ((n >> 24) <= 127) {
+    return log2_tab[n >> 24] + 24;
+  }
+
+  return 31;
+}
+
+#define POW2_MASK(n) ((1L << (n)) - 1)
+
+/* This function is to populate `random_pos` such that random_pos[i][*]
+ * contains random value in the range of [2**i, 2**(i+1)).
+ */
+static void str_hash_init_random(void)
+{
+  int i, seed, rml;
+
+  /* Calculate the ceil(log2(RAND_MAX)) */
+  rml = log2_floor(RAND_MAX);
+  if (RAND_MAX & (RAND_MAX - 1)) {
+    rml += 1;
+  }
+
+  /* Init seed */
+  seed = lj_crc32_u32(0, getpid());
+  seed = lj_crc32_u32(seed, time(NULL));
+  srandom(seed);
+
+  /* Now start to populate the random_pos[][]. */
+  for (i = 0; i < 3; i++) {
+    /* No need to provide random value for chunk smaller than 8 bytes */
+    random_pos[i][0] = random_pos[i][1] = 0;
+  }
+
+  for (; i < rml; i++) {
+    random_pos[i][0] = random() & POW2_MASK(i+1);
+    random_pos[i][1] = random() & POW2_MASK(i+1);
+  }
+
+  for (; i < 31; i++) {
+    int j;
+    for (j = 0; j < 2; j++) {
+      uint32_t v, scale;
+      scale = random_pos[i - rml][0];
+      if (scale == 0) {
+        scale = 1;
+      }
+      v = (random() * scale) & POW2_MASK(i+1);
+      random_pos[i][j] = v;
+    }
+  }
+}
+#undef POW2_MASK
+
+/* Return a pre-computed random number in the range of [1**chunk_sz_order,
+ * 1**(chunk_sz_order+1)). It is "unsafe" in the sense that the return value
+ * may be greater than chunk-size; it is up to the caller to make sure
+ * "chunk-base + return-value-of-this-func" has valid virtual address.
+ */
+static LJ_AINLINE uint32_t get_random_pos_unsafe(uint32_t chunk_sz_order,
+                                                 uint32_t idx)
+{
+  uint32_t pos = random_pos[chunk_sz_order][idx & 1];
+  return pos;
+}
+
+static LJ_NOINLINE uint32_t hash_128_above(uint64_t seed, const char* str,
+					   uint32_t len)
+{
+  uint32_t chunk_num, chunk_sz, chunk_sz_log2, i, pos1, pos2;
+  uint64_t h1, h2, v;
+  const char* chunk_ptr;
+
+  chunk_num = 16;
+  chunk_sz = len / chunk_num;
+  chunk_sz_log2 = log2_floor(chunk_sz);
+
+  pos1 = get_random_pos_unsafe(chunk_sz_log2, 0);
+  pos2 = get_random_pos_unsafe(chunk_sz_log2, 1);
+
+  h1 = lj_crc32_u32(0, len ^ seed);
+  h2 = 0;
+
+  /* loop over 14 chunks, 2 chunks at a time */
+  for (i = 0, chunk_ptr = str; i < (chunk_num / 2 - 1);
+       chunk_ptr += chunk_sz, i++) {
+
+    v = *cast_uint64p(chunk_ptr + pos1);
+    h1 = lj_crc32_u64(h1, v);
+
+    v = *cast_uint64p(chunk_ptr + chunk_sz + pos2);
+    h2 = lj_crc32_u64(h2, v);
+  }
+
+  /* the last two chunks */
+  v = *cast_uint64p(chunk_ptr + pos1);
+  h1 = lj_crc32_u64(h1, v);
+
+  v = *cast_uint64p(chunk_ptr + chunk_sz - 8 - pos2);
+  h2 = lj_crc32_u64(h2, v);
+
+  /* process the trailing part */
+  h1 = lj_crc32_u64(h1, *cast_uint64p(str));
+  h2 = lj_crc32_u64(h2, *cast_uint64p(str + len - 8));
+
+  h1 = lj_crc32_u32(h1, h2);
+  return h1;
+}
+
+/* NOTE: the "len" should not be zero */
+static StrHash hash_sparse_sse42(uint64_t seed, const char* str, MSize len)
+{
+  if (len < 4 || len >= 128)
+    return hash_sparse_1_4(seed, str, len);
+
+  if (len >= 16) /* [16, 128) */
+    return hash_16_128(seed, str, len);
+
+  /* [4, 16) */
+  return hash_sparse_4_16(seed, str, len);
+}
+
+#if LUAJIT_SECURITY_STRHASH
+static StrHash hash_dense_sse42(uint64_t seed, uint32_t h, const char* str,
+				MSize len)
+{
+  uint32_t b = lj_bswap(lj_rol(h ^ (uint32_t)(seed >> 32), 4));
+
+  if (len <= 16)
+    return b;
+
+  if (len < 128) /* [16, 128), try with a different seed. */
+    return hash_16_128(b, str, len);
+
+  /* Otherwise, do the slow crc32 randomization for long strings. */
+  return hash_128_above(b, str, len);
+}
+#endif
+
+void str_hash_init_sse42(void)
+{
+  hash_sparse = hash_sparse_sse42;
+#if LUAJIT_SECURITY_STRHASH
+  hash_dense = hash_dense_sse42;
+#endif
+  str_hash_init_random();
+}
+#endif
diff --git a/lib/luajit-3065c9/src/lj_strfmt.c b/lib/luajit2/src/lj_strfmt.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_strfmt.c
rename to lib/luajit2/src/lj_strfmt.c
index 5c8082903..909255db8 100644
--- a/lib/luajit-3065c9/src/lj_strfmt.c
+++ b/lib/luajit2/src/lj_strfmt.c
@@ -1,6 +1,6 @@
 /*
 ** String formatting.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include <stdio.h>
@@ -102,7 +102,7 @@ retlit:
 char * LJ_FASTCALL lj_strfmt_wint(char *p, int32_t k)
 {
   uint32_t u = (uint32_t)k;
-  if (k < 0) { u = (uint32_t)-k; *p++ = '-'; }
+  if (k < 0) { u = ~u+1u; *p++ = '-'; }
   if (u < 10000) {
     if (u < 10) goto dig1;
     if (u < 100) goto dig2;
@@ -287,7 +287,7 @@ SBuf *lj_strfmt_putfxint(SBuf *sb, SFormat sf, uint64_t k)
   /* Figure out signed prefixes. */
   if (STRFMT_TYPE(sf) == STRFMT_INT) {
     if ((int64_t)k < 0) {
-      k = (uint64_t)-(int64_t)k;
+      k = ~k+1u;
       prefix = 256 + '-';
     } else if ((sf & STRFMT_F_PLUS)) {
       prefix = 256 + '+';
diff --git a/lib/luajit-3065c9/src/lj_strfmt.h b/lib/luajit2/src/lj_strfmt.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_strfmt.h
rename to lib/luajit2/src/lj_strfmt.h
index a4529604e..bd17896ec 100644
--- a/lib/luajit-3065c9/src/lj_strfmt.h
+++ b/lib/luajit2/src/lj_strfmt.h
@@ -1,6 +1,6 @@
 /*
 ** String formatting.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_STRFMT_H
diff --git a/lib/luajit-3065c9/src/lj_strfmt_num.c b/lib/luajit2/src/lj_strfmt_num.c
similarity index 99%
rename from lib/luajit-3065c9/src/lj_strfmt_num.c
rename to lib/luajit2/src/lj_strfmt_num.c
index 3c60695cc..c6e776aa9 100644
--- a/lib/luajit-3065c9/src/lj_strfmt_num.c
+++ b/lib/luajit2/src/lj_strfmt_num.c
@@ -1,6 +1,6 @@
 /*
 ** String formatting for floating-point numbers.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 ** Contributed by Peter Cawley.
 */
 
@@ -454,7 +454,8 @@ static char *lj_strfmt_wfnum(SBuf *sb, SFormat sf, lua_Number n, char *p)
 	    prec--;
 	    if (!i) {
 	      if (ndlo == ndhi) { prec = 0; break; }
-	      lj_strfmt_wuint9(tail, nd[++ndlo]);
+	      ndlo = (ndlo + 1) & 0x3f;
+	      lj_strfmt_wuint9(tail, nd[ndlo]);
 	      i = 9;
 	    }
 	  }
diff --git a/lib/luajit-3065c9/src/lj_strscan.c b/lib/luajit2/src/lj_strscan.c
similarity index 96%
rename from lib/luajit-3065c9/src/lj_strscan.c
rename to lib/luajit2/src/lj_strscan.c
index 1d1c1c740..9dbf477a9 100644
--- a/lib/luajit-3065c9/src/lj_strscan.c
+++ b/lib/luajit2/src/lj_strscan.c
@@ -1,6 +1,6 @@
 /*
 ** String scanning.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include <math.h>
@@ -124,19 +124,19 @@ static StrScanFmt strscan_hex(const uint8_t *p, TValue *o,
   case STRSCAN_INT:
     if (!(opt & STRSCAN_OPT_TONUM) && x < 0x80000000u+neg &&
 	!(x == 0 && neg)) {
-      o->i = neg ? -(int32_t)x : (int32_t)x;
+      o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
       return STRSCAN_INT;  /* Fast path for 32 bit integers. */
     }
     if (!(opt & STRSCAN_OPT_C)) { fmt = STRSCAN_NUM; break; }
     /* fallthrough */
   case STRSCAN_U32:
     if (dig > 8) return STRSCAN_ERROR;
-    o->i = neg ? -(int32_t)x : (int32_t)x;
+    o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
     return STRSCAN_U32;
   case STRSCAN_I64:
   case STRSCAN_U64:
     if (dig > 16) return STRSCAN_ERROR;
-    o->u64 = neg ? (uint64_t)-(int64_t)x : x;
+    o->u64 = neg ? ~x+1u : x;
     return fmt;
   default:
     break;
@@ -168,12 +168,12 @@ static StrScanFmt strscan_oct(const uint8_t *p, TValue *o,
     /* fallthrough */
   case STRSCAN_U32:
     if ((x >> 32)) return STRSCAN_ERROR;
-    o->i = neg ? -(int32_t)x : (int32_t)x;
+    o->i = neg ? (int32_t)(~(uint32_t)x+1u) : (int32_t)x;
     break;
   default:
   case STRSCAN_I64:
   case STRSCAN_U64:
-    o->u64 = neg ? (uint64_t)-(int64_t)x : x;
+    o->u64 = neg ? ~x+1u : x;
     break;
   }
   return fmt;
@@ -229,18 +229,18 @@ static StrScanFmt strscan_dec(const uint8_t *p, TValue *o,
       switch (fmt) {
       case STRSCAN_INT:
 	if (!(opt & STRSCAN_OPT_TONUM) && x < 0x80000000u+neg) {
-	  o->i = neg ? -(int32_t)x : (int32_t)x;
+	  o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
 	  return STRSCAN_INT;  /* Fast path for 32 bit integers. */
 	}
 	if (!(opt & STRSCAN_OPT_C)) { fmt = STRSCAN_NUM; goto plainnumber; }
 	/* fallthrough */
       case STRSCAN_U32:
 	if ((x >> 32) != 0) return STRSCAN_ERROR;
-	o->i = neg ? -(int32_t)x : (int32_t)x;
+	o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
 	return STRSCAN_U32;
       case STRSCAN_I64:
       case STRSCAN_U64:
-	o->u64 = neg ? (uint64_t)-(int64_t)x : x;
+	o->u64 = neg ? ~x+1u : x;
 	return fmt;
       default:
       plainnumber:  /* Fast path for plain numbers < 2^63. */
@@ -348,18 +348,18 @@ static StrScanFmt strscan_bin(const uint8_t *p, TValue *o,
   switch (fmt) {
   case STRSCAN_INT:
     if (!(opt & STRSCAN_OPT_TONUM) && x < 0x80000000u+neg) {
-      o->i = neg ? -(int32_t)x : (int32_t)x;
+      o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
       return STRSCAN_INT;  /* Fast path for 32 bit integers. */
     }
     if (!(opt & STRSCAN_OPT_C)) { fmt = STRSCAN_NUM; break; }
     /* fallthrough */
   case STRSCAN_U32:
     if (dig > 32) return STRSCAN_ERROR;
-    o->i = neg ? -(int32_t)x : (int32_t)x;
+    o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
     return STRSCAN_U32;
   case STRSCAN_I64:
   case STRSCAN_U64:
-    o->u64 = neg ? (uint64_t)-(int64_t)x : x;
+    o->u64 = neg ? ~x+1u : x;
     return fmt;
   default:
     break;
@@ -468,7 +468,7 @@ StrScanFmt lj_strscan_scan(const uint8_t *p, MSize len, TValue *o,
 	if (xx >= STRSCAN_MAXEXP) return STRSCAN_ERROR;
 	p++;
       }
-      ex += negx ? -(int32_t)xx : (int32_t)xx;
+      ex += negx ? (int32_t)(~xx+1u) : (int32_t)xx;
     }
 
     /* Parse suffix. */
@@ -507,7 +507,7 @@ StrScanFmt lj_strscan_scan(const uint8_t *p, MSize len, TValue *o,
 	o->n = -0.0;
 	return STRSCAN_NUM;
       } else {
-	o->i = neg ? -(int32_t)x : (int32_t)x;
+	o->i = neg ? (int32_t)(~x+1u) : (int32_t)x;
 	return STRSCAN_INT;
       }
     }
diff --git a/lib/luajit-3065c9/src/lj_strscan.h b/lib/luajit2/src/lj_strscan.h
similarity index 94%
rename from lib/luajit-3065c9/src/lj_strscan.h
rename to lib/luajit2/src/lj_strscan.h
index 8ed31542a..a6047cf21 100644
--- a/lib/luajit-3065c9/src/lj_strscan.h
+++ b/lib/luajit2/src/lj_strscan.h
@@ -1,6 +1,6 @@
 /*
 ** String scanning.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_STRSCAN_H
diff --git a/lib/luajit-3065c9/src/lj_tab.c b/lib/luajit2/src/lj_tab.c
similarity index 92%
rename from lib/luajit-3065c9/src/lj_tab.c
rename to lib/luajit2/src/lj_tab.c
index c3609b38c..db0a5e8a0 100644
--- a/lib/luajit-3065c9/src/lj_tab.c
+++ b/lib/luajit2/src/lj_tab.c
@@ -1,6 +1,6 @@
 /*
 ** Table handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
@@ -14,6 +14,8 @@
 #include "lj_err.h"
 #include "lj_tab.h"
 
+#include <math.h>
+
 /* -- Object hashing ------------------------------------------------------ */
 
 /* Hash an arbitrary key and return its anchor position in the hash table. */
@@ -691,3 +693,85 @@ MSize LJ_FASTCALL lj_tab_len_hint(GCtab *t, size_t hint)
 }
 #endif
 
+
+GCtab * LJ_FASTCALL lj_tab_clone(lua_State *L, const GCtab *src)
+{
+  return lj_tab_dup(L, src);
+}
+
+int LJ_FASTCALL lj_tab_isarray(const GCtab *src)
+{
+  Node *node;
+  cTValue *o;
+  ptrdiff_t i;
+
+  node = noderef(src->node);
+  for (i = (ptrdiff_t)src->hmask; i >= 0; i--)
+    if (!tvisnil(&node[i].val)) {
+      o = &node[i].key;
+      if (LJ_UNLIKELY(tvisint(o))) {
+        continue;
+      }
+      if (LJ_UNLIKELY(tvisnum(o))) {
+        lua_Number n = numberVnum(o);
+        if (LJ_LIKELY(rint((double) n) == n)) {
+          continue;
+        }
+      }
+      return 0;
+    }
+
+  return 1;
+}
+
+MSize LJ_FASTCALL lj_tab_nkeys(const GCtab *t)
+{
+  MSize narr = (MSize)t->asize;
+  cTValue *e;
+  Node *node;
+  MSize i, cnt = 0;
+
+  e = tvref(t->array);
+  for (i = 0; i < narr; i++)
+    if (LJ_LIKELY(!tvisnil(&e[i])))
+      cnt++;
+
+  if (t->hmask <= 0)
+    return cnt;
+
+  node = noderef(t->node);
+  for (i = 0; i <= (MSize)t->hmask; i++) {
+    Node *n = &node[i];
+    if (LJ_LIKELY(!tvisnil(&n->val))) {
+      cnt++;
+    }
+  }
+
+  return cnt;
+}
+
+int LJ_FASTCALL lj_tab_isempty(const GCtab *t)
+{
+  MSize narr = (MSize)t->asize;
+  cTValue *e;
+  Node *node;
+  MSize i;
+
+  e = tvref(t->array);
+  for (i = 0; i < narr; i++)
+    if (LJ_LIKELY(!tvisnil(&e[i])))
+      return 0;
+
+  if (t->hmask <= 0)
+    return 1;
+
+  node = noderef(t->node);
+  for (i = 0; i <= (MSize)t->hmask; i++) {
+    Node *n = &node[i];
+    if (LJ_LIKELY(!tvisnil(&n->val))) {
+      return 0;
+    }
+  }
+
+  return 1;
+}
diff --git a/lib/luajit-3065c9/src/lj_tab.h b/lib/luajit2/src/lj_tab.h
similarity index 91%
rename from lib/luajit-3065c9/src/lj_tab.h
rename to lib/luajit2/src/lj_tab.h
index 2a3f76bfe..2d03d61e1 100644
--- a/lib/luajit-3065c9/src/lj_tab.h
+++ b/lib/luajit2/src/lj_tab.h
@@ -1,6 +1,6 @@
 /*
 ** Table handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TAB_H
@@ -93,4 +93,9 @@ LJ_FUNCA MSize LJ_FASTCALL lj_tab_len(GCtab *t);
 LJ_FUNC MSize LJ_FASTCALL lj_tab_len_hint(GCtab *t, size_t hint);
 #endif
 
+LJ_FUNCA GCtab * LJ_FASTCALL lj_tab_clone(lua_State *L, const GCtab *src);
+LJ_FUNCA int LJ_FASTCALL lj_tab_isarray(const GCtab *src);
+LJ_FUNCA MSize LJ_FASTCALL lj_tab_nkeys(const GCtab *src);
+LJ_FUNCA int LJ_FASTCALL lj_tab_isempty(const GCtab *t);
+
 #endif
diff --git a/lib/luajit-3065c9/src/lj_target.h b/lib/luajit2/src/lj_target.h
similarity index 94%
rename from lib/luajit-3065c9/src/lj_target.h
rename to lib/luajit2/src/lj_target.h
index 197169284..d00554d4b 100644
--- a/lib/luajit-3065c9/src/lj_target.h
+++ b/lib/luajit2/src/lj_target.h
@@ -1,6 +1,6 @@
 /*
 ** Definitions for target CPU.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TARGET_H
@@ -57,8 +57,14 @@ typedef uint32_t RegSP;
 */
 #if LJ_TARGET_PPC || LJ_TARGET_MIPS || LJ_TARGET_ARM64
 typedef uint64_t RegSet;
+#define RSET_BITS		6
+#define rset_picktop_(rs)	((Reg)lj_fls64(rs))
+#define rset_pickbot_(rs)	((Reg)lj_ffs64(rs))
 #else
 typedef uint32_t RegSet;
+#define RSET_BITS		5
+#define rset_picktop_(rs)	((Reg)lj_fls(rs))
+#define rset_pickbot_(rs)	((Reg)lj_ffs(rs))
 #endif
 
 #define RID2RSET(r)		(((RegSet)1) << (r))
@@ -69,13 +75,6 @@ typedef uint32_t RegSet;
 #define rset_set(rs, r)		(rs |= RID2RSET(r))
 #define rset_clear(rs, r)	(rs &= ~RID2RSET(r))
 #define rset_exclude(rs, r)	(rs & ~RID2RSET(r))
-#if LJ_TARGET_PPC || LJ_TARGET_MIPS || LJ_TARGET_ARM64
-#define rset_picktop(rs)	((Reg)(__builtin_clzll(rs)^63))
-#define rset_pickbot(rs)	((Reg)__builtin_ctzll(rs))
-#else
-#define rset_picktop(rs)	((Reg)lj_fls(rs))
-#define rset_pickbot(rs)	((Reg)lj_ffs(rs))
-#endif
 
 /* -- Register allocation cost -------------------------------------------- */
 
@@ -144,6 +143,8 @@ typedef uint32_t RegCost;
 #include "lj_target_ppc.h"
 #elif LJ_TARGET_MIPS
 #include "lj_target_mips.h"
+#elif LJ_TARGET_S390X
+#include "lj_target_s390x.h"
 #else
 #error "Missing include for target CPU"
 #endif
diff --git a/lib/luajit-3065c9/src/lj_target_arm.h b/lib/luajit2/src/lj_target_arm.h
similarity index 99%
rename from lib/luajit-3065c9/src/lj_target_arm.h
rename to lib/luajit2/src/lj_target_arm.h
index 48f487a5d..7170fcab0 100644
--- a/lib/luajit-3065c9/src/lj_target_arm.h
+++ b/lib/luajit2/src/lj_target_arm.h
@@ -1,6 +1,6 @@
 /*
 ** Definitions for ARM CPUs.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TARGET_ARM_H
diff --git a/lib/luajit-3065c9/src/lj_target_arm64.h b/lib/luajit2/src/lj_target_arm64.h
similarity index 97%
rename from lib/luajit-3065c9/src/lj_target_arm64.h
rename to lib/luajit2/src/lj_target_arm64.h
index d45af2e4d..c34f1e59c 100644
--- a/lib/luajit-3065c9/src/lj_target_arm64.h
+++ b/lib/luajit2/src/lj_target_arm64.h
@@ -1,6 +1,6 @@
 /*
 ** Definitions for ARM64 CPUs.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TARGET_ARM64_H
@@ -234,6 +234,8 @@ typedef enum A64Ins {
   A64I_MOVZx = 0xd2800000,
   A64I_MOVNw = 0x12800000,
   A64I_MOVNx = 0x92800000,
+  A64I_ADR = 0x10000000,
+  A64I_ADRP = 0x90000000,
 
   A64I_LDRB = 0x39400000,
   A64I_LDRH = 0x79400000,
@@ -260,6 +262,9 @@ typedef enum A64Ins {
   A64I_CBZ = 0x34000000,
   A64I_CBNZ = 0x35000000,
 
+  A64I_BRAAZ = 0xd61f081f,
+  A64I_BLRAAZ = 0xd63f081f,
+
   A64I_NOP = 0xd503201f,
 
   /* FP */
@@ -317,6 +322,9 @@ typedef enum A64Ins {
   A64I_FMOV_DI = 0x1e601000,
 } A64Ins;
 
+#define A64I_BR_AUTH	(LJ_ABI_PAUTH ? A64I_BRAAZ : A64I_BR)
+#define A64I_BLR_AUTH	(LJ_ABI_PAUTH ? A64I_BLRAAZ : A64I_BLR)
+
 typedef enum A64Shift {
   A64SH_LSL, A64SH_LSR, A64SH_ASR, A64SH_ROR
 } A64Shift;
diff --git a/lib/luajit-3065c9/src/lj_target_mips.h b/lib/luajit2/src/lj_target_mips.h
similarity index 99%
rename from lib/luajit-3065c9/src/lj_target_mips.h
rename to lib/luajit2/src/lj_target_mips.h
index da72d61a3..a3353884b 100644
--- a/lib/luajit-3065c9/src/lj_target_mips.h
+++ b/lib/luajit2/src/lj_target_mips.h
@@ -1,6 +1,6 @@
 /*
 ** Definitions for MIPS CPUs.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TARGET_MIPS_H
diff --git a/lib/luajit-3065c9/src/lj_target_ppc.h b/lib/luajit2/src/lj_target_ppc.h
similarity index 94%
rename from lib/luajit-3065c9/src/lj_target_ppc.h
rename to lib/luajit2/src/lj_target_ppc.h
index bc9802a42..887b7dde8 100644
--- a/lib/luajit-3065c9/src/lj_target_ppc.h
+++ b/lib/luajit2/src/lj_target_ppc.h
@@ -1,6 +1,6 @@
 /*
 ** Definitions for PPC CPUs.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TARGET_PPC_H
@@ -30,8 +30,13 @@ enum {
 
   /* Calling conventions. */
   RID_RET = RID_R3,
+#if LJ_LE
+  RID_RETHI = RID_R4,
+  RID_RETLO = RID_R3,
+#else
   RID_RETHI = RID_R3,
   RID_RETLO = RID_R4,
+#endif
   RID_FPRET = RID_F1,
 
   /* These definitions must match with the *.dasc file(s): */
@@ -131,6 +136,8 @@ static LJ_AINLINE uint32_t *exitstub_trace_addr_(uint32_t *p, uint32_t exitno)
 #define PPCF_C(r)	((r) << 6)
 #define PPCF_MB(n)	((n) << 6)
 #define PPCF_ME(n)	((n) << 1)
+#define PPCF_SH(n)	((((n) & 31) << (11+1)) | (((n) & 32) >> (5-1)))
+#define PPCF_M6(n)	((((n) & 31) << (5+1)) | (((n) & 32) << (11-5)))
 #define PPCF_Y		0x00200000
 #define PPCF_DOT	0x00000001
 
@@ -200,6 +207,13 @@ typedef enum PPCIns {
   PPCI_RLWINM = 0x54000000,
   PPCI_RLWIMI = 0x50000000,
 
+  PPCI_RLDICL = 0x78000000,
+  PPCI_RLDICR = 0x78000004,
+  PPCI_RLDIC = 0x78000008,
+  PPCI_RLDIMI = 0x7800000c,
+  PPCI_RLDCL = 0x78000010,
+  PPCI_RLDCR = 0x78000012,
+
   PPCI_B = 0x48000000,
   PPCI_BL = 0x48000001,
   PPCI_BC = 0x40800000,
diff --git a/lib/luajit2/src/lj_target_s390x.h b/lib/luajit2/src/lj_target_s390x.h
new file mode 100644
index 000000000..10b4bd580
--- /dev/null
+++ b/lib/luajit2/src/lj_target_s390x.h
@@ -0,0 +1,81 @@
+/*
+** Definitions for IBM z/Architecture (s390x) CPUs.
+** Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h
+*/
+
+#ifndef _LJ_TARGET_S390X_H
+#define _LJ_TARGET_S390X_H
+
+/* -- Registers IDs ------------------------------------------------------- */
+
+#define GPRDEF(_) \
+  _(R0) _(R1) _(R2) _(R3) _(R4) _(R5) _(R6) _(R7) \
+  _(R8) _(R9) _(R10) _(R11) _(R12) _(R13) _(R14) _(R15)
+#define FPRDEF(_) \
+  _(F0) _(F1) _(F2) _(F3) \
+  _(F4) _(F5) _(F6) _(F7) \
+  _(F8) _(F9) _(F10) _(F11) \
+  _(F12) _(F13) _(F14) _(F15) 
+// TODO: VREG?
+
+#define RIDENUM(name)	RID_##name,
+
+enum {
+  GPRDEF(RIDENUM)		/* General-purpose registers (GPRs). */
+  FPRDEF(RIDENUM)		/* Floating-point registers (FPRs). */
+  RID_MAX,
+
+  /* Calling conventions. */
+  RID_SP = RID_R15,
+  RID_RET = RID_R2,
+  RID_FPRET = RID_F0,
+
+  /* These definitions must match with the *.dasc file(s): */
+  RID_BASE = RID_R7,		/* Interpreter BASE. */
+  RID_LPC = RID_R9,		/* Interpreter PC. */
+  RID_DISPATCH = RID_R10,	/* Interpreter DISPATCH table. */
+
+  /* Register ranges [min, max) and number of registers. */
+  RID_MIN_GPR = RID_R0,
+  RID_MIN_FPR = RID_F0,
+  RID_MAX_GPR = RID_MIN_FPR,
+  RID_MAX_FPR = RID_MAX,
+  RID_NUM_GPR = RID_MAX_GPR - RID_MIN_GPR,
+  RID_NUM_FPR = RID_MAX_FPR - RID_MIN_FPR,
+};
+
+/* -- Register sets ------------------------------------------------------- */
+
+/* -- Spill slots --------------------------------------------------------- */
+
+/* Spill slots are 32 bit wide. An even/odd pair is used for FPRs.
+**
+** SPS_FIXED: Available fixed spill slots in interpreter frame.
+** This definition must match with the *.dasc file(s).
+**
+** SPS_FIRST: First spill slot for general use. Reserve min. two 32 bit slots.
+*/
+#define SPS_FIXED	2
+#define SPS_FIRST	2
+
+#define SPOFS_TMP	0
+
+#define sps_scale(slot)		(4 * (int32_t)(slot))
+#define sps_align(slot)		(((slot) - SPS_FIXED + 1) & ~1)
+
+/* -- Exit state ---------------------------------------------------------- */
+
+/* This definition must match with the *.dasc file(s). */
+typedef struct {
+  lua_Number fpr[RID_NUM_FPR];	/* Floating-point registers. */
+  int32_t gpr[RID_NUM_GPR];	/* General-purpose registers. */
+  int32_t spill[256];		/* Spill slots. */
+} ExitState;
+
+#define EXITSTUB_SPACING        4
+#define EXITSTUBS_PER_GROUP     32
+
+/* -- Instructions -------------------------------------------------------- */
+
+#endif
+
diff --git a/lib/luajit-3065c9/src/lj_target_x86.h b/lib/luajit2/src/lj_target_x86.h
similarity index 98%
rename from lib/luajit-3065c9/src/lj_target_x86.h
rename to lib/luajit2/src/lj_target_x86.h
index 69cb8ca53..3482309b3 100644
--- a/lib/luajit-3065c9/src/lj_target_x86.h
+++ b/lib/luajit2/src/lj_target_x86.h
@@ -1,6 +1,6 @@
 /*
 ** Definitions for x86 and x64 CPUs.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TARGET_X86_H
@@ -116,8 +116,8 @@ enum {
 
 #if LJ_64
 /* Prefer the low 8 regs of each type to reduce REX prefixes. */
-#undef rset_picktop
-#define rset_picktop(rs)	(lj_fls(lj_bswap(rs)) ^ 0x18)
+#undef rset_picktop_
+#define rset_picktop_(rs)	(lj_fls(lj_bswap(rs)) ^ 0x18)
 #endif
 
 /* -- Spill slots --------------------------------------------------------- */
diff --git a/lib/luajit-3065c9/src/lj_trace.c b/lib/luajit2/src/lj_trace.c
similarity index 94%
rename from lib/luajit-3065c9/src/lj_trace.c
rename to lib/luajit2/src/lj_trace.c
index c23293942..6dc77e286 100644
--- a/lib/luajit-3065c9/src/lj_trace.c
+++ b/lib/luajit2/src/lj_trace.c
@@ -1,6 +1,6 @@
 /*
 ** Trace management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_trace_c
@@ -153,6 +153,9 @@ static void trace_save(jit_State *J, GCtrace *T)
   newwhite(J2G(J), T);
   T->gct = ~LJ_TTRACE;
   T->ir = (IRIns *)p - J->cur.nk;  /* The IR has already been copied above. */
+#if LJ_ABI_PAUTH
+  T->mcauth = lj_ptr_sign((ASMFunction)T->mcode, T);
+#endif
   p += szins;
   TRACE_APPENDVEC(snap, nsnap, SnapShot)
   TRACE_APPENDVEC(snapmap, nsnapmap, SnapEntry)
@@ -312,6 +315,8 @@ void lj_trace_initstate(global_State *g)
   jit_State *J = G2J(g);
   TValue *tv;
 
+  J->prng = g->prng;
+
   /* Initialize aligned SIMD constants. */
   tv = LJ_KSIMD(J, LJ_KSIMD_ABS);
   tv[0].u64 = U64x(7fffffff,ffffffff);
@@ -390,7 +395,7 @@ static void penalty_pc(jit_State *J, GCproto *pt, BCIns *pc, TraceError e)
     if (mref(J->penalty[i].pc, const BCIns) == pc) {  /* Cache slot found? */
       /* First try to bump its hotcount several times. */
       val = ((uint32_t)J->penalty[i].val << 1) +
-	    (lj_prng_u64(&J2G(J)->prng) & ((1u<<PENALTY_RNDBITS)-1));
+	    (lj_prng_u64(&J->prng) & ((1u<<PENALTY_RNDBITS)-1));
       if (val > PENALTY_MAX) {
 	blacklist_pc(pt, pc);  /* Blacklist it, if that didn't help. */
 	return;
@@ -414,6 +419,9 @@ static void trace_start(jit_State *J)
 {
   lua_State *L;
   TraceNo traceno;
+#ifdef LUA_USE_TRACE_LOGS
+  const BCIns *pc = J->pc;
+#endif
 
   if ((J->pt->flags & PROTO_NOJIT)) {  /* JIT disabled for this proto? */
     if (J->parent == 0 && J->exitno == 0 && bc_op(*J->pc) != BC_ITERN) {
@@ -428,6 +436,12 @@ static void trace_start(jit_State *J)
     return;
   }
 
+  /* Ensuring forward progress for BC_ITERN can trigger hotcount again. */
+  if (!J->parent && bc_op(*J->pc) == BC_JLOOP) {  /* Already compiled. */
+    J->state = LJ_TRACE_IDLE;  /* Silently ignored. */
+    return;
+  }
+
   /* Get a new trace number. */
   traceno = trace_findfree(J);
   if (LJ_UNLIKELY(traceno == 0)) {  /* No free trace? */
@@ -474,6 +488,9 @@ static void trace_start(jit_State *J)
     }
   );
   lj_record_setup(J);
+#ifdef LUA_USE_TRACE_LOGS
+  lj_log_trace_start_record(L, (unsigned) J->cur.traceno, pc, J->fn);
+#endif
 }
 
 /* Stop tracing. */
@@ -604,21 +621,27 @@ static int trace_abort(jit_State *J)
     J->cur.link = 0;
     J->cur.linktype = LJ_TRLINK_NONE;
     lj_vmevent_send(L, TRACE,
-      TValue *frame;
+      cTValue *bot = tvref(L->stack)+LJ_FR2;
+      cTValue *frame;
       const BCIns *pc;
-      GCfunc *fn;
+      BCPos pos = 0;
       setstrV(L, L->top++, lj_str_newlit(L, "abort"));
       setintV(L->top++, traceno);
       /* Find original Lua function call to generate a better error message. */
-      frame = J->L->base-1;
-      pc = J->pc;
-      while (!isluafunc(frame_func(frame))) {
-	pc = (frame_iscont(frame) ? frame_contpc(frame) : frame_pc(frame)) - 1;
-	frame = frame_prev(frame);
+      for (frame = J->L->base-1, pc = J->pc; ; frame = frame_prev(frame)) {
+	if (isluafunc(frame_func(frame))) {
+	  pos = proto_bcpos(funcproto(frame_func(frame)), pc);
+	  break;
+	} else if (frame_prev(frame) <= bot) {
+	  break;
+	} else if (frame_iscont(frame)) {
+	  pc = frame_contpc(frame) - 1;
+	} else {
+	  pc = frame_pc(frame) - 1;
+	}
       }
-      fn = frame_func(frame);
-      setfuncV(L, L->top++, fn);
-      setintV(L->top++, proto_bcpos(funcproto(fn), pc));
+      setfuncV(L, L->top++, frame_func(frame));
+      setintV(L->top++, pos);
       copyTV(L, L->top++, restorestack(L, errobj));
       copyTV(L, L->top++, &J->errinfo);
     );
@@ -864,7 +887,7 @@ int LJ_FASTCALL lj_trace_exit(jit_State *J, void *exptr)
   ExitDataCP exd;
   int errcode, exitcode = J->exitcode;
   TValue exiterr;
-  const BCIns *pc;
+  const BCIns *pc, *retpc;
   void *cf;
   GCtrace *T;
 
@@ -913,25 +936,13 @@ int LJ_FASTCALL lj_trace_exit(jit_State *J, void *exptr)
   } else if (G(L)->gc.state == GCSatomic || G(L)->gc.state == GCSfinalize) {
     if (!(G(L)->hookmask & HOOK_GC))
       lj_gc_step(L);  /* Exited because of GC: drive GC forward. */
-  } else {
+  } else if ((J->flags & JIT_F_ON)) {
     trace_hotside(J, pc);
   }
-  if (bc_op(*pc) == BC_JLOOP) {
-    BCIns *retpc = &traceref(J, bc_d(*pc))->startins;
-    int isret = bc_isret(bc_op(*retpc));
-    if (isret || bc_op(*retpc) == BC_ITERN) {
-      if (J->state == LJ_TRACE_RECORD) {
-	J->patchins = *pc;
-	J->patchpc = (BCIns *)pc;
-	*J->patchpc = *retpc;
-	J->bcskip = 1;
-      } else if (isret) {
-	pc = retpc;
-	setcframe_pc(cf, pc);
-      }
-    }
-  }
-  /* Return MULTRES or 0. */
+#ifdef LUA_USE_TRACE_LOGS
+  lj_log_trace_normal_exit(L, (int) T->traceno, pc);
+#endif
+  /* Return MULTRES or 0 or -17. */
   ERRNO_RESTORE
   switch (bc_op(*pc)) {
   case BC_CALLM: case BC_CALLMT:
@@ -940,6 +951,18 @@ int LJ_FASTCALL lj_trace_exit(jit_State *J, void *exptr)
     return (int)((BCReg)(L->top - L->base) + 1 - bc_a(*pc) - bc_d(*pc));
   case BC_TSETM:
     return (int)((BCReg)(L->top - L->base) + 1 - bc_a(*pc));
+  case BC_JLOOP:
+    retpc = &traceref(J, bc_d(*pc))->startins;
+    if (bc_isret(bc_op(*retpc)) || bc_op(*retpc) == BC_ITERN) {
+      /* Dispatch to original ins to ensure forward progress. */
+      if (J->state != LJ_TRACE_RECORD) return -17;
+      /* Unpatch bytecode when recording. */
+      J->patchins = *pc;
+      J->patchpc = (BCIns *)pc;
+      *J->patchpc = *retpc;
+      J->bcskip = 1;
+    }
+    return 0;
   default:
     if (bc_op(*pc) >= BC_FUNCF)
       return (int)((BCReg)(L->top - L->base) + 1);
diff --git a/lib/luajit-3065c9/src/lj_trace.h b/lib/luajit2/src/lj_trace.h
similarity index 96%
rename from lib/luajit-3065c9/src/lj_trace.h
rename to lib/luajit2/src/lj_trace.h
index 3d7f76f03..5dcd365e7 100644
--- a/lib/luajit-3065c9/src/lj_trace.h
+++ b/lib/luajit2/src/lj_trace.h
@@ -1,6 +1,6 @@
 /*
 ** Trace management.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_TRACE_H
diff --git a/lib/luajit-3065c9/src/lj_traceerr.h b/lib/luajit2/src/lj_traceerr.h
similarity index 96%
rename from lib/luajit-3065c9/src/lj_traceerr.h
rename to lib/luajit2/src/lj_traceerr.h
index 8ed8ac823..19ce30ad8 100644
--- a/lib/luajit-3065c9/src/lj_traceerr.h
+++ b/lib/luajit2/src/lj_traceerr.h
@@ -1,6 +1,6 @@
 /*
 ** Trace compiler error messages.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 /* This file may be included multiple times with different TREDEF macros. */
diff --git a/lib/luajit-3065c9/src/lj_udata.c b/lib/luajit2/src/lj_udata.c
similarity index 96%
rename from lib/luajit-3065c9/src/lj_udata.c
rename to lib/luajit2/src/lj_udata.c
index ee4a145dc..7acd9e329 100644
--- a/lib/luajit-3065c9/src/lj_udata.c
+++ b/lib/luajit2/src/lj_udata.c
@@ -1,6 +1,6 @@
 /*
 ** Userdata handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_udata_c
diff --git a/lib/luajit-3065c9/src/lj_udata.h b/lib/luajit2/src/lj_udata.h
similarity index 83%
rename from lib/luajit-3065c9/src/lj_udata.h
rename to lib/luajit2/src/lj_udata.h
index 503c9e300..143bf81d0 100644
--- a/lib/luajit-3065c9/src/lj_udata.h
+++ b/lib/luajit2/src/lj_udata.h
@@ -1,6 +1,6 @@
 /*
 ** Userdata handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_UDATA_H
diff --git a/lib/luajit-3065c9/src/lj_vm.h b/lib/luajit2/src/lj_vm.h
similarity index 94%
rename from lib/luajit-3065c9/src/lj_vm.h
rename to lib/luajit2/src/lj_vm.h
index c66db0049..63d094396 100644
--- a/lib/luajit-3065c9/src/lj_vm.h
+++ b/lib/luajit2/src/lj_vm.h
@@ -1,6 +1,6 @@
 /*
 ** Assembler VM interface definitions.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_VM_H
@@ -54,8 +54,8 @@ LJ_ASMF void lj_vm_profhook(void);
 LJ_ASMF void lj_vm_IITERN(void);
 
 /* Trace exit handling. */
-LJ_ASMF void lj_vm_exit_handler(void);
-LJ_ASMF void lj_vm_exit_interp(void);
+LJ_ASMF char lj_vm_exit_handler[];
+LJ_ASMF char lj_vm_exit_interp[];
 
 /* Internal math helper functions. */
 #if LJ_TARGET_PPC || LJ_TARGET_ARM64 || (LJ_TARGET_MIPS && LJ_ABI_SOFTFP)
@@ -111,6 +111,6 @@ LJ_ASMF void lj_cont_stitch(void);  /* Trace stitching. */
 LJ_ASMF char lj_vm_asm_begin[];
 
 /* Bytecode offsets are relative to lj_vm_asm_begin. */
-#define makeasmfunc(ofs)	((ASMFunction)(lj_vm_asm_begin + (ofs)))
+#define makeasmfunc(ofs) lj_ptr_sign((ASMFunction)(lj_vm_asm_begin + (ofs)), 0)
 
 #endif
diff --git a/lib/luajit-3065c9/src/lj_vmevent.c b/lib/luajit2/src/lj_vmevent.c
similarity index 95%
rename from lib/luajit-3065c9/src/lj_vmevent.c
rename to lib/luajit2/src/lj_vmevent.c
index c8491d82c..477ee79bd 100644
--- a/lib/luajit-3065c9/src/lj_vmevent.c
+++ b/lib/luajit2/src/lj_vmevent.c
@@ -1,6 +1,6 @@
 /*
 ** VM event handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #include <stdio.h>
diff --git a/lib/luajit-3065c9/src/lj_vmevent.h b/lib/luajit2/src/lj_vmevent.h
similarity index 87%
rename from lib/luajit-3065c9/src/lj_vmevent.h
rename to lib/luajit2/src/lj_vmevent.h
index 40f9c6312..d757a8b5e 100644
--- a/lib/luajit-3065c9/src/lj_vmevent.h
+++ b/lib/luajit2/src/lj_vmevent.h
@@ -1,6 +1,6 @@
 /*
 ** VM event handling.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LJ_VMEVENT_H
@@ -24,9 +24,10 @@
 /* VM event IDs. */
 typedef enum {
   VMEVENT_DEF(BC,	0x00003883),
-  VMEVENT_DEF(TRACE,	0xb2d91467),
-  VMEVENT_DEF(RECORD,	0x9284bf4f),
-  VMEVENT_DEF(TEXIT,	0xb29df2b0),
+  VMEVENT_DEF(TRACE,	0x12d91467),
+  VMEVENT_DEF(RECORD,	0x1284bf4f),
+  VMEVENT_DEF(TEXIT,	0x129df2b0),
+  VMEVENT_DEF(ERRFIN,	0x12d93888),
   LJ_VMEVENT__MAX
 } VMEvent;
 
diff --git a/lib/luajit-3065c9/src/lj_vmmath.c b/lib/luajit2/src/lj_vmmath.c
similarity index 82%
rename from lib/luajit-3065c9/src/lj_vmmath.c
rename to lib/luajit2/src/lj_vmmath.c
index b6cc60ba5..3351e72b4 100644
--- a/lib/luajit-3065c9/src/lj_vmmath.c
+++ b/lib/luajit2/src/lj_vmmath.c
@@ -1,6 +1,6 @@
 /*
 ** Math helper functions for assembler VM.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define lj_vmmath_c
@@ -36,6 +36,17 @@ LJ_FUNCA double lj_wrap_fmod(double x, double y) { return fmod(x, y); }
 
 /* -- Helper functions ---------------------------------------------------- */
 
+/* Required to prevent the C compiler from applying FMA optimizations.
+**
+** Yes, there's -ffp-contract and the FP_CONTRACT pragma ... in theory.
+** But the current state of C compilers is a mess in this regard.
+** Also, this function is not performance sensitive at all.
+*/
+LJ_NOINLINE static double lj_vm_floormul(double x, double y)
+{
+  return lj_vm_floor(x / y) * y;
+}
+
 double lj_vm_foldarith(double x, double y, int op)
 {
   switch (op) {
@@ -43,7 +54,7 @@ double lj_vm_foldarith(double x, double y, int op)
   case IR_SUB - IR_ADD: return x-y; break;
   case IR_MUL - IR_ADD: return x*y; break;
   case IR_DIV - IR_ADD: return x/y; break;
-  case IR_MOD - IR_ADD: return x-lj_vm_floor(x/y)*y; break;
+  case IR_MOD - IR_ADD: return x-lj_vm_floormul(x, y); break;
   case IR_POW - IR_ADD: return pow(x, y); break;
   case IR_NEG - IR_ADD: return -x; break;
   case IR_ABS - IR_ADD: return fabs(x); break;
@@ -64,11 +75,11 @@ int32_t LJ_FASTCALL lj_vm_modi(int32_t a, int32_t b)
   uint32_t y, ua, ub;
   /* This must be checked before using this function. */
   lj_assertX(b != 0, "modulo with zero divisor");
-  ua = a < 0 ? (uint32_t)-a : (uint32_t)a;
-  ub = b < 0 ? (uint32_t)-b : (uint32_t)b;
+  ua = a < 0 ? ~(uint32_t)a+1u : (uint32_t)a;
+  ub = b < 0 ? ~(uint32_t)b+1u : (uint32_t)b;
   y = ua % ub;
   if (y != 0 && (a^b) < 0) y = y - ub;
-  if (((int32_t)y^b) < 0) y = (uint32_t)-(int32_t)y;
+  if (((int32_t)y^b) < 0) y = ~y+1u;
   return (int32_t)y;
 }
 #endif
diff --git a/lib/luajit-3065c9/src/ljamalg.c b/lib/luajit2/src/ljamalg.c
similarity index 96%
rename from lib/luajit-3065c9/src/ljamalg.c
rename to lib/luajit2/src/ljamalg.c
index cae8356c7..9a5108fcd 100644
--- a/lib/luajit-3065c9/src/ljamalg.c
+++ b/lib/luajit2/src/ljamalg.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT core and libraries amalgamation.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #define ljamalg_c
@@ -88,4 +88,3 @@
 #include "lib_ffi.c"
 #include "lib_buffer.c"
 #include "lib_init.c"
-
diff --git a/lib/luajit-3065c9/src/lua.h b/lib/luajit2/src/lua.h
similarity index 97%
rename from lib/luajit-3065c9/src/lua.h
rename to lib/luajit2/src/lua.h
index 6d1634d1c..3f631aa1e 100644
--- a/lib/luajit-3065c9/src/lua.h
+++ b/lib/luajit2/src/lua.h
@@ -112,6 +112,9 @@ LUA_API lua_State *(lua_newstate) (lua_Alloc f, void *ud);
 LUA_API void       (lua_close) (lua_State *L);
 LUA_API lua_State *(lua_newthread) (lua_State *L);
 
+#define HAVE_LUA_RESETTHREAD  1
+LUA_API void	   (lua_resetthread) (lua_State *L, lua_State *th);
+
 LUA_API lua_CFunction (lua_atpanic) (lua_State *L, lua_CFunction panicf);
 
 
@@ -245,7 +248,12 @@ LUA_API void  (lua_concat) (lua_State *L, int n);
 LUA_API lua_Alloc (lua_getallocf) (lua_State *L, void **ud);
 LUA_API void lua_setallocf (lua_State *L, lua_Alloc f, void *ud);
 
+LUA_API void lua_setexdata(lua_State *L, void *exdata);
+LUA_API void *lua_getexdata(lua_State *L);
 
+#define HAVE_LUA_EXDATA2 1
+LUA_API void lua_setexdata2(lua_State *L, void *exdata2);
+LUA_API void *lua_getexdata2(lua_State *L);
 
 /*
 ** ===============================================================
diff --git a/lib/luajit-3065c9/src/lua.hpp b/lib/luajit2/src/lua.hpp
similarity index 100%
rename from lib/luajit-3065c9/src/lua.hpp
rename to lib/luajit2/src/lua.hpp
diff --git a/lib/luajit-3065c9/src/luaconf.h b/lib/luajit2/src/luaconf.h
similarity index 97%
rename from lib/luajit-3065c9/src/luaconf.h
rename to lib/luajit2/src/luaconf.h
index e8790c1d0..f47f06802 100644
--- a/lib/luajit-3065c9/src/luaconf.h
+++ b/lib/luajit2/src/luaconf.h
@@ -1,6 +1,6 @@
 /*
 ** Configuration header.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef luaconf_h
@@ -37,7 +37,7 @@
 #endif
 #define LUA_LROOT	"/usr/local"
 #define LUA_LUADIR	"/lua/5.1/"
-#define LUA_LJDIR	"/luajit-2.1.0-beta3/"
+#define LUA_LJDIR	"/luajit-2.1/"
 
 #ifdef LUA_ROOT
 #define LUA_JROOT	LUA_ROOT
diff --git a/lib/luajit-3065c9/src/luajit.c b/lib/luajit2/src/luajit.c
similarity index 99%
rename from lib/luajit-3065c9/src/luajit.c
rename to lib/luajit2/src/luajit.c
index 6dd64026b..73e29d44f 100644
--- a/lib/luajit-3065c9/src/luajit.c
+++ b/lib/luajit2/src/luajit.c
@@ -1,6 +1,6 @@
 /*
 ** LuaJIT frontend. Runs commands, scripts, read-eval-print (REPL) etc.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 **
 ** Major portions taken verbatim or adapted from the Lua interpreter.
 ** Copyright (C) 1994-2008 Lua.org, PUC-Rio. See Copyright Notice in lua.h
diff --git a/lib/luajit-3065c9/src/luajit.h b/lib/luajit2/src/luajit_rolling.h
similarity index 87%
rename from lib/luajit-3065c9/src/luajit.h
rename to lib/luajit2/src/luajit_rolling.h
index 31f1eb1f5..cd617e7c6 100644
--- a/lib/luajit-3065c9/src/luajit.h
+++ b/lib/luajit2/src/luajit_rolling.h
@@ -1,7 +1,7 @@
 /*
 ** LuaJIT -- a Just-In-Time Compiler for Lua. https://luajit.org/
 **
-** Copyright (C) 2005-2022 Mike Pall. All rights reserved.
+** Copyright (C) 2005-2023 Mike Pall. All rights reserved.
 **
 ** Permission is hereby granted, free of charge, to any person obtaining
 ** a copy of this software and associated documentation files (the
@@ -30,10 +30,12 @@
 
 #include "lua.h"
 
-#define LUAJIT_VERSION		"LuaJIT 2.1.0-beta3"
-#define LUAJIT_VERSION_NUM	20100  /* Version 2.1.0 = 02.01.00. */
-#define LUAJIT_VERSION_SYM	luaJIT_version_2_1_0_beta3
-#define LUAJIT_COPYRIGHT	"Copyright (C) 2005-2022 Mike Pall"
+#define OPENRESTY_LUAJIT
+
+#define LUAJIT_VERSION		"LuaJIT 2.1.ROLLING"
+#define LUAJIT_VERSION_NUM	20199  /* Deprecated. */
+#define LUAJIT_VERSION_SYM	luaJIT_version_2_1_ROLLING
+#define LUAJIT_COPYRIGHT	"Copyright (C) 2005-2023 Mike Pall"
 #define LUAJIT_URL		"https://luajit.org/"
 
 /* Modes for luaJIT_setmode. */
@@ -76,4 +78,5 @@ LUA_API const char *luaJIT_profile_dumpstack(lua_State *L, const char *fmt,
 /* Enforce (dynamic) linker error for version mismatches. Call from main. */
 LUA_API void LUAJIT_VERSION_SYM(void);
 
+#error "DO NOT USE luajit_rolling.h -- only include build-generated luajit.h"
 #endif
diff --git a/lib/luajit-3065c9/src/lualib.h b/lib/luajit2/src/lualib.h
similarity index 91%
rename from lib/luajit-3065c9/src/lualib.h
rename to lib/luajit2/src/lualib.h
index 87748456f..e51887e39 100644
--- a/lib/luajit-3065c9/src/lualib.h
+++ b/lib/luajit2/src/lualib.h
@@ -1,6 +1,6 @@
 /*
 ** Standard library header.
-** Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+** Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 */
 
 #ifndef _LUALIB_H
@@ -21,6 +21,7 @@
 #define LUA_BITLIBNAME	"bit"
 #define LUA_JITLIBNAME	"jit"
 #define LUA_FFILIBNAME	"ffi"
+#define LUA_THRLIBNAME	"thread"
 
 LUALIB_API int luaopen_base(lua_State *L);
 LUALIB_API int luaopen_math(lua_State *L);
diff --git a/lib/luajit-3065c9/src/msvcbuild.bat b/lib/luajit2/src/msvcbuild.bat
similarity index 75%
rename from lib/luajit-3065c9/src/msvcbuild.bat
rename to lib/luajit2/src/msvcbuild.bat
index d323d8d44..91cfd0650 100644
--- a/lib/luajit-3065c9/src/msvcbuild.bat
+++ b/lib/luajit2/src/msvcbuild.bat
@@ -1,5 +1,5 @@
 @rem Script to build LuaJIT with MSVC.
-@rem Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+@rem Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 @rem
 @rem Open a "Visual Studio Command Prompt" (either x86 or x64).
 @rem Then cd to this directory and run this script. Use the following
@@ -16,6 +16,7 @@
 @rem Add more debug flags here, e.g. DEBUGCFLAGS=/DLUA_USE_APICHECK
 @set DEBUGCFLAGS=
 @set LJCOMPILE=cl /nologo /c /O2 /W3 /D_CRT_SECURE_NO_DEPRECATE /D_CRT_STDIO_INLINE=__declspec(dllexport)__inline
+@set LJDYNBUILD=/MD /DLUA_BUILD_AS_DLL
 @set LJLINK=link /nologo
 @set LJMT=mt /nologo
 @set LJLIB=lib /nologo /nodefaultlib
@@ -27,36 +28,52 @@
 @set BUILDTYPE=release
 @set ALL_LIB=lib_base.c lib_math.c lib_bit.c lib_string.c lib_table.c lib_io.c lib_os.c lib_package.c lib_debug.c lib_jit.c lib_ffi.c lib_buffer.c
 
+@setlocal
+@call :SETHOSTVARS
 %LJCOMPILE% host\minilua.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:minilua.exe minilua.obj
 @if errorlevel 1 goto :BAD
 if exist minilua.exe.manifest^
   %LJMT% -manifest minilua.exe.manifest -outputresource:minilua.exe
+@endlocal
 
-@set DASMFLAGS=-D WIN -D JIT -D FFI -D P64
+@set DASMFLAGS=-D WIN -D JIT -D FFI -D ENDIAN_LE -D FPU -D P64
 @set LJARCH=x64
 @minilua
-@if errorlevel 8 goto :X64
+@if errorlevel 8 goto :NO32
 @set DASC=vm_x86.dasc
-@set DASMFLAGS=-D WIN -D JIT -D FFI
+@set DASMFLAGS=-D WIN -D JIT -D FFI -D ENDIAN_LE -D FPU
 @set LJARCH=x86
 @set LJCOMPILE=%LJCOMPILE% /arch:SSE2
+@goto :DA
+:NO32
+@if "%VSCMD_ARG_TGT_ARCH%" neq "arm64" goto :X64
+@set DASC=vm_arm64.dasc
+@set DASMTARGET=-D LUAJIT_TARGET=LUAJIT_ARCH_ARM64
+@set LJARCH=arm64
+@goto :DA
 :X64
-@if "%1" neq "nogc64" goto :GC64
+@if "%1" neq "nogc64" goto :DA
 @shift
 @set DASC=vm_x86.dasc
 @set LJCOMPILE=%LJCOMPILE% /DLUAJIT_DISABLE_GC64
-:GC64
+:DA
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h %DASC%
 @if errorlevel 1 goto :BAD
 
-%LJCOMPILE% /I "." /I %DASMDIR% host\buildvm*.c
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
+@setlocal
+@call :SETHOSTVARS
+%LJCOMPILE% /I "." /I %DASMDIR% %DASMTARGET% host\buildvm*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
 @if errorlevel 1 goto :BAD
 if exist buildvm.exe.manifest^
   %LJMT% -manifest buildvm.exe.manifest -outputresource:buildvm.exe
+@endlocal
 
 buildvm -m peobj -o lj_vm.obj
 @if errorlevel 1 goto :BAD
@@ -77,12 +94,13 @@ buildvm -m folddef -o lj_folddef.h lj_opt_fold.c
 @shift
 @set BUILDTYPE=debug
 @set LJCOMPILE=%LJCOMPILE% /Zi %DEBUGCFLAGS%
+@set LJDYNBUILD=/MDd /DLUA_BUILD_AS_DLL
 @set LJLINK=%LJLINK% /opt:ref /opt:icf /incremental:no
 :NODEBUG
 @set LJLINK=%LJLINK% /%BUILDTYPE%
 @if "%1"=="amalg" goto :AMALGDLL
 @if "%1"=="static" goto :STATIC
-%LJCOMPILE% /MD /DLUA_BUILD_AS_DLL lj_*.c lib_*.c
+%LJCOMPILE% %LJDYNBUILD% lj_*.c lib_*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /DLL /out:%LJDLLNAME% lj_*.obj lib_*.obj
 @if errorlevel 1 goto :BAD
@@ -94,7 +112,7 @@ buildvm -m folddef -o lj_folddef.h lj_opt_fold.c
 @if errorlevel 1 goto :BAD
 @goto :MTDLL
 :AMALGDLL
-%LJCOMPILE% /MD /DLUA_BUILD_AS_DLL ljamalg.c
+%LJCOMPILE% %LJDYNBUILD% ljamalg.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /DLL /out:%LJDLLNAME% ljamalg.obj lj_vm.obj
 @if errorlevel 1 goto :BAD
@@ -115,6 +133,12 @@ if exist luajit.exe.manifest^
 @echo.
 @echo === Successfully built LuaJIT for Windows/%LJARCH% ===
 
+@goto :END
+:SETHOSTVARS
+@if "%VSCMD_ARG_HOST_ARCH%_%VSCMD_ARG_TGT_ARCH%" equ "x64_arm64" (
+  call "%VSINSTALLDIR%Common7\Tools\VsDevCmd.bat" -arch=%VSCMD_ARG_HOST_ARCH% -no_logo
+  echo on
+)
 @goto :END
 :BAD
 @echo.
diff --git a/lib/luajit-3065c9/src/nxbuild.bat b/lib/luajit2/src/nxbuild.bat
similarity index 94%
rename from lib/luajit-3065c9/src/nxbuild.bat
rename to lib/luajit2/src/nxbuild.bat
index c4a21f05c..7f84b747d 100644
--- a/lib/luajit-3065c9/src/nxbuild.bat
+++ b/lib/luajit2/src/nxbuild.bat
@@ -72,6 +72,10 @@ if exist minilua.exe.manifest^
 @set DASMFLAGS=%DASMFLAGS% %DASMTARGET% -D LJ_TARGET_NX -D LUAJIT_OS=LUAJIT_OS_OTHER -D LUAJIT_DISABLE_JIT -D LUAJIT_DISABLE_FFI
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h %DASC%
 @if errorlevel 1 goto :BAD
+
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
 %LJCOMPILE% /I "." /I %DASMDIR% %DASMTARGET% -D LJ_TARGET_NX -DLUAJIT_OS=LUAJIT_OS_OTHER -DLUAJIT_DISABLE_JIT -DLUAJIT_DISABLE_FFI host\buildvm*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
@@ -121,6 +125,7 @@ goto :BUILD
 @set TARGETLIB=libluajit_%TARGETLIB_SUFFIX%.a
 :BUILD
 del %TARGETLIB%
+@set LJCOMPILE=%LJCOMPILE% -fPIC
 @if "%1" neq "noamalg" goto :AMALG
 for %%f in (lj_*.c lib_*.c) do (
   %LJCOMPILE% %%f
diff --git a/lib/luajit-3065c9/src/ps4build.bat b/lib/luajit2/src/ps4build.bat
similarity index 89%
rename from lib/luajit-3065c9/src/ps4build.bat
rename to lib/luajit2/src/ps4build.bat
index fdd09d812..d6f73e5ab 100644
--- a/lib/luajit-3065c9/src/ps4build.bat
+++ b/lib/luajit2/src/ps4build.bat
@@ -51,7 +51,11 @@ if exist minilua.exe.manifest^
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h %DASC%
 @if errorlevel 1 goto :BAD
 
-%LJCOMPILE% /I "." /I %DASMDIR% %GC64% -DLUAJIT_TARGET=LUAJIT_ARCH_X64 -DLUAJIT_OS=LUAJIT_OS_OTHER -DLUAJIT_DISABLE_JIT -DLUAJIT_DISABLE_FFI -DLUAJIT_NO_UNWIND host\buildvm*.c
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
+%LJCOMPILE% /I "." /I %DASMDIR% %GC64% -DLUAJIT_TARGET=LUAJIT_ARCH_X64 -DLUAJIT_OS=LUAJIT_OS_OTHER -DLUAJIT_DISABLE_JIT -DLUAJIT_DISABLE_FFI -DLUAJIT_USE_SYSMALLOC -DLUAJIT_NO_UNWIND host\buildvm*.c
+
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
 @if errorlevel 1 goto :BAD
@@ -78,7 +82,7 @@ buildvm -m folddef -o lj_folddef.h lj_opt_fold.c
 @set LJLIB="%SCE_ORBIS_SDK_DIR%\host_tools\bin\orbis-ar" rcus
 @set INCLUDE=""
 
-orbis-as -o lj_vm.o lj_vm.s
+"%SCE_ORBIS_SDK_DIR%\host_tools\bin\orbis-as" -o lj_vm.o lj_vm.s
 
 @if "%1" neq "debug" goto :NODEBUG
 @shift
diff --git a/lib/luajit-3065c9/src/ps5build.bat b/lib/luajit2/src/ps5build.bat
similarity index 89%
rename from lib/luajit-3065c9/src/ps5build.bat
rename to lib/luajit2/src/ps5build.bat
index 0b1ebd5b4..30b719d63 100644
--- a/lib/luajit-3065c9/src/ps5build.bat
+++ b/lib/luajit2/src/ps5build.bat
@@ -51,6 +51,9 @@ if exist minilua.exe.manifest^
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h %DASC%
 @if errorlevel 1 goto :BAD
 
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
 %LJCOMPILE% /I "." /I %DASMDIR% %GC64% -DLUAJIT_TARGET=LUAJIT_ARCH_X64 -DLUAJIT_OS=LUAJIT_OS_OTHER -DLUAJIT_DISABLE_JIT -DLUAJIT_DISABLE_FFI -DLUAJIT_NO_UNWIND host\buildvm*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
@@ -74,11 +77,11 @@ buildvm -m folddef -o lj_folddef.h lj_opt_fold.c
 @if errorlevel 1 goto :BAD
 
 @rem ---- Cross compiler ----
-@set LJCOMPILE="%SCE_PROSPERO_SDK_DIR%\host_tools\bin\prospero-clang" -c -Wall -DLUAJIT_DISABLE_FFI %GC64%
+@set LJCOMPILE="%SCE_PROSPERO_SDK_DIR%\host_tools\bin\prospero-clang" -c -Wall -DLUAJIT_DISABLE_FFI -DLUAJIT_USE_SYSMALLOC %GC64%
 @set LJLIB="%SCE_PROSPERO_SDK_DIR%\host_tools\bin\prospero-llvm-ar" rcus
 @set INCLUDE=""
 
-%SCE_PROSPERO_SDK_DIR%\host_tools\bin\prospero-llvm-as -o lj_vm.o lj_vm.s
+"%SCE_PROSPERO_SDK_DIR%\host_tools\bin\prospero-clang" -c -o lj_vm.o lj_vm.s
 
 @if "%1" neq "debug" goto :NODEBUG
 @shift
diff --git a/lib/luajit-3065c9/src/psvitabuild.bat b/lib/luajit2/src/psvitabuild.bat
similarity index 92%
rename from lib/luajit-3065c9/src/psvitabuild.bat
rename to lib/luajit2/src/psvitabuild.bat
index 2980e1573..8d176e52f 100644
--- a/lib/luajit-3065c9/src/psvitabuild.bat
+++ b/lib/luajit2/src/psvitabuild.bat
@@ -31,6 +31,9 @@ if exist minilua.exe.manifest^
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h vm_arm.dasc
 @if errorlevel 1 goto :BAD
 
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
 %LJCOMPILE% /I "." /I %DASMDIR% -DLUAJIT_TARGET=LUAJIT_ARCH_ARM -DLUAJIT_OS=LUAJIT_OS_OTHER -DLUAJIT_DISABLE_JIT -DLUAJIT_DISABLE_FFI -DLJ_TARGET_PSVITA=1 host\buildvm*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
diff --git a/lib/luajit-3065c9/src/vm_arm.dasc b/lib/luajit2/src/vm_arm.dasc
similarity index 99%
rename from lib/luajit-3065c9/src/vm_arm.dasc
rename to lib/luajit2/src/vm_arm.dasc
index 770c1602b..fc08c658f 100644
--- a/lib/luajit-3065c9/src/vm_arm.dasc
+++ b/lib/luajit2/src/vm_arm.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for ARM CPUs.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |
 |.arch arm
 |.section code_op, code_sub
@@ -1195,8 +1195,11 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc pcall
+  |   ldr RB, L->maxstack
+  |   add INS, BASE, NARGS8:RC
   |  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
   |   cmp NARGS8:RC, #8
+  |   cmphs RB, INS
   |   blo ->fff_fallback
   |  tst RA, #HOOK_ACTIVE		// Remember active hook before pcall.
   |   mov RB, BASE
@@ -1207,7 +1210,11 @@ static void build_subroutines(BuildCtx *ctx)
   |  b ->vm_call_dispatch
   |
   |.ffunc_2 xpcall
+  |   ldr RB, L->maxstack
+  |   add INS, BASE, NARGS8:RC
   |  ldrb RA, [DISPATCH, #DISPATCH_GL(hookmask)]
+  |   cmp RB, INS
+  |   blo ->fff_fallback
   |  checkfunc CARG4, ->fff_fallback	// Traceback must be a function.
   |   mov RB, BASE
   |  strd CARG12, [BASE, #8]		// Swap function and traceback.
@@ -2196,8 +2203,8 @@ static void build_subroutines(BuildCtx *ctx)
   |.if JIT
   |  ldr L, SAVE_L
   |1:
-  |  cmp CARG1, #0
-  |  blt >9				// Check for error from exit.
+  |  cmn CARG1, #LUA_ERRERR
+  |  bhs >9				// Check for error from exit.
   |   lsl RC, CARG1, #3
   |  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
   |   str RC, SAVE_MULTRES
@@ -2213,6 +2220,8 @@ static void build_subroutines(BuildCtx *ctx)
   |   ldr INS, [PC], #4
   |     lsl MASKR8, MASKR8, #3		// MASKR8 = 255*8.
   |    st_vmstate CARG4
+  |  cmn CARG1, #17			// Static dispatch?
+  |  beq >5
   |  cmp OP, #BC_FUNCC+2		// Fast function?
   |  bhs >4
   |2:
@@ -2238,6 +2247,17 @@ static void build_subroutines(BuildCtx *ctx)
   |  ldr KBASE, [CARG3, #PC2PROTO(k)]
   |  b <2
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  ldr CARG1, [DISPATCH, #DISPATCH_J(trace)]
+  |  decode_RD RC, INS
+  |  ldr TRACE:CARG1, [CARG1, RC, lsl #2]
+  |  ldr INS, TRACE:CARG1->startins
+  |  decode_OP OP, INS
+  |   decode_RA8 RA, INS
+  |  add OP, DISPATCH, OP, lsl #2
+  |   decode_RD RC, INS
+  |  ldr pc, [OP, #GG_DISP2STATIC]
+  |
   |9:  // Rethrow error from the right C frame.
   |  rsb CARG2, CARG1, #0
   |  mov CARG1, L
@@ -2558,16 +2578,16 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |  mov r11, sp
   |  sub sp, sp, CARG1			// Readjust stack.
-  |   subs CARG2, CARG2, #1
+  |   subs CARG2, CARG2, #4
   |.if HFABI
   |  vldm RB, {d0-d7}
   |.endif
   |    ldr RB, CCSTATE->func
   |   bmi >2
   |1:  // Copy stack slots.
-  |  ldr CARG4, [CARG3, CARG2, lsl #2]
-  |  str CARG4, [sp, CARG2, lsl #2]
-  |  subs CARG2, CARG2, #1
+  |  ldr CARG4, [CARG3, CARG2]
+  |  str CARG4, [sp, CARG2]
+  |  subs CARG2, CARG2, #4
   |  bpl <1
   |2:
   |  ldrd CARG12, CCSTATE->gpr[0]
diff --git a/lib/luajit-3065c9/src/vm_arm64.dasc b/lib/luajit2/src/vm_arm64.dasc
similarity index 95%
rename from lib/luajit-3065c9/src/vm_arm64.dasc
rename to lib/luajit2/src/vm_arm64.dasc
index 3448d0d2b..a6ce05078 100644
--- a/lib/luajit-3065c9/src/vm_arm64.dasc
+++ b/lib/luajit2/src/vm_arm64.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for ARM64 CPUs.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |
 |.arch arm64
 |.section code_op, code_sub
@@ -77,6 +77,23 @@
 |.define CRET1,		x0
 |.define CRET1w,	w0
 |
+|//-----------------------------------------------------------------------
+|
+|// ARM64e pointer authentication codes (PAC).
+|.if PAUTH
+|.macro sp_auth; pacibsp; .endmacro
+|.macro br_auth, reg; braaz reg; .endmacro
+|.macro blr_auth, reg; blraaz reg; .endmacro
+|.macro ret_auth; retab; .endmacro
+|.else
+|.macro sp_auth; .endmacro
+|.macro br_auth, reg; br reg; .endmacro
+|.macro blr_auth, reg; blr reg; .endmacro
+|.macro ret_auth; ret; .endmacro
+|.endif
+|
+|//-----------------------------------------------------------------------
+|
 |// Stack layout while in interpreter. Must match with lj_frame.h.
 |
 |.define CFRAME_SPACE,	208
@@ -96,27 +113,52 @@
 |
 |.define TMPDofs,	#24
 |
+|.if WIN
+|// Windows unwind data is suited to r1 stored first.
+|.macro stp_unwind, r1, r2, where
+|  stp r1, r2, where
+|.endmacro
+|.macro ldp_unwind, r1, r2, where
+|  ldp r1, r2, where
+|.endmacro
+|.macro ldp_unwind, r1, r2, where, post_index
+|  ldp r1, r2, where, post_index
+|.endmacro
+|.else
+|// Otherwise store r2 first for compact unwind info (OSX).
+|.macro stp_unwind, r1, r2, where
+|  stp r2, r1, where
+|.endmacro
+|.macro ldp_unwind, r1, r2, where
+|  ldp r2, r1, where
+|.endmacro
+|.macro ldp_unwind, r1, r2, where, post_index
+|  ldp r2, r1, where, post_index
+|.endmacro
+|.endif
+|
 |.macro save_, gpr1, gpr2, fpr1, fpr2
-|  stp d..fpr2, d..fpr1, [sp, # SAVE_FPR_+(14-fpr1)*8]
-|  stp x..gpr2, x..gpr1, [sp, # SAVE_GPR_+(27-gpr1)*8]
+|  stp_unwind d..fpr1, d..fpr2, [sp, # SAVE_FPR_+(14-fpr1)*8]
+|  stp_unwind x..gpr1, x..gpr2, [sp, # SAVE_GPR_+(27-gpr1)*8]
 |.endmacro
 |.macro rest_, gpr1, gpr2, fpr1, fpr2
-|  ldp d..fpr2, d..fpr1, [sp, # SAVE_FPR_+(14-fpr1)*8]
-|  ldp x..gpr2, x..gpr1, [sp, # SAVE_GPR_+(27-gpr1)*8]
+|  ldp_unwind d..fpr1, d..fpr2, [sp, # SAVE_FPR_+(14-fpr1)*8]
+|  ldp_unwind x..gpr1, x..gpr2, [sp, # SAVE_GPR_+(27-gpr1)*8]
 |.endmacro
 |
 |.macro saveregs
+|  sp_auth
 |  sub sp, sp, # CFRAME_SPACE
 |  stp fp, lr, [sp, # SAVE_FP_LR_]
 |  add fp, sp, # SAVE_FP_LR_
-|  stp x20, x19, [sp, # SAVE_GPR_+(27-19)*8]
+|  stp_unwind x19, x20, [sp, # SAVE_GPR_+(27-19)*8]
 |  save_ 21, 22, 8, 9
 |  save_ 23, 24, 10, 11
 |  save_ 25, 26, 12, 13
 |  save_ 27, 28, 14, 15
 |.endmacro
 |.macro restoreregs
-|  ldp x20, x19, [sp, # SAVE_GPR_+(27-19)*8]
+|  ldp_unwind x19, x20, [sp, # SAVE_GPR_+(27-19)*8]
 |  rest_ 21, 22, 8, 9
 |  rest_ 23, 24, 10, 11
 |  rest_ 25, 26, 12, 13
@@ -180,7 +222,7 @@
 |   decode_RA RA, INS
 |  ldr TMP0, [TMP1, #GG_G2DISP]
 |   decode_RD RC, INS
-|  br TMP0
+|  br_auth TMP0
 |.endmacro
 |
 |// Instruction footer.
@@ -209,7 +251,7 @@
 |   decode_RA RA, INS
 |  ldr TMP0, [TMP1, #GG_G2DISP]
 |   add RA, BASE, RA, lsl #3
-|  br TMP0
+|  br_auth TMP0
 |.endmacro
 |
 |.macro ins_call
@@ -249,8 +291,17 @@
 |  blo target
 |.endmacro
 |
+|.macro init_constants
+|  movn TISNIL, #0
+|  movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
+|  movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
+|.endmacro
+|
 |.macro mov_false, reg; movn reg, #0x8000, lsl #32; .endmacro
 |.macro mov_true, reg; movn reg, #0x0001, lsl #48; .endmacro
+|.macro mov_nil, reg; mov reg, TISNIL; .endmacro
+|.macro cmp_nil, reg; cmp reg, TISNIL; .endmacro
+|.macro add_TISNUM, dst, src; add dst, src, TISNUM; .endmacro
 |
 #define GL_J(field)	(GG_G2J + (int)offsetof(jit_State, field))
 |
@@ -356,7 +407,7 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->vm_leave_unw:
   |  restoreregs
-  |  ret
+  |  ret_auth
   |
   |6:
   |  bgt >7				// Less results wanted?
@@ -388,26 +439,26 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
   |  // (void *cframe, int errcode)
+  |  add fp, CARG1, # SAVE_FP_LR_
   |  mov sp, CARG1
   |  mov CRET1, CARG2
-  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
   |  ldr L, SAVE_L
-  |   mv_vmstate TMP0w, C
   |  ldr GL, L->glref
+  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
+  |   mv_vmstate TMP0w, C
   |   st_vmstate TMP0w
   |  b ->vm_leave_unw
   |
   |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
   |  // (void *cframe)
-  |  and sp, CARG1, #CFRAME_RAWMASK
-  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
+  |  add fp, CARG1, # SAVE_FP_LR_
+  |  mov sp, CARG1
   |  ldr L, SAVE_L
-  |    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
-  |    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
-  |    movn TISNIL, #0
+  |    init_constants
+  |   ldr GL, L->glref			// Setup pointer to global state.
+  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
   |    mov RC, #16			// 2 results: false + error message.
   |  ldr BASE, L->base
-  |   ldr GL, L->glref			// Setup pointer to global state.
   |    mov_false TMP0
   |  sub RA, BASE, #8			// Results start at BASE-8.
   |  ldr PC, [BASE, FRAME_PC]		// Fetch PC of previous frame.
@@ -468,11 +519,9 @@ static void build_subroutines(BuildCtx *ctx)
   |  str L, GL->cur_L
   |  mov RA, BASE
   |   ldp BASE, CARG1, L->base
-  |    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
-  |    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
+  |    init_constants
   |  ldr PC, [BASE, FRAME_PC]
   |     strb wzr, L->status
-  |    movn TISNIL, #0
   |   sub RC, CARG1, BASE
   |  ands CARG1, PC, #FRAME_TYPE
   |   add RC, RC, #8
@@ -508,10 +557,8 @@ static void build_subroutines(BuildCtx *ctx)
   |3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
   |  str L, GL->cur_L
   |  ldp RB, CARG1, L->base		// RB = old base (for vmeta_call).
-  |    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
-  |    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
   |  add PC, PC, BASE
-  |    movn TISNIL, #0
+  |    init_constants
   |  sub PC, PC, RB			// PC = frame delta + frame type
   |   sub NARGS8:RC, CARG1, BASE
   |    st_vmstate ST_INTERP
@@ -542,7 +589,7 @@ static void build_subroutines(BuildCtx *ctx)
   |   str RC, SAVE_CFRAME
   |  str TMP0, L->cframe		// Add our C frame to cframe chain.
   |    str L, GL->cur_L
-  |  blr CARG4			// (lua_State *L, lua_CFunction func, void *ud)
+  |  blr_auth CARG4		// (lua_State *L, lua_CFunction func, void *ud)
   |  mov BASE, CRET1
   |   mov PC, #FRAME_CP
   |  cbnz BASE, <3			// Else continue with the call.
@@ -573,7 +620,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  ldr CARG3, LFUNC:CARG3->pc
   |  ldr KBASE, [CARG3, #PC2PROTO(k)]
   |  // BASE = base, RA = resultptr, CARG4 = meta base
-  |    br CARG1
+  |    br_auth CARG1
   |
   |.if FFI
   |1:
@@ -620,7 +667,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  b >1
   |
   |->vmeta_tgetb:			// RB = table, RC = index
-  |  add RC, RC, TISNUM
+  |  add_TISNUM RC, RC
   |   add CARG2, BASE, RB, lsl #3
   |   add CARG3, sp, TMPDofs
   |  str RC, TMPD
@@ -655,7 +702,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  sxtw CARG2, TMP1w
   |  bl extern lj_tab_getinth		// (GCtab *t, int32_t key)
   |  // Returns cTValue * or NULL.
-  |  mov TMP0, TISNIL
+  |  mov_nil TMP0
   |  cbz CRET1, ->BC_TGETR_Z
   |  ldr TMP0, [CRET1]
   |  b ->BC_TGETR_Z
@@ -678,7 +725,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  b >1
   |
   |->vmeta_tsetb:			// RB = table, RC = index
-  |  add RC, RC, TISNUM
+  |  add_TISNUM RC, RC
   |   add CARG2, BASE, RB, lsl #3
   |   add CARG3, sp, TMPDofs
   |  str RC, TMPD
@@ -992,7 +1039,7 @@ static void build_subroutines(BuildCtx *ctx)
   |1:  // Field metatable must be at same offset for GCtab and GCudata!
   |  ldr TAB:RB, TAB:CARG1->metatable
   |2:
-  |   mov CARG1, TISNIL
+  |   mov_nil CARG1
   |   ldr STR:RC, GL->gcroot[GCROOT_MMNAME+MM_metatable]
   |  cbz TAB:RB, ->fff_restv
   |  ldr TMP1w, TAB:RB->hmask
@@ -1014,7 +1061,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  movk CARG1, #(LJ_TTAB>>1)&0xffff, lsl #48
   |  b ->fff_restv
   |5:
-  |  cmp TMP0, TISNIL
+  |  cmp_nil TMP0
   |  bne ->fff_restv
   |  b <4
   |
@@ -1114,8 +1161,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  cbnz TAB:CARG2, ->fff_fallback
 #endif
   |  mov RC, #(3+1)*8
-  |  stp CARG1, TISNIL, [BASE, #-8]
-  |   str CFUNC:CARG4, [BASE, #-16]
+  |  stp CFUNC:CARG4, CARG1, [BASE, #-16]
+  |   str TISNIL, [BASE]
   |  b ->fff_res
   |
   |.ffunc_2 ipairs_aux
@@ -1127,14 +1174,14 @@ static void build_subroutines(BuildCtx *ctx)
   |  add CARG2w, CARG2w, #1
   |  cmp CARG2w, TMP1w
   |    ldr PC, [BASE, FRAME_PC]
-  |     add TMP2, CARG2, TISNUM
+  |     add_TISNUM TMP2, CARG2
   |   mov RC, #(0+1)*8
   |     str TMP2, [BASE, #-16]
   |  bhs >2				// Not in array part?
   |  ldr TMP0, [CARG3, CARG2, lsl #3]
   |1:
   |   mov TMP1, #(2+1)*8
-  |   cmp TMP0, TISNIL
+  |   cmp_nil TMP0
   |  str TMP0, [BASE, #-8]
   |   csel RC, RC, TMP1, eq
   |  b ->fff_res
@@ -1157,13 +1204,17 @@ static void build_subroutines(BuildCtx *ctx)
   |  cbnz TAB:CARG2, ->fff_fallback
 #endif
   |  mov RC, #(3+1)*8
-  |  stp CARG1, TISNUM, [BASE, #-8]
-  |   str CFUNC:CARG4, [BASE, #-16]
+  |  stp CFUNC:CARG4, CARG1, [BASE, #-16]
+  |   str TISNUM, [BASE]
   |  b ->fff_res
   |
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc pcall
+  |  ldr TMP1, L->maxstack
+  |  add TMP2, BASE, NARGS8:RC
+  |  cmp TMP1, TMP2
+  |  blo ->fff_fallback
   |   cmp NARGS8:RC, #8
   |  ldrb TMP0w, GL->hookmask
   |   blo ->fff_fallback
@@ -1183,6 +1234,10 @@ static void build_subroutines(BuildCtx *ctx)
   |  b ->vm_call_dispatch
   |
   |.ffunc xpcall
+  |  ldr TMP1, L->maxstack
+  |  add TMP2, BASE, NARGS8:RC
+  |  cmp TMP1, TMP2
+  |  blo ->fff_fallback
   |     ldp CARG1, CARG2, [BASE]
   |  ldrb TMP0w, GL->hookmask
   |   subs NARGS8:TMP1, NARGS8:RC, #16
@@ -1348,7 +1403,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  eor CARG2w, CARG1w, CARG1w, asr #31
   |   movz CARG3, #0x41e0, lsl #48	// 2^31.
   |  subs CARG1w, CARG2w, CARG1w, asr #31
-  |   add CARG1, CARG1, TISNUM
+  |   add_TISNUM CARG1, CARG1
   |  csel CARG1, CARG1, CARG3, pl
   |  // Fallthrough.
   |
@@ -1439,7 +1494,7 @@ static void build_subroutines(BuildCtx *ctx)
   |    ldr PC, [BASE, FRAME_PC]
   |  str d0, [BASE, #-16]
   |    mov RC, #(2+1)*8
-  |   add CARG2, CARG2, TISNUM
+  |   add_TISNUM CARG2, CARG2
   |   str CARG2, [BASE, #-8]
   |  b ->fff_res
   |
@@ -1505,7 +1560,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  bne ->fff_fallback
   |  ldrb TMP0w, STR:CARG1[1]		// Access is always ok (NUL at end).
   |   ldr CARG3w, STR:CARG1->len
-  |  add TMP0, TMP0, TISNUM
+  |  add_TISNUM TMP0, TMP0
   |  str TMP0, [BASE, #-16]
   |  mov RC, #(0+1)*8
   |   cbz CARG3, ->fff_res
@@ -1651,17 +1706,17 @@ static void build_subroutines(BuildCtx *ctx)
   |.ffunc_bit tobit
   |  mov TMP0w, CARG1w
   |9:  // Label reused by .ffunc_bit_op users.
-  |  add CARG1, TMP0, TISNUM
+  |  add_TISNUM CARG1, TMP0
   |  b ->fff_restv
   |
   |.ffunc_bit bswap
   |  rev TMP0w, CARG1w
-  |  add CARG1, TMP0, TISNUM
+  |  add_TISNUM CARG1, TMP0
   |  b ->fff_restv
   |
   |.ffunc_bit bnot
   |  mvn TMP0w, CARG1w
-  |  add CARG1, TMP0, TISNUM
+  |  add_TISNUM CARG1, TMP0
   |  b ->fff_restv
   |
   |.macro .ffunc_bit_sh, name, ins, shmod
@@ -1682,7 +1737,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  checkint CARG1, ->vm_tobit_fb
   |2:
   |  ins TMP0w, CARG1w, TMP1w
-  |  add CARG1, TMP0, TISNUM
+  |  add_TISNUM CARG1, TMP0
   |  b ->fff_restv
   |.endmacro
   |
@@ -1707,7 +1762,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  cmp TMP1, TMP2
   |   mov CARG1, L
   |  bhi >5				// Need to grow stack.
-  |   blr CARG3				// (lua_State *L)
+  |   blr_auth CARG3			// (lua_State *L)
   |  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
   |   ldr BASE, L->base
   |  cmp CRET1w, #0
@@ -1743,6 +1798,7 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->fff_gcstep:			// Call GC step function.
   |  // BASE = new base, RC = nargs*8
+  |  sp_auth
   |   add CARG2, BASE, NARGS8:RC	// Calculate L->top.
   |  mov RA, lr
   |   stp BASE, CARG2, L->base
@@ -1754,7 +1810,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  mov lr, RA				// Help return address predictor.
   |  sub NARGS8:RC, CARG2, BASE		// Calculate nargs*8.
   |   and CFUNC:CARG3, CARG3, #LJ_GCVMASK
-  |  ret
+  |  ret_auth
   |
   |//-----------------------------------------------------------------------
   |//-- Special dispatch targets -------------------------------------------
@@ -1781,7 +1837,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  tbz TMP2w, #HOOK_ACTIVE_SHIFT, >1	// Hook already active?
   |5:  // Re-dispatch to static ins.
   |  ldr TMP0, [TMP1, #GG_G2DISP+GG_DISP2STATIC]
-  |  br TMP0
+  |  br_auth TMP0
   |
   |->vm_inshook:			// Dispatch target for instr/line hooks.
   |  ldrb TMP2w, GL->hookmask
@@ -1807,7 +1863,7 @@ static void build_subroutines(BuildCtx *ctx)
   |   decode_RA RA, INS
   |  ldr TMP0, [TMP1, #GG_G2DISP+GG_DISP2STATIC]
   |   decode_RD RC, INS
-  |  br TMP0
+  |  br_auth TMP0
   |
   |->cont_hook:				// Continue from hook yield.
   |  ldr CARG1, [CARG4, #-40]
@@ -1857,7 +1913,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  sub NARGS8:RC, TMP1, BASE
   |   ldr INSw, [PC, #-4]
   |  and LFUNC:CARG3, CARG3, #LJ_GCVMASK
-  |  br CRET1
+  |  br_auth CRET1
   |
   |->cont_stitch:			// Trace stitching.
   |.if JIT
@@ -1870,8 +1926,7 @@ static void build_subroutines(BuildCtx *ctx)
   |    and CARG3, CARG3, #LJ_GCVMASK
   |   beq >2
   |1:  // Move results down.
-  |  ldr CARG1, [RA]
-  |    add RA, RA, #8
+  |  ldr CARG1, [RA], #8
   |   subs RB, RB, #8
   |  str CARG1, [BASE, RC, lsl #3]
   |    add RC, RC, #1
@@ -1986,13 +2041,11 @@ static void build_subroutines(BuildCtx *ctx)
   |.if JIT
   |  ldr L, SAVE_L
   |1:
-  |  cmp CARG1w, #0
-  |  blt >9				// Check for error from exit.
-  |   lsl RC, CARG1, #3
+  |   init_constants
+  |  cmn CARG1w, #LUA_ERRERR
+  |  bhs >9				// Check for error from exit.
   |  ldr LFUNC:CARG2, [BASE, FRAME_FUNC]
-  |    movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
-  |    movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
-  |    movn TISNIL, #0
+  |   lsl RC, CARG1, #3
   |  and LFUNC:CARG2, CARG2, #LJ_GCVMASK
   |   str RCw, SAVE_MULTRES
   |   str BASE, L->base
@@ -2004,6 +2057,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  ldrb RBw, [PC, # OFS_OP]
   |   ldr INSw, [PC], #4
   |    st_vmstate CARG4w
+  |  cmn CARG1w, #17			// Static dispatch?
+  |  beq >5
   |  cmp RBw, #BC_FUNCC+2		// Fast function?
   |   add TMP1, GL, INS, uxtb #3
   |  bhs >4
@@ -2014,13 +2069,13 @@ static void build_subroutines(BuildCtx *ctx)
   |   decode_RA RA, INS
   |   lsr TMP0, INS, #16
   |   csel RC, TMP0, RC, lo
-  |   blo >5
+  |   blo >3
   |   ldr CARG3, [BASE, FRAME_FUNC]
   |   sub RC, RC, #8
   |   add RA, BASE, RA, lsl #3	// Yes: RA = BASE+framesize*8, RC = nargs*8
   |   and LFUNC:CARG3, CARG3, #LJ_GCVMASK
-  |5:
-  |  br RB
+  |3:
+  |  br_auth RB
   |
   |4:  // Check frame below fast function.
   |  ldr CARG1, [BASE, FRAME_PC]
@@ -2036,6 +2091,17 @@ static void build_subroutines(BuildCtx *ctx)
   |  ldr KBASE, [CARG3, #PC2PROTO(k)]
   |  b <2
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  ldr RA, [GL, #GL_J(trace)]
+  |  decode_RD RC, INS
+  |  ldr TRACE:RA, [RA, RC, lsl #3]
+  |  ldr INSw, TRACE:RA->startins
+  |  add TMP0, GL, INS, uxtb #3
+  |   decode_RA RA, INS
+  |  ldr RB, [TMP0, #GG_G2DISP+GG_DISP2STATIC]
+  |   decode_RD RC, INS
+  |  br_auth RB
+  |
   |9:  // Rethrow error from the right C frame.
   |  neg CARG2w, CARG1w
   |  mov CARG1, L
@@ -2130,7 +2196,7 @@ static void build_subroutines(BuildCtx *ctx)
   |//-----------------------------------------------------------------------
   |
   |// Handler for callback functions.
-  |// Saveregs already performed. Callback slot number in [sp], g in r12.
+  |// Saveregs already performed. Callback slot number in w9, g in x10.
   |->vm_ffi_callback:
   |.if FFI
   |.type CTSTATE, CTState, PC
@@ -2154,9 +2220,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  bl extern lj_ccallback_enter	// (CTState *cts, void *cf)
   |  // Returns lua_State *.
   |  ldp BASE, RC, L:CRET1->base
-  |   movz TISNUM, #(LJ_TISNUM>>1)&0xffff, lsl #48
-  |   movz TISNUMhi, #(LJ_TISNUM>>1)&0xffff, lsl #16
-  |   movn TISNIL, #0
+  |   init_constants
   |   mov L, CRET1
   |  ldr LFUNC:CARG3, [BASE, FRAME_FUNC]
   |  sub RC, RC, BASE
@@ -2182,21 +2246,22 @@ static void build_subroutines(BuildCtx *ctx)
   |  // Caveat: needs special frame unwinding, see below.
   |.if FFI
   |  .type CCSTATE, CCallState, x19
-  |  stp x20, CCSTATE, [sp, #-32]!
+  |  sp_auth
+  |  stp_unwind CCSTATE, x20, [sp, #-32]!
   |  stp fp, lr, [sp, #16]
   |  add fp, sp, #16
   |  mov CCSTATE, x0
   |  ldr TMP0w, CCSTATE:x0->spadj
   |   ldrb TMP1w, CCSTATE->nsp
   |    add TMP2, CCSTATE, #offsetof(CCallState, stack)
-  |   subs TMP1, TMP1, #1
+  |   subs TMP1, TMP1, #8
   |    ldr TMP3, CCSTATE->func
   |  sub sp, sp, TMP0
   |   bmi >2
   |1:  // Copy stack slots
-  |  ldr TMP0, [TMP2, TMP1, lsl #3]
-  |  str TMP0, [sp, TMP1, lsl #3]
-  |  subs TMP1, TMP1, #1
+  |  ldr TMP0, [TMP2, TMP1]
+  |  str TMP0, [sp, TMP1]
+  |  subs TMP1, TMP1, #8
   |  bpl <1
   |2:
   |  ldp x0, x1, CCSTATE->gpr[0]
@@ -2208,14 +2273,14 @@ static void build_subroutines(BuildCtx *ctx)
   |  ldp x6, x7, CCSTATE->gpr[6]
   |   ldp d6, d7, CCSTATE->fpr[6]
   |  ldr x8, CCSTATE->retp
-  |  blr TMP3
+  |  blr_auth TMP3
   |  sub sp, fp, #16
   |  stp x0, x1, CCSTATE->gpr[0]
   |   stp d0, d1, CCSTATE->fpr[0]
   |   stp d2, d3, CCSTATE->fpr[2]
   |  ldp fp, lr, [sp, #16]
-  |  ldp x20, CCSTATE, [sp], #32
-  |  ret
+  |  ldp_unwind CCSTATE, x20, [sp], #32
+  |  ret_auth
   |.endif
   |// Note: vm_ffi_call must be the last function in this object file!
   |
@@ -2534,7 +2599,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bne >5
     |  negs TMP0w, TMP0w
     |   movz CARG3, #0x41e0, lsl #48	// 2^31.
-    |   add TMP0, TMP0, TISNUM
+    |   add_TISNUM TMP0, TMP0
     |  csel TMP0, TMP0, CARG3, vc
     |5:
     |  str TMP0, [BASE, RA, lsl #3]
@@ -2549,7 +2614,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bne >2
     |  ldr CARG1w, STR:CARG1->len
     |1:
-    |  add CARG1, CARG1, TISNUM
+    |  add_TISNUM CARG1, CARG1
     |  str CARG1, [BASE, RA, lsl #3]
     |  ins_next
     |
@@ -2636,7 +2701,9 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.macro ins_arithmod, res, reg1, reg2
     |  fdiv d2, reg1, reg2
     |  frintm d2, d2
-    |  fmsub res, d2, reg2, reg1
+    |  // Cannot use fmsub, because FMA is not enabled by default.
+    |  fmul d2, d2, reg2
+    |  fsub res, reg1, d2
     |.endmacro
     |
     |.macro ins_arithdn, intins, fpins
@@ -2655,7 +2722,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  intins CARG1w, CARG1w, CARG2w
     |  ins_arithfallback bvs
     |.endif
-    |  add CARG1, CARG1, TISNUM
+    |  add_TISNUM CARG1, CARG1
     |  str CARG1, [BASE, RA, lsl #3]
     |4:
     |  ins_next
@@ -2748,7 +2815,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_KSHORT:
     |  // RA = dst, RC = int16_literal
     |  sxth RCw, RCw
-    |  add TMP0, RC, TISNUM
+    |  add_TISNUM TMP0, RC
     |  str TMP0, [BASE, RA, lsl #3]
     |  ins_next
     break;
@@ -2971,7 +3038,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   cmp TMP1w, CARG1w		// In array part?
     |   bhs ->vmeta_tgetv
     |  ldr TMP0, [CARG3]
-    |  cmp TMP0, TISNIL
+    |  cmp_nil TMP0
     |  beq >5
     |1:
     |  str TMP0, [BASE, RA, lsl #3]
@@ -3014,7 +3081,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   ldr NODE:CARG3, NODE:CARG3->next
     |  cmp CARG1, CARG4
     |  bne >4
-    |  cmp TMP0, TISNIL
+    |  cmp_nil TMP0
     |  beq >5
     |3:
     |  str TMP0, [BASE, RA, lsl #3]
@@ -3023,7 +3090,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |4:  // Follow hash chain.
     |  cbnz NODE:CARG3, <1
     |  // End of hash chain: key not found, nil result.
-    |   mov TMP0, TISNIL
+    |   mov_nil TMP0
     |
     |5:  // Check for __index if table value is nil.
     |  ldr TAB:CARG1, TAB:CARG2->metatable
@@ -3044,7 +3111,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   cmp RCw, CARG1w			// In array part?
     |   bhs ->vmeta_tgetb
     |  ldr TMP0, [CARG3]
-    |  cmp TMP0, TISNIL
+    |  cmp_nil TMP0
     |  beq >5
     |1:
     |  str TMP0, [BASE, RA, lsl #3]
@@ -3091,7 +3158,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  ldr TMP1, [CARG3]
     |   ldr TMP0, [BASE, RA, lsl #3]
     |    ldrb TMP2w, TAB:CARG2->marked
-    |  cmp TMP1, TISNIL			// Previous value is nil?
+    |  cmp_nil TMP1			// Previous value is nil?
     |  beq >5
     |1:
     |   str TMP0, [CARG3]
@@ -3143,7 +3210,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  cmp CARG1, CARG4
     |  bne >5
     |   ldr TMP0, [BASE, RA, lsl #3]
-    |  cmp TMP1, TISNIL			// Previous value is nil?
+    |  cmp_nil TMP1			// Previous value is nil?
     |  beq >4
     |2:
     |   str TMP0, NODE:CARG3->val
@@ -3202,7 +3269,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  ldr TMP1, [CARG3]
     |   ldr TMP0, [BASE, RA, lsl #3]
     |    ldrb TMP2w, TAB:CARG2->marked
-    |  cmp TMP1, TISNIL			// Previous value is nil?
+    |  cmp_nil TMP1			// Previous value is nil?
     |  beq >5
     |1:
     |   str TMP0, [CARG3]
@@ -3301,9 +3368,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |->BC_CALL_Z:
     |  mov RB, BASE			// Save old BASE for vmeta_call.
     |  add BASE, BASE, RA, lsl #3
-    |  ldr CARG3, [BASE]
+    |  ldr CARG3, [BASE], #16
     |   sub NARGS8:RC, NARGS8:RC, #8
-    |   add BASE, BASE, #16
     |  checkfunc CARG3, ->vmeta_call
     |  ins_call
     break;
@@ -3319,9 +3385,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  // RA = base, (RB = 0,) RC = (nargs+1)*8
     |->BC_CALLT1_Z:
     |  add RA, BASE, RA, lsl #3
-    |  ldr TMP1, [RA]
+    |  ldr TMP1, [RA], #16
     |   sub NARGS8:RC, NARGS8:RC, #8
-    |   add RA, RA, #16
     |  checktp CARG3, TMP1, LJ_TFUNC, ->vmeta_callt
     |  ldr PC, [BASE, FRAME_PC]
     |->BC_CALLT2_Z:
@@ -3401,10 +3466,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   add CARG3, CARG2, CARG1, lsl #3
     |  bhs >5				// Index points after array part?
     |   ldr TMP0, [CARG3]
-    |   cmp TMP0, TISNIL
+    |   cmp_nil TMP0
     |   cinc CARG1, CARG1, eq		// Skip holes in array part.
     |   beq <1
-    |   add CARG1, CARG1, TISNUM
+    |   add_TISNUM CARG1, CARG1
     |   stp CARG1, TMP0, [RA]
     |    add CARG1, CARG1, #1
     |3:
@@ -3422,7 +3487,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   add NODE:CARG3, NODE:RB, CARG1, lsl #3  // node = tab->node + idx*3*8
     |  bhi <4
     |  ldp TMP0, CARG1, NODE:CARG3->val
-    |  cmp TMP0, TISNIL
+    |  cmp_nil TMP0
     |   add RC, RC, #1
     |  beq <6				// Skip holes in hash part.
     |  stp CARG1, TMP0, [RA]
@@ -3440,8 +3505,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  checkfunc CFUNC:CARG1, >5
     |   asr TMP0, TAB:CARG3, #47
     |  ldrb TMP1w, CFUNC:CARG1->ffid
-    |   cmn TMP0, #-LJ_TTAB
-    |   ccmp CARG4, TISNIL, #0, eq
+    |   cmp_nil CARG4
+    |   ccmn TMP0, #-LJ_TTAB, #0, eq
     |  ccmp TMP1w, #FF_next_N, #0, eq
     |  bne >5
     |  mov TMP0w, #0xfffe7fff		// LJ_KEYINDEX
@@ -3481,51 +3546,51 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   and RC, RC, #255
     |  // RA = base, RB = (nresults+1), RC = numparams
     |  ldr TMP1, [BASE, FRAME_PC]
-    |  add RC, BASE, RC, lsl #3
-    |   add RA, BASE, RA, lsl #3
-    |  add RC, RC, #FRAME_VARG
-    |   add TMP2, RA, RB, lsl #3
-    |  sub RC, RC, TMP1			// RC = vbase
-    |  // Note: RC may now be even _above_ BASE if nargs was < numparams.
+    |  add TMP0, BASE, RC, lsl #3
+    |   add RC, BASE, RA, lsl #3	// RC = destination
+    |  add TMP0, TMP0, #FRAME_VARG
+    |   add TMP2, RC, RB, lsl #3
+    |  sub RA, TMP0, TMP1		// RA = vbase
+    |  // Note: RA may now be even _above_ BASE if nargs was < numparams.
     |   sub TMP3, BASE, #16		// TMP3 = vtop
     |  cbz RB, >5
     |   sub TMP2, TMP2, #16
     |1:  // Copy vararg slots to destination slots.
-    |  cmp RC, TMP3
-    |  ldr TMP0, [RC], #8
-    |  csel TMP0, TMP0, TISNIL, lo
-    |   cmp RA, TMP2
-    |  str TMP0, [RA], #8
+    |  cmp RA, TMP3
+    |  ldr TMP0, [RA], #8
+    |  csinv TMP0, TMP0, xzr, lo	// TISNIL = ~xzr
+    |   cmp RC, TMP2
+    |  str TMP0, [RC], #8
     |   blo <1
     |2:
     |  ins_next
     |
     |5:  // Copy all varargs.
     |  ldr TMP0, L->maxstack
-    |   subs TMP2, TMP3, RC
+    |   subs TMP2, TMP3, RA
     |   csel RB, xzr, TMP2, le		// MULTRES = (max(vtop-vbase,0)+1)*8
     |   add RB, RB, #8
-    |  add TMP1, RA, TMP2
+    |  add TMP1, RC, TMP2
     |   str RBw, SAVE_MULTRES
     |   ble <2				// Nothing to copy.
     |  cmp TMP1, TMP0
     |  bhi >7
     |6:
-    |  ldr TMP0, [RC], #8
-    |  str TMP0, [RA], #8
-    |  cmp RC, TMP3
+    |  ldr TMP0, [RA], #8
+    |  str TMP0, [RC], #8
+    |  cmp RA, TMP3
     |  blo <6
     |  b <2
     |
     |7:  // Grow stack for varargs.
     |  lsr CARG2, TMP2, #3
-    |   stp BASE, RA, L->base
+    |   stp BASE, RC, L->base
     |  mov CARG1, L
-    |  sub RC, RC, BASE			// Need delta, because BASE may change.
+    |  sub RA, RA, BASE			// Need delta, because BASE may change.
     |   str PC, SAVE_PC
     |  bl extern lj_state_growstack	// (lua_State *L, int n)
-    |  ldp BASE, RA, L->base
-    |  add RC, BASE, RC
+    |  ldp BASE, RC, L->base
+    |  add RA, BASE, RA
     |  sub TMP3, BASE, #16
     |  b <6
     break;
@@ -3669,7 +3734,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     } else {
       |  adds CARG1w, CARG1w, CARG3w
       |  bvs >2
-      |   add TMP0, CARG1, TISNUM
+      |   add_TISNUM TMP0, CARG1
       |  tbnz CARG3w, #31, >4
       |  cmp CARG1w, CARG2w
     }
@@ -3748,7 +3813,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  // RA = base, RC = target
     |  ldr CARG1, [BASE, RA, lsl #3]
     |   add TMP1, BASE, RA, lsl #3
-    |  cmp CARG1, TISNIL
+    |  cmp_nil CARG1
     |  beq >1				// Stop if iterator returned nil.
     if (op == BC_JITERL) {
       |  str CARG1, [TMP1, #-8]
@@ -3781,15 +3846,22 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.if JIT
     |  // RA = base (ignored), RC = traceno
     |  ldr CARG1, [GL, #GL_J(trace)]
-    |   mov CARG2w, #0  // Traces on ARM64 don't store the trace #, so use 0.
+    |   st_vmstate wzr  // Traces on ARM64 don't store the trace #, so use 0.
     |  ldr TRACE:RC, [CARG1, RC, lsl #3]
-    |   st_vmstate CARG2w
+    |.if PAUTH
+    |  ldr RA, TRACE:RC->mcauth
+    |.else
     |  ldr RA, TRACE:RC->mcode
+    |.endif
     |   str BASE, GL->jit_base
     |   str L, GL->tmpbuf.L
     |  sub sp, sp, #16	// See SPS_FIXED. Avoids sp adjust in every root trace.
+    |.if PAUTH
+    |  braa RA, RC
+    |.else
     |  br RA
     |.endif
+    |.endif
     break;
 
   case BC_JMP:
@@ -3850,6 +3922,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   add TMP2, BASE, RC
     |   add LFUNC:CARG3, CARG3, TMP0, lsl #47
     |  add RA, RA, RC
+    |  sub CARG1, CARG1, #8
     |   add TMP0, RC, #16+FRAME_VARG
     |   str LFUNC:CARG3, [TMP2], #8	// Store (tagged) copy of LFUNC.
     |    ldr KBASE, [PC, #-4+PC2PROTO(k)]
@@ -3899,7 +3972,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  mov CARG1, L
     |   bhi ->vm_growstack_c		// Need to grow stack.
     |    st_vmstate TMP0w
-    |  blr CARG4			// (lua_State *L [, lua_CFunction f])
+    |  blr_auth CARG4			// (lua_State *L [, lua_CFunction f])
     |  // Returns nresults.
     |  ldp BASE, TMP1, L->base
     |    str L, GL->cur_L
diff --git a/lib/luajit-3065c9/src/vm_mips.dasc b/lib/luajit2/src/vm_mips.dasc
similarity index 99%
rename from lib/luajit-3065c9/src/vm_mips.dasc
rename to lib/luajit2/src/vm_mips.dasc
index 34645bf14..8760a1f60 100644
--- a/lib/luajit-3065c9/src/vm_mips.dasc
+++ b/lib/luajit2/src/vm_mips.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for MIPS CPUs.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |//
 |// MIPS soft-float support contributed by Djordje Kovacevic and
 |// Stefan Pejic from RT-RK.com, sponsored by Cisco Systems, Inc.
@@ -1374,9 +1374,13 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc pcall
+  |   lw TMP1, L->maxstack
+  |   addu TMP2, BASE, NARGS8:RC
   |  lbu TMP3, DISPATCH_GL(hookmask)(DISPATCH)
   |  beqz NARGS8:RC, ->fff_fallback
-  |   move TMP2, BASE
+  |.  sltu AT, TMP1, TMP2
+  |   bnez AT, ->fff_fallback
+  |.   move TMP2, BASE
   |   addiu BASE, BASE, 8
   |  // Remember active hook before pcall.
   |  srl TMP3, TMP3, HOOK_ACTIVE_SHIFT
@@ -1386,8 +1390,12 @@ static void build_subroutines(BuildCtx *ctx)
   |.  addiu NARGS8:RC, NARGS8:RC, -8
   |
   |.ffunc xpcall
+  |   lw TMP1, L->maxstack
+  |   addu TMP2, BASE, NARGS8:RC
   |    sltiu AT, NARGS8:RC, 16
   |  lw CARG4, 8+HI(BASE)
+  |   sltu TMP1, TMP1, TMP2
+  |    or AT, AT, TMP1
   |    bnez AT, ->fff_fallback
   |.  lw CARG3, 8+LO(BASE)
   |   lw CARG1, LO(BASE)
@@ -2466,7 +2474,8 @@ static void build_subroutines(BuildCtx *ctx)
   |   addiu DISPATCH, JGL, -GG_DISP2G-32768
   |  sw BASE, L->base
   |1:
-  |  bltz CRET1, >9			// Check for error from exit.
+  |  sltiu TMP0, CRET1, -LUA_ERRERR	// Check for error from exit.
+  |  beqz TMP0, >9
   |.  lw LFUNC:RB, FRAME_FUNC(BASE)
   |    .FPU lui TMP3, 0x59c0			// TOBIT = 2^52 + 2^51 (float).
   |  sll MULTRES, CRET1, 3
@@ -2480,14 +2489,16 @@ static void build_subroutines(BuildCtx *ctx)
   |    .FPU cvt.d.s TOBIT, TOBIT
   |  // Modified copy of ins_next which handles function header dispatch, too.
   |  lw INS, 0(PC)
-  |   addiu PC, PC, 4
+  |  addiu CRET1, CRET1, 17		// Static dispatch?
   |    // Assumes TISNIL == ~LJ_VMST_INTERP == -1
   |    sw TISNIL, DISPATCH_GL(vmstate)(DISPATCH)
+  |   decode_RD8a RD, INS
+  |  beqz CRET1, >5
+  |.  addiu PC, PC, 4
   |  decode_OP4a TMP1, INS
   |  decode_OP4b TMP1
-  |    sltiu TMP2, TMP1, BC_FUNCF*4
   |  addu TMP0, DISPATCH, TMP1
-  |   decode_RD8a RD, INS
+  |    sltiu TMP2, TMP1, BC_FUNCF*4
   |  lw AT, 0(TMP0)
   |   decode_RA8a RA, INS
   |    beqz TMP2, >2
@@ -2515,6 +2526,22 @@ static void build_subroutines(BuildCtx *ctx)
   |  jr AT
   |.  addu RA, RA, BASE
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  lw TMP0, DISPATCH_J(trace)(DISPATCH)
+  |  decode_RD4b RD
+  |  addu TMP0, TMP0, RD
+  |  lw TRACE:TMP2, 0(TMP0)
+  |  lw INS, TRACE:TMP2->startins
+  |  decode_OP4a TMP1, INS
+  |  decode_OP4b TMP1
+  |  addu TMP0, DISPATCH, TMP1
+  |   decode_RD8a RD, INS
+  |  lw AT, GG_DISP2STATIC(TMP0)
+  |   decode_RA8a RA, INS
+  |   decode_RD8b RD
+  |  jr AT
+  |.  decode_RA8b RA
+  |
   |9:  // Rethrow error from the right C frame.
   |  load_got lj_err_trace
   |  sub CARG2, r0, CRET1
@@ -2932,7 +2959,6 @@ static void build_subroutines(BuildCtx *ctx)
   |  move TMP2, sp
   |  subu sp, sp, TMP1
   |  sw ra, -4(TMP2)
-  |   sll CARG2, CARG2, 2
   |  sw r16, -8(TMP2)
   |  sw CCSTATE, -12(TMP2)
   |  move r16, TMP2
diff --git a/lib/luajit-3065c9/src/vm_mips64.dasc b/lib/luajit2/src/vm_mips64.dasc
similarity index 99%
rename from lib/luajit-3065c9/src/vm_mips64.dasc
rename to lib/luajit2/src/vm_mips64.dasc
index 651bc42e7..a8d204137 100644
--- a/lib/luajit-3065c9/src/vm_mips64.dasc
+++ b/lib/luajit2/src/vm_mips64.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for MIPS64 CPUs.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |//
 |// Contributed by Djordje Kovacevic and Stefan Pejic from RT-RK.com.
 |// Sponsored by Cisco Systems, Inc.
@@ -1415,8 +1415,12 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc pcall
+  |  ld TMP1, L->maxstack
+  |  daddu TMP2, BASE, NARGS8:RC
+  |  sltu AT, TMP1, TMP2
+  |  bnez AT, ->fff_fallback
+  |.  lbu TMP3, DISPATCH_GL(hookmask)(DISPATCH)
   |  daddiu NARGS8:RC, NARGS8:RC, -8
-  |  lbu TMP3, DISPATCH_GL(hookmask)(DISPATCH)
   |  bltz NARGS8:RC, ->fff_fallback
   |.   move TMP2, BASE
   |   daddiu BASE, BASE, 16
@@ -1437,8 +1441,12 @@ static void build_subroutines(BuildCtx *ctx)
   |.  nop
   |
   |.ffunc xpcall
+  |  ld TMP1, L->maxstack
+  |  daddu TMP2, BASE, NARGS8:RC
+  |  sltu AT, TMP1, TMP2
+  |  bnez AT, ->fff_fallback
+  |.  ld CARG1, 0(BASE)
   |  daddiu NARGS8:TMP0, NARGS8:RC, -16
-  |  ld CARG1, 0(BASE)
   |   ld CARG2, 8(BASE)
   |    bltz NARGS8:TMP0, ->fff_fallback
   |.    lbu TMP1, DISPATCH_GL(hookmask)(DISPATCH)
@@ -2571,7 +2579,8 @@ static void build_subroutines(BuildCtx *ctx)
   |   daddiu DISPATCH, JGL, -GG_DISP2G-32768
   |  sd BASE, L->base
   |1:
-  |  bltz CRET1, >9			// Check for error from exit.
+  |  sltiu TMP0, CRET1, -LUA_ERRERR	// Check for error from exit.
+  |  beqz TMP0, >9
   |.  ld LFUNC:RB, FRAME_FUNC(BASE)
   |    .FPU lui TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
   |  dsll MULTRES, CRET1, 3
@@ -2586,14 +2595,16 @@ static void build_subroutines(BuildCtx *ctx)
   |    .FPU cvt.d.s TOBIT, TOBIT
   |  // Modified copy of ins_next which handles function header dispatch, too.
   |  lw INS, 0(PC)
-  |   daddiu PC, PC, 4
+  |  addiu CRET1, CRET1, 17		// Static dispatch?
   |    // Assumes TISNIL == ~LJ_VMST_INTERP == -1
   |    sw TISNIL, DISPATCH_GL(vmstate)(DISPATCH)
+  |   decode_RD8a RD, INS
+  |  beqz CRET1, >5
+  |.  daddiu PC, PC, 4
   |  decode_OP8a TMP1, INS
   |  decode_OP8b TMP1
-  |    sltiu TMP2, TMP1, BC_FUNCF*8
   |  daddu TMP0, DISPATCH, TMP1
-  |   decode_RD8a RD, INS
+  |    sltiu TMP2, TMP1, BC_FUNCF*8
   |  ld AT, 0(TMP0)
   |   decode_RA8a RA, INS
   |    beqz TMP2, >2
@@ -2622,6 +2633,22 @@ static void build_subroutines(BuildCtx *ctx)
   |  jr AT
   |.  daddu RA, RA, BASE
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  ld TMP0, DISPATCH_J(trace)(DISPATCH)
+  |  decode_RD8b RD
+  |  daddu TMP0, TMP0, RD
+  |  ld TRACE:TMP2, 0(TMP0)
+  |  lw INS, TRACE:TMP2->startins
+  |  decode_OP8a TMP1, INS
+  |  decode_OP8b TMP1
+  |  daddu TMP0, DISPATCH, TMP1
+  |   decode_RD8a RD, INS
+  |  ld AT, GG_DISP2STATIC(TMP0)
+  |   decode_RA8a RA, INS
+  |   decode_RD8b RD
+  |  jr AT
+  |.  decode_RA8b RA
+  |
   |9:  // Rethrow error from the right C frame.
   |  load_got lj_err_trace
   |  sub CARG2, r0, CRET1
@@ -3046,7 +3073,6 @@ static void build_subroutines(BuildCtx *ctx)
   |  move TMP2, sp
   |  dsubu sp, sp, TMP1
   |  sd ra, -8(TMP2)
-  |   sll CARG2, CARG2, 3
   |  sd r16, -16(TMP2)
   |  sd CCSTATE, -24(TMP2)
   |  move r16, TMP2
@@ -5378,6 +5404,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   settp LFUNC:RB, TMP0
     |  daddu TMP0, RA, RC
     |   sd LFUNC:RB, 0(TMP1)		// Store (tagged) copy of LFUNC.
+    |  daddiu TMP2, TMP2, -8
     |   daddiu TMP3, RC, 16+FRAME_VARG
     |  sltu AT, TMP0, TMP2
     |    ld KBASE, -4+PC2PROTO(k)(PC)
diff --git a/lib/luajit-3065c9/src/vm_ppc.dasc b/lib/luajit2/src/vm_ppc.dasc
similarity index 83%
rename from lib/luajit-3065c9/src/vm_ppc.dasc
rename to lib/luajit2/src/vm_ppc.dasc
index 3cad37d28..8bb5bcefa 100644
--- a/lib/luajit-3065c9/src/vm_ppc.dasc
+++ b/lib/luajit2/src/vm_ppc.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for PowerPC 32 bit or 32on64 bit mode.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |
 |.arch ppc
 |.section code_op, code_sub
@@ -21,35 +21,40 @@
 |// GPR64   64 bit registers (but possibly 32 bit pointers, e.g. PS3).
 |//         Affects reg saves, stack layout, carry/overflow/dot flags etc.
 |// FRAME32 Use 32 bit frame layout, even with GPR64 (Xbox 360).
-|// TOC     Need table of contents (64 bit or 32 bit variant, e.g. PS3).
+|// OPD     Need function descriptors (64 bit or 32 bit variant, e.g. PS3).
 |//         Function pointers are really a struct: code, TOC, env (optional).
-|// TOCENV  Function pointers have an environment pointer, too (not on PS3).
+|// OPDENV  Function pointers have an environment pointer, too (not on PS3).
+|// ELFV2   The 64-bit ELF V2 ABI is in use.
 |// PPE     Power Processor Element of Cell (PS3) or Xenon (Xbox 360).
 |//         Must avoid (slow) micro-coded instructions.
 |
 |.if P64
-|.define TOC, 1
-|.define TOCENV, 1
 |.macro lpx, a, b, c; ldx a, b, c; .endmacro
 |.macro lp, a, b; ld a, b; .endmacro
 |.macro stp, a, b; std a, b; .endmacro
+|.macro stpx, a, b, c; stdx a, b, c; .endmacro
 |.define decode_OPP, decode_OP8
-|.if FFI
-|// Missing: Calling conventions, 64 bit regs, TOC.
-|.error lib_ffi not yet implemented for PPC64
-|.endif
+|.define PSIZE, 8
 |.else
 |.macro lpx, a, b, c; lwzx a, b, c; .endmacro
 |.macro lp, a, b; lwz a, b; .endmacro
 |.macro stp, a, b; stw a, b; .endmacro
+|.macro stpx, a, b, c; stwx a, b, c; .endmacro
 |.define decode_OPP, decode_OP4
+|.define PSIZE, 4
 |.endif
 |
 |// Convenience macros for TOC handling.
-|.if TOC
+|.if OPD or ELFV2
 |// Linker needs a TOC patch area for every external call relocation.
-|.macro blex, target; bl extern target@plt; nop; .endmacro
+|.macro blex, target; bl extern target; nop; .endmacro
 |.macro .toc, a, b; a, b; .endmacro
+|.else
+|.macro blex, target; bl extern target@plt; .endmacro
+|.macro .toc, a, b; .endmacro
+|.endif
+|.if OPD
+|.macro .opd, a, b; a, b; .endmacro
 |.if P64
 |.define TOC_OFS,	 8
 |.define ENV_OFS,	16
@@ -57,13 +62,13 @@
 |.define TOC_OFS,	4
 |.define ENV_OFS,	8
 |.endif
-|.else  // No TOC.
-|.macro blex, target; bl extern target@plt; .endmacro
-|.macro .toc, a, b; .endmacro
+|.else  // No OPD.
+|.macro .opd, a, b; .endmacro
 |.endif
-|.macro .tocenv, a, b; .if TOCENV; a, b; .endif; .endmacro
+|.macro .opdenv, a, b; .if OPDENV; a, b; .endif; .endmacro
 |
 |.macro .gpr64, a, b; .if GPR64; a, b; .endif; .endmacro
+|.macro .elfv2, a, b; .if ELFV2; a, b; .endif; .endmacro
 |
 |.macro andix., y, a, i
 |.if PPE
@@ -74,29 +79,6 @@
 |.endif
 |.endmacro
 |
-|.macro clrso, reg
-|.if PPE
-|  li reg, 0
-|  mtxer reg
-|.else
-|  mcrxr cr0
-|.endif
-|.endmacro
-|
-|.macro checkov, reg, noov
-|.if PPE
-|  mfxer reg
-|  add reg, reg, reg
-|  cmpwi reg, 0
-|   li reg, 0
-|   mtxer reg
-|  bgey noov
-|.else
-|  mcrxr cr0
-|  bley noov
-|.endif
-|.endmacro
-|
 |//-----------------------------------------------------------------------
 |
 |// Fixed register assignments for the interpreter.
@@ -122,6 +104,7 @@
 |.define LREG,		r18	// Register holding lua_State (also in SAVE_L).
 |.define MULTRES,	r19	// Size of multi-result: (nresults+1)*8.
 |.define JGL,		r31	// On-trace: global_State + 32768.
+|.define BASEP4,	r26	// Equal to BASE + 4
 |
 |// Constants for type-comparisons, stores and conversions. C callee-save.
 |.define TISNUM,	r22
@@ -158,6 +141,12 @@
 |.if FPU
 |.define FARG1,		f1
 |.define FARG2,		f2
+|.define FARG3,		f3
+|.define FARG4,		f4
+|.define FARG5,		f5
+|.define FARG6,		f6
+|.define FARG7,		f7
+|.define FARG8,		f8
 |.endif
 |
 |.define CRET1,		r3
@@ -165,6 +154,7 @@
 |
 |.define TOCREG,	r2	// TOC register (only used by C code).
 |.define ENVREG,	r11	// Environment pointer (nested C functions).
+|.define FUNCREG,	r12	// ELFv2 function pointer (overlaps RD)
 |
 |// Stack layout while in interpreter. Must match with lj_frame.h.
 |.if GPR64
@@ -198,6 +188,49 @@
 |.define TMPD,		TMPD_HI
 |.define TONUM_D,	TONUM_HI
 |
+|.elif ELFV2
+|
+|//			392(sp) // \ 32 bit C frame info.
+|.define SAVE_LR,	384(sp)
+|.define SAVE_CR,	376(sp) // 64 bit CR save.
+|.define CFRAME_SPACE,	368     // Delta for sp.
+|// Back chain for sp:	368(sp) <-- sp entering interpreter
+|.define SAVE_ERRF,	360(sp) // |
+|.define SAVE_NRES,	356(sp) // |
+|.define SAVE_L,	352(sp) //  > Parameter save area.
+|.define SAVE_PC,	348(sp) // |
+|.define SAVE_MULTRES,	344(sp) // |
+|.define SAVE_CFRAME,	336(sp) // / 64 bit C frame chain.
+|.define SAVE_FPR_,	192     // .. 192+18*8: 64 bit FPR saves.
+|.define SAVE_GPR_,	48      // .. 48+18*8: 64 bit GPR saves.
+|.if ENDIAN_LE
+|.define TMPD_HI,	44(sp)
+|.define TMPD_LO,	40(sp)
+|.define TONUM_HI,	36(sp)
+|.define TONUM_LO,	32(sp)
+|.else
+|.define TMPD_LO,	44(sp)
+|.define TMPD_HI,	40(sp)
+|.define TONUM_LO,	36(sp)
+|.define TONUM_HI,	32(sp)
+|.endif
+|.define SAVE_TOC,	24(sp)  // TOC save area.
+|// Next frame lr:	16(sp)
+|// Next frame cr:	8(sp)
+|// Back chain for sp:	0(sp)	<-- sp while in interpreter
+|
+|.if ENDIAN_LE
+|.define TMPD_BLO,	32(sp)
+|.define TMPD,		TMPD_LO
+|.define TONUM_D,	TONUM_LO
+|.else
+|.define TMPD_BLO,	39(sp)
+|.define TMPD,		TMPD_HI
+|.define TONUM_D,	TONUM_HI
+|.endif
+|
+|.define EXIT_OFFSET,	32
+|
 |.else
 |
 |//			508(sp) // \ 32 bit C frame info.
@@ -208,23 +241,39 @@
 |.define SAVE_MULTRES,	456(sp) // |
 |.define SAVE_CFRAME,	448(sp) // / 64 bit C frame chain.
 |.define SAVE_LR,	416(sp)
+|.define SAVE_CR,	408(sp)  // 64 bit CR save.
 |.define CFRAME_SPACE,	400     // Delta for sp.
 |// Back chain for sp:	400(sp) <-- sp entering interpreter
 |.define SAVE_FPR_,	256     // .. 256+18*8: 64 bit FPR saves.
 |.define SAVE_GPR_,	112     // .. 112+18*8: 64 bit GPR saves.
 |//			48(sp)  // Callee parameter save area (ABI mandated).
 |.define SAVE_TOC,	40(sp)  // TOC save area.
+|.if ENDIAN_LE
+|.define TMPD_HI,	36(sp)  // \ Link editor temp (ABI mandated).
+|.define TMPD_LO,	32(sp)  // /
+|.define TONUM_HI,	28(sp)  // \ Compiler temp (ABI mandated).
+|.define TONUM_LO,	24(sp)  // /
+|.else
 |.define TMPD_LO,	36(sp)  // \ Link editor temp (ABI mandated).
 |.define TMPD_HI,	32(sp)  // /
 |.define TONUM_LO,	28(sp)  // \ Compiler temp (ABI mandated).
 |.define TONUM_HI,	24(sp)  // /
+|.endif
 |// Next frame lr:	16(sp)
-|.define SAVE_CR,	8(sp)  // 64 bit CR save.
+|// Next frame cr:	8(sp)
 |// Back chain for sp:	0(sp)	<-- sp while in interpreter
 |
+|.if ENDIAN_LE
+|.define TMPD_BLO,	32(sp)
+|.define TMPD,		TMPD_LO
+|.define TONUM_D,	TONUM_LO
+|.else
 |.define TMPD_BLO,	39(sp)
 |.define TMPD,		TMPD_HI
 |.define TONUM_D,	TONUM_HI
+|.endif
+|
+|.define EXIT_OFFSET,	112
 |
 |.endif
 |.else
@@ -249,10 +298,17 @@
 |.define SAVE_MULTRES,	28(sp)
 |.define UNUSED1,	24(sp)
 |.if FPU
+|.if ENDIAN_LE
+|.define TMPD_HI,	20(sp)
+|.define TMPD_LO,	16(sp)
+|.define TONUM_HI,	12(sp)
+|.define TONUM_LO,	8(sp)
+|.else
 |.define TMPD_LO,	20(sp)
 |.define TMPD_HI,	16(sp)
 |.define TONUM_LO,	12(sp)
 |.define TONUM_HI,	8(sp)
+|.endif
 |.else
 |.define SFSAVE_4,	20(sp)
 |.define SFSAVE_3,	16(sp)
@@ -263,11 +319,23 @@
 |// Back chain for sp:	0(sp)	<-- sp while in interpreter
 |
 |.if FPU
+|.if ENDIAN_LE
+|.define TMPD_BLO,	16(sp)
+|.define TMPD,		TMPD_LO
+|.define TONUM_D,	TONUM_LO
+|.else
+|.define TMPD_BLO,	23(sp)
+|.define TMPD,		TMPD_HI
+|.define TONUM_D,	TONUM_HI
+|.endif
+|.else
 |.define TMPD_BLO,	23(sp)
 |.define TMPD,		TMPD_HI
 |.define TONUM_D,	TONUM_HI
 |.endif
 |
+|.define EXIT_OFFSET,	16
+|
 |.endif
 |
 |.macro save_, reg
@@ -383,8 +451,35 @@
 |//-----------------------------------------------------------------------
 |
 |// Access to frame relative to BASE.
+|.if ENDIAN_LE
+|.define FRAME_PC,	-4
+|.define FRAME_FUNC,	-8
+|.define FRAME_CONTPC,	-12
+|.define FRAME_CONTRET,	-16
+|.define WORD_LO,	0
+|.define WORD_HI,	4
+|.define WORD_BLO,	0
+|.define BASE_LO,	BASE
+|.define BASE_HI,	BASEP4
+|.macro lwzux2, hi, lo, base, idx
+|  lwzux lo, base, idx
+|  lwz hi, 4(base)
+|.endmacro
+|.else
 |.define FRAME_PC,	-8
 |.define FRAME_FUNC,	-4
+|.define FRAME_CONTPC,	-16
+|.define FRAME_CONTRET,	-12
+|.define WORD_LO,	4
+|.define WORD_HI,	0
+|.define WORD_BLO,	7
+|.define BASE_LO,	BASEP4
+|.define BASE_HI,	BASE
+|.macro lwzux2, hi, lo, base, idx
+|  lwzux hi, base, idx
+|  lwz lo, 4(base)
+|.endmacro
+|.endif
 |
 |// Instruction decode.
 |.macro decode_OP4, dst, ins; rlwinm dst, ins, 2, 22, 29; .endmacro
@@ -445,6 +540,7 @@
 |// Call decode and dispatch.
 |.macro ins_callt
 |  // BASE = new base, RB = LFUNC/CFUNC, RC = nargs*8, FRAME_PC(BASE) = PC
+|  addi BASEP4, BASE, 4
 |  lwz PC, LFUNC:RB->pc
 |  lwz INS, 0(PC)
 |   addi PC, PC, 4
@@ -537,7 +633,12 @@ static void build_subroutines(BuildCtx *ctx)
   |  lwz PC, FRAME_PC(TMP2)		// Fetch PC of previous frame.
   |  mr BASE, TMP2			// Restore caller base.
   |  // Prepending may overwrite the pcall frame, so do it at the end.
-  |   stwu TMP1, FRAME_PC(RA)		// Prepend true to results.
+  |  .if ENDIAN_LE
+  |    addi RA, RA, -8
+  |    stw TMP1, WORD_HI(RA)		// Prepend true to results.
+  |  .else
+  |    stwu TMP1, -8(RA)		// Prepend true to results.
+  |  .endif
   |
   |->vm_returnc:
   |  addi RD, RD, 8			// RD = (nresults+1)*8.
@@ -603,7 +704,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  lwz TMP1, L->maxstack
   |  cmplw BASE, TMP1
   |  bge >8
-  |  stw TISNIL, 0(BASE)
+  |  stw TISNIL, WORD_HI(BASE)
   |  addi RD, RD, 8
   |  addi BASE, BASE, 8
   |  b <2
@@ -654,7 +755,12 @@ static void build_subroutines(BuildCtx *ctx)
   |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
   |  lwz L, SAVE_L
   |  .toc ld TOCREG, SAVE_TOC
+  |.if P64
+  |     lus TISNUM, LJ_TISNUM >> 16	// Setup type comparison constants.
+  |     ori TISNUM, TISNUM, LJ_TISNUM & 0xffff
+  |.else
   |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
+  |.endif
   |  lp BASE, L->base
   |     .FPU lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
   |   lwz DISPATCH, L->glref		// Setup pointer to dispatch table.
@@ -669,7 +775,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  la RA, -8(BASE)			// Results start at BASE-8.
   |     .FPU stw TMP3, TMPD
   |   addi DISPATCH, DISPATCH, GG_G2DISP
-  |  stw TMP1, 0(RA)			// Prepend false to error message.
+  |  stw TMP1, WORD_HI(RA)		// Prepend false to error message.
   |  li RD, 16				// 2 results: false + error message.
   |    st_vmstate
   |     .FPU lfs TONUM, TMPD
@@ -730,7 +836,12 @@ static void build_subroutines(BuildCtx *ctx)
   |  stw L, DISPATCH_GL(cur_L)(DISPATCH)
   |  mr RA, BASE
   |   lp BASE, L->base
+  |.if P64
+  |     lus TISNUM, LJ_TISNUM >> 16	// Setup type comparison constants.
+  |     ori TISNUM, TISNUM, LJ_TISNUM & 0xffff
+  |.else
   |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
+  |.endif
   |   lp TMP1, L->top
   |  lwz PC, FRAME_PC(BASE)
   |     .FPU lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
@@ -780,7 +891,12 @@ static void build_subroutines(BuildCtx *ctx)
   |3:  // Entry point for vm_cpcall/vm_resume (BASE = base, PC = ftype).
   |  stw L, DISPATCH_GL(cur_L)(DISPATCH)
   |  lp TMP2, L->base			// TMP2 = old base (used in vmeta_call).
+  |.if P64
+  |     lus TISNUM, LJ_TISNUM >> 16	// Setup type comparison constants.
+  |     ori TISNUM, TISNUM, LJ_TISNUM & 0xffff
+  |.else
   |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
+  |.endif
   |   lp TMP1, L->top
   |     .FPU lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
   |  add PC, PC, BASE
@@ -800,8 +916,8 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->vm_call_dispatch:
   |  // TMP2 = old base, BASE = new base, RC = nargs*8, PC = caller PC
-  |  lwz TMP0, FRAME_PC(BASE)
-  |   lwz LFUNC:RB, FRAME_FUNC(BASE)
+  |  lwz TMP0, WORD_HI-8(BASE)
+  |   lwz LFUNC:RB, WORD_LO-8(BASE)
   |  checkfunc TMP0; bne ->vmeta_call
   |
   |->vm_call_dispatch_f:
@@ -820,7 +936,9 @@ static void build_subroutines(BuildCtx *ctx)
   |   sub TMP0, TMP0, TMP1		// Compute -savestack(L, L->top).
   |    lp TMP1, L->cframe
   |     addi DISPATCH, DISPATCH, GG_G2DISP
-  |  .toc lp CARG4, 0(CARG4)
+  |  .opd lp TOCREG, TOC_OFS(CARG4)
+  |  .opdenv lp ENVREG, ENV_OFS(CARG4)
+  |  .opd lp CARG4, 0(CARG4)
   |  li TMP2, 0
   |   stw TMP0, SAVE_NRES		// Neg. delta means cframe w/o frame.
   |  stw TMP2, SAVE_ERRF		// No error function.
@@ -828,7 +946,9 @@ static void build_subroutines(BuildCtx *ctx)
   |    stp sp, L->cframe		// Add our C frame to cframe chain.
   |     stw L, DISPATCH_GL(cur_L)(DISPATCH)
   |  mtctr CARG4
+  |  .elfv2 mr FUNCREG, CARG4
   |  bctrl			// (lua_State *L, lua_CFunction func, void *ud)
+  |  .toc lp TOCREG, SAVE_TOC
   |.if PPE
   |  mr BASE, CRET1
   |  cmpwi CRET1, 0
@@ -850,20 +970,28 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->cont_dispatch:
   |  // BASE = meta base, RA = resultptr, RD = (nresults+1)*8
-  |  lwz TMP0, -12(BASE)		// Continuation.
+  |  lwz TMP0, FRAME_CONTRET(BASE)	// Continuation.
   |   mr RB, BASE
   |   mr BASE, TMP2			// Restore caller BASE.
   |    lwz LFUNC:TMP1, FRAME_FUNC(TMP2)
   |.if FFI
   |  cmplwi TMP0, 1
   |.endif
-  |     lwz PC, -16(RB)			// Restore PC from [cont|PC].
-  |   subi TMP2, RD, 8
+  |// PC value corrected to avoid segfault
+  |   lwz PC, FRAME_CONTPC(RB)        // Restore PC from [cont|PC].
+  |	addi BASEP4, BASE, 4 
+  |	addi TMP2, RD, WORD_HI-8
+  |	lwz TMP1, LFUNC:TMP1->pc
   |   stwx TISNIL, RA, TMP2		// Ensure one valid arg.
+  |.if P64
+  |   ld TMP3, 0(DISPATCH)
+  |.endif
   |.if FFI
   |  ble >1
   |.endif
-  |    lwz TMP1, LFUNC:TMP1->pc
+  |.if P64
+  |  add TMP0, TMP0, TMP3
+  |.endif
   |    lwz KBASE, PC2PROTO(k)(TMP1)
   |  // BASE = base, RA = resultptr, RB = meta base
   |  mtctr TMP0
@@ -914,20 +1042,20 @@ static void build_subroutines(BuildCtx *ctx)
   |  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
   |  li TMP0, LJ_TSTR
   |   decode_RB8 RB, INS
-  |  stw STR:RC, 4(CARG3)
+  |  stw STR:RC, WORD_LO(CARG3)
   |   add CARG2, BASE, RB
-  |  stw TMP0, 0(CARG3)
+  |  stw TMP0, WORD_HI(CARG3)
   |  b >1
   |
   |->vmeta_tgets:
   |  la CARG2, DISPATCH_GL(tmptv)(DISPATCH)
   |  li TMP0, LJ_TTAB
-  |  stw TAB:RB, 4(CARG2)
+  |  stw TAB:RB, WORD_LO(CARG2)
   |   la CARG3, DISPATCH_GL(tmptv2)(DISPATCH)
-  |  stw TMP0, 0(CARG2)
+  |  stw TMP0, WORD_HI(CARG2)
   |   li TMP1, LJ_TSTR
-  |   stw STR:RC, 4(CARG3)
-  |   stw TMP1, 0(CARG3)
+  |   stw STR:RC, WORD_LO(CARG3)
+  |   stw TMP1, WORD_HI(CARG3)
   |  b >1
   |
   |->vmeta_tgetb:			// TMP0 = index
@@ -938,8 +1066,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
   |   add CARG2, BASE, RB
   |.if DUALNUM
-  |  stw TISNUM, 0(CARG3)
-  |  stw TMP0, 4(CARG3)
+  |  stw TISNUM, WORD_HI(CARG3)
+  |  stw TMP0, WORD_LO(CARG3)
   |.else
   |  stfd f0, 0(CARG3)
   |.endif
@@ -977,7 +1105,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  // BASE = base, L->top = new base, stack = cont/func/t/k
   |  subfic TMP1, BASE, FRAME_CONT
   |  lp BASE, L->top
-  |  stw PC, -16(BASE)			// [cont|PC]
+  |  stw PC, FRAME_CONTPC(BASE)		// [cont|PC]
   |   add PC, TMP1, BASE
   |  lwz LFUNC:RB, FRAME_FUNC(BASE)	// Guaranteed to be a function here.
   |   li NARGS8:RC, 16			// 2 args for func(t, k).
@@ -996,7 +1124,10 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |  b ->BC_TGETR_Z
   |1:
-  |  stwx TISNIL, BASE, RA
+  |.if ENDIAN_LE
+  |  addi BASEP4, BASE, 4
+  |.endif
+  |  stwx TISNIL, BASE_HI, RA
   |  b ->cont_nop
   |
   |//-----------------------------------------------------------------------
@@ -1005,20 +1136,20 @@ static void build_subroutines(BuildCtx *ctx)
   |  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
   |  li TMP0, LJ_TSTR
   |   decode_RB8 RB, INS
-  |  stw STR:RC, 4(CARG3)
+  |  stw STR:RC, WORD_LO(CARG3)
   |   add CARG2, BASE, RB
-  |  stw TMP0, 0(CARG3)
+  |  stw TMP0, WORD_HI(CARG3)
   |  b >1
   |
   |->vmeta_tsets:
   |  la CARG2, DISPATCH_GL(tmptv)(DISPATCH)
   |  li TMP0, LJ_TTAB
-  |  stw TAB:RB, 4(CARG2)
+  |  stw TAB:RB, WORD_LO(CARG2)
   |   la CARG3, DISPATCH_GL(tmptv2)(DISPATCH)
-  |  stw TMP0, 0(CARG2)
+  |  stw TMP0, WORD_HI(CARG2)
   |   li TMP1, LJ_TSTR
-  |   stw STR:RC, 4(CARG3)
-  |   stw TMP1, 0(CARG3)
+  |   stw STR:RC, WORD_LO(CARG3)
+  |   stw TMP1, WORD_HI(CARG3)
   |  b >1
   |
   |->vmeta_tsetb:			// TMP0 = index
@@ -1029,8 +1160,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  la CARG3, DISPATCH_GL(tmptv)(DISPATCH)
   |   add CARG2, BASE, RB
   |.if DUALNUM
-  |  stw TISNUM, 0(CARG3)
-  |  stw TMP0, 4(CARG3)
+  |  stw TISNUM, WORD_HI(CARG3)
+  |  stw TMP0, WORD_LO(CARG3)
   |.else
   |  stfd f0, 0(CARG3)
   |.endif
@@ -1069,7 +1200,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
   |  subfic TMP1, BASE, FRAME_CONT
   |  lp BASE, L->top
-  |  stw PC, -16(BASE)			// [cont|PC]
+  |  stw PC, FRAME_CONTPC(BASE)		// [cont|PC]
   |   add PC, TMP1, BASE
   |  lwz LFUNC:RB, FRAME_FUNC(BASE)	// Guaranteed to be a function here.
   |   li NARGS8:RC, 24			// 3 args for func(t, k, v)
@@ -1100,17 +1231,9 @@ static void build_subroutines(BuildCtx *ctx)
   |->vmeta_comp:
   |  mr CARG1, L
   |   subi PC, PC, 4
-  |.if DUALNUM
-  |  mr CARG2, RA
-  |.else
   |  add CARG2, BASE, RA
-  |.endif
   |   stw PC, SAVE_PC
-  |.if DUALNUM
-  |  mr CARG3, RD
-  |.else
   |  add CARG3, BASE, RD
-  |.endif
   |   stp BASE, L->base
   |  decode_OP1 CARG4, INS
   |  bl extern lj_meta_comp  // (lua_State *L, TValue *o1, *o2, int op)
@@ -1147,7 +1270,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  b ->cont_nop
   |
   |->cont_condt:			// RA = resultptr
-  |  lwz TMP0, 0(RA)
+  |  lwz TMP0, WORD_HI(RA)
   |  .gpr64 extsw TMP0, TMP0
   |  subfic TMP0, TMP0, LJ_TTRUE	// Branch if result is true.
   |  subfe CRET1, CRET1, CRET1
@@ -1155,7 +1278,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  b <4
   |
   |->cont_condf:			// RA = resultptr
-  |  lwz TMP0, 0(RA)
+  |  lwz TMP0, WORD_HI(RA)
   |  .gpr64 extsw TMP0, TMP0
   |  subfic TMP0, TMP0, LJ_TTRUE	// Branch if result is false.
   |  subfe CRET1, CRET1, CRET1
@@ -1207,8 +1330,8 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |
   |->vmeta_unm:
-  |  mr CARG3, RD
-  |  mr CARG4, RD
+  |  add CARG3, BASE, RD
+  |  add CARG4, BASE, RD
   |  b >1
   |
   |->vmeta_arith_vn:
@@ -1243,7 +1366,7 @@ static void build_subroutines(BuildCtx *ctx)
   |->vmeta_binop:
   |  // BASE = old base, CRET1 = new base, stack = cont/func/o1/o2
   |  sub TMP1, CRET1, BASE
-  |   stw PC, -16(CRET1)		// [cont|PC]
+  |   stw PC, FRAME_CONTPC(CRET1)	// [cont|PC]
   |   mr TMP2, BASE
   |  addi PC, TMP1, FRAME_CONT
   |   mr BASE, CRET1
@@ -1254,7 +1377,7 @@ static void build_subroutines(BuildCtx *ctx)
 #if LJ_52
   |  mr SAVE0, CARG1
 #endif
-  |  mr CARG2, RD
+  |  add CARG2, BASE, RD
   |   stp BASE, L->base
   |  mr CARG1, L
   |   stw PC, SAVE_PC
@@ -1331,25 +1454,25 @@ static void build_subroutines(BuildCtx *ctx)
   |.macro .ffunc_1, name
   |->ff_ .. name:
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG3, 0(BASE)
-  |    lwz CARG1, 4(BASE)
+  |   lwz CARG3, WORD_HI(BASE)
+  |    lwz CARG1, WORD_LO(BASE)
   |  blt ->fff_fallback
   |.endmacro
   |
   |.macro .ffunc_2, name
   |->ff_ .. name:
   |  cmplwi NARGS8:RC, 16
-  |   lwz CARG3, 0(BASE)
-  |    lwz CARG4, 8(BASE)
-  |   lwz CARG1, 4(BASE)
-  |    lwz CARG2, 12(BASE)
+  |   lwz CARG3, WORD_HI(BASE)
+  |    lwz CARG4, WORD_HI+8(BASE)
+  |   lwz CARG1, WORD_LO(BASE)
+  |    lwz CARG2, WORD_LO+8(BASE)
   |  blt ->fff_fallback
   |.endmacro
   |
   |.macro .ffunc_n, name
   |->ff_ .. name:
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG1, 0(BASE)
+  |   lwz CARG1, WORD_HI(BASE)
   |.if FPU
   |    lfd FARG1, 0(BASE)
   |.else
@@ -1362,15 +1485,15 @@ static void build_subroutines(BuildCtx *ctx)
   |.macro .ffunc_nn, name
   |->ff_ .. name:
   |  cmplwi NARGS8:RC, 16
-  |   lwz CARG1, 0(BASE)
+  |   lwz CARG1, WORD_HI(BASE)
   |.if FPU
   |    lfd FARG1, 0(BASE)
-  |   lwz CARG3, 8(BASE)
+  |   lwz CARG3, WORD_HI+8(BASE)
   |    lfd FARG2, 8(BASE)
   |.else
-  |    lwz CARG2, 4(BASE)
-  |   lwz CARG3, 8(BASE)
-  |    lwz CARG4, 12(BASE)
+  |    lwz CARG2, WORD_LO(BASE)
+  |   lwz CARG3, WORD_HI+8(BASE)
+  |    lwz CARG4, WORD_LO+8(BASE)
   |.endif
   |  blt ->fff_fallback
   |  checknum CARG1; bge ->fff_fallback
@@ -1393,17 +1516,17 @@ static void build_subroutines(BuildCtx *ctx)
   |  cmplw cr1, CARG3, TMP1
   |    lwz PC, FRAME_PC(BASE)
   |  bge cr1, ->fff_fallback
-  |   stw CARG3, 0(RA)
+  |   stw CARG3, WORD_HI(RA)
   |  addi RD, NARGS8:RC, 8		// Compute (nresults+1)*8.
   |  addi TMP1, BASE, 8
   |  add TMP2, RA, NARGS8:RC
-  |   stw CARG1, 4(RA)
+  |   stw CARG1, WORD_LO(RA)
   |  beq ->fff_res			// Done if exactly 1 argument.
   |1:
   |  cmplw TMP1, TMP2
   |.if FPU
   |   lfd f0, 0(TMP1)
-  |   stfd f0, 0(TMP1)
+  |   stfd f0, -8(TMP1)
   |.else
   |   lwz CARG1, 0(TMP1)
   |   lwz CARG2, 4(TMP1)
@@ -1416,14 +1539,28 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |.ffunc type
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG1, 0(BASE)
+  |   lwz CARG1, WORD_HI(BASE)
   |  blt ->fff_fallback
   |  .gpr64 extsw CARG1, CARG1
+  |.if P64
+  |  li TMP0, LJ_TNUMX
+  |    srawi TMP3, CARG1, 15
+  |  subfc TMP1, TMP0, CARG1
+  |.else
   |  subfc TMP0, TISNUM, CARG1
-  |  subfe TMP2, CARG1, CARG1
+  |.endif
+  |    subfe TMP2, CARG1, CARG1
+  |.if P64
+  |  cmpwi TMP3, -2
+  |    orc TMP1, TMP2, TMP1
+  |    subf TMP1, TMP0, TMP1
+  |  beq >1
+  |.else
   |  orc TMP1, TMP2, TMP0
-  |  addi TMP1, TMP1, ~LJ_TISNUM+1
+  |  subf TMP1, TISNUM, TMP1
+  |.endif
   |  slwi TMP1, TMP1, 3
+  |2:
   |.if FPU
   |   la TMP2, CFUNC:RB->upvalue
   |  lfdx FARG1, TMP2, TMP1
@@ -1433,6 +1570,11 @@ static void build_subroutines(BuildCtx *ctx)
   |  lwz CARG2, CFUNC:TMP1->upvalue[0].u32.lo
   |.endif
   |  b ->fff_resn
+  |.if P64
+  |1:
+  |  li TMP1, ~LJ_TLIGHTUD<<3
+  |  b <2
+  |.endif
   |
   |//-- Base library: getters and setters ---------------------------------
   |
@@ -1455,10 +1597,10 @@ static void build_subroutines(BuildCtx *ctx)
   |  sub TMP1, TMP0, TMP1
   |  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
   |3:  // Rearranged logic, because we expect _not_ to find the key.
-  |  lwz CARG4, NODE:TMP2->key
-  |   lwz TMP0, 4+offsetof(Node, key)(NODE:TMP2)
-  |    lwz CARG2, NODE:TMP2->val
-  |     lwz TMP1, 4+offsetof(Node, val)(NODE:TMP2)
+  |  lwz CARG4, WORD_HI+offsetof(Node, key)(NODE:TMP2)
+  |   lwz TMP0, WORD_LO+offsetof(Node, key)(NODE:TMP2)
+  |    lwz CARG2, WORD_HI+offsetof(Node, val)(NODE:TMP2)
+  |     lwz TMP1, WORD_LO+offsetof(Node, val)(NODE:TMP2)
   |  checkstr CARG4; bne >4
   |   cmpw TMP0, STR:RC; beq >5
   |4:
@@ -1476,14 +1618,33 @@ static void build_subroutines(BuildCtx *ctx)
   |6:
   |  cmpwi CARG3, LJ_TUDATA; beq <1
   |  .gpr64 extsw CARG3, CARG3
+  |.if P64
+  |  li TMP0, LJ_TNUMX
+  |    srawi TMP3, CARG3, 15
+  |  subfc TMP1, TMP0, CARG3
+  |.else
   |  subfc TMP0, TISNUM, CARG3
+  |.endif
   |  subfe TMP2, CARG3, CARG3
+  |.if P64
+  |  cmpwi TMP3, -2
+  |    orc TMP1, TMP2, TMP1
+  |    subf TMP1, TMP0, TMP1
+  |  beq >7
+  |.else
   |  orc TMP1, TMP2, TMP0
-  |  addi TMP1, TMP1, ~LJ_TISNUM+1
+  |  subf TMP1, TISNUM, TMP1
+  |.endif
   |  slwi TMP1, TMP1, 2
+  |8:
   |   la TMP2, DISPATCH_GL(gcroot[GCROOT_BASEMT])(DISPATCH)
   |  lwzx TAB:CARG1, TMP2, TMP1
   |  b <2
+  |.if P64
+  |7:
+  |  li TMP1, ~LJ_TLIGHTUD<<2
+  |  b <8
+  |.endif
   |
   |.ffunc_2 setmetatable
   |  // Fast path: no mt for table yet and not clearing the mt.
@@ -1501,8 +1662,8 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |.ffunc rawget
   |  cmplwi NARGS8:RC, 16
-  |   lwz CARG4, 0(BASE)
-  |    lwz TAB:CARG2, 4(BASE)
+  |   lwz CARG4, WORD_HI(BASE)
+  |    lwz TAB:CARG2, WORD_LO(BASE)
   |  blt ->fff_fallback
   |  checktab CARG4; bne ->fff_fallback
   |   la CARG3, 8(BASE)
@@ -1522,11 +1683,11 @@ static void build_subroutines(BuildCtx *ctx)
   |.ffunc tonumber
   |  // Only handles the number case inline (without a base argument).
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG1, 0(BASE)
+  |   lwz CARG1, WORD_HI(BASE)
   |.if FPU
   |    lfd FARG1, 0(BASE)
   |.else
-  |    lwz CARG2, 4(BASE)
+  |    lwz CARG2, WORD_LO(BASE)
   |.endif
   |  bne ->fff_fallback			// Exactly one argument.
   |   checknum CARG1; bgt ->fff_fallback
@@ -1560,13 +1721,25 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: iterators -------------------------------------------
   |
   |.ffunc_1 next
-  |   stwx TISNIL, BASE, NARGS8:RC	// Set missing 2nd arg to nil.
-  |  checktab CARG3
+  |  cmplwi NARGS8:RC, 8
+  |    lwz TAB:CARG1, WORD_LO(BASE)
+  |    lwz CARG2, WORD_HI(BASE)
+  |  blt ->fff_fallback
+  |.if ENDIAN_LE
+  |   add TMP1, BASE, NARGS8:RC
+  |   stw TISNIL, WORD_HI(TMP1)         // Set missing 2nd arg to nil.
+  |.else
+  |   stwx TISNIL, BASE, NARGS8:RC      // Set missing 2nd arg to nil.
+  |.endif
+  |  checktab CARG2
   |   lwz PC, FRAME_PC(BASE)
   |  bne ->fff_fallback
+  |   stp BASE, L->base                 // Add frame since C call can throw.
+  |   stp BASE, L->top                  // Dummy frame length is ok.
   |  la CARG2, 8(BASE)
   |  la CARG3, -8(BASE)
-  |  bl extern lj_tab_next		// (GCtab *t, cTValue *key, TValue *o)
+  |   stw PC, SAVE_PC
+  |  bl extern lj_tab_next      // (GCtab *t, cTValue *key,TValue *o)
   |  // Returns 1=found, 0=end, -1=error.
   |  cmpwi CRET1, 0
   |   la RA, -8(BASE)
@@ -1602,7 +1775,7 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |  la RA, -8(BASE)
 #endif
-  |   stw TISNIL, 8(BASE)
+  |   stw TISNIL, 8+WORD_HI(BASE)
   |  li RD, (3+1)*8
   |.if FPU
   |  stfd f0, 0(RA)
@@ -1614,11 +1787,11 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |.ffunc ipairs_aux
   |  cmplwi NARGS8:RC, 16
-  |   lwz CARG3, 0(BASE)
-  |    lwz TAB:CARG1, 4(BASE)
-  |   lwz CARG4, 8(BASE)
+  |   lwz CARG3, WORD_HI(BASE)
+  |    lwz TAB:CARG1, WORD_LO(BASE)
+  |   lwz CARG4, 8+WORD_HI(BASE)
   |.if DUALNUM
-  |    lwz TMP2, 12(BASE)
+  |    lwz TMP2, 8+WORD_LO(BASE)
   |.else
   |    lfd FARG2, 8(BASE)
   |.endif
@@ -1647,20 +1820,20 @@ static void build_subroutines(BuildCtx *ctx)
   |   la RA, -8(BASE)
   |  cmplw TMP0, TMP2
   |.if DUALNUM
-  |  stw TISNUM, 0(RA)
+  |  stw TISNUM, WORD_HI(RA)
   |   slwi TMP3, TMP2, 3
-  |  stw TMP2, 4(RA)
+  |  stw TMP2, WORD_LO(RA)
   |.else
   |   slwi TMP3, TMP2, 3
   |  stfd FARG2, 0(RA)
   |.endif
   |  ble >2				// Not in array part?
   |.if FPU
-  |  lwzx TMP2, TMP1, TMP3
-  |  lfdx f0, TMP1, TMP3
+  |  lfdux f0, TMP1, TMP3
+  |  lwz TMP2, WORD_HI(TMP1)
   |.else
   |  lwzux TMP2, TMP1, TMP3
-  |  lwz TMP3, 4(TMP1)
+  |  lwz TMP3, WORD_HI(TMP1)
   |.endif
   |1:
   |  checknil TMP2
@@ -1685,7 +1858,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  cmplwi CRET1, 0
   |   li RD, (0+1)*8
   |  beq ->fff_res
-  |  lwz TMP2, 0(CRET1)
+  |  lwz TMP2, WORD_HI(CRET1)
   |.if FPU
   |  lfd f0, 0(CRET1)
   |.else
@@ -1718,11 +1891,11 @@ static void build_subroutines(BuildCtx *ctx)
   |  la RA, -8(BASE)
 #endif
   |.if DUALNUM
-  |  stw TISNUM, 8(BASE)
+  |  stw TISNUM, 8+WORD_HI(BASE)
   |.else
-  |  stw ZERO, 8(BASE)
+  |  stw ZERO, 8+WORD_HI(BASE)
   |.endif
-  |   stw ZERO, 12(BASE)
+  |   stw ZERO, 8+WORD_LO(BASE)
   |  li RD, (3+1)*8
   |.if FPU
   |  stfd f0, 0(RA)
@@ -1735,8 +1908,12 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc pcall
+  |    lwz TMP1, L->maxstack
+  |    add TMP2, BASE, NARGS8:RC
   |  cmplwi NARGS8:RC, 8
   |   lbz TMP3, DISPATCH_GL(hookmask)(DISPATCH)
+  |    cmplw cr1, TMP1, TMP2
+  |  cror 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
   |  blt ->fff_fallback
   |   mr TMP2, BASE
   |   la BASE, 8(BASE)
@@ -1747,14 +1924,19 @@ static void build_subroutines(BuildCtx *ctx)
   |  b ->vm_call_dispatch
   |
   |.ffunc xpcall
+  |     lwz TMP1, L->maxstack
+  |     add TMP2, BASE, NARGS8:RC
   |  cmplwi NARGS8:RC, 16
-  |   lwz CARG3, 8(BASE)
+  |   lwz CARG3, 8+WORD_HI(BASE)
+  |     cmplw cr1, TMP1, TMP2
   |.if FPU
   |    lfd FARG2, 8(BASE)
+  |  cror 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
   |    lfd FARG1, 0(BASE)
   |.else
   |    lwz CARG1, 0(BASE)
   |    lwz CARG2, 4(BASE)
+  |  cror 4*cr0+lt, 4*cr0+lt, 4*cr1+lt
   |    lwz CARG4, 12(BASE)
   |.endif
   |  blt ->fff_fallback
@@ -1879,7 +2061,7 @@ static void build_subroutines(BuildCtx *ctx)
   |.if resume
   |  li TMP1, LJ_TTRUE
   |   la RA, -8(BASE)
-  |  stw TMP1, -8(BASE)			// Prepend true to results.
+  |  stw TMP1, WORD_HI-8(BASE)		// Prepend true to results.
   |  addi RD, RD, 16
   |.else
   |  mr RA, BASE
@@ -1904,7 +2086,7 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |   stp TMP3, L:SAVE0->top		// Remove error from coroutine stack.
   |    li RD, (2+1)*8
-  |   stw TMP1, -8(BASE)		// Prepend false to results.
+  |   stw TMP1, WORD_HI-8(BASE)		// Prepend false to results.
   |    la RA, -8(BASE)
   |.if FPU
   |  stfd f0, 0(BASE)			// Copy error message.
@@ -1962,8 +2144,8 @@ static void build_subroutines(BuildCtx *ctx)
   |->fff_resi:
   |  lwz PC, FRAME_PC(BASE)
   |  la RA, -8(BASE)
-  |  stw TISNUM, -8(BASE)
-  |  stw CRET1, -4(BASE)
+  |  stw TISNUM, WORD_HI-8(BASE)
+  |  stw CRET1, WORD_LO-8(BASE)
   |  b ->fff_res1
   |1:
   |  lus CARG3, 0x41e0	// 2^31.
@@ -1978,9 +2160,9 @@ static void build_subroutines(BuildCtx *ctx)
   |->fff_restv:
   |  // CARG3/CARG1 = TValue result.
   |  lwz PC, FRAME_PC(BASE)
-  |   stw CARG3, -8(BASE)
+  |   stw CARG3, WORD_HI-8(BASE)
   |  la RA, -8(BASE)
-  |   stw CARG1, -4(BASE)
+  |   stw CARG1, WORD_LO-8(BASE)
   |->fff_res1:
   |  // RA = results, PC = return.
   |  li RD, (1+1)*8
@@ -1998,10 +2180,11 @@ static void build_subroutines(BuildCtx *ctx)
   |  ins_next1
   |  // Adjust BASE. KBASE is assumed to be set for the calling frame.
   |   sub BASE, RA, TMP0
+  |   addi BASEP4, BASE, 4
   |  ins_next2
   |
   |6:  // Fill up results with nil.
-  |  subi TMP1, RD, 8
+  |  addi TMP1, RD, WORD_HI-8
   |   addi RD, RD, 8
   |  stwx TISNIL, RA, TMP1
   |  b <5
@@ -2119,7 +2302,7 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |.ffunc math_log
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG1, 0(BASE)
+  |   lwz CARG1, WORD_HI(BASE)
   |  bne ->fff_fallback			// Need exactly 1 argument.
   |  checknum CARG1; bge ->fff_fallback
   |.if FPU
@@ -2148,20 +2331,20 @@ static void build_subroutines(BuildCtx *ctx)
   |.if DUALNUM
   |.ffunc math_ldexp
   |  cmplwi NARGS8:RC, 16
-  |   lwz TMP0, 0(BASE)
+  |   lwz TMP0, WORD_HI(BASE)
   |.if FPU
   |    lfd FARG1, 0(BASE)
   |.else
-  |    lwz CARG1, 0(BASE)
-  |    lwz CARG2, 4(BASE)
+  |    lwz CARG1, WORD_HI(BASE)
+  |    lwz CARG2, WORD_LO(BASE)
   |.endif
-  |   lwz TMP1, 8(BASE)
+  |   lwz TMP1, WORD_HI+8(BASE)
   |.if GPR64
-  |    lwz CARG2, 12(BASE)
+  |    lwz CARG2, WORD_LO+8(BASE)
   |.elif FPU
-  |    lwz CARG1, 12(BASE)
+  |    lwz CARG1, WORD_LO+8(BASE)
   |.else
-  |    lwz CARG3, 12(BASE)
+  |    lwz CARG3, WORD_LO+8(BASE)
   |.endif
   |  blt ->fff_fallback
   |  checknum TMP0; bge ->fff_fallback
@@ -2200,8 +2383,8 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |  li RD, (2+1)*8
   |.if DUALNUM
-  |   stw TISNUM, 8(RA)
-  |   stw TMP1, 12(RA)
+  |   stw TISNUM, WORD_HI+8(RA)
+  |   stw TMP1, WORD_LO+8(RA)
   |.else
   |   stfd FARG2, 8(RA)
   |.endif
@@ -2235,9 +2418,9 @@ static void build_subroutines(BuildCtx *ctx)
   |   add SAVE1, BASE, NARGS8:RC
   |  bne >4
   |1:  // Handle integers.
-  |  lwz CARG4, 0(SAVE0)
+  |  lwz CARG4, WORD_HI(SAVE0)
   |   cmplw cr1, SAVE0, SAVE1
-  |  lwz CARG2, 4(SAVE0)
+  |  lwz CARG2, WORD_LO(SAVE0)
   |   bge cr1, ->fff_resi
   |  checknum CARG4
   |   xoris TMP0, CARG1, 0x8000
@@ -2278,7 +2461,7 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |  bge ->fff_fallback
   |5:  // Handle numbers.
-  |  lwz CARG3, 0(SAVE0)
+  |  lwz CARG3, WORD_HI(SAVE0)
   |   cmplw cr1, SAVE0, SAVE1
   |.if FPU
   |  lfd FARG2, 0(SAVE0)
@@ -2317,7 +2500,7 @@ static void build_subroutines(BuildCtx *ctx)
   |.endif
   |  b <5
   |7:  // Convert integer to number and continue above.
-  |   lwz CARG3, 4(SAVE0)
+  |   lwz CARG3, WORD_LO(SAVE0)
   |  bne ->fff_fallback
   |.if FPU
   |  tonum_i FARG2, CARG3
@@ -2329,7 +2512,12 @@ static void build_subroutines(BuildCtx *ctx)
   |  .ffunc_n name
   |  li TMP1, 8
   |1:
+  |.if ENDIAN_LE
+  |   add CARG2, BASE, TMP1
+  |   lwz CARG2, WORD_HI(CARG2)
+  |.else
   |   lwzx CARG2, BASE, TMP1
+  |.endif
   |   lfdx FARG2, BASE, TMP1
   |  cmplw cr1, TMP1, NARGS8:RC
   |   checknum CARG2
@@ -2353,8 +2541,8 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |.ffunc string_byte			// Only handle the 1-arg case here.
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG3, 0(BASE)
-  |    lwz STR:CARG1, 4(BASE)
+  |   lwz CARG3, WORD_HI(BASE)
+  |    lwz STR:CARG1, WORD_LO(BASE)
   |  bne ->fff_fallback			// Need exactly 1 argument.
   |   checkstr CARG3
   |   bne ->fff_fallback
@@ -2385,12 +2573,12 @@ static void build_subroutines(BuildCtx *ctx)
   |.ffunc string_char			// Only handle the 1-arg case here.
   |  ffgccheck
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG3, 0(BASE)
+  |   lwz CARG3, WORD_HI(BASE)
   |.if DUALNUM
-  |    lwz TMP0, 4(BASE)
+  |    lwz TMP0, WORD_LO(BASE)
   |  bne ->fff_fallback			// Exactly 1 argument.
   |  checknum CARG3; bne ->fff_fallback
-  |   la CARG2, 7(BASE)
+  |   la CARG2, WORD_BLO(BASE)
   |.else
   |    lfd FARG1, 0(BASE)
   |  bne ->fff_fallback			// Exactly 1 argument.
@@ -2414,16 +2602,16 @@ static void build_subroutines(BuildCtx *ctx)
   |.ffunc string_sub
   |  ffgccheck
   |  cmplwi NARGS8:RC, 16
-  |   lwz CARG3, 16(BASE)
+  |   lwz CARG3, WORD_HI+16(BASE)
   |.if not DUALNUM
   |    lfd f0, 16(BASE)
   |.endif
-  |   lwz TMP0, 0(BASE)
-  |    lwz STR:CARG1, 4(BASE)
+  |   lwz TMP0, WORD_HI(BASE)
+  |    lwz STR:CARG1, WORD_LO(BASE)
   |  blt ->fff_fallback
-  |   lwz CARG2, 8(BASE)
+  |   lwz CARG2, WORD_HI+8(BASE)
   |.if DUALNUM
-  |    lwz TMP1, 12(BASE)
+  |    lwz TMP1, WORD_LO+8(BASE)
   |.else
   |    lfd f1, 8(BASE)
   |.endif
@@ -2431,7 +2619,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  beq >1
   |.if DUALNUM
   |  checknum CARG3
-  |   lwz TMP2, 20(BASE)
+  |   lwz TMP2, WORD_LO+16(BASE)
   |  bne ->fff_fallback
   |1:
   |  checknum CARG2; bne ->fff_fallback
@@ -2487,8 +2675,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  .ffunc string_ .. name
   |  ffgccheck
   |  cmplwi NARGS8:RC, 8
-  |   lwz CARG3, 0(BASE)
-  |    lwz STR:CARG2, 4(BASE)
+  |   lwz CARG3, WORD_HI(BASE)
+  |    lwz STR:CARG2, WORD_LO(BASE)
   |  blt ->fff_fallback
   |  checkstr CARG3
   |   la SBUF:CARG1, DISPATCH_GL(tmpbuf)(DISPATCH)
@@ -2526,10 +2714,10 @@ static void build_subroutines(BuildCtx *ctx)
   |  addi SAVE0, BASE, 8
   |  add SAVE1, BASE, NARGS8:RC
   |1:
-  |  lwz CARG4, 0(SAVE0)
+  |  lwz CARG4, WORD_HI(SAVE0)
   |   cmplw cr1, SAVE0, SAVE1
   |.if DUALNUM
-  |  lwz CARG2, 4(SAVE0)
+  |  lwz CARG2, WORD_LO(SAVE0)
   |.else
   |  lfd FARG1, 0(SAVE0)
   |.endif
@@ -2696,20 +2884,23 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->fff_fallback:			// Call fast function fallback handler.
   |  // BASE = new base, RB = CFUNC, RC = nargs*8
-  |  lp TMP3, CFUNC:RB->f
+  |  lp FUNCREG, CFUNC:RB->f
   |    add TMP1, BASE, NARGS8:RC
   |   lwz PC, FRAME_PC(BASE)		// Fallback may overwrite PC.
   |    addi TMP0, TMP1, 8*LUA_MINSTACK
   |     lwz TMP2, L->maxstack
   |   stw PC, SAVE_PC			// Redundant (but a defined value).
-  |  .toc lp TMP3, 0(TMP3)
+  |  .opd lp TOCREG, TOC_OFS(FUNCREG)
+  |  .opdenv lp ENVREG, ENV_OFS(FUNCREG)
+  |  .opd lp FUNCREG, 0(FUNCREG)
   |  cmplw TMP0, TMP2
   |     stp BASE, L->base
   |    stp TMP1, L->top
   |   mr CARG1, L
   |  bgt >5				// Need to grow stack.
-  |  mtctr TMP3
+  |  mtctr FUNCREG
   |  bctrl				// (lua_State *L)
+  |  .toc lp TOCREG, SAVE_TOC
   |  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
   |  lp BASE, L->base
   |  cmpwi CRET1, 0
@@ -2811,6 +3002,7 @@ static void build_subroutines(BuildCtx *ctx)
   |3:
   |  lp BASE, L->base
   |4:  // Re-dispatch to static ins.
+  |  addi BASEP4, BASE, 4
   |  lwz INS, -4(PC)
   |  decode_OPP TMP1, INS
   |   decode_RB8 RB, INS
@@ -2824,7 +3016,7 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |->cont_hook:				// Continue from hook yield.
   |  addi PC, PC, 4
-  |  lwz MULTRES, -20(RB)		// Restore MULTRES for *M ins.
+  |  lwz MULTRES, WORD_LO-24(RB)		// Restore MULTRES for *M ins.
   |  b <4
   |
   |->vm_hotloop:			// Hot loop counter underflow.
@@ -2866,6 +3058,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  lp BASE, L->base
   |   lp TMP0, L->top
   |   stw ZERO, SAVE_PC			// Invalidate for subsequent line hook.
+  |  addi BASEP4, BASE, 4
   |  sub NARGS8:RC, TMP0, BASE
   |  add RA, BASE, RA
   |  lwz LFUNC:RB, FRAME_FUNC(BASE)
@@ -2877,7 +3070,7 @@ static void build_subroutines(BuildCtx *ctx)
   |.if JIT
   |  // RA = resultptr, RB = meta base
   |  lwz INS, -4(PC)
-  |    lwz TRACE:TMP2, -20(RB)		// Save previous trace.
+  |    lwz TRACE:TMP2, WORD_LO-24(RB)	// Save previous trace.
   |   addic. TMP1, MULTRES, -8
   |  decode_RA8 RC, INS			// Call base.
   |   beq >2
@@ -2923,10 +3116,16 @@ static void build_subroutines(BuildCtx *ctx)
   |  mr CARG2, PC
   |  bl extern lj_dispatch_stitch	// (jit_State *J, const BCIns *pc)
   |  lp BASE, L->base
+  |  addi BASEP4, BASE, 4
   |  b ->cont_nop
   |
   |9:
+  |.if ENDIAN_LE
+  |  addi BASEP4, BASE, 4
+  |  stwx TISNIL, BASEP4, RC
+  |.else
   |  stwx TISNIL, BASE, RC
+  |.endif
   |  addi RC, RC, 8
   |  b <3
   |.endif
@@ -2941,6 +3140,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  // HOOK_PROFILE is off again, so re-dispatch to dynamic instruction.
   |  lp BASE, L->base
   |  subi PC, PC, 4
+  |  addi BASEP4, BASE, 4
   |  b ->cont_nop
 #endif
   |
@@ -2950,40 +3150,73 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |.macro savex_, a, b, c, d
   |.if FPU
-  |  stfd f..a, 16+a*8(sp)
-  |  stfd f..b, 16+b*8(sp)
-  |  stfd f..c, 16+c*8(sp)
-  |  stfd f..d, 16+d*8(sp)
+  |  stfd f..a, EXIT_OFFSET+a*8(sp)
+  |  stfd f..b, EXIT_OFFSET+b*8(sp)
+  |  stfd f..c, EXIT_OFFSET+c*8(sp)
+  |  stfd f..d, EXIT_OFFSET+d*8(sp)
   |.endif
   |.endmacro
   |
+  |.macro saver, a
+  |  stp r..a, EXIT_OFFSET+32*8+a*PSIZE(sp)
+  |.endmacro
+  |
   |->vm_exit_handler:
   |.if JIT
-  |  addi sp, sp, -(16+32*8+32*4)
-  |  stmw r2, 16+32*8+2*4(sp)
+  |  addi sp, sp, -(EXIT_OFFSET+32*8+32*PSIZE)
+  |  saver 3 // CARG1
+  |  saver 4 // CARG2
+  |  saver 5 // CARG3
+  |  saver 17 // DISPATCH
   |    addi DISPATCH, JGL, -GG_DISP2G-32768
   |    li CARG2, ~LJ_VMST_EXIT
-  |   lwz CARG1, 16+32*8+32*4(sp)	// Get stack chain.
+  |   lp CARG1, EXIT_OFFSET+32*8+32*PSIZE(sp)	// Get stack chain.
   |    stw CARG2, DISPATCH_GL(vmstate)(DISPATCH)
+  |  saver 2
+  |  saver 6
+  |  saver 7
+  |  saver 8
+  |  saver 9
+  |  saver 10
+  |  saver 11
+  |  saver 12
+  |  saver 13
   |  savex_ 0,1,2,3
-  |   stw CARG1, 0(sp)			// Store extended stack chain.
-  |   clrso TMP1
+  |   stp CARG1, 0(sp)			// Store extended stack chain.
+
   |  savex_ 4,5,6,7
-  |   addi CARG2, sp, 16+32*8+32*4	// Recompute original value of sp.
+  |  saver 14
+  |  saver 15
+  |  saver 16
+  |  saver 18
+  |   addi CARG2, sp, EXIT_OFFSET+32*8+32*PSIZE	// Recompute original value of sp.
   |  savex_ 8,9,10,11
-  |   stw CARG2, 16+32*8+1*4(sp)	// Store sp in RID_SP.
+  |   stp CARG2, EXIT_OFFSET+32*8+1*PSIZE(sp)	// Store sp in RID_SP.
   |  savex_ 12,13,14,15
   |   mflr CARG3
   |   li TMP1, 0
   |  savex_ 16,17,18,19
-  |   stw TMP1, 16+32*8+0*4(sp)		// Clear RID_TMP.
+  |   stw TMP1, EXIT_OFFSET+32*8+0*PSIZE(sp)		// Clear RID_TMP.
   |  savex_ 20,21,22,23
   |   lhz CARG4, 2(CARG3)		// Load trace number.
   |  savex_ 24,25,26,27
   |  lwz L, DISPATCH_GL(cur_L)(DISPATCH)
   |  savex_ 28,29,30,31
+  |  saver 19
+  |  saver 20
+  |  saver 21
+  |  saver 22
+  |  saver 23
+  |  saver 24
+  |  saver 25
+  |  saver 26
+  |  saver 27
+  |  saver 28
+  |  saver 29
+  |  saver 30
+  |  saver 31
   |   sub CARG3, TMP0, CARG3		// Compute exit number.
-  |  lp BASE, DISPATCH_GL(jit_base)(DISPATCH)
+  |  lwz BASE, DISPATCH_GL(jit_base)(DISPATCH)
   |   srwi CARG3, CARG3, 2
   |  stp L, DISPATCH_J(L)(DISPATCH)
   |   subi CARG3, CARG3, 2
@@ -2992,11 +3225,11 @@ static void build_subroutines(BuildCtx *ctx)
   |  stw TMP1, DISPATCH_GL(jit_base)(DISPATCH)
   |  addi CARG1, DISPATCH, GG_DISP2J
   |   stw CARG3, DISPATCH_J(exitno)(DISPATCH)
-  |  addi CARG2, sp, 16
+  |  addi CARG2, sp, EXIT_OFFSET
   |  bl extern lj_trace_exit		// (jit_State *J, ExitState *ex)
   |  // Returns MULTRES (unscaled) or negated error code.
   |  lp TMP1, L->cframe
-  |  lwz TMP2, 0(sp)
+  |  lp TMP2, 0(sp)
   |   lp BASE, L->base
   |.if GPR64
   |  rldicr sp, TMP1, 0, 61
@@ -3004,7 +3237,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  rlwinm sp, TMP1, 0, 0, 29
   |.endif
   |   lwz PC, SAVE_PC			// Get SAVE_PC.
-  |  stw TMP2, 0(sp)
+  |  stp TMP2, 0(sp)
   |  stw L, SAVE_L			// Set SAVE_L (on-trace resume/yield).
   |  b >1
   |.endif
@@ -3015,8 +3248,9 @@ static void build_subroutines(BuildCtx *ctx)
   |  addi DISPATCH, JGL, -GG_DISP2G-32768
   |  stp BASE, L->base
   |1:
-  |  cmpwi CARG1, 0
-  |  blt >9				// Check for error from exit.
+  |  li TMP2, -LUA_ERRERR
+  |  cmplw CARG1, TMP2
+  |  bge >9				// Check for error from exit.
   |  lwz LFUNC:RB, FRAME_FUNC(BASE)
   |   slwi MULTRES, CARG1, 3
   |    li TMP2, 0
@@ -3025,7 +3259,12 @@ static void build_subroutines(BuildCtx *ctx)
   |    stw TMP2, DISPATCH_GL(jit_base)(DISPATCH)
   |  lwz KBASE, PC2PROTO(k)(TMP1)
   |  // Setup type comparison constants.
+  |.if P64
+  |  lus TISNUM, LJ_TISNUM >> 16
+  |  ori TISNUM, TISNUM, LJ_TISNUM & 0xffff
+  |.else
   |  li TISNUM, LJ_TISNUM
+  |.endif
   |  .FPU lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
   |  .FPU stw TMP3, TMPD
   |  li ZERO, 0
@@ -3041,18 +3280,20 @@ static void build_subroutines(BuildCtx *ctx)
   |   addi PC, PC, 4
   |    // Assumes TISNIL == ~LJ_VMST_INTERP == -1.
   |    stw TISNIL, DISPATCH_GL(vmstate)(DISPATCH)
+  |  cmpwi CARG1, -17			// Static dispatch?
+  |  beq >5
   |  decode_OPP TMP1, INS
   |   decode_RA8 RA, INS
   |  lpx TMP0, DISPATCH, TMP1
   |  mtctr TMP0
-  |  cmplwi TMP1, BC_FUNCF*4		// Function header?
+  |  cmplwi TMP1, BC_FUNCF*PSIZE	// Function header?
   |  bge >2
   |   decode_RB8 RB, INS
   |   decode_RD8 RD, INS
   |   decode_RC8 RC, INS
   |  bctr
   |2:
-  |  cmplwi TMP1, (BC_FUNCC+2)*4	// Fast function?
+  |  cmplwi TMP1, (BC_FUNCC+2)*PSIZE	// Fast function?
   |  blt >3
   |  // Check frame below fast function.
   |  lwz TMP1, FRAME_PC(BASE)
@@ -3062,7 +3303,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  lwz TMP2, -4(TMP1)
   |  decode_RA8 TMP0, TMP2
   |  sub TMP1, BASE, TMP0
-  |  lwz LFUNC:TMP2, -12(TMP1)
+  |  lwz LFUNC:TMP2, WORD_LO-16(TMP1)
   |  lwz TMP1, LFUNC:TMP2->pc
   |  lwz KBASE, PC2PROTO(k)(TMP1)
   |3:
@@ -3070,6 +3311,21 @@ static void build_subroutines(BuildCtx *ctx)
   |   add RA, RA, BASE
   |  bctr
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  lwz TMP1, DISPATCH_J(trace)(DISPATCH)
+  |  decode_RD4 RD, INS
+  |  lwzx TRACE:TMP1, TMP1, RD
+  |  lwz INS, TRACE:TMP1->startins
+  |  decode_OPP TMP1, INS
+  |  addi TMP1, TMP1, GG_DISP2STATIC
+  |  lpx TMP0, DISPATCH, TMP1
+  |  mtctr TMP0
+  |   decode_RB8 RB, INS
+  |   decode_RD8 RD, INS
+  |   decode_RA8 RA, INS
+  |   decode_RC8 RC, INS
+  |  bctr
+  |
   |9:  // Rethrow error from the right C frame.
   |  neg CARG2, CARG1
   |  mr CARG1, L
@@ -3111,6 +3367,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  sfi2d CARG3, CARG4
   |
   |->vm_modi:
+  |  li TMP1, 0
+  |  mtxer TMP1
   |  divwo. TMP0, CARG1, CARG2
   |  bso >1
   |.if GPR64
@@ -3129,7 +3387,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  cmpwi CARG2, 0
   |   li CARG1, 0
   |  beqlr
-  |  clrso TMP0			// Clear SO for -2147483648 % -1 and return 0.
+  |  // Clear SO for -2147483648 % -1 and return 0.
+  |  crxor 4*cr0+so, 4*cr0+so, 4*cr0+so
   |  blr
   |
   |//-----------------------------------------------------------------------
@@ -3142,10 +3401,18 @@ static void build_subroutines(BuildCtx *ctx)
   |->vm_cachesync:
   |.if JIT or FFI
   |  // Compute start of first cache line and number of cache lines.
+  |  .if GPR64
+  |  rldicr CARG1, CARG1, 0, 58
+  |  .else
   |  rlwinm CARG1, CARG1, 0, 0, 26
+  |  .endif
   |  sub CARG2, CARG2, CARG1
   |  addi CARG2, CARG2, 31
+  |  .if GPR64
+  |  srdi. CARG2, CARG2, 5
+  |  .else
   |  rlwinm. CARG2, CARG2, 27, 5, 31
+  |  .endif
   |  beqlr
   |  mtctr CARG2
   |  mr CARG3, CARG1
@@ -3172,39 +3439,70 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- FFI helper functions -----------------------------------------------
   |//-----------------------------------------------------------------------
   |
-  |// Handler for callback functions. Callback slot number in r11, g in r12.
+  |// Handler for callback functions.
+  |// 32-bit: Callback slot number in r12, g in r11.
+  |// 64-bit v1: Callback slot number in bits 47+ of r11, g in 0-46, TOC in r2.
+  |// 64-bit v2: Callback slot number in bits 2-11 of r12, g in r11,
+  |// vm_ffi_callback in r2.
   |->vm_ffi_callback:
   |.if FFI
   |.type CTSTATE, CTState, PC
+  |  .if OPD
+  |   rldicl r12, r11, 17, 47
+  |   rldicl r11, r11, 0, 17
+  |  .endif
+  |  .if ELFV2
+  |   rlwinm r12, r12, 30, 22, 31
+  |   addisl TOCREG, TOCREG, extern .TOC.-lj_vm_ffi_callback@ha
+  |   addil TOCREG, TOCREG, extern .TOC.-lj_vm_ffi_callback@l
+  |  .endif
   |  saveregs
-  |  lwz CTSTATE, GL:r12->ctype_state
-  |   addi DISPATCH, r12, GG_G2DISP
-  |  stw r11, CTSTATE->cb.slot
-  |  stw r3, CTSTATE->cb.gpr[0]
+  |  lwz CTSTATE, GL:r11->ctype_state
+  |   addi DISPATCH, r11, GG_G2DISP
+  |  stw r12, CTSTATE->cb.slot
+  |  stp r3, CTSTATE->cb.gpr[0]
   |   .FPU stfd f1, CTSTATE->cb.fpr[0]
-  |  stw r4, CTSTATE->cb.gpr[1]
+  |  stp r4, CTSTATE->cb.gpr[1]
   |   .FPU stfd f2, CTSTATE->cb.fpr[1]
-  |  stw r5, CTSTATE->cb.gpr[2]
+  |  stp r5, CTSTATE->cb.gpr[2]
   |   .FPU stfd f3, CTSTATE->cb.fpr[2]
-  |  stw r6, CTSTATE->cb.gpr[3]
+  |  stp r6, CTSTATE->cb.gpr[3]
   |   .FPU stfd f4, CTSTATE->cb.fpr[3]
-  |  stw r7, CTSTATE->cb.gpr[4]
+  |  stp r7, CTSTATE->cb.gpr[4]
   |   .FPU stfd f5, CTSTATE->cb.fpr[4]
-  |  stw r8, CTSTATE->cb.gpr[5]
+  |  stp r8, CTSTATE->cb.gpr[5]
   |   .FPU stfd f6, CTSTATE->cb.fpr[5]
-  |  stw r9, CTSTATE->cb.gpr[6]
+  |  stp r9, CTSTATE->cb.gpr[6]
   |   .FPU stfd f7, CTSTATE->cb.fpr[6]
-  |  stw r10, CTSTATE->cb.gpr[7]
+  |  stp r10, CTSTATE->cb.gpr[7]
   |   .FPU stfd f8, CTSTATE->cb.fpr[7]
+  |  .if GPR64
+  |   stfd f9, CTSTATE->cb.fpr[8]
+  |   stfd f10, CTSTATE->cb.fpr[9]
+  |   stfd f11, CTSTATE->cb.fpr[10]
+  |   stfd f12, CTSTATE->cb.fpr[11]
+  |   stfd f13, CTSTATE->cb.fpr[12]
+  |  .endif
+  |  .if ELFV2
+  |  addi TMP0, sp, CFRAME_SPACE+96
+  |  .elif GPR64
+  |  addi TMP0, sp, CFRAME_SPACE+112
+  |  .else
   |  addi TMP0, sp, CFRAME_SPACE+8
-  |  stw TMP0, CTSTATE->cb.stack
+  |  .endif
+  |  stp TMP0, CTSTATE->cb.stack
   |   mr CARG1, CTSTATE
   |  stw CTSTATE, SAVE_PC		// Any value outside of bytecode is ok.
   |   mr CARG2, sp
   |  bl extern lj_ccallback_enter	// (CTState *cts, void *cf)
   |  // Returns lua_State *.
   |  lp BASE, L:CRET1->base
+  |.if P64
+  |     lus TISNUM, LJ_TISNUM >> 16	// Setup type comparison constants.
+  |     ori TISNUM, TISNUM, LJ_TISNUM & 0xffff
+  |.else
   |     li TISNUM, LJ_TISNUM		// Setup type comparison constants.
+  |.endif
   |  lp RC, L:CRET1->top
   |     .FPU lus TMP3, 0x59c0		// TOBIT = 2^52 + 2^51 (float).
   |     li ZERO, 0
@@ -3233,9 +3531,21 @@ static void build_subroutines(BuildCtx *ctx)
   |  mr CARG1, CTSTATE
   |  mr CARG2, RA
   |  bl extern lj_ccallback_leave	// (CTState *cts, TValue *o)
-  |  lwz CRET1, CTSTATE->cb.gpr[0]
+  |  lp CRET1, CTSTATE->cb.gpr[0]
   |  .FPU lfd FARG1, CTSTATE->cb.fpr[0]
-  |  lwz CRET2, CTSTATE->cb.gpr[1]
+  |  lp CRET2, CTSTATE->cb.gpr[1]
+  |  .if GPR64
+  |    lfd FARG2, CTSTATE->cb.fpr[1]
+  |  .else
+  |    lp CARG3, CTSTATE->cb.gpr[2]
+  |    lp CARG4, CTSTATE->cb.gpr[3]
+  |  .endif
+  |  .elfv2 lfd f3, CTSTATE->cb.fpr[2]
+  |  .elfv2 lfd f4, CTSTATE->cb.fpr[3]
+  |  .elfv2 lfd f5, CTSTATE->cb.fpr[4]
+  |  .elfv2 lfd f6, CTSTATE->cb.fpr[5]
+  |  .elfv2 lfd f7, CTSTATE->cb.fpr[6]
+  |  .elfv2 lfd f8, CTSTATE->cb.fpr[7]
   |  b ->vm_leave_unw
   |.endif
   |
@@ -3248,23 +3558,41 @@ static void build_subroutines(BuildCtx *ctx)
   |   lbz CARG2, CCSTATE->nsp
   |   lbz CARG3, CCSTATE->nfpr
   |  neg TMP1, TMP1
+  |  .if GPR64
+  |    std TMP0, 16(sp)
+  |  .else
   |    stw TMP0, 4(sp)
+  |  .endif
   |   cmpwi cr1, CARG3, 0
   |  mr TMP2, sp
-  |   addic. CARG2, CARG2, -1
+  |   addic. CARG2, CARG2, -PSIZE
+  |  .if GPR64
+  |  stdux sp, sp, TMP1
+  |  .else
   |  stwux sp, sp, TMP1
+  |  .endif
   |   crnot 4*cr1+eq, 4*cr1+eq		// For vararg calls.
-  |  stw r14, -4(TMP2)
-  |  stw CCSTATE, -8(TMP2)
+  |  .if GPR64
+  |    std r14, -8(TMP2)
+  |    std CCSTATE, -16(TMP2)
+  |  .else
+  |    stw r14, -4(TMP2)
+  |    stw CCSTATE, -8(TMP2)
+  |  .endif
   |  mr r14, TMP2
   |  la TMP1, CCSTATE->stack
-  |   slwi CARG2, CARG2, 2
   |   blty >2
-  |  la TMP2, 8(sp)
+  |  .if ELFV2
+  |    la TMP2, 96(sp)
+  |  .elif GPR64
+  |    la TMP2, 112(sp)
+  |  .else
+  |    la TMP2, 8(sp)
+  |  .endif
   |1:
-  |  lwzx TMP0, TMP1, CARG2
-  |  stwx TMP0, TMP2, CARG2
-  |   addic. CARG2, CARG2, -4
+  |  lpx TMP0, TMP1, CARG2
+  |  stpx TMP0, TMP2, CARG2
+  |   addic. CARG2, CARG2, -PSIZE
   |  bge <1
   |2:
   |  bney cr1, >3
@@ -3276,28 +3604,55 @@ static void build_subroutines(BuildCtx *ctx)
   |  .FPU lfd f6, CCSTATE->fpr[5]
   |  .FPU lfd f7, CCSTATE->fpr[6]
   |  .FPU lfd f8, CCSTATE->fpr[7]
+  |  .if GPR64
+  |  .FPU lfd f9, CCSTATE->fpr[8]
+  |  .FPU lfd f10, CCSTATE->fpr[9]
+  |  .FPU lfd f11, CCSTATE->fpr[10]
+  |  .FPU lfd f12, CCSTATE->fpr[11]
+  |  .FPU lfd f13, CCSTATE->fpr[12]
+  |  .endif
   |3:
-  |   lp TMP0, CCSTATE->func
-  |  lwz CARG2, CCSTATE->gpr[1]
-  |  lwz CARG3, CCSTATE->gpr[2]
-  |  lwz CARG4, CCSTATE->gpr[3]
-  |  lwz CARG5, CCSTATE->gpr[4]
-  |   mtctr TMP0
-  |  lwz r8, CCSTATE->gpr[5]
-  |  lwz r9, CCSTATE->gpr[6]
-  |  lwz r10, CCSTATE->gpr[7]
-  |  lwz CARG1, CCSTATE->gpr[0]		// Do this last, since CCSTATE is CARG1.
+  |  .toc std TOCREG, SAVE_TOC
+  |   lp FUNCREG, CCSTATE->func
+  |  lp CARG2, CCSTATE->gpr[1]
+  |  lp CARG3, CCSTATE->gpr[2]
+  |  .opd lp TOCREG, TOC_OFS(FUNCREG)
+  |  .opdenv lp ENVREG, ENV_OFS(FUNCREG)
+  |  .opd lp FUNCREG, 0(FUNCREG)
+  |  lp CARG4, CCSTATE->gpr[3]
+  |  lp CARG5, CCSTATE->gpr[4]
+  |   mtctr FUNCREG
+  |  lp r8, CCSTATE->gpr[5]
+  |  lp r9, CCSTATE->gpr[6]
+  |  lp r10, CCSTATE->gpr[7]
+  |  lp CARG1, CCSTATE->gpr[0]		// Do this last, since CCSTATE is CARG1.
   |   bctrl
-  |  lwz CCSTATE:TMP1, -8(r14)
-  |  lwz TMP2, -4(r14)
+  |   .toc lp TOCREG, SAVE_TOC
+  |  .if GPR64
+  |   ld CCSTATE:TMP1, -16(r14)
+  |   ld TMP2, -8(r14)
+  |   ld TMP0, 16(r14)
+  |  .else
+  |   lwz CCSTATE:TMP1, -8(r14)
+  |   lwz TMP2, -4(r14)
   |   lwz TMP0, 4(r14)
-  |  stw CARG1, CCSTATE:TMP1->gpr[0]
+  |  .endif
+  |  stp CARG1, CCSTATE:TMP1->gpr[0]
   |  .FPU stfd FARG1, CCSTATE:TMP1->fpr[0]
-  |  stw CARG2, CCSTATE:TMP1->gpr[1]
+  |  stp CARG2, CCSTATE:TMP1->gpr[1]
+  |  .if GPR64
+  |   stfd FARG2, CCSTATE:TMP1->fpr[1]
+  |  .endif
+  |  .elfv2 stfd FARG3, CCSTATE:TMP1->fpr[2]
+  |  .elfv2 stfd FARG4, CCSTATE:TMP1->fpr[3]
+  |  .elfv2 stfd FARG5, CCSTATE:TMP1->fpr[4]
+  |  .elfv2 stfd FARG6, CCSTATE:TMP1->fpr[5]
+  |  .elfv2 stfd FARG7, CCSTATE:TMP1->fpr[6]
+  |  .elfv2 stfd FARG8, CCSTATE:TMP1->fpr[7]
   |   mtlr TMP0
-  |  stw CARG3, CCSTATE:TMP1->gpr[2]
+  |  stp CARG3, CCSTATE:TMP1->gpr[2]
   |   mr sp, r14
-  |  stw CARG4, CCSTATE:TMP1->gpr[3]
+  |  stp CARG4, CCSTATE:TMP1->gpr[3]
   |   mr r14, TMP2
   |  blr
   |.endif
@@ -3320,14 +3675,15 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
   case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
     |  // RA = src1*8, RD = src2*8, JMP with RD = target
+    |  addi BASEP4, BASE, 4
     |.if DUALNUM
-    |  lwzux CARG1, RA, BASE
+    |  lwzx CARG1, BASE_HI, RA
     |    addi PC, PC, 4
-    |   lwz CARG2, 4(RA)
-    |  lwzux CARG3, RD, BASE
+    |   lwzx CARG2, BASE_LO, RA
+    |  lwzx CARG3, BASE_HI, RD
     |    lwz TMP2, -4(PC)
     |  checknum cr0, CARG1
-    |   lwz CARG4, 4(RD)
+    |   lwzx CARG4, BASE_LO, RD
     |    decode_RD4 TMP2, TMP2
     |  checknum cr1, CARG3
     |    addis SAVE0, TMP2, -(BCBIAS_J*4 >> 16)
@@ -3351,7 +3707,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |7:  // RA is not an integer.
     |  bgt cr0, ->vmeta_comp
     |  // RA is a number.
-    |   .FPU lfd f0, 0(RA)
+    |   .FPU lfdx f0, BASE, RA
     |  bgt cr1, ->vmeta_comp
     |  blt cr1, >4
     |  // RA is a number, RD is an integer.
@@ -3371,7 +3727,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bl ->vm_sfi2d_1
     |.endif
     |4:
-    |  .FPU lfd f1, 0(RD)
+    |  .FPU lfdx f1, BASE, RD
     |5:
     |.if FPU
     |  fcmpu cr0, f0, f1
@@ -3392,10 +3748,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     }
     |  b <1
     |.else
-    |  lwzx TMP0, BASE, RA
+    |  lwzx TMP0, BASE_HI, RA
     |    addi PC, PC, 4
     |   lfdx f0, BASE, RA
-    |  lwzx TMP1, BASE, RD
+    |  lwzx TMP1, BASE_HI, RD
     |  checknum cr0, TMP0
     |    lwz TMP2, -4(PC)
     |   lfdx f1, BASE, RD
@@ -3425,16 +3781,25 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_ISEQV: case BC_ISNEV:
     vk = op == BC_ISEQV;
     |  // RA = src1*8, RD = src2*8, JMP with RD = target
+    |  addi BASEP4, BASE, 4
     |.if DUALNUM
-    |  lwzux CARG1, RA, BASE
+    |  lwzx CARG1, BASE_HI, RA
     |    addi PC, PC, 4
-    |   lwz CARG2, 4(RA)
-    |  lwzux CARG3, RD, BASE
+    |   lwzx CARG2, BASE_LO, RA
+    |  .if ENDIAN_LE
+    |    lwzx CARG3, BASE_HI, RD
+    |  .else
+    |    lwzux CARG3, RD, BASE_HI
+    |  .endif
     |  checknum cr0, CARG1
     |    lwz SAVE0, -4(PC)
     |  checknum cr1, CARG3
     |    decode_RD4 SAVE0, SAVE0
-    |   lwz CARG4, 4(RD)
+    |  .if ENDIAN_LE
+    |   lwzux CARG4, RD, BASE_LO
+    |  .else
+    |   lwz CARG4, WORD_LO(RD)
+    |  .endif
     |  cror 4*cr7+gt, 4*cr0+gt, 4*cr1+gt
     |    addis SAVE0, SAVE0, -(BCBIAS_J*4 >> 16)
     if (vk) {
@@ -3443,11 +3808,11 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
       |  ble cr7, ->BC_ISNEN_Z
     }
     |.else
-    |  lwzux CARG1, RA, BASE
+    |  lwzx CARG1, BASE_HI, RA
     |   lwz SAVE0, 0(PC)
-    |    lfd f0, 0(RA)
+    |    lfdx f0, BASE, RA
     |   addi PC, PC, 4
-    |  lwzux CARG3, RD, BASE
+    |  lwzx CARG3, BASE_HI, RD
     |  checknum cr0, CARG1
     |   decode_RD4 SAVE0, SAVE0
     |    lfd f1, 0(RD)
@@ -3468,8 +3833,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.endif
     |5:  // Either or both types are not numbers.
     |.if not DUALNUM
-    |    lwz CARG2, 4(RA)
-    |    lwz CARG4, 4(RD)
+    |    lwzx CARG2, BASE_LO, RA
+    |    lwzx CARG4, BASE_LO, RD
     |.endif
     |.if FFI
     |  cmpwi cr7, CARG1, LJ_TCDATA
@@ -3485,10 +3850,16 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.if FFI
     |  beq cr7, ->vmeta_equal_cd
     |.endif
+    |.if P64
+    |   cmplwi cr7, TMP2, ~LJ_TUDATA		// Avoid 64 bit lightuserdata.
+    |.endif
     |    cmplw cr5, CARG2, CARG4
     |  crandc 4*cr0+gt, 4*cr0+eq, 4*cr1+gt	// 2: Same type and primitive.
     |  crorc 4*cr0+lt, 4*cr5+eq, 4*cr0+eq	// 1: Same tv or different type.
     |  crand 4*cr0+eq, 4*cr0+eq, 4*cr5+eq	// 0: Same type and same tv.
+    |.if P64
+    |   cror 4*cr6+lt, 4*cr6+lt, 4*cr7+gt
+    |.endif
     |   mr SAVE1, PC
     |  cror 4*cr0+eq, 4*cr0+eq, 4*cr0+gt	// 0 or 2.
     |  cror 4*cr0+lt, 4*cr0+lt, 4*cr0+gt	// 1 or 2.
@@ -3528,9 +3899,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_ISEQS: case BC_ISNES:
     vk = op == BC_ISEQS;
     |  // RA = src*8, RD = str_const*8 (~), JMP with RD = target
-    |  lwzux TMP0, RA, BASE
+    |  addi BASEP4, BASE, 4
+    |  lwzx TMP0, BASE_HI, RA
     |   srwi RD, RD, 1
-    |  lwz STR:TMP3, 4(RA)
+    |  lwzx STR:TMP3, BASE_LO, RA
     |    lwz TMP2, 0(PC)
     |   subfic RD, RD, -4
     |    addi PC, PC, 4
@@ -3561,16 +3933,16 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_ISEQN: case BC_ISNEN:
     vk = op == BC_ISEQN;
     |  // RA = src*8, RD = num_const*8, JMP with RD = target
+    |  addi BASEP4, BASE, 4
     |.if DUALNUM
-    |  lwzux CARG1, RA, BASE
+    |  lwzx CARG1, BASE_HI, RA
     |    addi PC, PC, 4
-    |   lwz CARG2, 4(RA)
-    |  lwzux CARG3, RD, KBASE
+    |   lwzx CARG2, BASE_LO, RA
+    |  lwzux2 CARG3, CARG4, RD, KBASE
     |  checknum cr0, CARG1
     |    lwz SAVE0, -4(PC)
     |  checknum cr1, CARG3
     |    decode_RD4 SAVE0, SAVE0
-    |   lwz CARG4, 4(RD)
     |    addis SAVE0, SAVE0, -(BCBIAS_J*4 >> 16)
     if (vk) {
       |->BC_ISEQN_Z:
@@ -3587,7 +3959,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     } else {
       |->BC_ISNEN_Z:  // Dummy label.
     }
-    |  lwzx CARG1, BASE, RA
+    |  lwzx CARG1, BASE_HI, RA
     |    addi PC, PC, 4
     |   lfdx f0, BASE, RA
     |    lwz SAVE0, -4(PC)
@@ -3625,7 +3997,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |7:  // RA is not an integer.
     |  bge cr0, <3
     |  // RA is a number.
-    |   .FPU lfd f0, 0(RA)
+    |   .FPU lfdx f0, BASE, RA
     |  blt cr1, >1
     |  // RA is a number, RD is an integer.
     |.if FPU
@@ -3657,7 +4029,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_ISEQP: case BC_ISNEP:
     vk = op == BC_ISEQP;
     |  // RA = src*8, RD = primitive_type*8 (~), JMP with RD = target
-    |  lwzx TMP0, BASE, RA
+    |  addi BASEP4, BASE, 4
+    |  lwzx TMP0, BASE_HI, RA
     |   srwi TMP1, RD, 3
     |    lwz TMP2, 0(PC)
     |   not TMP1, TMP1
@@ -3687,7 +4060,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
   case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
     |  // RA = dst*8 or unused, RD = src*8, JMP with RD = target
-    |  lwzx TMP0, BASE, RD
+    |  addi BASEP4, BASE, 4
+    |  lwzx TMP0, BASE_HI, RD
     |   lwz INS, 0(PC)
     |   addi PC, PC, 4
     if (op == BC_IST || op == BC_ISF) {
@@ -3732,7 +4106,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
   case BC_ISTYPE:
     |  // RA = src*8, RD = -type*8
-    |  lwzx TMP0, BASE, RA
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
+    |  lwzx TMP0, BASE_HI, RA
     |  srwi TMP1, RD, 3
     |  ins_next1
     |.if not PPE and not GPR64
@@ -3746,7 +4123,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_ISNUM:
     |  // RA = src*8, RD = -(TISNUM-1)*8
-    |  lwzx TMP0, BASE, RA
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
+    |  lwzx TMP0, BASE_HI, RA
     |  ins_next1
     |  checknum TMP0
     |  bge ->vmeta_istype
@@ -3771,18 +4151,25 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_NOT:
     |  // RA = dst*8, RD = src*8
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
     |  ins_next1
-    |  lwzx TMP0, BASE, RD
+    |  lwzx TMP0, BASE_HI, RD
     |  .gpr64 extsw TMP0, TMP0
     |  subfic TMP1, TMP0, LJ_TTRUE
     |  adde TMP0, TMP0, TMP1
-    |  stwx TMP0, BASE, RA
+    |  stwx TMP0, BASE_HI, RA
     |  ins_next2
     break;
   case BC_UNM:
     |  // RA = dst*8, RD = src*8
-    |  lwzux TMP1, RD, BASE
-    |   lwz TMP0, 4(RD)
+    |  addi BASEP4, BASE, 4
+    |  lwzx TMP1, BASE_HI, RD
+    |   lwzx TMP0, BASE_LO, RD
+    |.if DUALNUM and not GPR64
+    |  mtxer ZERO
+    |.endif
     |  checknum TMP1
     |.if DUALNUM
     |  bne >5
@@ -3794,18 +4181,13 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.else
     |  nego. TMP0, TMP0
     |  bso >4
-    |1:
     |.endif
     |  ins_next1
-    |  stwux TISNUM, RA, BASE
-    |   stw TMP0, 4(RA)
+    |  stwx TISNUM, BASE_HI, RA
+    |   stwx TMP0, BASE_LO, RA
     |3:
     |  ins_next2
     |4:
-    |.if not GPR64
-    |  // Potential overflow.
-    |  checkov TMP1, <1			// Ignore unrelated overflow.
-    |.endif
     |  lus TMP1, 0x41e0			// 2^31.
     |  li TMP0, 0
     |  b >7
@@ -3815,8 +4197,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  xoris TMP1, TMP1, 0x8000
     |7:
     |  ins_next1
-    |  stwux TMP1, RA, BASE
-    |   stw TMP0, 4(RA)
+    |  stwx TMP1, BASE_HI, RA
+    |   stwx TMP0, BASE_LO, RA
     |.if DUALNUM
     |  b <3
     |.else
@@ -3825,15 +4207,16 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_LEN:
     |  // RA = dst*8, RD = src*8
-    |  lwzux TMP0, RD, BASE
-    |   lwz CARG1, 4(RD)
+    |  addi BASEP4, BASE, 4
+    |  lwzx TMP0, BASE_HI, RD
+    |   lwzx CARG1, BASE_LO, RD
     |  checkstr TMP0; bne >2
     |  lwz CRET1, STR:CARG1->len
     |1:
     |.if DUALNUM
     |  ins_next1
-    |  stwux TISNUM, RA, BASE
-    |   stw CRET1, 4(RA)
+    |  stwx TISNUM, BASE_HI, RA
+    |   stwx CRET1, BASE_LO, RA
     |.else
     |  tonum_u f0, CRET1		// Result is a non-negative integer.
     |  ins_next1
@@ -3865,12 +4248,20 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
     |.macro ins_arithpre
     |  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
+    |  addi BASEP4, BASE, 4
     ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
     ||switch (vk) {
     ||case 0:
-    |   lwzx CARG1, BASE, RB
+    |   .if ENDIAN_LE and DUALNUM
+    |     addi CARG3, RC, 4
+    |   .endif
+    |   lwzx CARG1, BASE_HI, RB
     |   .if DUALNUM
-    |     lwzx CARG3, KBASE, RC
+    |     .if ENDIAN_LE
+    |       lwzx CARG3, KBASE, CARG3
+    |     .else
+    |       lwzx CARG3, KBASE, RC
+    |     .endif
     |   .endif
     |   .if FPU
     |    lfdx f14, BASE, RB
@@ -3891,9 +4282,16 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   .endif
     ||  break;
     ||case 1:
-    |   lwzx CARG1, BASE, RB
+    |   .if ENDIAN_LE and DUALNUM
+    |     addi CARG3, RC, 4
+    |   .endif
+    |   lwzx CARG1, BASE_HI, RB
     |   .if DUALNUM
-    |     lwzx CARG3, KBASE, RC
+    |     .if ENDIAN_LE
+    |       lwzx CARG3, KBASE, CARG3
+    |     .else
+    |       lwzx CARG3, KBASE, RC
+    |     .endif
     |   .endif
     |   .if FPU
     |    lfdx f15, BASE, RB
@@ -3914,8 +4312,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   .endif
     ||  break;
     ||default:
-    |   lwzx CARG1, BASE, RB
-    |   lwzx CARG3, BASE, RC
+    |   lwzx CARG1, BASE_HI, RB
+    |   lwzx CARG3, BASE_HI, RC
     |   .if FPU
     |    lfdx f14, BASE, RB
     |    lfdx f15, BASE, RC
@@ -3998,50 +4396,78 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |
     |.macro ins_arithdn, intins, fpins, fpcall
     |  // RA = dst*8, RB = src1*8, RC = src2*8 | num_const*8
+    |  addi BASEP4, BASE, 4
     ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
     ||switch (vk) {
     ||case 0:
-    |   lwzux CARG1, RB, BASE
-    |   lwzux CARG3, RC, KBASE
+    |   .if ENDIAN_LE
+    |     lwzx TMP1, RB, BASE_HI
+    |     lwzux CARG2, RC, KBASE
+    |      lwz TMP2, 4(RC)
+    |     checknum cr0, TMP1
+    |      lwzux CARG1, RB, BASE
+    |     checknum cr1, TMP2
+    |   .else
+    |     lwzux CARG1, RB, BASE
+    |     lwzux CARG3, RC, KBASE
     |    lwz CARG2, 4(RB)
-    |   checknum cr0, CARG1
-    |    lwz CARG4, 4(RC)
-    |   checknum cr1, CARG3
+    |     checknum cr0, CARG1
+    |      lwz CARG4, 4(RC)
+    |     checknum cr1, CARG3
+    |   .endif
     ||  break;
     ||case 1:
-    |   lwzux CARG3, RB, BASE
-    |   lwzux CARG1, RC, KBASE
-    |    lwz CARG4, 4(RB)
-    |   checknum cr0, CARG3
-    |    lwz CARG2, 4(RC)
-    |   checknum cr1, CARG1
+    |   .if ENDIAN_LE
+    |     lwzux CARG1, RC, KBASE
+    |     lwzx TMP1, RB, BASE_HI
+    |      lwz TMP2, 4(RC)
+    |     checknum cr0, TMP1
+    |      lwzux CARG2, RB, BASE
+    |     checknum cr1, TMP2
+    |   .else
+    |     lwzux CARG3, RB, BASE
+    |     lwzux CARG1, RC, KBASE
+    |      lwz CARG4, 4(RB)
+    |     checknum cr0, CARG3
+    |      lwz CARG2, 4(RC)
+    |     checknum cr1, CARG1
+    |   .endif
     ||  break;
     ||default:
-    |   lwzux CARG1, RB, BASE
-    |   lwzux CARG3, RC, BASE
-    |    lwz CARG2, 4(RB)
-    |   checknum cr0, CARG1
-    |    lwz CARG4, 4(RC)
-    |   checknum cr1, CARG3
+    |   .if ENDIAN_LE
+    |     lwzx TMP1, RB, BASE_HI
+    |     lwzx TMP2, RC, BASE_HI
+    |      lwzux CARG1, RB, BASE
+    |     checknum cr0, TMP1
+    |      lwzux CARG2, RC, BASE
+    |     checknum cr1, TMP2
+    |   .else
+    |     lwzux CARG1, RB, BASE
+    |     lwzux CARG3, RC, BASE
+    |      lwz CARG2, 4(RB)
+    |     checknum cr0, CARG1
+    |      lwz CARG4, 4(RC)
+    |     checknum cr1, CARG3
+    |   .endif
     ||  break;
     ||}
     |  bne >5
     |  bne cr1, >5
-    |.if "intins" == "intmod"
-    |  mr CARG1, CARG2
-    |  mr CARG2, CARG4
-    |.endif
+    |.if ENDIAN_LE
+    |  intins CARG1, CARG1, CARG2
+    |.else
+    |  .if "intins" == "intmod"
+    |    mr CARG1, CARG2
+    |    mr CARG2, CARG4
+    |  .endif
     |  intins CARG1, CARG2, CARG4
-    |  bso >4
-    |1:
+    |.endif
+    |  ins_arithfallback bso
     |  ins_next1
-    |  stwux TISNUM, RA, BASE
-    |  stw CARG1, 4(RA)
+    |  stwx TISNUM, BASE_HI, RA
+    |  stwx CARG1, BASE_LO, RA
     |2:
     |  ins_next2
-    |4:  // Overflow.
-    |  checkov TMP0, <1			// Ignore unrelated overflow.
-    |  ins_arithfallback b
     |5:  // FP variant.
     |.if FPU
     ||if (vk == 1) {
@@ -4124,8 +4550,11 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_POW:
     |  // NYI: (partial) integer arithmetic.
-    |  lwzx CARG1, BASE, RB
-    |  lwzx CARG3, BASE, RC
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
+    |  lwzx CARG1, BASE_HI, RB
+    |  lwzx CARG3, BASE_HI, RC
     |.if FPU
     |   lfdx FARG1, BASE, RB
     |   lfdx FARG2, BASE, RC
@@ -4164,6 +4593,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  // Returns NULL (finished) or TValue * (metamethod).
     |  cmplwi CRET1, 0
     |   lp BASE, L->base
+    |   addi BASEP4, BASE, 4
     |  bne ->vmeta_binop
     |  ins_next1
     |.if FPU
@@ -4182,42 +4612,46 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
   case BC_KSTR:
     |  // RA = dst*8, RD = str_const*8 (~)
+    |  addi BASEP4, BASE, 4
     |  srwi TMP1, RD, 1
     |  subfic TMP1, TMP1, -4
     |  ins_next1
     |  lwzx TMP0, KBASE, TMP1		// KBASE-4-str_const*4
     |  li TMP2, LJ_TSTR
-    |  stwux TMP2, RA, BASE
-    |  stw TMP0, 4(RA)
+    |  stwx TMP2, BASE_HI, RA
+    |  stwx TMP0, BASE_LO, RA
     |  ins_next2
     break;
   case BC_KCDATA:
     |.if FFI
     |  // RA = dst*8, RD = cdata_const*8 (~)
+    |  addi BASEP4, BASE, 4
     |  srwi TMP1, RD, 1
     |  subfic TMP1, TMP1, -4
     |  ins_next1
     |  lwzx TMP0, KBASE, TMP1		// KBASE-4-cdata_const*4
     |  li TMP2, LJ_TCDATA
-    |  stwux TMP2, RA, BASE
-    |  stw TMP0, 4(RA)
+    |  stwx TMP2, BASE_HI, RA
+    |  stwx TMP0, BASE_LO, RA
     |  ins_next2
     |.endif
     break;
   case BC_KSHORT:
     |  // RA = dst*8, RD = int16_literal*8
+    |  addi BASEP4, BASE, 4
     |.if DUALNUM
     |  slwi RD, RD, 13
     |  srawi RD, RD, 16
     |  ins_next1
-    |   stwux TISNUM, RA, BASE
-    |   stw RD, 4(RA)
+    |   stwx TISNUM, BASE_HI, RA
+    |   stwx RD, BASE_LO, RA
     |  ins_next2
     |.else
     |  // The soft-float approach is faster.
     |  slwi RD, RD, 13
     |  srawi TMP1, RD, 31
     |  xor TMP2, TMP1, RD
+    |  .gpr64 extsw RD, RD
     |  sub TMP2, TMP2, TMP1		// TMP2 = abs(x)
     |  cntlzw TMP3, TMP2
     |  subfic TMP1, TMP3, 0x40d		// TMP1 = exponent-1
@@ -4229,8 +4663,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   add RD, RD, TMP1		// hi = hi + exponent-1
     |    and RD, RD, TMP0		// hi = x == 0 ? 0 : hi
     |  ins_next1
-    |    stwux RD, RA, BASE
-    |    stw ZERO, 4(RA)
+    |    stwx RD, BASE_HI, RA
+    |    stwx ZERO, BASE_LO, RA
     |  ins_next2
     |.endif
     break;
@@ -4250,18 +4684,24 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_KPRI:
     |  // RA = dst*8, RD = primitive_type*8 (~)
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
     |  srwi TMP1, RD, 3
     |  not TMP0, TMP1
     |  ins_next1
-    |  stwx TMP0, BASE, RA
+    |  stwx TMP0, BASE_HI, RA
     |  ins_next2
     break;
   case BC_KNIL:
     |  // RA = base*8, RD = end*8
-    |  stwx TISNIL, BASE, RA
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
+    |  stwx TISNIL, BASE_HI, RA
     |   addi RA, RA, 8
     |1:
-    |  stwx TISNIL, BASE, RA
+    |  stwx TISNIL, BASE_HI, RA
     |  cmpw RA, RD
     |   addi RA, RA, 8
     |  blt <1
@@ -4305,7 +4745,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   lwz CARG2, UPVAL:RB->v
     |  andix. TMP3, TMP3, LJ_GC_BLACK	// isblack(uv)
     |    lbz TMP0, UPVAL:RB->closed
-    |   lwz TMP2, 0(RD)
+    |   lwz TMP2, WORD_HI(RD)
     |.if FPU
     |   stfd f0, 0(CARG2)
     |.else
@@ -4313,7 +4753,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   stw CARG3, 4(CARG2)
     |.endif
     |    cmplwi cr1, TMP0, 0
-    |   lwz TMP1, 4(RD)
+    |   lwz TMP1, WORD_LO(RD)
     |  cror 4*cr0+eq, 4*cr0+eq, 4*cr1+eq
     |   subi TMP2, TMP2, (LJ_TNUMX+1)
     |  bne >2				// Upvalue is closed and black?
@@ -4346,8 +4786,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   lbz TMP3, STR:TMP1->marked
     |   lbz TMP2, UPVAL:RB->closed
     |   li TMP0, LJ_TSTR
-    |   stw STR:TMP1, 4(CARG2)
-    |   stw TMP0, 0(CARG2)
+    |   stw STR:TMP1, WORD_LO(CARG2)
+    |   stw TMP0, WORD_HI(CARG2)
     |  bne >2
     |1:
     |  ins_next
@@ -4394,7 +4834,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  lwzx UPVAL:RB, LFUNC:RB, RA
     |  ins_next1
     |  lwz TMP1, UPVAL:RB->v
-    |  stw TMP0, 0(TMP1)
+    |  stw TMP0, WORD_HI(TMP1)
     |  ins_next2
     break;
 
@@ -4409,6 +4849,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   add CARG2, BASE, RA
     |  bl extern lj_func_closeuv	// (lua_State *L, TValue *level)
     |  lp BASE, L->base
+    |  addi BASEP4, BASE, 4
     |1:
     |  ins_next
     break;
@@ -4427,8 +4868,9 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  // Returns GCfuncL *.
     |  lp BASE, L->base
     |   li TMP0, LJ_TFUNC
-    |  stwux TMP0, RA, BASE
-    |  stw LFUNC:CRET1, 4(RA)
+    |  addi BASEP4, BASE, 4
+    |  stwx TMP0, BASE_HI, RA
+    |  stwx LFUNC:CRET1, BASE_LO, RA
     |  ins_next
     break;
 
@@ -4461,8 +4903,9 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     }
     |  lp BASE, L->base
     |   li TMP0, LJ_TTAB
-    |  stwux TMP0, RA, BASE
-    |  stw TAB:CRET1, 4(RA)
+    |  addi BASEP4, BASE, 4
+    |  stwx TMP0, BASE_HI, RA
+    |  stwx TAB:CRET1, BASE_LO, RA
     |  ins_next
     if (op == BC_TNEW) {
       |3:
@@ -4495,13 +4938,14 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
   case BC_TGETV:
     |  // RA = dst*8, RB = table*8, RC = key*8
-    |  lwzux CARG1, RB, BASE
-    |  lwzux CARG2, RC, BASE
-    |   lwz TAB:RB, 4(RB)
+    |  addi BASEP4, BASE, 4
+    |  lwzx CARG1, BASE_HI, RB
+    |  lwzx CARG2, BASE_HI, RC
+    |   lwzx TAB:RB, BASE_LO, RB
     |.if DUALNUM
-    |   lwz RC, 4(RC)
+    |   lwzx RC, BASE_LO, RC
     |.else
-    |   lfd f0, 0(RC)
+    |   lfdx f0, BASE, RC
     |.endif
     |  checktab CARG1
     |   checknum cr1, CARG2
@@ -4528,9 +4972,14 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   slwi TMP2, TMP2, 3
     |.endif
     |  ble ->vmeta_tgetv		// Integer key and in array part?
-    |  lwzx TMP0, TMP1, TMP2
     |.if FPU
-    |   lfdx f14, TMP1, TMP2
+    |  .if ENDIAN_LE
+    |    lfdux f14, TMP1, TMP2
+    |    lwz TMP0, WORD_HI(TMP1)
+    |  .else
+    |    lwzx TMP0, TMP1, TMP2
+    |    lfdx f14, TMP1, TMP2
+    |  .endif
     |.else
     |   lwzux SAVE0, TMP1, TMP2
     |   lwz SAVE1, 4(TMP1)
@@ -4558,21 +5007,23 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |5:
     |  checkstr CARG2; bne ->vmeta_tgetv
     |.if not DUALNUM
-    |  lwz STR:RC, 4(RC)
+    |  lwzx STR:RC, BASE_LO, RC
     |.endif
     |  b ->BC_TGETS_Z			// String key?
     break;
   case BC_TGETS:
     |  // RA = dst*8, RB = table*8, RC = str_const*8 (~)
-    |  lwzux CARG1, RB, BASE
+    |  addi BASEP4, BASE, 4
+    |  lwzx CARG1, BASE_HI, RB
     |   srwi TMP1, RC, 1
-    |    lwz TAB:RB, 4(RB)
+    |    lwzx TAB:RB, BASE_LO, RB
     |   subfic TMP1, TMP1, -4
     |  checktab CARG1
     |   lwzx STR:RC, KBASE, TMP1	// KBASE-4-str_const*4
     |  bne ->vmeta_tgets1
     |->BC_TGETS_Z:
     |  // TAB:RB = GCtab *, STR:RC = GCstr *, RA = dst*8
+    |  addi BASEP4, BASE, 4
     |  lwz TMP0, TAB:RB->hmask
     |  lwz TMP1, STR:RC->sid
     |  lwz NODE:TMP2, TAB:RB->node
@@ -4582,16 +5033,16 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  sub TMP1, TMP0, TMP1
     |  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
     |1:
-    |  lwz CARG1, NODE:TMP2->key
-    |   lwz TMP0, 4+offsetof(Node, key)(NODE:TMP2)
-    |    lwz CARG2, NODE:TMP2->val
-    |     lwz TMP1, 4+offsetof(Node, val)(NODE:TMP2)
+    |  lwz CARG1, WORD_HI+offsetof(Node, key)(NODE:TMP2)
+    |   lwz TMP0, WORD_LO+offsetof(Node, key)(NODE:TMP2)
+    |    lwz CARG2, WORD_HI+offsetof(Node, val)(NODE:TMP2)
+    |     lwz TMP1, WORD_LO+offsetof(Node, val)(NODE:TMP2)
     |  checkstr CARG1; bne >4
     |   cmpw TMP0, STR:RC; bne >4
     |    checknil CARG2; beq >5		// Key found, but nil value?
     |3:
-    |    stwux CARG2, RA, BASE
-    |     stw TMP1, 4(RA)
+    |    stwx CARG2, BASE_HI, RA
+    |     stwx TMP1, BASE_LO, RA
     |  ins_next
     |
     |4:  // Follow hash chain.
@@ -4612,16 +5063,22 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_TGETB:
     |  // RA = dst*8, RB = table*8, RC = index*8
-    |  lwzux CARG1, RB, BASE
+    |  addi BASEP4, BASE, 4
+    |  lwzx CARG1, BASE_HI, RB
     |   srwi TMP0, RC, 3
-    |   lwz TAB:RB, 4(RB)
+    |   lwzx TAB:RB, BASE_LO, RB
     |  checktab CARG1; bne ->vmeta_tgetb
     |  lwz TMP1, TAB:RB->asize
     |   lwz TMP2, TAB:RB->array
     |  cmplw TMP0, TMP1; bge ->vmeta_tgetb
     |.if FPU
-    |  lwzx TMP1, TMP2, RC
-    |   lfdx f0, TMP2, RC
+    |  .if ENDIAN_LE
+    |    lfdux f0, TMP2, RC
+    |    lwz TMP1, WORD_HI(TMP2)
+    |  .else
+    |    lwzx TMP1, TMP2, RC
+    |    lfdx f0, TMP2, RC
+    |  .endif
     |.else
     |  lwzux TMP1, TMP2, RC
     |   lwz TMP3, 4(TMP2)
@@ -4648,12 +5105,11 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_TGETR:
     |  // RA = dst*8, RB = table*8, RC = key*8
-    |  add RB, BASE, RB
-    |  lwz TAB:CARG1, 4(RB)
+    |  addi BASEP4, BASE, 4
+    |  lwzx TAB:CARG1, BASE_LO, RB
     |.if DUALNUM
-    |  add RC, BASE, RC
     |  lwz TMP0, TAB:CARG1->asize
-    |  lwz CARG2, 4(RC)
+    |  lwzx CARG2, BASE_LO, RC
     |   lwz TMP1, TAB:CARG1->array
     |.else
     |  lfdx f0, BASE, RC
@@ -4683,13 +5139,14 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 
   case BC_TSETV:
     |  // RA = src*8, RB = table*8, RC = key*8
-    |  lwzux CARG1, RB, BASE
-    |  lwzux CARG2, RC, BASE
-    |   lwz TAB:RB, 4(RB)
+    |  addi BASEP4, BASE, 4
+    |  lwzx CARG1, BASE_HI, RB
+    |  lwzx CARG2, BASE_HI, RC
+    |   lwzx TAB:RB, BASE_LO, RB
     |.if DUALNUM
-    |   lwz RC, 4(RC)
+    |   lwzx RC, BASE_LO, RC
     |.else
-    |   lfd f0, 0(RC)
+    |   lfdx f0, BASE, RC
     |.endif
     |  checktab CARG1
     |   checknum cr1, CARG2
@@ -4716,7 +5173,12 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   slwi TMP0, TMP2, 3
     |.endif
     |  ble ->vmeta_tsetv		// Integer key and in array part?
+    |  .if ENDIAN_LE
+    |   addi TMP2, TMP1, 4
+    |   lwzx TMP2, TMP2, TMP0
+    |  .else
     |   lwzx TMP2, TMP1, TMP0
+    |  .endif
     |  lbz TMP3, TAB:RB->marked
     |.if FPU
     |    lfdx f14, BASE, RA
@@ -4750,7 +5212,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |5:
     |  checkstr CARG2; bne ->vmeta_tsetv
     |.if not DUALNUM
-    |  lwz STR:RC, 4(RC)
+    |  lwzx STR:RC, BASE_LO, RC
     |.endif
     |  b ->BC_TSETS_Z			// String key?
     |
@@ -4760,9 +5222,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_TSETS:
     |  // RA = src*8, RB = table*8, RC = str_const*8 (~)
-    |  lwzux CARG1, RB, BASE
+    |  addi BASEP4, BASE, 4
+    |  lwzx CARG1, BASE_HI, RB
     |   srwi TMP1, RC, 1
-    |    lwz TAB:RB, 4(RB)
+    |    lwzx TAB:RB, BASE_LO, RB
     |   subfic TMP1, TMP1, -4
     |  checktab CARG1
     |   lwzx STR:RC, KBASE, TMP1	// KBASE-4-str_const*4
@@ -4787,9 +5250,9 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |    lbz TMP3, TAB:RB->marked
     |  add NODE:TMP2, NODE:TMP2, TMP1	// node = tab->node + (idx*32-idx*8)
     |1:
-    |  lwz CARG1, NODE:TMP2->key
-    |   lwz TMP0, 4+offsetof(Node, key)(NODE:TMP2)
-    |    lwz CARG2, NODE:TMP2->val
+    |  lwz CARG1, WORD_HI+offsetof(Node, key)(NODE:TMP2)
+    |   lwz TMP0, WORD_LO+offsetof(Node, key)(NODE:TMP2)
+    |    lwz CARG2, WORD_HI+offsetof(Node, val)(NODE:TMP2)
     |     lwz NODE:TMP1, NODE:TMP2->next
     |  checkstr CARG1; bne >5
     |   cmpw TMP0, STR:RC; bne >5
@@ -4834,9 +5297,9 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  beq ->vmeta_tsets		// 'no __newindex' flag NOT set: check.
     |6:
     |  li TMP0, LJ_TSTR
-    |   stw STR:RC, 4(CARG3)
+    |   stw STR:RC, WORD_LO(CARG3)
     |   mr CARG2, TAB:RB
-    |  stw TMP0, 0(CARG3)
+    |  stw TMP0, WORD_HI(CARG3)
     |  bl extern lj_tab_newkey		// (lua_State *L, GCtab *t, TValue *k)
     |  // Returns TValue *.
     |  lp BASE, L->base
@@ -4846,6 +5309,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  stw SAVE0, 0(CRET1)
     |  stw SAVE1, 4(CRET1)
     |.endif
+    |   addi BASEP4, BASE, 4
     |  b <3				// No 2nd write barrier needed.
     |
     |7:  // Possible table write barrier for the value. Skip valiswhite check.
@@ -4854,9 +5318,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_TSETB:
     |  // RA = src*8, RB = table*8, RC = index*8
-    |  lwzux CARG1, RB, BASE
+    |  addi BASEP4, BASE, 4
+    |  lwzx CARG1, BASE_HI, RB
     |   srwi TMP0, RC, 3
-    |   lwz TAB:RB, 4(RB)
+    |   lwzx TAB:RB, BASE_LO, RB
     |  checktab CARG1; bne ->vmeta_tsetb
     |  lwz TMP1, TAB:RB->asize
     |   lwz TMP2, TAB:RB->array
@@ -4870,7 +5335,12 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |   lwz SAVE1, 4(CARG2)
     |.endif
     |  bge ->vmeta_tsetb
-    |  lwzx TMP1, TMP2, RC
+    |  .if ENDIAN_LE
+    |    addi TMP1, TMP2, 4
+    |    lwzx TMP1, TMP1, RC
+    |  .else
+    |    lwzx TMP1, TMP2, RC
+    |  .endif
     |  checknil TMP1; beq >5
     |1:
     |  andix. TMP0, TMP3, LJ_GC_BLACK	// isblack(table)
@@ -4899,13 +5369,12 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_TSETR:
     |  // RA = dst*8, RB = table*8, RC = key*8
-    |  add RB, BASE, RB
-    |  lwz TAB:CARG2, 4(RB)
+    |  addi BASEP4, BASE, 4
+    |  lwzx TAB:CARG2, BASE_LO, RB
     |.if DUALNUM
-    |  add RC, BASE, RC
     |    lbz TMP3, TAB:CARG2->marked
     |  lwz TMP0, TAB:CARG2->asize
-    |  lwz CARG3, 4(RC)
+    |  lwzx CARG3, BASE_LO, RC
     |   lwz TMP1, TAB:CARG2->array
     |.else
     |  lfdx f0, BASE, RC
@@ -4946,9 +5415,9 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  add RA, BASE, RA
     |1:
     |   add TMP3, KBASE, RD
-    |  lwz TAB:CARG2, -4(RA)		// Guaranteed to be a table.
+    |  lwz TAB:CARG2, WORD_LO-8(RA)	// Guaranteed to be a table.
     |    addic. TMP0, MULTRES, -8
-    |   lwz TMP3, 4(TMP3)		// Integer constant is in lo-word.
+    |   lwz TMP3, WORD_LO(TMP3)		// Integer constant is in lo-word.
     |    srwi CARG3, TMP0, 3
     |    beq >4				// Nothing to copy?
     |  add CARG3, CARG3, TMP3
@@ -5007,8 +5476,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_CALL:
     |  // RA = base*8, (RB = (nresults+1)*8,) RC = (nargs+1)*8
     |  mr TMP2, BASE
-    |  lwzux TMP0, BASE, RA
-    |   lwz LFUNC:RB, 4(BASE)
+    |  lwzux2 TMP0, LFUNC:RB, BASE, RA
     |    subi NARGS8:RC, NARGS8:RC, 8
     |   addi BASE, BASE, 8
     |  checkfunc TMP0; bne ->vmeta_call
@@ -5022,8 +5490,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     break;
   case BC_CALLT:
     |  // RA = base*8, (RB = 0,) RC = (nargs+1)*8
-    |  lwzux TMP0, RA, BASE
-    |   lwz LFUNC:RB, 4(RA)
+    |  lwzux2 TMP0, LFUNC:RB, RA, BASE
     |    subi NARGS8:RC, NARGS8:RC, 8
     |    lwz TMP1, FRAME_PC(BASE)
     |  checkfunc TMP0
@@ -5086,8 +5553,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  // RA = base*8, (RB = (nresults+1)*8, RC = (nargs+1)*8 ((2+1)*8))
     |  mr TMP2, BASE
     |  add BASE, BASE, RA
-    |  lwz TMP1, -24(BASE)
-    |   lwz LFUNC:RB, -20(BASE)
+    |  lwz TMP1, WORD_HI-24(BASE)
+    |   lwz LFUNC:RB, WORD_LO-24(BASE)
     |.if FPU
     |    lfd f1, -8(BASE)
     |    lfd f0, -16(BASE)
@@ -5097,8 +5564,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |    lwz CARG3, -16(BASE)
     |    lwz CARG4, -12(BASE)
     |.endif
-    |  stw TMP1, 0(BASE)		// Copy callable.
-    |   stw LFUNC:RB, 4(BASE)
+    |  stw TMP1, WORD_HI(BASE)		// Copy callable.
+    |   stw LFUNC:RB, WORD_LO(BASE)
     |  checkfunc TMP1
     |     li NARGS8:RC, 16		// Iterators get 2 arguments.
     |.if FPU
@@ -5121,8 +5588,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.endif
     |->vm_IITERN:
     |  add RA, BASE, RA
-    |  lwz TAB:RB, -12(RA)
-    |  lwz RC, -4(RA)			// Get index from control var.
+    |  lwz TAB:RB, WORD_LO-16(RA)
+    |  lwz RC, WORD_LO-8(RA)		// Get index from control var.
     |  lwz TMP0, TAB:RB->asize
     |  lwz TMP1, TAB:RB->array
     |   addi PC, PC, 4
@@ -5130,10 +5597,11 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  cmplw RC, TMP0
     |   slwi TMP3, RC, 3
     |  bge >5				// Index points after array part?
-    |  lwzx TMP2, TMP1, TMP3
     |.if FPU
-    |   lfdx f0, TMP1, TMP3
+    |  lfdux f0, TMP3, TMP1
+    |   lwz TMP2, WORD_HI(TMP3)
     |.else
+    |  lwzx TMP2, TMP1, TMP3
     |   lwzux CARG1, TMP3, TMP1
     |   lwz CARG2, 4(TMP3)
     |.endif
@@ -5141,8 +5609,8 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |     lwz INS, -4(PC)
     |  beq >4
     |.if DUALNUM
-    |   stw RC, 4(RA)
-    |   stw TISNUM, 0(RA)
+    |   stw RC, WORD_LO(RA)
+    |   stw TISNUM, WORD_HI(RA)
     |.else
     |   tonum_u f1, RC
     |.endif
@@ -5155,7 +5623,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  stw CARG2, 12(RA)
     |.endif
     |     decode_RD4 TMP1, INS
-    |    stw RC, -4(RA)			// Update control var.
+    |    stw RC, WORD_LO-8(RA)		// Update control var.
     |     add PC, TMP1, TMP3
     |.if not DUALNUM
     |   stfd f1, 0(RA)
@@ -5177,15 +5645,15 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bgty <3
     |   slwi RB, RC, 3
     |   sub TMP3, TMP3, RB
-    |  lwzx RB, TMP2, TMP3
     |.if FPU
-    |  lfdx f0, TMP2, TMP3
+    |  lfdux f0, TMP3, TMP2
+    |  lwz RB, WORD_HI(TMP3)
     |.else
     |  add CARG3, TMP2, TMP3
     |  lwz CARG1, 0(CARG3)
     |  lwz CARG2, 4(CARG3)
-    |.endif
     |   add NODE:TMP3, TMP2, TMP3
+    |.endif
     |  checknil RB
     |     lwz INS, -4(PC)
     |  beq >7
@@ -5212,7 +5680,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |.endif
     |    addi RC, RC, 1
     |     add PC, TMP1, TMP2
-    |    stw RC, -4(RA)			// Update control var.
+    |    stw RC, WORD_LO-8(RA)		// Update control var.
     |  b <3
     |
     |7:  // Skip holes in hash part.
@@ -5223,10 +5691,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_ISNEXT:
     |  // RA = base*8, RD = target (points to ITERN)
     |  add RA, BASE, RA
-    |  lwz TMP0, -24(RA)
-    |  lwz CFUNC:TMP1, -20(RA)
-    |   lwz TMP2, -16(RA)
-    |    lwz TMP3, -8(RA)
+    |  lwz TMP0, WORD_HI-24(RA)
+    |  lwz CFUNC:TMP1, WORD_LO-24(RA)
+    |   lwz TMP2, WORD_HI-16(RA)
+    |    lwz TMP3, WORD_HI-8(RA)
     |   cmpwi cr0, TMP2, LJ_TTAB
     |  cmpwi cr1, TMP0, LJ_TFUNC
     |    cmpwi cr6, TMP3, LJ_TNIL
@@ -5240,18 +5708,26 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bne cr0, >5
     |  lus TMP1, (LJ_KEYINDEX >> 16)
     |  ori TMP1, TMP1, (LJ_KEYINDEX & 0xffff)
-    |  stw ZERO, -4(RA)			// Initialize control var.
-    |  stw TMP1, -8(RA)
+    |  stw ZERO, WORD_LO-8(RA)          // Initialize control var.
+    |  stw TMP1, WORD_HI-8(RA)
     |    addis PC, TMP3, -(BCBIAS_J*4 >> 16)
     |1:
     |  ins_next
     |5:  // Despecialize bytecode if any of the checks fail.
     |  li TMP0, BC_JMP
     |   li TMP1, BC_ITERC
+    |  .if ENDIAN_LE
+    |  stb TMP0, -4(PC)
+    |  .else
     |  stb TMP0, -1(PC)
+    |  .endif
     |    addis PC, TMP3, -(BCBIAS_J*4 >> 16)
+    |  .if ENDIAN_LE
+    |   stb TMP1, 0(PC)
+    |  .else
     |  // NYI on big-endian: unpatch JLOOP.
     |   stb TMP1, 3(PC)
+    |  .endif
     |  b <1
     break;
 
@@ -5295,7 +5771,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |    addi RA, RA, 8
     |   blt cr1, <1			// More vararg slots?
     |2:  // Fill up remainder with nil.
-    |  stw TISNIL, 0(RA)
+    |  stw TISNIL, WORD_HI(RA)
     |  cmplw RA, TMP2
     |   addi RA, RA, 8
     |  blt <2
@@ -5342,6 +5818,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  add RA, BASE, RA
     |  add RC, BASE, SAVE0
     |  subi TMP3, BASE, 8
+    |  addi BASEP4, BASE, 4
     |  b <6
     break;
 
@@ -5414,13 +5891,14 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bgt >6
     |   sub BASE, TMP2, RA
     |  lwz LFUNC:TMP1, FRAME_FUNC(BASE)
+    |  addi BASEP4, BASE, 4
     |  ins_next1
     |  lwz TMP1, LFUNC:TMP1->pc
     |  lwz KBASE, PC2PROTO(k)(TMP1)
     |  ins_next2
     |
     |6:  // Fill up results with nil.
-    |  subi TMP1, RD, 8
+    |  addi TMP1, RD, WORD_HI-8
     |   addi RD, RD, 8
     |  stwx TISNIL, TMP2, TMP1
     |  b <5
@@ -5463,13 +5941,14 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  bgt >6
     |   sub BASE, TMP2, RA
     |  lwz LFUNC:TMP1, FRAME_FUNC(BASE)
+    |  addi BASEP4, BASE, 4
     |  ins_next1
     |  lwz TMP1, LFUNC:TMP1->pc
     |  lwz KBASE, PC2PROTO(k)(TMP1)
     |  ins_next2
     |
     |6:  // Fill up results with nil.
-    |  subi TMP1, RD, 8
+    |  addi TMP1, RD, WORD_HI-8
     |   addi RD, RD, 8
     |  stwx TISNIL, TMP2, TMP1
     |  b <5
@@ -5495,11 +5974,13 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     vk = (op == BC_IFORL || op == BC_JFORL);
     |.if DUALNUM
     |  // Integer loop.
-    |  lwzux TMP1, RA, BASE
-    |   lwz CARG1, FORL_IDX*8+4(RA)
+    |  lwzux2 TMP1, CARG1, RA, BASE
+    if (vk) {
+      |  mtxer ZERO
+    }
     |  cmplw cr0, TMP1, TISNUM
     if (vk) {
-      |   lwz CARG3, FORL_STEP*8+4(RA)
+      |   lwz CARG3, FORL_STEP*8+WORD_LO(RA)
       |  bne >9
       |.if GPR64
       |  // Need to check overflow for (a<<32) + (b<<32).
@@ -5511,15 +5992,15 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
       |  addo. CARG1, CARG1, CARG3
       |.endif
       |    cmpwi cr6, CARG3, 0
-      |   lwz CARG2, FORL_STOP*8+4(RA)
-      |  bso >6
+      |   lwz CARG2, FORL_STOP*8+WORD_LO(RA)
+      |  bso >2
       |4:
-      |  stw CARG1, FORL_IDX*8+4(RA)
+      |  stw CARG1, FORL_IDX*8+WORD_LO(RA)
     } else {
-      |  lwz SAVE0, FORL_STEP*8(RA)
-      |   lwz CARG3, FORL_STEP*8+4(RA)
-      |  lwz TMP2, FORL_STOP*8(RA)
-      |   lwz CARG2, FORL_STOP*8+4(RA)
+      |  lwz SAVE0, FORL_STEP*8+WORD_HI(RA)
+      |   lwz CARG3, FORL_STEP*8+WORD_LO(RA)
+      |  lwz TMP2, FORL_STOP*8+WORD_HI(RA)
+      |   lwz CARG2, FORL_STOP*8+WORD_LO(RA)
       |  cmplw cr7, SAVE0, TISNUM
       |  cmplw cr1, TMP2, TISNUM
       |  crand 4*cr0+eq, 4*cr0+eq, 4*cr7+eq
@@ -5530,11 +6011,11 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |    blt cr6, >5
     |  cmpw CARG1, CARG2
     |1:
-    |   stw TISNUM, FORL_EXT*8(RA)
+    |   stw TISNUM, FORL_EXT*8+WORD_HI(RA)
     if (op != BC_JFORL) {
       |  srwi RD, RD, 1
     }
-    |   stw CARG1, FORL_EXT*8+4(RA)
+    |   stw CARG1, FORL_EXT*8+WORD_LO(RA)
     if (op != BC_JFORL) {
       |  add RD, PC, RD
     }
@@ -5554,11 +6035,6 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |5:  // Invert check for negative step.
     |  cmpw CARG2, CARG1
     |  b <1
-    if (vk) {
-      |6:  // Potential overflow.
-      |  checkov TMP0, <4		// Ignore unrelated overflow.
-      |  b <2
-    }
     |.endif
     if (vk) {
       |.if DUALNUM
@@ -5588,12 +6064,18 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
       |  lwz CARG3, FORL_STOP*8(RA)
       |  lwz CARG4, FORL_STOP*8+4(RA)
       |.endif
-      |   lwz SAVE0, FORL_STEP*8(RA)
+      |   lwz SAVE0, FORL_STEP*8+WORD_HI(RA)
     } else {
       |.if DUALNUM
       |9:  // FP loop.
       |.else
+      |.if ENDIAN_LE
+      |  addi BASEP4, BASE, 4
+      |  lwzx TMP1, RA, BASE_LO
+      |  add RA, RA, BASE
+      |.else
       |  lwzux TMP1, RA, BASE
+      |.endif
       |  lwz SAVE0, FORL_STEP*8(RA)
       |  lwz TMP2, FORL_STOP*8(RA)
       |  cmplw cr0, TMP1, TISNUM
@@ -5696,17 +6178,16 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
 #endif
   case BC_IITERL:
     |  // RA = base*8, RD = target
-    |  lwzux TMP1, RA, BASE
-    |   lwz TMP2, 4(RA)
+    |  lwzux2 TMP1, TMP2, RA, BASE
     |  checknil TMP1; beq >1		// Stop if iterator returned nil.
     if (op == BC_JITERL) {
-      |  stw TMP1, -8(RA)
-      |   stw TMP2, -4(RA)
+      |  stw TMP1, WORD_HI-8(RA)
+      |   stw TMP2, WORD_LO-8(RA)
       |  b =>BC_JLOOP
     } else {
       |  branch_RD			// Otherwise save control var + branch.
-      |  stw TMP1, -8(RA)
-      |   stw TMP2, -4(RA)
+      |  stw TMP1, WORD_HI-8(RA)
+      |   stw TMP2, WORD_LO-8(RA)
     }
     |1:
     |  ins_next
@@ -5735,7 +6216,7 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  // Traces on PPC don't store the trace number, so use 0.
     |   stw ZERO, DISPATCH_GL(vmstate)(DISPATCH)
     |  lwzx TRACE:TMP2, TMP1, RD
-    |  clrso TMP1
+    |  mtxer ZERO
     |  lp TMP2, TRACE:TMP2->mcode
     |   stw BASE, DISPATCH_GL(jit_base)(DISPATCH)
     |  mtctr TMP2
@@ -5787,7 +6268,10 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     }
     |
     |3:  // Clear missing parameters.
-    |  stwx TISNIL, BASE, NARGS8:RC
+    |.if ENDIAN_LE
+    |  addi BASEP4, BASE, 4
+    |.endif
+    |  stwx TISNIL, BASE_HI, NARGS8:RC
     |  addi NARGS8:RC, NARGS8:RC, 8
     |  b <2
     break;
@@ -5804,11 +6288,11 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  lwz TMP2, L->maxstack
     |   add TMP1, BASE, RC
     |  add TMP0, RA, RC
-    |   stw LFUNC:RB, 4(TMP1)		// Store copy of LFUNC.
+    |   stw LFUNC:RB, WORD_LO(TMP1)	// Store copy of LFUNC.
     |   addi TMP3, RC, 8+FRAME_VARG
     |    lwz KBASE, -4+PC2PROTO(k)(PC)
     |  cmplw TMP0, TMP2
-    |   stw TMP3, 0(TMP1)		// Store delta + FRAME_VARG.
+    |   stw TMP3, WORD_HI(TMP1)		// Store delta + FRAME_VARG.
     |  bge ->vm_growstack_l
     |  lbz TMP2, -4+PC2PROTO(numparams)(PC)
     |   mr RA, BASE
@@ -5819,18 +6303,19 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
     |  beq >3
     |1:
     |  cmplw RA, RC			// Less args than parameters?
-    |   lwz TMP0, 0(RA)
-    |   lwz TMP3, 4(RA)
+    |   lwz TMP0, WORD_HI(RA)
+    |   lwz TMP3, WORD_LO(RA)
     |  bge >4
-    |    stw TISNIL, 0(RA)		// Clear old fixarg slot (help the GC).
+    |    stw TISNIL, WORD_HI(RA)	// Clear old fixarg slot (help the GC).
     |    addi RA, RA, 8
     |2:
     |  addic. TMP2, TMP2, -1
-    |   stw TMP0, 8(TMP1)
-    |   stw TMP3, 12(TMP1)
+    |   stw TMP0, WORD_HI+8(TMP1)
+    |   stw TMP3, WORD_LO+8(TMP1)
     |    addi TMP1, TMP1, 8
     |  bne <1
     |3:
+    |  addi BASEP4, BASE, 4
     |  ins_next2
     |
     |4:  // Clear missing parameters.
@@ -5842,35 +6327,35 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_FUNCCW:
     |  // BASE = new base, RA = BASE+framesize*8, RB = CFUNC, RC = nargs*8
     if (op == BC_FUNCC) {
-      |  lp RD, CFUNC:RB->f
+      |  lp FUNCREG, CFUNC:RB->f
     } else {
-      |  lp RD, DISPATCH_GL(wrapf)(DISPATCH)
+      |  lp FUNCREG, DISPATCH_GL(wrapf)(DISPATCH)
     }
     |   add TMP1, RA, NARGS8:RC
     |   lwz TMP2, L->maxstack
-    |  .toc lp TMP3, 0(RD)
+    |  .opd lp TMP3, 0(FUNCREG)
     |    add RC, BASE, NARGS8:RC
     |   stp BASE, L->base
     |   cmplw TMP1, TMP2
     |    stp RC, L->top
     |     li_vmstate C
-    |.if TOC
+    |.if OPD
     |  mtctr TMP3
     |.else
-    |  mtctr RD
+    |  mtctr FUNCREG
     |.endif
     if (op == BC_FUNCCW) {
       |  lp CARG2, CFUNC:RB->f
     }
     |  mr CARG1, L
     |   bgt ->vm_growstack_c		// Need to grow stack.
-    |  .toc lp TOCREG, TOC_OFS(RD)
-    |  .tocenv lp ENVREG, ENV_OFS(RD)
+    |  .opd lp TOCREG, TOC_OFS(FUNCREG)
+    |  .opdenv lp ENVREG, ENV_OFS(FUNCREG)
     |     st_vmstate
     |  bctrl				// (lua_State *L [, lua_CFunction f])
+    |  .toc lp TOCREG, SAVE_TOC
     |  // Returns nresults.
     |  lp BASE, L->base
-    |  .toc ld TOCREG, SAVE_TOC
     |   slwi RD, CRET1, 3
     |  lp TMP1, L->top
     |    li_vmstate INTERP
@@ -5921,7 +6406,11 @@ static void emit_asm_debug(BuildCtx *ctx)
 	"\t.byte 0x1\n"
 	"\t.string \"\"\n"
 	"\t.uleb128 0x1\n"
+#if LJ_ARCH_PPC32ON64
+	"\t.sleb128 -8\n"
+#else
 	"\t.sleb128 -4\n"
+#endif
 	"\t.byte 65\n"
 	"\t.byte 0xc\n\t.uleb128 1\n\t.uleb128 0\n"
 	"\t.align 2\n"
@@ -5934,14 +6423,24 @@ static void emit_asm_debug(BuildCtx *ctx)
 	"\t.long .Lbegin\n"
 	"\t.long %d\n"
 	"\t.byte 0xe\n\t.uleb128 %d\n"
+#if LJ_ARCH_PPC32ON64
+	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -2\n"
+	"\t.byte 0x11\n\t.uleb128 70\n\t.sleb128 -1\n",
+#else
 	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
 	"\t.byte 0x5\n\t.uleb128 70\n\t.uleb128 55\n",
+#endif
 	fcofs, CFRAME_SIZE);
     for (i = 14; i <= 31; i++)
       fprintf(ctx->fp,
 	"\t.byte %d\n\t.uleb128 %d\n"
 	"\t.byte %d\n\t.uleb128 %d\n",
-	0x80+i, 37+(31-i), 0x80+32+i, 2+2*(31-i));
+#if LJ_ARCH_PPC32ON64
+	0x80+i, 19+(31-i), 0x80+32+i, 1+(31-i)
+#else
+	0x80+i, 37+(31-i), 0x80+32+i, 2+2*(31-i)
+#endif
+      );
     fprintf(ctx->fp,
 	"\t.align 2\n"
 	".LEFDE0:\n\n");
@@ -5957,8 +6456,12 @@ static void emit_asm_debug(BuildCtx *ctx)
 	"\t.long lj_vm_ffi_call\n"
 #endif
 	"\t.long %d\n"
+#if LJ_ARCH_PPC32ON64
+	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -2\n"
+#else
 	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
-	"\t.byte 0x8e\n\t.uleb128 2\n"
+#endif
+	"\t.byte 0x8e\n\t.uleb128 1\n"
 	"\t.byte 0xd\n\t.uleb128 0xe\n"
 	"\t.align 2\n"
 	".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
@@ -5973,7 +6476,11 @@ static void emit_asm_debug(BuildCtx *ctx)
 	"\t.byte 0x1\n"
 	"\t.string \"zPR\"\n"
 	"\t.uleb128 0x1\n"
+#if LJ_ARCH_PPC32ON64
+	"\t.sleb128 -8\n"
+#else
 	"\t.sleb128 -4\n"
+#endif
 	"\t.byte 65\n"
 	"\t.uleb128 6\n"			/* augmentation length */
 	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
@@ -5991,14 +6498,24 @@ static void emit_asm_debug(BuildCtx *ctx)
 	"\t.long %d\n"
 	"\t.uleb128 0\n"			/* augmentation length */
 	"\t.byte 0xe\n\t.uleb128 %d\n"
+#if LJ_ARCH_PPC32ON64
+	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -2\n"
+	"\t.byte 0x11\n\t.uleb128 70\n\t.sleb128 -1\n",
+#else
 	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
 	"\t.byte 0x5\n\t.uleb128 70\n\t.uleb128 55\n",
+#endif
 	fcofs, CFRAME_SIZE);
     for (i = 14; i <= 31; i++)
       fprintf(ctx->fp,
 	"\t.byte %d\n\t.uleb128 %d\n"
 	"\t.byte %d\n\t.uleb128 %d\n",
-	0x80+i, 37+(31-i), 0x80+32+i, 2+2*(31-i));
+#if LJ_ARCH_PPC32ON64
+	0x80+i, 19+(31-i), 0x80+32+i, 1+(31-i)
+#else
+	0x80+i, 37+(31-i), 0x80+32+i, 2+2*(31-i)
+#endif
+      );
     fprintf(ctx->fp,
 	"\t.align 2\n"
 	".LEFDE2:\n\n");
@@ -6026,8 +6543,12 @@ static void emit_asm_debug(BuildCtx *ctx)
 	"\t.long lj_vm_ffi_call-.\n"
 	"\t.long %d\n"
 	"\t.uleb128 0\n"			/* augmentation length */
+#if LJ_ARCH_PPC32ON64
+	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -2\n"
+#else
 	"\t.byte 0x11\n\t.uleb128 65\n\t.sleb128 -1\n"
-	"\t.byte 0x8e\n\t.uleb128 2\n"
+#endif
+	"\t.byte 0x8e\n\t.uleb128 1\n"
 	"\t.byte 0xd\n\t.uleb128 0xe\n"
 	"\t.align 2\n"
 	".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
diff --git a/lib/luajit2/src/vm_s390x.dasc b/lib/luajit2/src/vm_s390x.dasc
new file mode 100644
index 000000000..7f1a873fc
--- /dev/null
+++ b/lib/luajit2/src/vm_s390x.dasc
@@ -0,0 +1,4300 @@
+|// Low-level VM code for IBM z/Architecture (s390x) CPUs in LJ_GC64 mode.
+|// Bytecode interpreter, fast functions and helper functions.
+|// Copyright (C) 2005-2017 Mike Pall. See Copyright Notice in luajit.h
+|
+|// This assembly targets the instruction set available on z10 (and newer)
+|// machines.
+|
+|// ELF ABI registers:
+|// r0,r1       |                            | volatile |
+|// r2          | parameter and return value | volatile |
+|// r3-r5       | parameter                  | volatile |
+|// r6          | parameter                  | saved    |
+|// r7-r11      |                            | saved    |
+|// r12         | GOT pointer (needed?)      | saved    |
+|// r13         | literal pool (not needed)  | saved    |
+|// r14         | return address             | volatile |
+|// r15         | stack pointer              | saved    |
+|// f0,f2,f4,f6 | parameter and return value | volatile |
+|// f1,f3,f5,f7 |                            | volatile |
+|// f8-f15      |                            | saved    |
+|// ar0,ar1     | TLS                        | volatile |
+|// ar2-ar15    |                            | volatile |
+|
+|.arch s390x
+|.section code_op, code_sub
+|
+|.actionlist build_actionlist
+|.globals GLOB_
+|.globalnames globnames
+|.externnames extnames
+|
+|//-----------------------------------------------------------------------
+|
+|// Fixed register assignments for the interpreter, callee-saved.
+|.define KBASE,			r8	// Constants of current Lua function.
+|.define PC,			r9	// Next PC.
+|.define DISPATCH,		r10	// Opcode dispatch table.
+|.define ITYPE,			r11	// Temporary used for type information.
+|.define BASE,			r13	// Base of current Lua stack frame.
+|
+|// The following temporaries are not saved across C calls, except for RB.
+|.define RA,			r4	// Overlaps CARG3.
+|.define RB,			r7	// Must be callee-save.
+|.define RC,			r5	// Overlaps CARG4.
+|.define RD,			r6	// Overlaps CARG5.
+|
+|// Calling conventions. Also used as temporaries.
+|.define CARG1,			r2
+|.define CARG2,			r3
+|.define CARG3,			r4
+|.define CARG4,			r5
+|.define CARG5,			r6
+|
+|.define FARG1,			f0
+|.define FARG2,			f2
+|.define FARG3,			f4
+|.define FARG4,			f6
+|
+|.define CRET1,			r2
+|
+|.define TMPR0,			r0
+|.define TMPR1,			r1
+|.define OP,			r2
+|
+|// Stack layout while in interpreter. Must match with lj_frame.h.
+|.define CFRAME_SPACE,	240	// Delta for sp, 8 byte aligned.
+|
+|// Register save area.
+|.define SAVE_GPRS,	288(sp)	// Save area for r6-r15 (10*8 bytes).
+|.define SAVE_GPRS_P,	48(sp)  // Save area for r6-r15 (10*8 bytes) in prologue (before stack frame is allocated).
+|
+|// Argument save area.
+|.define SAVE_ERRF,	280(sp) // Argument 4, in r5.
+|.define SAVE_NRES,	272(sp)	// Argument 3, in r4. Size is 4-bytes.
+|.define SAVE_CFRAME,	264(sp)	// Argument 2, in r3.
+|.define SAVE_L,	256(sp)	// Argument 1, in r2.
+|.define RESERVED,	248(sp)	// Reserved for compiler use.
+|.define BACKCHAIN,	240(sp)	// <- sp entering interpreter.
+|
+|// Interpreter stack frame.
+|.define SAVE_FPR15,	232(sp)
+|.define SAVE_FPR14,	224(sp)
+|.define SAVE_FPR13,	216(sp)
+|.define SAVE_FPR12,	208(sp)
+|.define SAVE_FPR11,	200(sp)
+|.define SAVE_FPR10,	192(sp)
+|.define SAVE_FPR9,	184(sp)
+|.define SAVE_FPR8,	176(sp)
+|.define SAVE_PC,	168(sp)
+|.define SAVE_MULTRES,	160(sp)
+|.define SAVE_TMP,	160(sp) // Overlaps SAVE_MULTRES
+|.define SAVE_TMP_HI,	164(sp) // High 32-bits (to avoid SAVE_MULTRES).
+|
+|// Callee save area (allocated by interpreter).
+|.define CALLEESAVE,	000(sp) // <- sp in interpreter.
+|
+|.macro saveregs
+|  stmg r6, r15, SAVE_GPRS_P
+|  lay sp, -CFRAME_SPACE(sp)	// Allocate stack frame.
+|  std f8, SAVE_FPR8		// f8-f15 are callee-saved.
+|  std f9, SAVE_FPR9
+|  std f10, SAVE_FPR10
+|  std f11, SAVE_FPR11
+|  std f12, SAVE_FPR12
+|  std f13, SAVE_FPR13
+|  std f14, SAVE_FPR14
+|  std f15, SAVE_FPR15
+|.endmacro
+|
+|.macro restoreregs
+|  ld f8, SAVE_FPR8		// f8-f15 are callee-saved.
+|  ld f9, SAVE_FPR9
+|  ld f10, SAVE_FPR10
+|  ld f11, SAVE_FPR11
+|  ld f12, SAVE_FPR12
+|  ld f13, SAVE_FPR13
+|  ld f14, SAVE_FPR14
+|  ld f15, SAVE_FPR15
+|  lmg r6, r15, SAVE_GPRS	// Restores the stack pointer.
+|.endmacro
+|
+|// Type definitions. Some of these are only used for documentation.
+|.type L,		lua_State
+|.type GL,		global_State
+|.type TVALUE,		TValue
+|.type GCOBJ,		GCobj
+|.type STR,		GCstr
+|.type TAB,		GCtab
+|.type LFUNC,		GCfuncL
+|.type CFUNC,		GCfuncC
+|.type PROTO,		GCproto
+|.type UPVAL,		GCupval
+|.type NODE,		Node
+|.type NARGS,		int
+|.type TRACE,		GCtrace
+|.type SBUF,		SBuf
+|
+|//-----------------------------------------------------------------------
+|
+|// Instruction headers.
+|.macro ins_A; .endmacro
+|.macro ins_AD; .endmacro
+|.macro ins_AJ; .endmacro
+|.macro ins_ABC; srlg RB, RD, 8; llgcr RC, RD; .endmacro
+|.macro ins_AB_; srlg RB, RD, 8; .endmacro
+|.macro ins_A_C; llgcr RC, RD; .endmacro
+|.macro ins_AND; lghi TMPR1, -1; xgr RD, TMPR1; .endmacro // RD = ~RD
+|
+|// Instruction decode+dispatch.
+|.macro ins_NEXT
+|  llgc OP, 3(PC)
+|  llgh RD, 0(PC)
+|  llgc RA, 2(PC)
+|  sllg TMPR1, OP, 3
+|  lg TMPR1, 0(TMPR1, DISPATCH)
+|  la PC, 4(PC)
+|  br TMPR1
+|.endmacro
+|
+|// Instruction footer.
+|.if 1
+|  // Replicated dispatch. Less unpredictable branches, but higher I-Cache use.
+|  .define ins_next, ins_NEXT
+|  .define ins_next_, ins_NEXT
+|.else
+|  // Common dispatch. Lower I-Cache use, only one (very) unpredictable branch.
+|  .macro ins_next
+|    j ->ins_next
+|  .endmacro
+|  .macro ins_next_
+|  ->ins_next:
+|    ins_NEXT
+|  .endmacro
+|.endif
+|
+|// Call decode and dispatch.
+|.macro ins_callt
+|  // BASE = new base, RB = LFUNC, RD = nargs+1, -8(BASE) = PC
+|  lg PC, LFUNC:RB->pc
+|  llgc OP, 3(PC)
+|  llgc RA, 2(PC)
+|  sllg TMPR1, OP, 3
+|  la PC, 4(PC)
+|  lg TMPR1, 0(TMPR1, DISPATCH)
+|  br TMPR1
+|.endmacro
+|
+|.macro ins_call
+|  // BASE = new base, RB = LFUNC, RD = nargs+1
+|  stg PC, -8(BASE)
+|  ins_callt
+|.endmacro
+|
+|// Assumes DISPATCH is relative to GL.
+#define DISPATCH_GL(field)	(GG_DISP2G + (int)offsetof(global_State, field))
+#define DISPATCH_J(field)	(GG_DISP2J + (int)offsetof(jit_State, field))
+|
+#define PC2PROTO(field)  ((int)offsetof(GCproto, field)-(int)sizeof(GCproto))
+|
+|//-----------------------------------------------------------------------
+|
+|// Macros to clear or set tags.
+|.macro cleartp, reg
+|  nihf reg, 0x7fff
+|.endmacro
+|.macro settp, reg, tp
+|  oihf reg, tp<<15
+|.endmacro
+|.macro settp, dst, reg, tp
+|  llihf dst, tp<<15
+|  ogr dst, reg
+|.endmacro
+|.macro setint, reg
+|  settp reg, LJ_TISNUM
+|.endmacro
+|.macro setint, dst, reg
+|  settp dst, reg, LJ_TISNUM
+|.endmacro
+|
+|// Macros to test operand types.
+|.macro checktp_nc, reg, tp, target
+|  srag ITYPE, reg, 47
+|  clfi ITYPE, tp
+|  jne target
+|.endmacro
+|.macro checktp, reg, tp, target
+|  srag ITYPE, reg, 47
+|  cleartp reg
+|  clfi ITYPE, tp
+|  jne target
+|.endmacro
+|.macro checktptp, src, tp, target
+|  srag ITYPE, src, 47
+|  clfi ITYPE, tp
+|  jne target
+|.endmacro
+|.macro checkstr, reg, target; checktp reg, LJ_TSTR, target; .endmacro
+|.macro checktab, reg, target; checktp reg, LJ_TTAB, target; .endmacro
+|.macro checkfunc, reg, target; checktp reg, LJ_TFUNC, target; .endmacro
+|
+|.macro checknumx, reg, target, jump
+|  srag ITYPE, reg, 47
+|  clfi ITYPE, LJ_TISNUM
+|  jump target
+|.endmacro
+|.macro checkint, reg, target; checknumx reg, target, jne; .endmacro
+|.macro checkinttp, src, target; checknumx src, target, jne; .endmacro
+|.macro checknum, reg, target; checknumx reg, target, jhe; .endmacro
+|.macro checknumtp, src, target; checknumx src, target, jhe; .endmacro
+|.macro checknumber, src, target; checknumx src, target, jh; .endmacro
+|
+|.macro load_false, reg; lghi reg, -1; iihl reg, 0x7fff; .endmacro	// assumes LJ_TFALSE == ~(1<<47)
+|.macro load_true, reg; lghi reg, -1; iihh reg, 0xfffe; .endmacro	// assumes LJ_TTRUE  == ~(2<<47)
+|
+|.define PC_OP, -1(PC)
+|.define PC_RA, -2(PC)
+|.define PC_RB, -4(PC)
+|.define PC_RC, -3(PC)
+|.define PC_RD, -4(PC)
+|
+|.macro branchPC, reg
+|  // Must not clobber condition code.
+|  sllg TMPR1, reg, 2
+|  lay PC, (-BCBIAS_J*4)(TMPR1, PC)
+|.endmacro
+|
+|// Decrement hashed hotcount and trigger trace recorder if zero.
+|.macro hotloop, reg
+|  lgr reg, PC   
+|  srlg reg, reg, 1
+|  nill reg, HOTCOUNT_PCMASK 
+|  afi reg, GG_DISP2HOT
+|  agr reg, DISPATCH
+|  lg TMPR1, (reg) 
+|  aghi TMPR1, -HOTCOUNT_LOOP 
+|  stg TMPR1, (reg) 
+|  jl ->vm_hotloop
+|.endmacro
+|
+|// Set current VM state.
+|.macro set_vmstate, st
+|  lghi TMPR1, ~LJ_VMST_..st
+|  stg TMPR1, DISPATCH_GL(vmstate)(DISPATCH)
+|.endmacro
+|
+|// Synthesize binary floating-point constants.
+|.macro bfpconst_tobit, reg, tmp	// Synthesize 2^52 + 2^51.
+|  llihh tmp, 0x4338
+|  ldgr reg, tmp
+|.endmacro
+|
+|// Move table write barrier back. Overwrites reg.
+|.macro barrierback, tab, reg
+|  ni tab->marked, ~LJ_GC_BLACK // black2gray(tab)
+|  lg reg, (DISPATCH_GL(gc.grayagain))(DISPATCH)
+|  stg tab, (DISPATCH_GL(gc.grayagain))(DISPATCH)
+|  stg reg, tab->gclist
+|.endmacro
+
+#if !LJ_DUALNUM
+#error "Only dual-number mode supported for s390x target"
+#endif
+
+/* Generate subroutines used by opcodes and other parts of the VM. */
+/* The .code_sub section should be last to help static branch prediction. */
+static void build_subroutines(BuildCtx *ctx)
+{
+  |.code_sub
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Return handling ----------------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |->vm_returnp:
+  |  tmll PC, FRAME_P
+  |  je ->cont_dispatch
+  |
+  |  // Return from pcall or xpcall fast func.
+  |  nill PC, -8
+  |  sgr BASE, PC			// Restore caller base.
+  |  lay RA, -8(RA, PC)			// Rebase RA and prepend one result.
+  |  lg PC, -8(BASE)			// Fetch PC of previous frame.
+  |  // Prepending may overwrite the pcall frame, so do it at the end.
+  |  load_true ITYPE
+  |  stg ITYPE, 0(RA, BASE)		// Prepend true to results.
+  |
+  |->vm_returnc:
+  |  aghi RD, 1				// RD = nresults+1
+  |  je ->vm_unwind_yield
+  |  st RD, SAVE_MULTRES
+  |  tmll PC, FRAME_TYPE
+  |  je ->BC_RET_Z			// Handle regular return to Lua.
+  |
+  |->vm_return:
+  |  // BASE = base, RA = resultofs, RD = nresults+1 (= MULTRES), PC = return
+  |  lghi TMPR1, FRAME_C
+  |  xgr PC, TMPR1
+  |  tmll PC, FRAME_TYPE
+  |  jne ->vm_returnp
+  |
+  |  // Return to C.
+  |  set_vmstate C
+  |  nill PC, -8
+  |  sgr PC, BASE
+  |  lcgr PC, PC			// Previous base = BASE - delta.
+  |
+  |  aghi RD, -1
+  |  je >2
+  |1:  // Move results down.
+  |  lg RB, 0(BASE, RA)
+  |  stg RB, -16(BASE)
+  |  la BASE, 8(BASE)
+  |  aghi RD, -1
+  |  jne <1
+  |2:
+  |  lg L:RB, SAVE_L
+  |  stg PC, L:RB->base
+  |3:
+  |  llgf RD, SAVE_MULTRES
+  |  lgf RA, SAVE_NRES			// RA = wanted nresults+1
+  |4:
+  |  cgr RA, RD
+  |  jne >6				// More/less results wanted?
+  |5:
+  |  lay BASE, -16(BASE)
+  |  stg BASE, L:RB->top
+  |
+  |->vm_leave_cp:
+  |  lg RA, SAVE_CFRAME			// Restore previous C frame.
+  |  stg RA, L:RB->cframe
+  |  lghi CRET1, 0			// Ok return status for vm_pcall.
+  |
+  |->vm_leave_unw:
+  |  restoreregs
+  |  br r14
+  |
+  |6:
+  |  jl >7				// Less results wanted?
+  |  // More results wanted. Check stack size and fill up results with nil.
+  |  cg BASE, L:RB->maxstack
+  |  jh >8
+  |  lghi TMPR1, LJ_TNIL
+  |  stg TMPR1, -16(BASE)
+  |  la BASE, 8(BASE)
+  |  aghi RD, 1
+  |  j <4
+  |
+  |7:  // Fewer results wanted.
+  |  cghi RA, 0
+  |  je <5				// But check for LUA_MULTRET+1.
+  |  sgr RA, RD				// Negative result!
+  |  sllg TMPR1, RA, 3
+  |  la BASE, 0(TMPR1, BASE)		// Correct top.
+  |  j <5
+  |
+  |8:  // Corner case: need to grow stack for filling up results.
+  |  // This can happen if:
+  |  // - A C function grows the stack (a lot).
+  |  // - The GC shrinks the stack in between.
+  |  // - A return back from a lua_call() with (high) nresults adjustment.
+  |  stg BASE, L:RB->top		// Save current top held in BASE (yes).
+  |  st RD, SAVE_MULTRES		// Need to fill only remainder with nil.
+  |  lgr CARG2, RA
+  |  lgr CARG1, L:RB
+  |  brasl r14, extern lj_state_growstack	// (lua_State *L, int n)
+  |  lg BASE, L:RB->top			// Need the (realloced) L->top in BASE.
+  |  j <3
+  |
+  |->vm_unwind_yield:
+  |  lghi CRET1, LUA_YIELD
+  |  j ->vm_unwind_c_eh
+  |
+  |->vm_unwind_c:			// Unwind C stack, return from vm_pcall.
+  |  // (void *cframe, int errcode)
+  |  lgr sp, CARG1
+  |  lgfr CARG2, CRET1			// Error return status for vm_pcall.
+  |->vm_unwind_c_eh:			// Landing pad for external unwinder.
+  |  lg L:RB, SAVE_L
+  |  lg GL:RB, L:RB->glref
+  |  lghi TMPR1, ~LJ_VMST_C
+  |  stg TMPR1, GL:RB->vmstate
+  |  j ->vm_leave_unw
+  |
+  |->vm_unwind_ff:			// Unwind C stack, return from ff pcall.
+  |  // (void *cframe)
+  |  nill CARG1, CFRAME_RAWMASK		// Assumes high 48-bits set in CFRAME_RAWMASK.
+  |  lgr sp, CARG1
+  |->vm_unwind_ff_eh:			// Landing pad for external unwinder.
+  |  lg L:RB, SAVE_L
+  |  lghi RD, 1+1			// Really 1+2 results, incr. later.
+  |  lg BASE, L:RB->base
+  |  lg DISPATCH, L:RB->glref		// Setup pointer to dispatch table.
+  |  la DISPATCH, GG_G2DISP(DISPATCH)
+  |  lg PC, -8(BASE)			// Fetch PC of previous frame.
+  |  load_false RA
+  |  lg RB, 0(BASE)
+  |  stg RA, -16(BASE)			// Prepend false to error message.
+  |  stg RB, -8(BASE)
+  |  lghi RA, -16			// Results start at BASE+RA = BASE-16.
+  |  set_vmstate INTERP
+  |  j ->vm_returnc			// Increments RD/MULTRES and returns.
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Grow stack for calls -----------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |->vm_growstack_c:			// Grow stack for C function.
+  |  lghi CARG2, LUA_MINSTACK
+  |  j >2
+  |
+  |->vm_growstack_v:			// Grow stack for vararg Lua function.
+  |  aghi RD, -16			// LJ_FR2
+  |  j >1
+  |
+  |->vm_growstack_f:			// Grow stack for fixarg Lua function.
+  |  // BASE = new base, RD = nargs+1, RB = L, PC = first PC
+  |  sllg RD, NARGS:RD, 3
+  |  lay RD, -8(RD, BASE)
+  |1:
+  |  llgc RA, (PC2PROTO(framesize)-4)(PC)
+  |  la PC, 4(PC)			// Must point after first instruction.
+  |  stg BASE, L:RB->base
+  |  stg RD, L:RB->top
+  |  stg PC, SAVE_PC
+  |  lgr CARG2, RA
+  |2:
+  |  // RB = L, L->base = new base, L->top = top
+  |  lgr CARG1, L:RB
+  |  brasl r14, extern lj_state_growstack	// (lua_State *L, int n)
+  |  lg BASE, L:RB->base
+  |  lg RD, L:RB->top
+  |  lg LFUNC:RB, -16(BASE)
+  |  cleartp LFUNC:RB
+  |  sgr RD, BASE
+  |  srlg RD, RD, 3
+  |  aghi NARGS:RD, 1
+  |  // BASE = new base, RB = LFUNC, RD = nargs+1
+  |  ins_callt				// Just retry the call.
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Entry points into the assembler VM ---------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |->vm_resume:				// Setup C frame and resume thread.
+  |  // (lua_State *L, TValue *base, int nres1 = 0, ptrdiff_t ef = 0)
+  |  saveregs
+  |  lgr L:RB, CARG1
+  |  stg CARG1, SAVE_L
+  |  lgr RA, CARG2
+  |  lghi PC, FRAME_CP
+  |  lghi RD, 0
+  |  la KBASE, CFRAME_RESUME(sp)
+  |  lg DISPATCH, L:RB->glref		// Setup pointer to dispatch table.
+  |  aghi DISPATCH, GG_G2DISP
+  |  stg RD, SAVE_PC			// Any value outside of bytecode is ok.
+  |  stg RD, SAVE_CFRAME
+  |  st RD, SAVE_NRES
+  |  stg RD, SAVE_ERRF
+  |  stg KBASE, L:RB->cframe
+  |  clm RD, 1, L:RB->status
+  |  je >2				// Initial resume (like a call).
+  |
+  |  // Resume after yield (like a return).
+  |  stg L:RB, (DISPATCH_GL(cur_L))(DISPATCH)
+  |  set_vmstate INTERP
+  |  stc RD, L:RB->status
+  |  lg BASE, L:RB->base
+  |  lg RD, L:RB->top
+  |  sgr RD, RA
+  |  srlg RD, RD, 3
+  |  aghi RD, 1				// RD = nresults+1
+  |  sgr RA, BASE			// RA = resultofs
+  |  lg PC, -8(BASE)
+  |  st RD, SAVE_MULTRES
+  |  tmll PC, FRAME_TYPE
+  |  je ->BC_RET_Z
+  |  j ->vm_return
+  |
+  |->vm_pcall:				// Setup protected C frame and enter VM.
+  |  // (lua_State *L, TValue *base, int nres1, ptrdiff_t ef)
+  |  saveregs
+  |  lghi PC, FRAME_CP
+  |  llgfr CARG4, CARG4
+  |  stg CARG4, SAVE_ERRF
+  |  j >1
+  |
+  |->vm_call:				// Setup C frame and enter VM.
+  |  // (lua_State *L, TValue *base, int nres1)
+  |  saveregs
+  |  lghi PC, FRAME_C
+  |
+  |1:  // Entry point for vm_pcall above (PC = ftype).
+  |  st CARG3, SAVE_NRES
+  |  lgr L:RB, CARG1
+  |  stg CARG1, SAVE_L
+  |  lgr RA, CARG2			// Caveat: RA = CARG3.
+  |
+  |  lg DISPATCH, L:RB->glref		// Setup pointer to dispatch table.
+  |  lg KBASE, L:RB->cframe		// Add our C frame to cframe chain.
+  |  stg KBASE, SAVE_CFRAME
+  |  stg L:RB, SAVE_PC			// Any value outside of bytecode is ok.
+  |  aghi DISPATCH, GG_G2DISP
+  |  stg sp, L:RB->cframe
+  |
+  |2: // Entry point for vm_resume/vm_cpcall (RA = base, RB = L, PC = ftype).
+  |  stg L:RB, DISPATCH_GL(cur_L)(DISPATCH)
+  |  set_vmstate INTERP
+  |  lg BASE, L:RB->base		// BASE = old base (used in vmeta_call).
+  |  agr PC, RA
+  |  sgr PC, BASE			// PC = frame delta + frame type
+  |
+  |  lg RD, L:RB->top
+  |  sgr RD, RA
+  |  srlg NARGS:RD, NARGS:RD, 3
+  |  aghi NARGS:RD, 1			// RD = nargs+1
+  |
+  |->vm_call_dispatch:
+  |  lg LFUNC:RB, -16(RA)
+  |  checkfunc LFUNC:RB, ->vmeta_call	// Ensure KBASE defined and != BASE.
+  |
+  |->vm_call_dispatch_f:
+  |  lgr BASE, RA
+  |  ins_call
+  |  // BASE = new base, RB = func, RD = nargs+1, PC = caller PC
+  |
+  |->vm_cpcall:				// Setup protected C frame, call C.
+  |  // (lua_State *L, lua_CFunction func, void *ud, lua_CPFunction cp)
+  |  saveregs
+  |  lgr L:RB, CARG1
+  |  stg L:RB, SAVE_L
+  |  stg L:RB, SAVE_PC			// Any value outside of bytecode is ok.
+  |
+  |  lg KBASE, L:RB->stack		// Compute -savestack(L, L->top).
+  |  sg KBASE, L:RB->top
+  |   lg DISPATCH, L:RB->glref	// Setup pointer to dispatch table.
+  |  lghi TMPR0, 0
+  |  stg TMPR0, SAVE_ERRF		// No error function.
+  |  st KBASE, SAVE_NRES		// Neg. delta means cframe w/o frame.
+  |   aghi DISPATCH, GG_G2DISP
+  |  // Handler may change cframe_nres(L->cframe) or cframe_errfunc(L->cframe).
+  |
+  |  lg KBASE, L:RB->cframe		// Add our C frame to cframe chain.
+  |  stg KBASE, SAVE_CFRAME
+  |  stg sp, L:RB->cframe
+  |  stg L:RB, DISPATCH_GL(cur_L)(DISPATCH)
+  |
+  |  basr r14, CARG4			// (lua_State *L, lua_CFunction func, void *ud)
+  |  // TValue * (new base) or NULL returned in r2 (CRET1/).
+  |  cghi CRET1, 0
+  |  je ->vm_leave_cp			// No base? Just remove C frame.
+  |  lgr RA, CRET1
+  |  lghi PC, FRAME_CP
+  |  j <2				// Else continue with the call.
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Metamethod handling ------------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |//-- Continuation dispatch ----------------------------------------------
+  |
+  |->cont_dispatch:
+  |  // BASE = meta base, RA = resultofs, RD = nresults+1 (also in MULTRES)
+  |  agr RA, BASE
+  |  nill PC, -8
+  |  lgr RB, BASE
+  |  sgr BASE, PC			// Restore caller BASE.
+  |  sllg TMPR1, RD, 3
+  |  lghi TMPR0, LJ_TNIL
+  |  stg TMPR0, -8(RA, TMPR1)		// Ensure one valid arg.
+  |  lgr RC, RA				// ... in [RC]
+  |  lg PC, -24(RB)			// Restore PC from [cont|PC].
+  |  lg RA, -32(RB)
+  |.if FFI
+  |  clfi RA, 1
+  |  jle >1
+  |.endif
+  |  lg LFUNC:KBASE, -16(BASE)
+  |  cleartp LFUNC:KBASE
+  |  lg KBASE, LFUNC:KBASE->pc
+  |  lg KBASE, (PC2PROTO(k))(KBASE)
+  |  // BASE = base, RC = result, RB = meta base
+  |  br RA				// Jump to continuation.
+  |
+  |.if FFI
+  |1:
+  |  je ->cont_ffi_callback		// cont = 1: return from FFI callback.
+  |  // cont = 0: Tail call from C function.
+  |  sgr RB, BASE
+  |  srl RB, 3
+  |  ahi RB, -3
+  |  llgfr RD, RB
+  |  j ->vm_call_tail
+  |.endif
+  |
+  |->cont_cat:				// BASE = base, RC = result, RB = mbase
+  |  llgc RA, PC_RB
+  |  sllg RA, RA, 3
+  |  aghi RB, -32
+  |  la RA, 0(RA, BASE)
+  |  sgr RA, RB
+  |  je ->cont_ra
+  |  lcgr RA, RA
+  |  srlg RA, RA, 3
+  |  lg L:CARG1, SAVE_L
+  |  stg BASE, L:CARG1->base
+  |  lgfr CARG3, RA			// Caveat: RA == CARG3.
+  |  lg TMPR0, 0(RC)
+  |  stg TMPR0, 0(RB)
+  |  lgr CARG2, RB
+  |  j ->BC_CAT_Z
+  |
+  |//-- Table indexing metamethods -----------------------------------------
+  |
+  |->vmeta_tgets:
+  |  settp STR:RC, LJ_TSTR			// STR:RC = GCstr *
+  |  stg STR:RC, SAVE_TMP
+  |  la RC, SAVE_TMP
+  |  llgc TMPR1, PC_OP
+  |  cghi TMPR1, BC_GGET
+  |  jne >1
+  |  settp TAB:RA, TAB:RB, LJ_TTAB		// TAB:RB = GCtab *
+  |  lay RB, (DISPATCH_GL(tmptv))(DISPATCH)	// Store fn->l.env in g->tmptv.
+  |  stg TAB:RA, 0(RB)
+  |  j >2
+  |
+  |->vmeta_tgetb:
+  |  llgc RC, PC_RC
+  |  setint RC
+  |  stg RC, SAVE_TMP
+  |  la RC, SAVE_TMP
+  |  j >1
+  |
+  |->vmeta_tgetv:
+  |  llgc RC, PC_RC			// Reload TValue *k from RC.
+  |  sllg RC, RC, 3
+  |  la RC, 0(RC, BASE)
+  |1:
+  |  llgc RB, PC_RB			// Reload TValue *t from RB.
+  |  sllg RB, RB, 3
+  |  la RB, 0(RB, BASE)
+  |2:
+  |  lg L:CARG1, SAVE_L
+  |  stg BASE, L:CARG1->base
+  |  lgr CARG2, RB
+  |  lgr CARG3, RC
+  |  lgr L:RB, L:CARG1
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_tget	// (lua_State *L, TValue *o, TValue *k)
+  |  // TValue * (finished) or NULL (metamethod) returned in r2 (CRET1).
+  |  lg BASE, L:RB->base
+  |  ltgr RC, CRET1
+  |  je >3
+  |->cont_ra:				// BASE = base, RC = result
+  |  llgc RA, PC_RA
+  |  sllg RA, RA, 3
+  |  lg RB, 0(RC)
+  |  stg RB, 0(RA, BASE)
+  |  ins_next
+  |
+  |3:  // Call __index metamethod.
+  |  // BASE = base, L->top = new base, stack = cont/func/t/k
+  |  lg RA, L:RB->top
+  |  stg PC, -24(RA)			// [cont|PC]
+  |  la PC, FRAME_CONT(RA)
+  |  sgr PC, BASE
+  |  lg LFUNC:RB, -16(RA)		// Guaranteed to be a function here.
+  |  lghi NARGS:RD, 2+1			// 2 args for func(t, k).
+  |  cleartp LFUNC:RB
+  |  j ->vm_call_dispatch_f
+  |
+  |->vmeta_tgetr:
+  |  lgr CARG1, TAB:RB
+  |  lgfr CARG2, RC
+  |  brasl r14, extern lj_tab_getinth		// (GCtab *t, int32_t key)
+  |  // cTValue * or NULL returned in r2 (CRET1).
+  |  llgc RA, PC_RA
+  |  ltgr RC, CRET1
+  |  jne ->BC_TGETR_Z
+  |  lghi ITYPE, LJ_TNIL
+  |  j ->BC_TGETR2_Z
+  |
+  |//-----------------------------------------------------------------------
+  |
+  |->vmeta_tsets:
+  |  settp STR:RC, LJ_TSTR			// STR:RC = GCstr *
+  |  stg STR:RC, SAVE_TMP
+  |  la RC, SAVE_TMP
+  |  llgc TMPR0, PC_OP
+  |  cghi TMPR0, BC_GSET
+  |  jne >1
+  |  settp TAB:RA, TAB:RB, LJ_TTAB		// TAB:RB = GCtab *
+  |  lay RB, (DISPATCH_GL(tmptv))(DISPATCH)	// Store fn->l.env in g->tmptv.
+  |  stg TAB:RA, 0(RB)
+  |  j >2
+  |
+  |->vmeta_tsetb:
+  |  llgc RC, PC_RC
+  |  setint RC
+  |  stg RC, SAVE_TMP
+  |  la RC, SAVE_TMP
+  |  j >1
+  |
+  |->vmeta_tsetv:
+  |  llgc RC, PC_RC			// Reload TValue *k from RC.
+  |  sllg RC, RC, 3
+  |  la RC, 0(RC, BASE)
+  |1:
+  |  llgc RB, PC_RB			// Reload TValue *t from RB.
+  |  sllg RB, RB, 3
+  |  la RB, 0(RB, BASE)
+  |2:
+  |  lg L:CARG1, SAVE_L
+  |  stg BASE, L:CARG1->base
+  |  lgr CARG2, RB
+  |  lgr CARG3, RC
+  |  lgr L:RB, L:CARG1
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_tset	// (lua_State *L, TValue *o, TValue *k)
+  |  // TValue * (finished) or NULL (metamethod) returned in r2 (CRET1).
+  |  lg BASE, L:RB->base
+  |  ltgr RC, CRET1
+  |  je >3
+  |  // NOBARRIER: lj_meta_tset ensures the table is not black.
+  |  llgc RA, PC_RA
+  |  sllg RA, RA, 3
+  |  lg RB, 0(RA, BASE)
+  |  stg RB, 0(RC)
+  |->cont_nop:				// BASE = base, (RC = result)
+  |  ins_next
+  |
+  |3:  // Call __newindex metamethod.
+  |  // BASE = base, L->top = new base, stack = cont/func/t/k/(v)
+  |  lg RA, L:RB->top
+  |  stg PC, -24(RA)			// [cont|PC]
+  |  llgc RC, PC_RA
+  |  // Copy value to third argument.
+  |  sllg RB, RC, 3
+  |  lg RB, 0(RB, BASE)
+  |  stg RB, 16(RA)
+  |  la PC, FRAME_CONT(RA)
+  |  sgr PC, BASE
+  |  lg LFUNC:RB, -16(RA)		// Guaranteed to be a function here.
+  |  lghi NARGS:RD, 3+1			// 3 args for func(t, k, v).
+  |  cleartp LFUNC:RB
+  |  j ->vm_call_dispatch_f
+  |
+  |->vmeta_tsetr:
+  |  lg L:CARG1, SAVE_L
+  |  lgr CARG2, TAB:RB
+  |  stg BASE, L:CARG1->base
+  |  lgfr CARG3, RC
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_tab_setinth  // (lua_State *L, GCtab *t, int32_t key)
+  |  // TValue * returned in r2 (CRET1).
+  |  lgr RC, CRET1
+  |  llgc RA, PC_RA
+  |  j ->BC_TSETR_Z
+  |
+  |//-- Comparison metamethods ---------------------------------------------
+  |
+  |->vmeta_comp:
+  |  llgh RD, PC_RD
+  |  sllg RD, RD, 3
+  |  llgc RA, PC_RA
+  |  sllg RA, RA, 3
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  la CARG2, 0(RA, BASE)
+  |  la CARG3, 0(RD, BASE)		// Caveat: RA == CARG3
+  |  lgr CARG1, L:RB
+  |  llgc CARG4, PC_OP
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_comp	// (lua_State *L, TValue *o1, *o2, int op)
+  |  // 0/1 or TValue * (metamethod) returned in r2 (CRET1).
+  |3:
+  |  lgr RC, CRET1
+  |  lg BASE, L:RB->base
+  |  clgfi RC, 1
+  |  jh ->vmeta_binop
+  |4:
+  |  la PC, 4(PC)
+  |  jl >6
+  |5:
+  |  llgh RD, PC_RD
+  |  branchPC RD
+  |6:
+  |  ins_next
+  |
+  |->cont_condt:			// BASE = base, RC = result
+  |  la PC, 4(PC)
+  |  lg ITYPE, 0(RC)
+  |  srag ITYPE, ITYPE, 47
+  |  lghi TMPR0, LJ_TISTRUECOND
+  |  clr ITYPE, TMPR0		// Branch if result is true.
+  |  jl <5
+  |  j <6
+  |
+  |->cont_condf:			// BASE = base, RC = result
+  |  lg ITYPE, 0(RC)
+  |  srag ITYPE, ITYPE, 47
+  |  lghi TMPR0, LJ_TISTRUECOND
+  |  clr ITYPE, TMPR0		// Branch if result is false.
+  |  j <4
+  |
+  |->vmeta_equal:
+  |  cleartp TAB:RD
+  |  lay PC, -4(PC)
+  |  lgr CARG2, RA
+  |  lgfr CARG4, RB
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  lgr CARG3, RD
+  |  lgr CARG1, L:RB
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_equal	// (lua_State *L, GCobj *o1, *o2, int ne)
+  |  // 0/1 or TValue * (metamethod) returned in r2 (CRET1).
+  |  j <3
+  |
+  |->vmeta_equal_cd:
+  |.if FFI
+  |  lay PC, -4(PC)
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  lgr CARG1, L:RB
+  |  llgf CARG2, -4(PC)
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_equal_cd	// (lua_State *L, BCIns ins)
+  |  // 0/1 or TValue * (metamethod) returned in r2 (CRET1).
+  |  j <3
+  |.endif
+  |
+  |->vmeta_istype:
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  llgfr CARG2, RA
+  |  llgfr CARG3, RD			// Caveat: CARG3 == RA.
+  |  lgr L:CARG1, L:RB
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_istype  // (lua_State *L, BCReg ra, BCReg tp)
+  |  lg BASE, L:RB->base
+  |  j <6
+  |
+  |//-- Arithmetic metamethods ---------------------------------------------
+  |
+  |->vmeta_arith_vno:
+  |  llgc RB, PC_RB
+  |  llgc RC, PC_RC
+  |->vmeta_arith_vn:
+  |  sllg RB, RB, 3
+  |  sllg RC, RC, 3
+  |  la RB, 0(RB, BASE)
+  |  la RC, 0(RC, KBASE)
+  |  j >1
+  |
+  |->vmeta_arith_nvo:
+  |  llgc RC, PC_RC
+  |  llgc RB, PC_RB
+  |->vmeta_arith_nv:
+  |  sllg RC, RC, 3
+  |  sllg RB, RB, 3
+  |  la TMPR1, 0(RC, KBASE)
+  |  la RC, 0(RB, BASE)
+  |  lgr RB, TMPR1
+  |  j >1
+  |
+  |->vmeta_unm:
+  |  llgh RD, PC_RD
+  |  sllg RD, RD, 3
+  |  la RC, 0(RD, BASE)
+  |  lgr RB, RC
+  |  j >1
+  |
+  |->vmeta_arith_vvo:
+  |  llgc RB, PC_RB
+  |  llgc RC, PC_RC
+  |->vmeta_arith_vv:
+  |  sllg RC, RC, 3
+  |  sllg RB, RB, 3
+  |  la RB, 0(RB, BASE)
+  |  la RC, 0(RC, BASE)
+  |1:
+  |  llgc RA, PC_RA
+  |  sllg RA, RA, 3
+  |  la RA, 0(RA, BASE)
+  |  llgc CARG5, PC_OP			// Caveat: CARG5 == RD.
+  |  lgr CARG2, RA
+  |  lgr CARG3, RB			// Caveat: CARG3 == RA.
+  |  // lgr CARG4, RC			// Caveat: CARG4 == RC (nop, so commented out).
+  |  lg L:CARG1, SAVE_L
+  |  stg BASE, L:CARG1->base
+  |  lgr L:RB, L:CARG1
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_arith // (lua_State *L, TValue *ra,*rb,*rc, BCReg op)
+  |  // NULL (finished) or TValue * (metamethod) returned in r2 (CRET1).
+  |  lg BASE, L:RB->base
+  |  cghi CRET1, 0
+  |  lgr RC, CRET1
+  |  je ->cont_nop
+  |
+  |  // Call metamethod for binary op.
+  |->vmeta_binop:
+  |  // BASE = base, RC = new base, stack = cont/func/o1/o2
+  |  lgr RA, RC
+  |  sgr RC, BASE
+  |  stg PC, -24(RA)			// [cont|PC]
+  |  la PC, FRAME_CONT(RC)
+  |  lghi NARGS:RD, 2+1			// 2 args for func(o1, o2).
+  |  j ->vm_call_dispatch
+  |
+  |->vmeta_len:
+  |  llgh RD, PC_RD
+  |  sllg RD, RD, 3
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  la CARG2, 0(RD, BASE)
+  |  lgr L:CARG1, L:RB
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_len	// (lua_State *L, TValue *o)
+  |  // NULL (retry) or TValue * (metamethod) returned in r2 (CRET1).
+  |  lgr RC, CRET1
+  |  lg BASE, L:RB->base
+#if LJ_52
+  |  cghi RC, 0
+  |  jne ->vmeta_binop			// Binop call for compatibility.
+  |  llgh RD, PC_RD
+  |  sllg RD, RD, 3
+  |  lg TAB:CARG1, 0(RD, BASE)
+  |  cleartp TAB:CARG1
+  |  j ->BC_LEN_Z
+#else
+  |  j ->vmeta_binop			// Binop call for compatibility.
+#endif
+  |
+  |//-- Call metamethod ----------------------------------------------------
+  |
+  |->vmeta_call_ra:
+  |  la RA, 16(RA, BASE)		// RA previously set to RA*8.
+  |->vmeta_call:			// Resolve and call __call metamethod.
+  |  // BASE = old base, RA = new base, RC = nargs+1, PC = return
+  |  stg NARGS:RD, SAVE_TMP		// Save RA, RC for us (not sure about this).
+  |  lgr RB, RA
+  |  lg L:CARG1, SAVE_L
+  |  stg BASE, L:CARG1->base
+  |  lay CARG2, -16(RA)
+  |  sllg RD, RD, 3
+  |  lay CARG3, -8(RA, RD)		// Caveat: CARG3 == RA.
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_call	// (lua_State *L, TValue *func, TValue *top)
+  |  lgr RA, RB
+  |  lg L:RB, SAVE_L
+  |  lg BASE, L:RB->base
+  |  lg NARGS:RD, SAVE_TMP
+  |  lg LFUNC:RB, -16(RA)
+  |  aghi NARGS:RD, 1			// 32-bit on x64.
+  |  // This is fragile. L->base must not move, KBASE must always be defined.
+  |  cgr KBASE, BASE			// Continue with CALLT if flag set.
+  |  je ->BC_CALLT_Z
+  |  cleartp LFUNC:RB
+  |  lgr BASE, RA
+  |  ins_call				// Otherwise call resolved metamethod.
+  |
+  |//-- Argument coercion for 'for' statement ------------------------------
+  |
+  |->vmeta_for:
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  lgr CARG2, RA
+  |  lgr CARG1, RB
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_meta_for	// (lua_State *L, TValue *base)
+  |  lg BASE, L:RB->base
+  |  llgc OP, PC_OP
+  |  llgc RA, PC_RA
+  |  llgh RD, PC_RD
+  |  sllg TMPR1, OP, 3
+  |  lg TMPR1, GG_DISP2STATIC(TMPR1, DISPATCH)	// Retry FORI or JFORI.
+  |  br TMPR1
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Fast functions -----------------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |.macro .ffunc, name
+  |->ff_ .. name:
+  |.endmacro
+  |
+  |.macro .ffunc_1, name
+  |->ff_ .. name:
+  |  clfi NARGS:RD, 1+1; jl ->fff_fallback
+  |.endmacro
+  |
+  |.macro .ffunc_2, name
+  |->ff_ .. name:
+  |  clfi NARGS:RD, 2+1; jl ->fff_fallback
+  |.endmacro
+  |
+  |.macro .ffunc_n, name, op
+  |  .ffunc_1 name
+  |  lg TMPR0, 0(BASE)
+  |  checknumtp TMPR0, ->fff_fallback
+  |  op f0, 0(BASE)
+  |.endmacro
+  |
+  |.macro .ffunc_n, name
+  |  .ffunc_n name, ld
+  |.endmacro
+  |
+  |.macro .ffunc_nn, name
+  |  .ffunc_2 name
+  |  lg TMPR1, 0(BASE)
+  |  lg TMPR0, 8(BASE)
+  |  ld FARG1, 0(BASE)
+  |  ld FARG2, 8(BASE)
+  |  checknumtp TMPR1, ->fff_fallback
+  |  checknumtp TMPR0, ->fff_fallback
+  |.endmacro
+  |
+  |// Inlined GC threshold check. Caveat: uses label 1.
+  |.macro ffgccheck
+  |  lg RB, (DISPATCH_GL(gc.total))(DISPATCH)
+  |  clg RB, (DISPATCH_GL(gc.threshold))(DISPATCH)
+  |  jl >1
+  |  brasl r14, ->fff_gcstep
+  |1:
+  |.endmacro
+  |
+  |//-- Base library: checks -----------------------------------------------
+  |
+  |.ffunc_1 assert
+  |  lg RB, 0(BASE)
+  |  srag ITYPE, RB, 47
+  |  clfi ITYPE, LJ_TISTRUECOND; jhe ->fff_fallback
+  |  lg PC, -8(BASE)
+  |  st RD, SAVE_MULTRES
+  |  lg RB, 0(BASE)
+  |  stg RB, -16(BASE)
+  |  ahi RD, -2
+  |  je >2
+  |  lgr RA, BASE
+  |1:
+  |  la RA, 8(RA)
+  |  lg RB, 0(RA)
+  |  stg RB, -16(RA)
+  |  brct RD, <1
+  |2:
+  |  llgf RD, SAVE_MULTRES
+  |  j ->fff_res_
+  |
+  |.ffunc_1 type
+  |  lg RC, 0(BASE)
+  |  srag RC, RC, 47
+  |  lghi RB, LJ_TISNUM
+  |  clgr RC, RB
+  |  jnl >1
+  |  lgr RC, RB
+  |1:
+  |  lghi TMPR0, -1
+  |  xgr RC, TMPR0
+  |2:
+  |  lg CFUNC:RB, -16(BASE)
+  |  cleartp CFUNC:RB
+  |  sllg RC, RC, 3
+  |  lg STR:RC, ((char *)(&((GCfuncC *)0)->upvalue))(RC, CFUNC:RB)
+  |  lg PC, -8(BASE)
+  |  settp STR:RC, LJ_TSTR
+  |  stg STR:RC, -16(BASE)
+  |  j ->fff_res1
+  |
+  |//-- Base library: getters and setters ---------------------------------
+  |
+  |.ffunc_1 getmetatable
+  |  lg TAB:RB, 0(BASE)
+  |  lg PC, -8(BASE)
+  |  checktab TAB:RB, >6
+  |1:  // Field metatable must be at same offset for GCtab and GCudata!
+  |  lg TAB:RB, TAB:RB->metatable
+  |2:
+  |  lghi TMPR0, LJ_TNIL
+  |  stg TMPR0, -16(BASE)
+  |  cghi TAB:RB, 0
+  |  je ->fff_res1
+  |  settp TAB:RC, TAB:RB, LJ_TTAB
+  |  stg TAB:RC, -16(BASE)		// Store metatable as default result.
+  |  lg STR:RC, (DISPATCH_GL(gcroot)+8*(GCROOT_MMNAME+MM_metatable))(DISPATCH)
+  |  llgf RA, TAB:RB->hmask
+  |  n RA, STR:RC->sid
+  |  settp STR:RC, LJ_TSTR
+  |  mghi RA, #NODE
+  |  ag NODE:RA, TAB:RB->node
+  |3:  // Rearranged logic, because we expect _not_ to find the key.
+  |  cg STR:RC, NODE:RA->key
+  |  je >5
+  |4:
+  |  ltg NODE:RA, NODE:RA->next
+  |  jne <3
+  |  j ->fff_res1			// Not found, keep default result.
+  |5:
+  |  lg RB, NODE:RA->val
+  |  cghi RB, LJ_TNIL; je ->fff_res1	// Ditto for nil value.
+  |  stg RB, -16(BASE)			// Return value of mt.__metatable.
+  |  j ->fff_res1
+  |
+  |6:
+  |  clfi ITYPE, LJ_TUDATA; je <1
+  |  clfi ITYPE, LJ_TISNUM; jh >7
+  |  lhi ITYPE, LJ_TISNUM
+  |7:
+  |  lhi TMPR0, -1
+  |  xr ITYPE, TMPR0 // not ITYPE
+  |  llgfr ITYPE, ITYPE
+  |  sllg ITYPE, ITYPE, 3
+  |  lg TAB:RB, (DISPATCH_GL(gcroot[GCROOT_BASEMT]))(ITYPE, DISPATCH)
+  |  j <2
+  |
+  |.ffunc_2 setmetatable
+  |  lg TAB:RB, 0(BASE)
+  |  lgr TAB:TMPR1, TAB:RB
+  |  checktab TAB:RB, ->fff_fallback
+  |  // Fast path: no mt for table yet and not clearing the mt.
+  |  lghi TMPR0, 0
+  |  cg TMPR0, TAB:RB->metatable; jne ->fff_fallback
+  |  lg TAB:RA, 8(BASE)
+  |  checktab TAB:RA, ->fff_fallback
+  |  stg TAB:RA, TAB:RB->metatable
+  |  lg PC, -8(BASE)
+  |  stg TAB:TMPR1, -16(BASE)			// Return original table.
+  |  tm TAB:RB->marked, LJ_GC_BLACK		// isblack(table)
+  |  je >1
+  |  // Possible write barrier. Table is black, but skip iswhite(mt) check.
+  |  barrierback TAB:RB, RC
+  |1:
+  |  j ->fff_res1
+  |
+  |.ffunc_2 rawget
+  |  lg TAB:CARG2, 0(BASE)
+  |  checktab TAB:CARG2, ->fff_fallback
+  |  la CARG3, 8(BASE)
+  |  lg CARG1, SAVE_L
+  |  brasl r14, extern lj_tab_get	// (lua_State *L, GCtab *t, cTValue *key)
+  |  // cTValue * returned in r2 (CRET1).
+  |  // Copy table slot.
+  |  lg RB, 0(CRET1)
+  |  lg PC, -8(BASE)
+  |  stg RB, -16(BASE)
+  |  j ->fff_res1
+  |
+  |//-- Base library: conversions ------------------------------------------
+  |
+  |.ffunc tonumber
+  |  // Only handles the number case inline (without a base argument).
+  |  clfi NARGS:RD, 1+1; jne ->fff_fallback	// Exactly one argument.
+  |  lg RB, 0(BASE)
+  |  checknumber RB, ->fff_fallback
+  |  lg PC, -8(BASE)
+  |  stg RB, -16(BASE)
+  |  j ->fff_res1
+  |
+  |.ffunc_1 tostring
+  |  // Only handles the string or number case inline.
+  |  lg PC, -8(BASE)
+  |  lg STR:RB, 0(BASE)
+  |  checktp_nc STR:RB, LJ_TSTR, >3
+  |  // A __tostring method in the string base metatable is ignored.
+  |2:
+  |  stg STR:RB, -16(BASE)
+  |  j ->fff_res1
+  |3:  // Handle numbers inline, unless a number base metatable is present.
+  |  clfi ITYPE, LJ_TISNUM; jh ->fff_fallback_1
+  |  lghi TMPR0, 0
+  |  cg TMPR0, (DISPATCH_GL(gcroot[GCROOT_BASEMT_NUM]))(DISPATCH)
+  |  jne ->fff_fallback
+  |  ffgccheck				// Caveat: uses label 1.
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base		// Add frame since C call can throw.
+  |  stg PC, SAVE_PC			// Redundant (but a defined value).
+  |  lgr CARG2, BASE			// Otherwise: CARG2 == BASE
+  |  lgr L:CARG1, L:RB
+  |  brasl r14, extern lj_strfmt_number	// (lua_State *L, cTValue *o)
+  |  // GCstr returned in r2 (CRET1).
+  |  lg BASE, L:RB->base
+  |  settp STR:RB, CRET1, LJ_TSTR
+  |  j <2
+  |
+  |//-- Base library: iterators -------------------------------------------
+  |
+  |.ffunc_1 next
+  |  je >2				// Missing 2nd arg?
+  |1:
+  |  lg CARG1, 0(BASE)
+  |  lg PC, -8(BASE)
+  |  checktab CARG1, ->fff_fallback
+  |  lgr RB, BASE                       // Save BASE.
+  |  la CARG2, 8(BASE)
+  |  lay CARG3, -16(BASE)
+  |  brasl r14, extern lj_tab_next      // (GCtab *t, cTValue *key, TValue *o)
+  |  // 1=found, 0=end, -1=error returned in r2 (CRET1).
+  |  lgr BASE, RB                       // Restore BASE.
+  |  ltr RD, CRET1;  jh ->fff_res2      // Found key/value.
+  |  jl ->fff_fallback_2                // Invalid key.
+  |  // End of traversal: return nil.
+  |  lghi TMPR0, LJ_TNIL
+  |  stg TMPR0, -16(BASE)
+  |  j ->fff_res1
+  |2:  // Set missing 2nd arg to nil.
+  |  lghi TMPR0, LJ_TNIL
+  |  stg TMPR0, 8(BASE)
+  |  j <1
+  |
+  |.ffunc_1 pairs
+  |  lg TAB:RB, 0(BASE)
+  |  lgr TMPR1, TAB:RB
+  |  checktab TAB:RB, ->fff_fallback
+#if LJ_52
+  |  ltg TMPR0, TAB:RB->metatable; jne ->fff_fallback
+#endif
+  |  lg CFUNC:RD, -16(BASE)
+  |  cleartp CFUNC:RD
+  |  lg CFUNC:RD, CFUNC:RD->upvalue[0]
+  |  settp CFUNC:RD, LJ_TFUNC
+  |  lg PC, -8(BASE)
+  |  stg CFUNC:RD, -16(BASE)
+  |  stg TMPR1, -8(BASE)
+  |  lghi TMPR0, LJ_TNIL
+  |  stg TMPR0, 0(BASE)
+  |  lghi RD, 1+3
+  |  j ->fff_res
+  |
+  |.ffunc_2 ipairs_aux
+  |  lg TAB:RB, 0(BASE)
+  |  checktab TAB:RB, ->fff_fallback
+  |  lg RA, 8(BASE)
+  |  checkint RA, ->fff_fallback
+  |  lg PC, -8(BASE)
+  |  aghi RA, 1
+  |  setint ITYPE, RA
+  |  stg ITYPE, -16(BASE)
+  |  cl RA, TAB:RB->asize;  jhe >2	// Not in array part?
+  |  lg RD, TAB:RB->array
+  |  lgfr TMPR1, RA
+  |  sllg TMPR1, TMPR1, 3
+  |  la RD, 0(TMPR1, RD)
+  |1:
+  |  lg TMPR0, 0(RD)
+  |  cghi TMPR0, LJ_TNIL;  je ->fff_res0
+  |  // Copy array slot.
+  |  stg TMPR0, -8(BASE)
+  |->fff_res2:
+  |  lghi RD, 1+2
+  |  j ->fff_res
+  |2:  // Check for empty hash part first. Otherwise call C function.
+  |  lt TMPR0, TAB:RB->hmask; je ->fff_res0
+  |  lgr CARG1, TAB:RB
+  |  lgfr CARG2, RA
+  |  brasl r14, extern lj_tab_getinth	// (GCtab *t, int32_t key)
+  |  // cTValue * or NULL returned in r2 (CRET1).
+  |  ltgr RD, CRET1
+  |  jne <1
+  |->fff_res0:
+  |  lghi RD, 1+0
+  |  j ->fff_res
+  |
+  |.ffunc_1 ipairs
+  |  lg TAB:RB, 0(BASE)
+  |  lgr TMPR1, TAB:RB
+  |  checktab TAB:RB, ->fff_fallback
+#if LJ_52
+  |  lghi TMPR0, 0
+  |  cg TMPR0, TAB:RB->metatable; jne ->fff_fallback
+#endif
+  |  lg CFUNC:RD, -16(BASE)
+  |  cleartp CFUNC:RD
+  |  lg CFUNC:RD, CFUNC:RD->upvalue[0]
+  |  settp CFUNC:RD, LJ_TFUNC
+  |  lg PC, -8(BASE)
+  |  stg CFUNC:RD, -16(BASE)
+  |  stg TMPR1, -8(BASE)
+  |  llihf RD, LJ_TISNUM<<15
+  |  stg RD, 0(BASE)
+  |  lghi RD, 1+3
+  |  j ->fff_res
+  |
+  |//-- Base library: catch errors ----------------------------------------
+  |
+  |.ffunc_1 pcall
+  |  la RA, 16(BASE)
+  |  aghi NARGS:RD, -1
+  |  lghi PC, 16+FRAME_PCALL
+  |1:
+  |  llgc RB, (DISPATCH_GL(hookmask))(DISPATCH)
+  |  srlg RB, RB, HOOK_ACTIVE_SHIFT(r0)
+  |  nill RB, 1				// High bits already zero (from load).
+  |  agr PC, RB				// Remember active hook before pcall.
+  |  // Note: this does a (harmless) copy of the function to the PC slot, too.
+  |  lgr KBASE, RD
+  |2:
+  |  sllg TMPR1, KBASE, 3
+  |  lg RB, -24(TMPR1, RA)
+  |  stg RB, -16(TMPR1, RA)
+  |  aghi KBASE, -1
+  |  jh <2
+  |  j ->vm_call_dispatch
+  |
+  |.ffunc_2 xpcall
+  |  lg LFUNC:RA, 8(BASE)
+  |  checktp_nc LFUNC:RA, LJ_TFUNC, ->fff_fallback
+  |  lg LFUNC:RB, 0(BASE)		// Swap function and traceback.
+  |  stg LFUNC:RA, 0(BASE)
+  |  stg LFUNC:RB, 8(BASE)
+  |  la RA, 24(BASE)
+  |  aghi NARGS:RD, -2
+  |  lghi PC, 24+FRAME_PCALL
+  |  j <1
+  |
+  |//-- Coroutine library --------------------------------------------------
+  |
+  |.macro coroutine_resume_wrap, resume
+  |.if resume
+  |.ffunc_1 coroutine_resume
+  |  lg L:RB, 0(BASE)
+  |  lgr L:TMPR0, L:RB			// Save type for checktptp.
+  |  cleartp L:RB
+  |.else
+  |.ffunc coroutine_wrap_aux
+  |  lg CFUNC:RB, -16(BASE)
+  |  cleartp CFUNC:RB
+  |  lg L:RB, CFUNC:RB->upvalue[0].gcr
+  |  cleartp L:RB
+  |.endif
+  |  lg PC, -8(BASE)
+  |  stg PC, SAVE_PC
+  |  stg L:RB, SAVE_TMP
+  |.if resume
+  |  checktptp L:TMPR0, LJ_TTHREAD, ->fff_fallback
+  |.endif
+  |  ltg TMPR0, L:RB->cframe; jne ->fff_fallback
+  |  cli L:RB->status, LUA_YIELD; jh ->fff_fallback
+  |  lg RA, L:RB->top
+  |  je >1				// Status != LUA_YIELD (i.e. 0)?
+  |  cg RA, L:RB->base			// Check for presence of initial func.
+  |  je ->fff_fallback
+  |  lg PC, -8(RA)			// Move initial function up.
+  |  stg PC, 0(RA)
+  |  la RA, 8(RA)
+  |1:
+  |  sllg TMPR1, NARGS:RD, 3
+  |.if resume
+  |  lay PC, -16(TMPR1, RA)		// Check stack space (-1-thread).
+  |.else
+  |  lay PC, -8(TMPR1, RA)		// Check stack space (-1).
+  |.endif
+  |  clg PC, L:RB->maxstack; jh ->fff_fallback
+  |  stg PC, L:RB->top
+  |
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |.if resume
+  |  la BASE, 8(BASE)			// Keep resumed thread in stack for GC.
+  |.endif
+  |  stg BASE, L:RB->top
+  |.if resume
+  |  lay RB, -24(TMPR1, BASE)		// RB = end of source for stack move.
+  |.else
+  |  lay RB, -16(TMPR1, BASE)		// RB = end of source for stack move.
+  |.endif
+  |  sgr RB, PC			// Relative to PC.
+  |
+  |  cgr PC, RA
+  |  je >3
+  |2:  // Move args to coroutine.
+  |  lg RC, 0(RB, PC)
+  |  stg RC, -8(PC)
+  |  lay PC, -8(PC)
+  |  cgr PC, RA
+  |  jne <2
+  |3:
+  |  lgr CARG2, RA
+  |  lg L:CARG1, SAVE_TMP
+  |  lghi CARG3, 0
+  |  lghi CARG4, 0
+  |  brasl r14, ->vm_resume			// (lua_State *L, TValue *base, 0, 0)
+  |
+  |  lg L:RB, SAVE_L
+  |  lg L:PC, SAVE_TMP
+  |  lg BASE, L:RB->base
+  |  stg L:RB, (DISPATCH_GL(cur_L))(DISPATCH)
+  |  set_vmstate INTERP
+  |
+  |  clfi CRET1, LUA_YIELD
+  |  jh >8
+  |4:
+  |  lg RA, L:PC->base
+  |  lg KBASE, L:PC->top
+  |  stg RA, L:PC->top			// Clear coroutine stack.
+  |  lgr PC, KBASE
+  |  sgr PC, RA
+  |  je >6				// No results?
+  |  la RD, 0(PC, BASE)
+  |  llgfr PC, PC
+  |  srlg PC, PC, 3
+  |  clg RD, L:RB->maxstack
+  |  jh >9				// Need to grow stack?
+  |
+  |  lgr RB, BASE
+  |  sgr RB, RA
+  |5:  // Move results from coroutine.
+  |  lg RD, 0(RA)
+  |  stg RD, 0(RA, RB)
+  |  la RA, 8(RA)
+  |  cgr RA, KBASE
+  |  jne <5
+  |6:
+  |.if resume
+  |  la RD, 2(PC)			// nresults+1 = 1 + true + results.
+  |  load_true ITYPE			// Prepend true to results.
+  |  stg ITYPE, -8(BASE)
+  |.else
+  |  la RD, 1(PC)			// nresults+1 = 1 + results.
+  |.endif
+  |7:
+  |  lg PC, SAVE_PC
+  |  st RD, SAVE_MULTRES
+  |.if resume
+  |  lghi RA, -8
+  |.else
+  |  lghi RA, 0
+  |.endif
+  |  tmll PC, FRAME_TYPE
+  |  je ->BC_RET_Z
+  |  j ->vm_return
+  |
+  |8:  // Coroutine returned with error (at co->top-1).
+  |.if resume
+  |  load_false ITYPE			// Prepend false to results.
+  |  stg ITYPE, -8(BASE)
+  |  lg RA, L:PC->top
+  |  aghi RA, -8
+  |  stg RA, L:PC->top			// Clear error from coroutine stack.
+  |  // Copy error message.
+  |  lg RD, 0(RA)
+  |  stg RD, 0(BASE)
+  |  lghi RD, 1+2			// nresults+1 = 1 + false + error.
+  |  j <7
+  |.else
+  |  lgr CARG2, L:PC
+  |  lgr CARG1, L:RB
+  |  brasl r14, extern lj_ffh_coroutine_wrap_err  // (lua_State *L, lua_State *co)
+  |  // Error function does not return.
+  |.endif
+  |
+  |9:  // Handle stack expansion on return from yield.
+  |  lg L:RA, SAVE_TMP
+  |  stg KBASE, L:RA->top		// Undo coroutine stack clearing.
+  |  lgr CARG2, PC
+  |  lgr CARG1, L:RB
+  |  brasl r14, extern lj_state_growstack	// (lua_State *L, int n)
+  |  lg L:PC, SAVE_TMP
+  |  lg BASE, L:RB->base
+  |  j <4				// Retry the stack move.
+  |.endmacro
+  |
+  |  coroutine_resume_wrap 1		// coroutine.resume
+  |  coroutine_resume_wrap 0		// coroutine.wrap
+  |
+  |.ffunc coroutine_yield
+  |  lg L:RB, SAVE_L
+  |  lg TMPR0, L:RB->cframe
+  |  tmll TMPR0, CFRAME_RESUME
+  |  je ->fff_fallback
+  |  stg BASE, L:RB->base
+  |  sllg RD, NARGS:RD, 3
+  |  lay RD, -8(RD, BASE)
+  |  stg RD, L:RB->top
+  |  lghi RD, 0
+  |  stg RD, L:RB->cframe
+  |  lghi CRET1, LUA_YIELD
+  |  stc CRET1, L:RB->status
+  |  j ->vm_leave_unw
+  |
+  |//-- Math library -------------------------------------------------------
+  |
+  |.ffunc_1 math_abs
+  |  lg RB, 0(BASE)
+  |  checkint RB, >3
+  |  lpr RB, RB; jo >2
+  |->fff_resbit:
+  |->fff_resi:
+  |  setint RB
+  |->fff_resRB:
+  |  lg PC, -8(BASE)
+  |  stg RB, -16(BASE)
+  |  j ->fff_res1
+  |2:
+  |  llihh RB, 0x41e0	// 2^31
+  |  j ->fff_resRB
+  |3:
+  |  jh ->fff_fallback
+  |  nihh RB, 0x7fff	// Clear sign bit.
+  |  lg PC, -8(BASE)
+  |  stg RB, -16(BASE)
+  |  j ->fff_res1
+  |
+  |.ffunc_n math_sqrt, sqdb
+  |->fff_resf0:
+  |  lg PC, -8(BASE)
+  |  stdy f0, -16(BASE)
+  |  // fallthrough
+  |
+  |->fff_res1:
+  |  lghi RD, 1+1
+  |->fff_res:
+  |  st RD, SAVE_MULTRES
+  |->fff_res_:
+  |  tmll PC, FRAME_TYPE
+  |  jne >7
+  |5:
+  |  llgc TMPR1, PC_RB
+  |  clgr TMPR1, RD			// More results expected?
+  |  jh >6
+  |  // Adjust BASE. KBASE is assumed to be set for the calling frame.
+  |  llgc RA, PC_RA
+  |  lcgr RA, RA
+  |  sllg RA, RA, 3
+  |  lay BASE, -16(RA, BASE)		// base = base - (RA+2)*8
+  |  ins_next
+  |
+  |6:  // Fill up results with nil.
+  |  sllg TMPR1, RD, 3
+  |  lghi TMPR0, LJ_TNIL
+  |  stg TMPR0, -24(TMPR1, BASE)
+  |  la RD, 1(RD)
+  |  j <5
+  |
+  |7:  // Non-standard return case.
+  |  lghi RA, -16			// Results start at BASE+RA = BASE-16.
+  |  j ->vm_return
+  |
+  |.macro math_round, func
+  |  .ffunc math_ .. func
+  |  lg RB, 0(BASE)
+  |  ld f0, 0(BASE)
+  |  checknumx RB, ->fff_resRB, je
+  |  jh ->fff_fallback
+  |  brasl r14, ->vm_ .. func
+  |  cfdbr RB, 0, f0
+  |  jo ->fff_resf0
+  |  llgfr RB, RB
+  |  j ->fff_resi
+  |.endmacro
+  |
+  |  math_round floor
+  |  math_round ceil
+  |
+  |.ffunc math_log
+  |  chi NARGS:RD, 1+1; jne ->fff_fallback	// Exactly one argument.
+  |  lg TMPR0, 0(BASE)
+  |  ld FARG1, 0(BASE)
+  |  checknumtp TMPR0, ->fff_fallback
+  |  brasl r14, extern log
+  |  j ->fff_resf0
+  |
+  |.macro math_extern, func
+  |  .ffunc_n math_ .. func
+  |  brasl r14, extern func
+  |  j ->fff_resf0
+  |.endmacro
+  |
+  |.macro math_extern2, func
+  |  .ffunc_nn math_ .. func
+  |  brasl r14, extern func
+  |  j ->fff_resf0
+  |.endmacro
+  |
+  |  math_extern log10
+  |  math_extern exp
+  |  math_extern sin
+  |  math_extern cos
+  |  math_extern tan
+  |  math_extern asin
+  |  math_extern acos
+  |  math_extern atan
+  |  math_extern sinh
+  |  math_extern cosh
+  |  math_extern tanh
+  |  math_extern2 pow
+  |  math_extern2 atan2
+  |  math_extern2 fmod
+  |
+  |.ffunc_2 math_ldexp
+  |  lg TMPR0, 0(BASE)
+  |  ld FARG1, 0(BASE)
+  |  lg CARG1, 8(BASE)
+  |  checknumtp TMPR0, ->fff_fallback
+  |  checkinttp CARG1, ->fff_fallback
+  |  lgfr CARG1, CARG1
+  |  brasl r14, extern ldexp	// (double, int)
+  |  j ->fff_resf0
+  |
+  |.ffunc_n math_frexp
+  |  la CARG1, SAVE_TMP
+  |  brasl r14, extern frexp
+  |  llgf RB, SAVE_TMP
+  |  lg PC, -8(BASE)
+  |  stdy f0, -16(BASE)
+  |  setint RB
+  |  stg RB, -8(BASE)
+  |  lghi RD, 1+2
+  |  j ->fff_res
+  |
+  |.ffunc_n math_modf
+  |  lay CARG1, -16(BASE)
+  |  brasl r14, extern modf	// (double, double*)
+  |  lg PC, -8(BASE)
+  |  stdy f0, -8(BASE)
+  |  lghi RD, 1+2
+  |  j ->fff_res
+  |
+  |.macro math_minmax, name, cjmp
+  |  .ffunc name
+  |  lghi RA, 2*8
+  |  sllg TMPR1, RD, 3
+  |  lg RB, 0(BASE)
+  |  ld f0, 0(BASE)
+  |  checkint RB, >4
+  |1:  // Handle integers.
+  |  clgr RA, TMPR1; jhe ->fff_resRB
+  |  lg TMPR0, -8(RA, BASE)
+  |  checkint TMPR0, >3
+  |  cr RB, TMPR0
+  |  cjmp >2
+  |  lgr RB, TMPR0
+  |2:
+  |  aghi RA, 8
+  |  j <1
+  |3:
+  |  jh ->fff_fallback
+  |  // Convert intermediate result to number and continue below.
+  |  cdfbr f0, RB
+  |  ldgr f1, TMPR0
+  |  j >6
+  |4:
+  |  jh ->fff_fallback
+  |5:  // Handle numbers or integers.
+  |  clgr RA, TMPR1; jhe ->fff_resf0
+  |  lg RB, -8(RA, BASE)
+  |  ldy f1, -8(RA, BASE)
+  |  checknumx RB, >6, jl
+  |  jh ->fff_fallback
+  |  cdfbr f1, RB
+  |6:
+  |  cdbr f0, f1
+  |  cjmp >7
+  |  ldr f0, f1
+  |7:
+  |  aghi RA, 8
+  |  j <5
+  |.endmacro
+  |
+  |  math_minmax math_min, jnh
+  |  math_minmax math_max, jnl
+  |
+  |//-- String library -----------------------------------------------------
+  |
+  |.ffunc string_byte			// Only handle the 1-arg case here.
+  |  chi NARGS:RD, 1+1;  jne ->fff_fallback
+  |  lg STR:RB, 0(BASE)
+  |  checkstr STR:RB, ->fff_fallback
+  |  lg PC, -8(BASE)
+  |  ltg TMPR0, STR:RB->len
+  |  je ->fff_res0			// Return no results for empty string.
+  |  llgc RB, STR:RB[1]
+  |  j ->fff_resi
+  |
+  |.ffunc string_char			// Only handle the 1-arg case here.
+  |  ffgccheck
+  |  chi NARGS:RD, 1+1;  jne ->fff_fallback	// *Exactly* 1 arg.
+  |  lg RB, 0(BASE)
+  |  checkint RB, ->fff_fallback
+  |  clfi RB, 255;  jh ->fff_fallback
+  |  strvh RB, SAVE_TMP		// Store [c,0].
+  |  lghi TMPR1, 1
+  |  la RD, SAVE_TMP			// Points to stack. Little-endian.
+  |->fff_newstr:
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  llgfr CARG3, TMPR1			// Zero-extended to size_t.
+  |  lgr CARG2, RD
+  |  lgr CARG1, L:RB
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_str_new	// (lua_State *L, char *str, size_t l)
+  |->fff_resstr:
+  |  // GCstr * returned in r2 (CRET1).
+  |  lgr STR:RD, CRET1
+  |  lg BASE, L:RB->base
+  |  lg PC, -8(BASE)
+  |  settp STR:RD, LJ_TSTR
+  |  stg STR:RD, -16(BASE)
+  |  j ->fff_res1
+  |
+  |.ffunc string_sub
+  |  ffgccheck
+  |  lghi TMPR1, -1
+  |  clfi NARGS:RD, 1+2;  jl ->fff_fallback
+  |  jnh >1
+  |  lg TMPR1, 16(BASE)
+  |  checkint TMPR1, ->fff_fallback
+  |1:
+  |  lg STR:RB, 0(BASE)
+  |  checkstr STR:RB, ->fff_fallback
+  |  lg ITYPE, 8(BASE)
+  |  lgfr RA, ITYPE
+  |  srag ITYPE, ITYPE, 47
+  |  cghi ITYPE, LJ_TISNUM
+  |  jne ->fff_fallback
+  |  llgf RC, STR:RB->len
+  |  clr RC, TMPR1			// len < end? (unsigned compare)
+  |  jl >5
+  |2:
+  |  cghi RA, 0				// start <= 0?
+  |  jle >7
+  |3:
+  |  sr TMPR1, RA			// start > end?
+  |  jnhe ->fff_emptystr
+  |  la RD, (#STR-1)(RA, STR:RB)
+  |  ahi TMPR1, 1
+  |4:
+  |  j ->fff_newstr
+  |
+  |5:  // Negative end or overflow.
+  |  chi TMPR1, 0
+  |  jnl >6
+  |  ahi TMPR1, 1
+  |  ar TMPR1, RC			// end = end+(len+1)
+  |  j <2
+  |6:  // Overflow.
+  |  lr TMPR1, RC			// end = len
+  |  j <2
+  |
+  |7:  // Negative start or underflow.
+  |  je >8
+  |  agr RA, RC			// start = start+(len+1)
+  |  aghi RA, 1
+  |  jh <3				// start > 0?
+  |8:  // Underflow.
+  |  lghi RA, 1				// start = 1
+  |  j <3
+  |
+  |->fff_emptystr:  // Range underflow.
+  |  lghi TMPR1, 0
+  |  j <4
+  |
+  |.macro ffstring_op, name
+  |  .ffunc_1 string_ .. name
+  |  ffgccheck
+  |  lg STR:CARG2, 0(BASE)
+  |  checkstr STR:CARG2, ->fff_fallback
+  |  lg L:RB, SAVE_L
+  |   lay SBUF:CARG1, (DISPATCH_GL(tmpbuf))(DISPATCH)
+  |  stg BASE, L:RB->base
+  |   lg RC, SBUF:CARG1->b
+  |   stg L:RB, SBUF:CARG1->L
+  |   stg RC, SBUF:CARG1->w
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_buf_putstr_ .. name
+  |  // lgr CARG1, CRET1 (nop, CARG1==CRET1)
+  |  brasl r14, extern lj_buf_tostr
+  |  j ->fff_resstr
+  |.endmacro
+  |
+  |ffstring_op reverse
+  |ffstring_op lower
+  |ffstring_op upper
+  |
+  |//-- Bit library --------------------------------------------------------
+  |
+  |.macro .ffunc_bit, name, kind, fdef
+  |  fdef name
+  |.if kind == 2
+  |  bfpconst_tobit f1, RB
+  |.endif
+  |  lg RB, 0(BASE)
+  |  ld f0, 0(BASE)
+  |  checkint RB, >1
+  |.if kind > 0
+  |  j >2
+  |.else
+  |  j ->fff_resbit
+  |.endif
+  |1:
+  |  jh ->fff_fallback
+  |.if kind < 2
+  |  bfpconst_tobit f1, RB
+  |.endif
+  |  adbr f0, f1
+  |  lgdr RB, f0
+  |  llgfr RB, RB
+  |2:
+  |.endmacro
+  |
+  |.macro .ffunc_bit, name, kind
+  |  .ffunc_bit name, kind, .ffunc_1
+  |.endmacro
+  |
+  |.ffunc_bit bit_tobit, 0
+  |  j ->fff_resbit
+  |
+  |.macro .ffunc_bit_op, name, ins
+  |  .ffunc_bit name, 2
+  |  lgr TMPR1, NARGS:RD		// Save for fallback.
+  |  sllg RD, NARGS:RD, 3
+  |  lay RD, -16(RD, BASE)
+  |1:
+  |  clgr RD, BASE
+  |  jle ->fff_resbit
+  |  lg RA, 0(RD)
+  |  checkint RA, >2
+  |  ins RB, RA
+  |  aghi RD, -8
+  |  j <1
+  |2:
+  |  jh ->fff_fallback_bit_op
+  |  ldgr f0, RA
+  |  adbr f0, f1
+  |  lgdr RA, f0
+  |  ins RB, RA
+  |  aghi RD, -8
+  |  j <1
+  |.endmacro
+  |
+  |.ffunc_bit_op bit_band, nr
+  |.ffunc_bit_op bit_bor, or
+  |.ffunc_bit_op bit_bxor, xr
+  |
+  |.ffunc_bit bit_bswap, 1
+  |  lrvr RB, RB
+  |  j ->fff_resbit
+  |
+  |.ffunc_bit bit_bnot, 1
+  |  xilf RB, -1
+  |  j ->fff_resbit
+  |
+  |->fff_fallback_bit_op:
+  |  lgr NARGS:RD, TMPR1		// Restore for fallback
+  |  j ->fff_fallback
+  |
+  |.macro .ffunc_bit_sh, name, ins
+  |  .ffunc_bit name, 1, .ffunc_2
+  |  // Note: no inline conversion from number for 2nd argument!
+  |  lg RA, 8(BASE)
+  |  checkint RA, ->fff_fallback
+  |  nill RA, 0x1f	// Limit shift to 5-bits.
+  |  ins RB, 0(RA)
+  |  j ->fff_resbit
+  |.endmacro
+  |
+  |.ffunc_bit_sh bit_lshift, sll
+  |.ffunc_bit_sh bit_rshift, srl
+  |.ffunc_bit_sh bit_arshift, sra
+  |
+  |.ffunc_bit bit_rol, 1, .ffunc_2
+  |  // Note: no inline conversion from number for 2nd argument!
+  |  lg RA, 8(BASE)
+  |  checkint RA, ->fff_fallback
+  |  rll RB, RB, 0(RA)
+  |  j ->fff_resbit
+  |
+  |.ffunc_bit bit_ror, 1, .ffunc_2
+  |  // Note: no inline conversion from number for 2nd argument!
+  |  lg RA, 8(BASE)
+  |  checkint RA, ->fff_fallback
+  |  lcr RA, RA		// Right rotate equivalent to negative left rotate.
+  |  rll RB, RB, 0(RA)
+  |  j ->fff_resbit
+  |
+  |//-----------------------------------------------------------------------
+  |
+  |->fff_fallback_2:
+  |  lghi NARGS:RD, 1+2			// Other args are ignored, anyway.
+  |  j ->fff_fallback
+  |->fff_fallback_1:
+  |  lghi NARGS:RD, 1+1			// Other args are ignored, anyway.
+  |->fff_fallback:			// Call fast function fallback handler.
+  |  // BASE = new base, RD = nargs+1
+  |  lg L:RB, SAVE_L
+  |  lg PC, -8(BASE)			// Fallback may overwrite PC.
+  |  stg PC, SAVE_PC			// Redundant (but a defined value).
+  |  stg BASE, L:RB->base
+  |  sllg RD, NARGS:RD, 3
+  |  lay RD, -8(RD, BASE)
+  |  la RA, (8*LUA_MINSTACK)(RD)	// Ensure enough space for handler.
+  |  stg RD, L:RB->top
+  |  lg CFUNC:RD, -16(BASE)
+  |  cleartp CFUNC:RD
+  |  clg RA, L:RB->maxstack
+  |  jh >5				// Need to grow stack.
+  |  lgr CARG1, L:RB
+  |  lg TMPR1, CFUNC:RD->f
+  |  basr r14, TMPR1			// (lua_State *L)
+  |  lg BASE, L:RB->base
+  |  // Either throws an error, or recovers and returns -1, 0 or nresults+1.
+  |  lgr RD, CRET1
+  |  cghi RD, 0; jh ->fff_res	// Returned nresults+1?
+  |1:
+  |  lg RA, L:RB->top
+  |  sgr RA, BASE
+  |  srlg RA, RA, 3
+  |  cghi RD, 0
+  |    la NARGS:RD, 1(RA)
+  |    lg LFUNC:RB, -16(BASE)
+  |  jne ->vm_call_tail			// Returned -1?
+  |  cleartp LFUNC:RB
+  |  ins_callt				// Returned 0: retry fast path.
+  |
+  |// Reconstruct previous base for vmeta_call during tailcall.
+  |->vm_call_tail:
+  |  lgr RA, BASE
+  |  tmll PC, FRAME_TYPE
+  |  jne >3
+  |  llgc RB, PC_RA
+  |  lcgr RB, RB
+  |  sllg RB, RB, 3
+  |  lay BASE, -16(RB, BASE)		// base = base - (RB+2)*8
+  |  j ->vm_call_dispatch		// Resolve again for tailcall.
+  |3:
+  |  lgr RB, PC
+  |  nill RB, -8
+  |  sgr BASE, RB
+  |  j ->vm_call_dispatch		// Resolve again for tailcall.
+  |
+  |5:  // Grow stack for fallback handler.
+  |  lghi CARG2, LUA_MINSTACK
+  |  lgr CARG1, L:RB
+  |  brasl r14, extern lj_state_growstack	// (lua_State *L, int n)
+  |  lg BASE, L:RB->base
+  |  lghi RD, 0				// Simulate a return 0.
+  |  j <1				// Dumb retry (goes through ff first).
+  |
+  |->fff_gcstep:			// Call GC step function.
+  |  // BASE = new base, RD = nargs+1
+  |  stg r14, SAVE_TMP			// Save return address
+  |  lg L:RB, SAVE_L
+  |  stg PC, SAVE_PC			// Redundant (but a defined value).
+  |  stg BASE, L:RB->base
+  |  sllg RD, NARGS:RD, 3
+  |  lay RD, -8(RD, BASE)
+  |  lgr CARG1, L:RB
+  |  stg RD, L:RB->top
+  |  brasl r14, extern lj_gc_step	// (lua_State *L)
+  |  lg BASE, L:RB->base
+  |  lg RD, L:RB->top
+  |  sgr RD, BASE
+  |  srlg RD, RD, 3
+  |  aghi NARGS:RD, 1
+  |  lg r14, SAVE_TMP			// Restore return address.
+  |  br r14
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Special dispatch targets -------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |->vm_record:				// Dispatch target for recording phase.
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |->vm_rethook:			// Dispatch target for return hooks.
+  |  llgc RD, (DISPATCH_GL(hookmask))(DISPATCH)
+  |  tmll RD, HOOK_ACTIVE
+  |  jne >5
+  |  j >1
+  |
+  |->vm_inshook:			// Dispatch target for instr/line hooks.
+  |  llgc RD, (DISPATCH_GL(hookmask))(DISPATCH)
+  |  tmll RD, HOOK_ACTIVE		// Hook already active?
+  |  jne >5
+  |
+  |  tmll RD, LUA_MASKLINE|LUA_MASKCOUNT
+  |  je >5
+  |  ly TMPR0, (DISPATCH_GL(hookcount))(DISPATCH)
+  |  ahi TMPR0, -1
+  |  sty TMPR0, (DISPATCH_GL(hookcount))(DISPATCH)
+  |  je >1
+  |  tmll RD, LUA_MASKLINE
+  |  je >5
+  |1:
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  lgr CARG2, PC
+  |  lgr CARG1, L:RB
+  |  // SAVE_PC must hold the _previous_ PC. The callee updates it with PC.
+  |  brasl r14, extern lj_dispatch_ins	// (lua_State *L, const BCIns *pc)
+  |3:
+  |  lg BASE, L:RB->base
+  |4:
+  |  llgc RA, PC_RA
+  |5:
+  |  llgc OP, PC_OP
+  |  sllg TMPR1, OP, 3
+  |  llgh RD, PC_RD
+  |  lg TMPR1, GG_DISP2STATIC(TMPR1, DISPATCH)
+  |  br TMPR1
+  |
+  |->cont_hook:				// Continue from hook yield.
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |->vm_hotloop:			// Hot loop counter underflow.
+  |.if JIT
+  |  lg LFUNC:RB, -16(BASE) 
+  |  cleartp LFUNC:RB 
+  |  lg RB, LFUNC:RB->pc 
+  |  llgc RD, (PC2PROTO(framesize))(RB) 
+  |  sllg RD, RD, 3
+  |  la RD, 0(RD, BASE)
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  stg RD, L:RB->top 
+  |  lgr CARG2, PC
+  |  la CARG1, GG_DISP2J(DISPATCH)
+  |  stg L:RB, (DISPATCH_J(L))(DISPATCH)
+  |  stg PC, SAVE_PC
+  |  brasl r14, extern lj_trace_hot		// (jit_State *J, const BCIns *pc)
+  |  j <3
+  |.endif  
+  |    
+  |->vm_callhook:			// Dispatch target for call hooks.
+  |  stg PC, SAVE_PC
+  |.if JIT
+  |  j >1
+  |.endif
+  |
+  |->vm_hotcall:			// Hot call counter underflow.
+  |.if JIT
+  |  stg PC, SAVE_PC
+  |  oill PC, 1				// Marker for hot call.
+  |1:
+  |.endif
+  |  sllg RD, NARGS:RD, 3
+  |  lay RD, -8(RD, BASE)
+  |  lg L:RB, SAVE_L
+  |  stg BASE, L:RB->base
+  |  stg RD, L:RB->top
+  |  lgr CARG2, PC
+  |  lgr CARG1, L:RB
+  |  brasl r14, extern lj_dispatch_call	// (lua_State *L, const BCIns *pc)
+  |  // ASMFunction returned in r2 (CRET1).
+  |  lghi TMPR0, 0
+  |  stg TMPR0, SAVE_PC			// Invalidate for subsequent line hook.
+  |.if JIT
+  |  nill PC, -2
+  |.endif
+  |  lg BASE, L:RB->base
+  |  lg RD, L:RB->top
+  |  sgr RD, BASE
+  |  lgr RB, CRET1
+  |  llgc RA, PC_RA
+  |  srl RD, 3
+  |  ahi NARGS:RD, 1
+  |  llgfr RD, RD
+  |  br RB
+  |
+  |->cont_stitch:			// Trace stitching.
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |->vm_profhook:			// Dispatch target for profiler hook.
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Trace exit handler -------------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |// Called from an exit stub with the exit number on the stack.
+  |// The 16 bit exit number is stored with two (sign-extended) push imm8.
+  |->vm_exit_handler:
+  |  stg r0, 0
+  |  stg r0, 0
+  |->vm_exit_interp:
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Math helper functions ----------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |// FP value rounding. Called by math.floor/math.ceil fast functions.
+  |// Value to round is in f0. May clobber f0-f7 and r0. Return address is r14.
+  |.macro vm_round, name, mask
+  |->name:
+  |  ldr f4, f0
+  |  lghi r0, 1
+  |  cdfbr f1, r0
+  |  didbr f0, f2, f1, mask // f0=remainder, f2=quotient.
+  |  fidbra f4, mask, f4, 0
+  |  ldr f0, f4
+  |  jnle >1
+  |  br r14
+  |1: // partial remainder (sanity check)
+  |  stg r0, 0
+  |.endmacro
+  |
+  |  vm_round vm_floor, 7 // Round towards -inf.
+  |  vm_round vm_ceil,  6 // Round towards +inf.
+  |  vm_round vm_trunc, 5 // Round towards 0.
+  |
+  |// FP modulo x%y. Called by BC_MOD* and vm_arith.
+  |->vm_mod: // NYI.
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |//-----------------------------------------------------------------------
+  |//-- Assertions ---------------------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |->assert_bad_for_arg_type:
+  |  stg r0, 0
+  |  stg r0, 0
+#ifdef LUA_USE_ASSERT
+#endif
+  |
+  |->vm_next:
+  |.if JIT
+  |  stg r0, 0 // NYI On big-endian.
+  |  stg r0, 0
+  |.endif
+  |
+  |//-----------------------------------------------------------------------
+  |//-- FFI helper functions -----------------------------------------------
+  |//-----------------------------------------------------------------------
+  |
+  |// Handler for callback functions. Callback slot number in ah/al.
+  |->vm_ffi_callback:
+  |.if FFI
+  |.type CTSTATE, CTState, PC
+  |  saveregs
+  |  la DISPATCH, GG_G2DISP(RB)
+  |  lg CTSTATE, GL:RB->ctype_state
+  |  llgcr RC, RC
+  |  stg RC, CTSTATE->cb.slot
+  |  
+  |  la RC, CFRAME_SIZE(sp)
+  |.endif
+  |
+  |->cont_ffi_callback:			// Return from FFI callback.
+  |  stg r0, 0
+  |  stg r0, 0
+  |
+  |->vm_ffi_call:			// Call C function via FFI.
+  |  // Caveat: needs special frame unwinding, see below.
+  |.if FFI
+  |  .type CCSTATE, CCallState, r8
+  |  stmg r6, r15, 48(sp)
+  |  lgr r13, sp			// Use r13 as frame pointer.
+  |  lgr CCSTATE, CARG1
+  |  lg r7, CCSTATE->func
+  |
+  |  // Readjust stack.
+  |  sgf sp, CCSTATE->spadj
+  |
+  |  // Copy stack slots.
+  |  llgc r1, CCSTATE->nsp
+  |  chi r1, 0
+  |  jh >2
+  |1:
+  |  lmg CARG1, CARG5, CCSTATE->gpr[0]
+  |  // TODO: conditionally load FPRs?
+  |  ld FARG1, CCSTATE->fpr[0]
+  |  ld FARG2, CCSTATE->fpr[1]
+  |  ld FARG3, CCSTATE->fpr[2]
+  |  ld FARG4, CCSTATE->fpr[3]
+  |  basr r14, r7
+  |
+  |  stg CRET1, CCSTATE->gpr[0]
+  |  std f0, CCSTATE->fpr[0]
+  |
+  |  lgr sp, r13
+  |  lmg r6, r15, 48(sp)
+  |  br r14
+  |
+  |2:
+  |  la r10, (offsetof(CCallState, stack))(CCSTATE)	// Source.
+  |  la r11, (CCALL_SPS_EXTRA*8)(sp)			// Destination.
+  |3:
+  |  chi r1, 256
+  |  jl >4
+  |  mvc 0(256, r11), 0(r10)
+  |  la r10, 256(r10)
+  |  la r11, 256(r11)
+  |  ahi r1, -256
+  |  j <3
+  |
+  |4:
+  |  ahi r1, -1
+  |  jl <1
+  |  larl r9, >5
+  |  ex r1, 0(r9)
+  |  j <1
+  |
+  |5:
+  |  // exrl target
+  |  mvc 0(1, r11), 0(r10)
+  |.endif
+  |// Note: vm_ffi_call must be the last function in this object file!
+  |
+  |//-----------------------------------------------------------------------
+}
+
+/* Generate the code for a single instruction. */
+static void build_ins(BuildCtx *ctx, BCOp op, int defop)
+{
+  int vk = 0;
+  (void)vk;
+  |// Note: aligning all instructions does not pay off.
+  |=>defop:
+
+  switch (op) {
+
+  /* -- Comparison ops ---------------------------------------------------- */
+
+  /* Remember: all ops branch for a true comparison, fall through otherwise. */
+
+  |.macro jmp_comp, lt, ge, le, gt, target
+  ||switch (op) {
+  ||case BC_ISLT:
+  |   lt target
+  ||break;
+  ||case BC_ISGE:
+  |   ge target
+  ||break;
+  ||case BC_ISLE:
+  |   le target
+  ||break;
+  ||case BC_ISGT:
+  |   gt target
+  ||break;
+  ||default: break;  /* Shut up GCC. */
+  ||}
+  |.endmacro
+
+  case BC_ISLT: case BC_ISGE: case BC_ISLE: case BC_ISGT:
+    |  // RA = src1, RD = src2, JMP with RD = target
+    |  ins_AD
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  ld f0, 0(RA, BASE)
+    |  ld f1, 0(RD, BASE)
+    |  lg RA, 0(RA, BASE)
+    |  lg RD, 0(RD, BASE)
+    |  srag ITYPE, RA, 47
+    |  srag RB, RD, 47
+    |
+    |  clfi ITYPE, LJ_TISNUM; jne >7
+    |  clfi RB, LJ_TISNUM; jne >8
+    |  // Both are integers.
+    |  la PC, 4(PC)
+    |  cr RA, RD
+    |  jmp_comp jhe, jl, jh, jle, >9
+    |6:
+    |  llgh RD, PC_RD
+    |  branchPC RD
+    |9:
+    |  ins_next
+    |
+    |7:  // RA is not an integer.
+    |  jh ->vmeta_comp
+    |  // RA is a number.
+    |  clfi RB, LJ_TISNUM; jl >1; jne ->vmeta_comp
+    |  // RA is a number, RD is an integer.
+    |  cdfbr f1, RD
+    |  j >1
+    |
+    |8:  // RA is an integer, RD is not an integer.
+    |  jh ->vmeta_comp
+    |  // RA is an integer, RD is a number.
+    |  cdfbr f0, RA
+    |1:
+    |  la PC, 4(PC)
+    |  cdbr f0, f1
+    |  // To preserve NaN semantics GE/GT branch on unordered, but LT/LE don't.
+    |  jmp_comp jnl, jl, jnle, jle, <9
+    |  j <6
+    break;
+
+  case BC_ISEQV: case BC_ISNEV:
+    vk = op == BC_ISEQV;
+    |  ins_AD	// RA = src1, RD = src2, JMP with RD = target
+    |  sllg RD, RD, 3
+    |  ld f1, 0(RD, BASE)
+    |  lg RD, 0(RD, BASE)
+    |  sllg RA, RA, 3
+    |  ld f0, 0(RA, BASE)
+    |  lg RA, 0(RA, BASE)
+    |  la PC, 4(PC)
+    |  srag RB, RD, 47
+    |  srag ITYPE, RA, 47
+    |  clfi RB, LJ_TISNUM; jne >7
+    |  clfi ITYPE, LJ_TISNUM; jne >8
+    |  cr RD, RA
+    if (vk) {
+      |  jne >9
+    } else {
+      |  je >9
+    }
+    |  llgh RD, PC_RD
+    |  branchPC RD
+    |9:
+    |  ins_next
+    |
+    |7:  // RD is not an integer.
+    |  jh >5
+    |  // RD is a number.
+    |  clfi ITYPE, LJ_TISNUM; jl >1; jne >5
+    |  // RD is a number, RA is an integer.
+    |  cdfbr f0, RA
+    |  j >1
+    |
+    |8:  // RD is an integer, RA is not an integer.
+    |  jh >5
+    |  // RD is an integer, RA is a number.
+    |  cdfbr f1, RD
+    |  j >1
+    |
+    |1:
+    |  cdbr f0, f1
+    |4:
+  iseqne_fp:
+    if (vk) {
+      |  jne >2				// Unordered means not equal.
+    } else {
+      |  je >1				// Unordered means not equal.
+    }
+  iseqne_end:
+    if (vk) {
+      |1:				// EQ: Branch to the target.
+      |  llgh RD, PC_RD
+      |  branchPC RD
+      |2:				// NE: Fallthrough to next instruction.
+      |.if not FFI
+      |3:
+      |.endif
+    } else {
+      |.if not FFI
+      |3:
+      |.endif
+      |2:				// NE: Branch to the target.
+      |  llgh RD, PC_RD
+      |  branchPC RD
+      |1:				// EQ: Fallthrough to next instruction.
+    }
+    if (LJ_DUALNUM && (op == BC_ISEQV || op == BC_ISNEV ||
+		       op == BC_ISEQN || op == BC_ISNEN)) {
+      |  j <9
+    } else {
+      |  ins_next
+    }
+    |
+    if (op == BC_ISEQV || op == BC_ISNEV) {
+      |5:  // Either or both types are not numbers.
+      |.if FFI
+      |  clfi RB, LJ_TCDATA; je ->vmeta_equal_cd
+      |  clfi ITYPE, LJ_TCDATA; je ->vmeta_equal_cd
+      |.endif
+      |  cgr RA, RD
+      |  je <1				// Same GCobjs or pvalues?
+      |  cr RB, ITYPE
+      |  jne <2				// Not the same type?
+      |  clfi RB, LJ_TISTABUD
+      |  jh <2				// Different objects and not table/ud?
+      |
+      |  // Different tables or userdatas. Need to check __eq metamethod.
+      |  // Field metatable must be at same offset for GCtab and GCudata!
+      |  cleartp TAB:RA
+      |  lg TAB:RB, TAB:RA->metatable
+      |  cghi TAB:RB, 0
+      |  je <2				// No metatable?
+      |  tm TAB:RB->nomm, 1<<MM_eq
+      |  jne <2				// Or 'no __eq' flag set?
+      if (vk) {
+	|  lghi RB, 0			// ne = 0
+      } else {
+	|  lghi RB, 1			// ne = 1
+      }
+      |  j ->vmeta_equal		// Handle __eq metamethod.
+    } else {
+      |.if FFI
+      |3:
+      |  clfi ITYPE, LJ_TCDATA
+      if (LJ_DUALNUM && vk) {
+	|  jne <9
+      } else {
+	|  jne <2
+      }
+      |  j ->vmeta_equal_cd
+      |.endif
+    }
+    break;
+  case BC_ISEQS: case BC_ISNES:
+    vk = op == BC_ISEQS;
+    |  ins_AND	// RA = src, RD = str const, JMP with RD = target
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  lg RB, 0(RA, BASE)
+    |  la PC, 4(PC)
+    |  checkstr RB, >3
+    |  cg RB, 0(RD, KBASE)
+  iseqne_test:
+    if (vk) {
+      |  jne >2
+    } else {
+      |  je >1
+    }
+    goto iseqne_end;
+  case BC_ISEQN: case BC_ISNEN:
+    vk = op == BC_ISEQN;
+    |  ins_AD	// RA = src, RD = num const, JMP with RD = target
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  ld f0, 0(RA, BASE)
+    |  lg RB, 0(RA, BASE)
+    |  ld f1, 0(RD, KBASE)
+    |  lg RD, 0(RD, KBASE)
+    |  la PC, 4(PC)
+    |  checkint RB, >7
+    |  checkint RD, >8
+    |  cr RB, RD
+    if (vk) {
+      |  jne >9
+    } else {
+      |  je >9
+    }
+    |  llgh RD, PC_RD
+    |  branchPC RD
+    |9:
+    |  ins_next
+    |
+    |7:  // RA is not an integer.
+    |  jh >3
+    |  // RA is a number.
+    |  checkint RD, >1
+    |  // RA is a number, RD is an integer.
+    |  cdfbr f1, RD
+    |  j >1
+    |
+    |8:  // RA is an integer, RD is a number.
+    |  cdfbr f0, RB
+    |  cdbr f0, f1
+    |  j >4
+    |1:
+    |  cdbr f0, f1
+    |4:
+    goto iseqne_fp;
+  case BC_ISEQP: case BC_ISNEP:
+    vk = op == BC_ISEQP;
+    |  ins_AND	// RA = src, RD = primitive type (~), JMP with RD = target
+    |  sllg RA, RA, 3
+    |  lg RB, 0(RA, BASE)
+    |  srag RB, RB, 47
+    |  la PC, 4(PC)
+    |  cr RB, RD
+    if (!LJ_HASFFI) goto iseqne_test;
+    if (vk) {
+      |  jne >3
+      |  llgh RD, PC_RD
+      |  branchPC RD
+      |2:
+      |  ins_next
+      |3:
+      |  cghi RB, LJ_TCDATA; jne <2
+      |  j ->vmeta_equal_cd
+    } else {
+      |  je >2
+      |  cghi RB, LJ_TCDATA; je ->vmeta_equal_cd
+      |  llgh RD, PC_RD
+      |  branchPC RD
+      |2:
+      |  ins_next
+    }
+    break;
+
+  /* -- Unary test and copy ops ------------------------------------------- */
+
+  case BC_ISTC: case BC_ISFC: case BC_IST: case BC_ISF:
+    |  ins_AD	// RA = dst or unused, RD = src, JMP with RD = target
+    |  sllg RD, RD, 3
+    |  sllg RA, RA, 3
+    |  lg ITYPE, 0(RD, BASE)
+    |  la PC, 4(PC)
+    if (op == BC_ISTC || op == BC_ISFC) {
+      |  lgr RB, ITYPE
+    }
+    |  srag ITYPE, ITYPE, 47
+    |  clfi ITYPE, LJ_TISTRUECOND
+    if (op == BC_IST || op == BC_ISTC) {
+      |  jhe >1
+    } else {
+      |  jl >1
+    }
+    if (op == BC_ISTC || op == BC_ISFC) {
+      |  stg RB, 0(RA, BASE)
+    }
+    |  llgh RD, PC_RD
+    |  branchPC RD
+    |1:					// Fallthrough to the next instruction.
+    |  ins_next
+    break;
+
+  case BC_ISTYPE:
+    |  ins_AD	// RA = src, RD = -type
+    |  lghr RD, RD
+    |  sllg RA, RA, 3
+    |  lg RB, 0(RA, BASE)
+    |  srag RB, RB, 47
+    |  agr RB, RD
+    |  jne ->vmeta_istype
+    |  ins_next
+    break;
+  case BC_ISNUM:
+    |  ins_AD	// RA = src, RD = -(TISNUM-1)
+    |  sllg TMPR1, RA, 3
+    |  lg TMPR1, 0(TMPR1, BASE)
+    |  checknumtp TMPR1, ->vmeta_istype
+    |  ins_next
+    break;
+  case BC_MOV:
+    |  ins_AD	// RA = dst, RD = src
+    |  sllg RD, RD, 3
+    |  lg RB, 0(RD, BASE)
+    |  sllg RA, RA, 3
+    |  stg RB, 0(RA, BASE)
+    |  ins_next_
+    break;
+  case BC_NOT:
+    |  ins_AD	// RA = dst, RD = src
+    |  sllg RD, RD, 3
+    |  sllg RA, RA, 3
+    |  lg RB, 0(RD, BASE)
+    |  srag RB, RB, 47
+    |  load_false RC
+    |  clfi RB, LJ_TISTRUECOND
+    |  jl >1
+    |  load_true RC
+    |1:
+    |  stg RC, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_UNM:
+    |  ins_AD	// RA = dst, RD = src
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  lg RB, 0(RD, BASE)
+    |  checkint RB, >3
+    |  lcr RB, RB; jo >2
+    |1:
+    |  stg RB, 0(RA, BASE)
+    |  ins_next
+    |2:
+    |  llihh RB, 0x41e0 // (double)2^31
+    |  j <1
+    |3:
+    |  jh ->vmeta_unm
+    |  // Toggle sign bit.
+    |  llihh TMPR0, 0x8000
+    |  xgr RB, TMPR0
+    |  j <1
+    break;
+  case BC_LEN:
+    |  ins_AD	// RA = dst, RD = src
+    |  sllg RD, RD, 3
+    |  lg RD, 0(RD, BASE)
+    |  checkstr RD, >2
+    |  llgf RD, STR:RD->len
+    |1:
+    |  sllg RA, RA, 3
+    |  setint RD
+    |  stg RD, 0(RA, BASE)
+    |  ins_next
+    |2:
+    |  cghi ITYPE, LJ_TTAB; jne ->vmeta_len
+    |  lgr TAB:CARG1, TAB:RD
+#if LJ_52
+    |  lg TAB:RB, TAB:RD->metatable
+    |  cghi TAB:RB, 0
+    |  jne >9
+    |3:
+#endif
+    |->BC_LEN_Z:
+    |  brasl r14, extern lj_tab_len	// (GCtab *t)
+    |  // Length of table returned in r2 (CRET1).
+    |  lgr RD, CRET1
+    |  llgc RA, PC_RA
+    |  j <1
+#if LJ_52
+    |9:  // Check for __len.
+    |  tm TAB:RB->nomm, 1<<MM_len
+    |  jne <3
+    |  j ->vmeta_len			// 'no __len' flag NOT set: check.
+#endif
+    break;
+
+  /* -- Binary ops -------------------------------------------------------- */
+
+    |.macro ins_arithpre
+    |  ins_ABC
+    |  sllg RB, RB, 3
+    |  sllg RC, RC, 3
+    |  sllg RA, RA, 3
+    |.endmacro
+    |
+    |.macro ins_arithfp, ins
+    |  ins_arithpre
+    ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    ||switch (vk) {
+    ||case 0:
+    |   ld f0, 0(RB, BASE)
+    |   ld f1, 0(RC, KBASE)
+    |   lg RB, 0(RB, BASE)
+    |   lg RC, 0(RC, KBASE)
+    |   checknumtp RB, ->vmeta_arith_vno
+    |   checknumtp RC, ->vmeta_arith_vno
+    |   ins f0, f1
+    ||  break;
+    ||case 1:
+    |   ld f1, 0(RB, BASE)
+    |   ld f0, 0(RC, KBASE)
+    |   lg RB, 0(RB, BASE)
+    |   lg RC, 0(RC, KBASE)
+    |   checknumtp RB, ->vmeta_arith_nvo
+    |   checknumtp RC, ->vmeta_arith_nvo
+    |   ins f0, f1
+    ||  break;
+    ||default:
+    |   ld f0, 0(RB, BASE)
+    |   ld f1, 0(RC, BASE)
+    |   lg RB, 0(RB, BASE)
+    |   lg RC, 0(RC, BASE)
+    |   checknumtp RB, ->vmeta_arith_vvo
+    |   checknumtp RC, ->vmeta_arith_vvo
+    |   ins f0, f1
+    ||  break;
+    ||}
+    |  std f0, 0(RA, BASE)
+    |  ins_next
+    |.endmacro
+    |
+    |.macro ins_arithdn, intins
+    |  ins_arithpre
+    ||vk = ((int)op - BC_ADDVN) / (BC_ADDNV-BC_ADDVN);
+    ||switch (vk) {
+    ||case 0:
+    |   lg RB, 0(RB, BASE)
+    |   lg RC, 0(RC, KBASE)
+    |   checkint RB, ->vmeta_arith_vno
+    |   checkint RC, ->vmeta_arith_vno
+    |   intins RB, RC; jo ->vmeta_arith_vno
+    ||  break;
+    ||case 1:
+    |   lg RB, 0(RB, BASE)
+    |   lg RC, 0(RC, KBASE)
+    |   checkint RB, ->vmeta_arith_nvo
+    |   checkint RC, ->vmeta_arith_nvo
+    |   intins RC, RB; jo ->vmeta_arith_nvo
+    ||  break;
+    ||default:
+    |   lg RB, 0(RB, BASE)
+    |   lg RC, 0(RC, BASE)
+    |   checkint RB, ->vmeta_arith_vvo
+    |   checkint RC, ->vmeta_arith_vvo
+    |   intins RB, RC; jo ->vmeta_arith_vvo
+    ||  break;
+    ||}
+    ||if (vk == 1) {
+    |   // setint RC
+    |   stg RC, 0(RA, BASE)
+    ||} else {
+    |   // setint RB
+    |   stg RB, 0(RA, BASE)
+    ||}
+    |  ins_next
+    |.endmacro
+
+    |  // RA = dst, RB = src1 or num const, RC = src2 or num const
+  case BC_ADDVN: case BC_ADDNV: case BC_ADDVV:
+    |  ins_arithdn ar
+    break;
+  case BC_SUBVN: case BC_SUBNV: case BC_SUBVV:
+    |  ins_arithdn sr
+    break;
+  case BC_MULVN: case BC_MULNV: case BC_MULVV:
+    |  ins_arithpre
+    |  // For multiplication we use msgfr and check if the result
+    |  // fits in an int32_t.
+    switch(op) {
+    case BC_MULVN:
+      |  lg RB, 0(RB, BASE)
+      |  lg RC, 0(RC, KBASE)
+      |  checkint RB, ->vmeta_arith_vno
+      |  checkint RC, ->vmeta_arith_vno
+      |  lgfr RB, RB
+      |  msgfr RB, RC
+      |  lgfr RC, RB
+      |  cgr RB, RC; jne ->vmeta_arith_vno
+      break;
+    case BC_MULNV:
+      |  lg RB, 0(RB, BASE)
+      |  lg RC, 0(RC, KBASE)
+      |  checkint RB, ->vmeta_arith_nvo
+      |  checkint RC, ->vmeta_arith_nvo
+      |  lgfr RB, RB
+      |  msgfr RB, RC
+      |  lgfr RC, RB
+      |  cgr RB, RC; jne ->vmeta_arith_nvo
+      break;
+    default:
+      |  lg RB, 0(RB, BASE)
+      |  lg RC, 0(RC, BASE)
+      |  checkint RB, ->vmeta_arith_vvo
+      |  checkint RC, ->vmeta_arith_vvo
+      |  lgfr RB, RB
+      |  msgfr RB, RC
+      |  lgfr RC, RB
+      |  cgr RB, RC; jne ->vmeta_arith_vvo
+      break;
+    }
+    |  llgfr RB, RB
+    |  setint RB
+    |  stg RB, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_DIVVN: case BC_DIVNV: case BC_DIVVV:
+    |  ins_arithfp ddbr
+    break;
+  // TODO: implement fast mod operation.
+  // x86_64 does floating point mod, however it might be better to use integer mod.
+  case BC_MODVN:
+    |  j ->vmeta_arith_vno
+    break;
+  case BC_MODNV:
+    |  j ->vmeta_arith_nvo
+    break;
+  case BC_MODVV:
+    |  j ->vmeta_arith_vvo
+    break;
+  case BC_POW:
+    |  ins_ABC
+    |  sllg RB, RB, 3
+    |  sllg RC, RC, 3
+    |  ld FARG1, 0(RB, BASE)
+    |  ld FARG2, 0(RC, BASE)
+    |  lg TMPR0, 0(RB, BASE)
+    |  checknumtp TMPR0, ->vmeta_arith_vvo
+    |  lg TMPR0, 0(RC, BASE)
+    |  checknumtp TMPR0, ->vmeta_arith_vvo
+    |  brasl r14, extern pow	// double pow(double x, double y), result in f0.
+    |  llgc RA, PC_RA
+    |  sllg RA, RA, 3
+    |  std f0, 0(RA, BASE)
+    |  ins_next
+    break;
+
+  case BC_CAT:
+    |  ins_ABC	// RA = dst, RB = src_start, RC = src_end
+    |  lg L:CARG1, SAVE_L
+    |  stg BASE, L:CARG1->base
+    |  lgr CARG3, RC
+    |  sgr CARG3, RB
+    |  sllg RC, RC, 3
+    |  la CARG2, 0(RC, BASE)
+    |->BC_CAT_Z:
+    |  lgr L:RB, L:CARG1
+    |  stg PC, SAVE_PC
+    |  brasl r14, extern lj_meta_cat		// (lua_State *L, TValue *top, int left)
+    |  // NULL (finished) or TValue * (metamethod) returned in r2 (CRET1).
+    |  lg BASE, L:RB->base
+    |  ltgr RC, CRET1
+    |  jne ->vmeta_binop
+    |  llgc RB, PC_RB			// Copy result to Stk[RA] from Stk[RB].
+    |  sllg RB, RB, 3
+    |  llgc RA, PC_RA
+    |  sllg RA, RA, 3
+    |  lg RC, 0(RB, BASE)
+    |  stg RC, 0(RA, BASE)
+    |  ins_next
+    break;
+
+  /* -- Constant ops ------------------------------------------------------ */
+
+  case BC_KSTR:
+    |  ins_AND	// RA = dst, RD = str const (~)
+    |  sllg RD, RD, 3
+    |  lg RD, 0(RD, KBASE)
+    |  settp RD, LJ_TSTR
+    |  sllg RA, RA, 3
+    |  stg RD, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_KCDATA:
+    |.if FFI
+    |  ins_AND	// RA = dst, RD = cdata const (~)
+    |  sllg RD, RD, 3
+    |  sllg RA, RA, 3
+    |  lg RD, 0(RD, KBASE)
+    |  settp RD, LJ_TCDATA
+    |  stg RD, 0(RA, BASE)
+    |  ins_next
+    |.endif
+    break;
+  case BC_KSHORT:
+    |  ins_AD	// RA = dst, RD = signed int16 literal
+    |  // Assumes DUALNUM.
+    |  lhr RD, RD			// Sign-extend literal to 32-bits.
+    |  setint RD
+    |  sllg RA, RA, 3
+    |  stg RD, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_KNUM:
+    |  ins_AD	// RA = dst, RD = num const
+    |  sllg RD, RD, 3
+    |  ld f0, 0(RD, KBASE)
+    |  sllg RA, RA, 3
+    |  std f0, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_KPRI:
+    |  ins_AD	// RA = dst, RD = primitive type (~)
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 47
+    |  lghi TMPR0, -1
+    |  xgr RD, TMPR0 // not
+    |  stg RD, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_KNIL:
+    |  ins_AD	// RA = dst_start, RD = dst_end
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  la RA, 8(RA, BASE)
+    |  la RD, 0(RD, BASE)
+    |  lghi RB, LJ_TNIL
+    |  stg RB, -8(RA)			// Sets minimum 2 slots.
+    |1:
+    |  stg RB, 0(RA)
+    |  la RA, 8(RA)
+    |  clgr RA, RD
+    |  jle <1
+    |  ins_next
+    break;
+
+/* -- Upvalue and function ops ------------------------------------------ */
+
+  case BC_UGET:
+    |  ins_AD	// RA = dst, RD = upvalue #
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  lg LFUNC:RB, -16(BASE)
+    |  cleartp LFUNC:RB
+    |  lg UPVAL:RB, (offsetof(GCfuncL, uvptr))(RD, LFUNC:RB)
+    |  lg RB, UPVAL:RB->v
+    |  lg RD, 0(RB)
+    |  stg RD, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_USETV:
+#define TV2MARKOFS \
+ ((int32_t)offsetof(GCupval, marked)-(int32_t)offsetof(GCupval, tv))
+    |  ins_AD	// RA = upvalue #, RD = src
+    |  lg LFUNC:RB, -16(BASE)
+    |  cleartp LFUNC:RB
+    |  sllg RA, RA, 3
+    |  lg UPVAL:RB, (offsetof(GCfuncL, uvptr))(RA, LFUNC:RB)
+    |  tm UPVAL:RB->closed, 0xff
+    |  lg RB, UPVAL:RB->v
+    |  sllg TMPR1, RD, 3
+    |  lg RA, 0(TMPR1, BASE)
+    |  stg RA, 0(RB)
+    |  je >1
+    |  // Check barrier for closed upvalue.
+    |  tmy TV2MARKOFS(RB), LJ_GC_BLACK		// isblack(uv)
+    |  jne >2
+    |1:
+    |  ins_next
+    |
+    |2:  // Upvalue is black. Check if new value is collectable and white.
+    |  srag RD, RA, 47
+    |  ahi RD, -LJ_TISGCV
+    |  clfi RD, LJ_TNUMX - LJ_TISGCV		// tvisgcv(v)
+    |  jle <1
+    |  cleartp GCOBJ:RA
+    |  tm GCOBJ:RA->gch.marked, LJ_GC_WHITES	// iswhite(v)
+    |  je <1
+    |  // Crossed a write barrier. Move the barrier forward.
+    |  lgr CARG2, RB
+    |  lay GL:CARG1, GG_DISP2G(DISPATCH)
+    |  brasl r14, extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
+    |  j <1
+    break;
+#undef TV2MARKOFS
+  case BC_USETS:
+    |  ins_AND	// RA = upvalue #, RD = str const (~)
+    |  lg LFUNC:RB, -16(BASE)
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  cleartp LFUNC:RB
+    |  lg UPVAL:RB, (offsetof(GCfuncL, uvptr))(RA, LFUNC:RB)
+    |  lg STR:RA, 0(RD, KBASE)
+    |  lg RD, UPVAL:RB->v
+    |  settp STR:ITYPE, STR:RA, LJ_TSTR
+    |  stg STR:ITYPE, 0(RD)
+    |  tm UPVAL:RB->marked, LJ_GC_BLACK		// isblack(uv)
+    |  jne >2
+    |1:
+    |  ins_next
+    |
+    |2:  // Check if string is white and ensure upvalue is closed.
+    |  tm GCOBJ:RA->gch.marked, LJ_GC_WHITES	// iswhite(str)
+    |  je <1
+    |  tm UPVAL:RB->closed, 0xff
+    |  je <1
+    |  // Crossed a write barrier. Move the barrier forward.
+    |  lgr CARG2, RD
+    |  lay GL:CARG1, GG_DISP2G(DISPATCH)
+    |  brasl r14, extern lj_gc_barrieruv	// (global_State *g, TValue *tv)
+    |  j <1
+    break;
+  case BC_USETN:
+    |  ins_AD	// RA = upvalue #, RD = num const
+    |  lg LFUNC:RB, -16(BASE)
+    |  sllg RA, RA, 3
+    |  sllg RD, RD, 3
+    |  cleartp LFUNC:RB
+    |  ld f0, 0(RD, KBASE)
+    |  lg UPVAL:RB, (offsetof(GCfuncL, uvptr))(RA, LFUNC:RB)
+    |  lg RA, UPVAL:RB->v
+    |  std f0, 0(RA)
+    |  ins_next
+    break;
+  case BC_USETP:
+    |  ins_AD	// RA = upvalue #, RD = primitive type (~)
+    |  lg LFUNC:RB, -16(BASE)
+    |  sllg RA, RA, 3
+    |  cleartp LFUNC:RB
+    |  lg UPVAL:RB, (offsetof(GCfuncL, uvptr))(RA, LFUNC:RB)
+    |  sllg RD, RD, 47
+    |  lghi TMPR0, -1
+    |  xgr RD, TMPR0
+    |  lg RA, UPVAL:RB->v
+    |  stg RD, 0(RA)
+    |  ins_next
+    break;
+  case BC_UCLO:
+    |  ins_AD	// RA = level, RD = target
+    |  branchPC RD				// Do this first to free RD.
+    |  lg L:RB, SAVE_L
+    |  ltg TMPR0, L:RB->openupval
+    |  je >1
+    |  stg BASE, L:RB->base
+    |  sllg RA, RA, 3
+    |  la CARG2, 0(RA, BASE)
+    |  lgr L:CARG1, L:RB
+    |  brasl r14, extern lj_func_closeuv	// (lua_State *L, TValue *level)
+    |  lg BASE, L:RB->base
+    |1:
+    |  ins_next
+    break;
+
+  case BC_FNEW:
+    |  ins_AND	// RA = dst, RD = proto const (~) (holding function prototype)
+    |  lg L:RB, SAVE_L
+    |  stg BASE, L:RB->base
+    |  lg CARG3, -16(BASE)
+    |  cleartp CARG3
+    |  sllg RD, RD, 3
+    |  lg CARG2, 0(RD, KBASE)		// Fetch GCproto *.
+    |  lgr CARG1, L:RB
+    |  stg PC, SAVE_PC
+    |  // (lua_State *L, GCproto *pt, GCfuncL *parent)
+    |  brasl r14, extern lj_func_newL_gc
+    |  // GCfuncL * returned in r2 (CRET1).
+    |  lg BASE, L:RB->base
+    |  llgc RA, PC_RA
+    |  sllg RA, RA, 3
+    |  settp LFUNC:CRET1, LJ_TFUNC
+    |  stg LFUNC:CRET1, 0(RA, BASE)
+    |  ins_next
+    break;
+  case BC_TNEW:
+    |  ins_AD	// RA = dst, RD = hbits|asize
+    |  lg L:RB, SAVE_L
+    |  stg BASE, L:RB->base
+    |  lg RA, (DISPATCH_GL(gc.total))(DISPATCH)
+    |  clg RA, (DISPATCH_GL(gc.threshold))(DISPATCH)
+    |  stg PC, SAVE_PC
+    |  jhe >5
+    |1:
+    |  srlg CARG3, RD, 11
+    |  llill TMPR0, 0x7ff
+    |  nr RD, TMPR0
+    |  cr RD, TMPR0
+    |  je >3
+    |2:
+    |  lgr L:CARG1, L:RB
+    |  llgfr CARG2, RD
+    |  brasl r14, extern lj_tab_new  // (lua_State *L, uint32_t asize, uint32_t hbits)
+    |  // Table * returned in r2 (CRET1).
+    |  lg BASE, L:RB->base
+    |  llgc RA, PC_RA
+    |  sllg RA, RA, 3
+    |  settp TAB:CRET1, LJ_TTAB
+    |  stg TAB:CRET1, 0(RA, BASE)
+    |  ins_next
+    |3:  // Turn 0x7ff into 0x801.
+    |  llill RD, 0x801
+    |  j <2
+    |5:
+    |  lgr L:CARG1, L:RB
+    |  brasl r14, extern lj_gc_step_fixtop	// (lua_State *L)
+    |  llgh RD, PC_RD
+    |  j <1
+    break;
+  case BC_TDUP:
+    |  ins_AND	// RA = dst, RD = table const (~) (holding template table)
+    |  lg L:RB, SAVE_L
+    |  lg RA, (DISPATCH_GL(gc.total))(DISPATCH)
+    |  stg PC, SAVE_PC
+    |  clg RA, (DISPATCH_GL(gc.threshold))(DISPATCH)
+    |  stg BASE, L:RB->base
+    |  jhe >3
+    |2:
+    |  sllg RD, RD, 3
+    |  lg TAB:CARG2, 0(RD, KBASE)
+    |  lgr L:CARG1, L:RB
+    |  brasl r14, extern lj_tab_dup		// (lua_State *L, Table *kt)
+    |  // Table * returned in r2 (CRET1).
+    |  lg BASE, L:RB->base
+    |  llgc RA, PC_RA
+    |  settp TAB:CRET1, LJ_TTAB
+    |  sllg RA, RA, 3
+    |  stg TAB:CRET1, 0(RA, BASE)
+    |  ins_next
+    |3:
+    |  lgr L:CARG1, L:RB
+    |  brasl r14, extern lj_gc_step_fixtop	// (lua_State *L)
+    |  llgh RD, PC_RD				// Need to reload RD.
+    |  lghi TMPR0, -1
+    |  xgr RD, TMPR0				// not RD
+    |  j <2
+    break;
+
+  case BC_GGET:
+    |  ins_AND	// RA = dst, RD = str const (~)
+    |  lg LFUNC:RB, -16(BASE)
+    |  cleartp LFUNC:RB
+    |  lg TAB:RB, LFUNC:RB->env
+    |  sllg TMPR1, RD, 3
+    |  lg STR:RC, 0(TMPR1, KBASE)
+    |  j ->BC_TGETS_Z
+    break;
+  case BC_GSET:
+    |  ins_AND	// RA = src, RD = str const (~)
+    |  lg LFUNC:RB, -16(BASE)
+    |  cleartp LFUNC:RB
+    |  lg TAB:RB, LFUNC:RB->env
+    |  sllg TMPR1, RD, 3
+    |  lg STR:RC, 0(TMPR1, KBASE)
+    |  j ->BC_TSETS_Z
+    break;
+
+  case BC_TGETV:
+    |  ins_ABC	// RA = dst, RB = table, RC = key
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  sllg RC, RC, 3
+    |  lg RC, 0(RC, BASE)
+    |  checktab TAB:RB, ->vmeta_tgetv
+    |
+    |  // Integer key?
+    |  checkint RC, >5
+    |  cl RC, TAB:RB->asize		// Takes care of unordered, too.
+    |  jhe ->vmeta_tgetv		// Not in array part? Use fallback.
+    |  llgfr RC, RC
+    |  sllg RC, RC, 3
+    |  ag RC, TAB:RB->array
+    |  // Get array slot.
+    |  lg ITYPE, 0(RC)
+    |  cghi ITYPE, LJ_TNIL		// Avoid overwriting RB in fastpath.
+    |  je >2
+    |1:
+    |  sllg RA, RA, 3
+    |  stg ITYPE, 0(RA, BASE)
+    |  ins_next
+    |
+    |2:  // Check for __index if table value is nil.
+    |  lg TAB:TMPR1, TAB:RB->metatable
+    |  cghi TAB:TMPR1, 0
+    |  je <1
+    |  tm TAB:TMPR1->nomm, 1<<MM_index
+    |  je ->vmeta_tgetv			// 'no __index' flag NOT set: check.
+    |  j <1
+    |
+    |5:  // String key?
+    |  cghi ITYPE, LJ_TSTR; jne ->vmeta_tgetv
+    |  cleartp STR:RC
+    |  j ->BC_TGETS_Z
+    break;
+  case BC_TGETS:
+    |  ins_ABC
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  lghi TMPR1, -1
+    |  xgr RC, TMPR1
+    |  sllg RC, RC, 3
+    |  lg STR:RC, 0(RC, KBASE)
+    |  checktab TAB:RB, ->vmeta_tgets
+    |->BC_TGETS_Z:	// RB = GCtab *, RC = GCstr *
+    |  l TMPR1, TAB:RB->hmask
+    |  n TMPR1, STR:RC->sid
+    |  lgfr TMPR1, TMPR1
+    |  mghi TMPR1, #NODE
+    |  ag NODE:TMPR1, TAB:RB->node
+    |  settp ITYPE, STR:RC, LJ_TSTR
+    |1:
+    |  cg ITYPE, NODE:TMPR1->key
+    |  jne >4
+    |  // Get node value.
+    |  lg ITYPE, NODE:TMPR1->val
+    |  cghi ITYPE, LJ_TNIL
+    |  je >5				// Key found, but nil value?
+    |2:
+    |  sllg RA, RA, 3
+    |  stg ITYPE, 0(RA, BASE)
+    |  ins_next
+    |
+    |4:  // Follow hash chain.
+    |  lg NODE:TMPR1, NODE:TMPR1->next
+    |  cghi NODE:TMPR1, 0
+    |  jne <1
+    |  // End of hash chain: key not found, nil result.
+    |  lghi ITYPE, LJ_TNIL
+    |
+    |5:  // Check for __index if table value is nil.
+    |  lg TAB:TMPR1, TAB:RB->metatable
+    |  cghi TAB:TMPR1, 0
+    |  je <2				// No metatable: done.
+    |  tm TAB:TMPR1->nomm, 1<<MM_index
+    |  jne <2				// 'no __index' flag set: done.
+    |  j ->vmeta_tgets			// Caveat: preserve STR:RC.
+    break;
+  case BC_TGETB:
+    |  ins_ABC	// RA = dst, RB = table, RC = byte literal
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  checktab TAB:RB, ->vmeta_tgetb
+    |  cl RC, TAB:RB->asize
+    |  jhe ->vmeta_tgetb
+    |  sllg RC, RC, 3
+    |  ag RC, TAB:RB->array
+    |  // Get array slot.
+    |  lg ITYPE, 0(RC)
+    |  cghi ITYPE, LJ_TNIL
+    |  je >2
+    |1:
+    |  sllg RA, RA, 3
+    |  stg ITYPE, 0(RA, BASE)
+    |  ins_next
+    |
+    |2:  // Check for __index if table value is nil.
+    |  lg TAB:TMPR1, TAB:RB->metatable
+    |  cghi TAB:TMPR1, 0
+    |  je <1
+    |  tm TAB:TMPR1->nomm, 1<<MM_index
+    |  je ->vmeta_tgetb			// 'no __index' flag NOT set: check.
+    |  j <1
+    break;
+  case BC_TGETR:
+    |  ins_ABC	// RA = dst, RB = table, RC = key
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  cleartp TAB:RB
+    |  sllg RC, RC, 3
+    |  llgf RC, 4(RC, BASE)		// Load low word (big endian).
+    |  cl RC, TAB:RB->asize
+    |  jhe ->vmeta_tgetr		// Not in array part? Use fallback.
+    |  sllg RC, RC, 3
+    |  ag RC, TAB:RB->array
+    |  // Get array slot.
+    |->BC_TGETR_Z:
+    |  lg ITYPE, 0(RC)
+    |->BC_TGETR2_Z:
+    |  sllg RA, RA, 3
+    |  stg ITYPE, 0(RA, BASE)
+    |  ins_next
+    break;
+
+  case BC_TSETV:
+    |  ins_ABC	// RA = src, RB = table, RC = key
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  sllg RC, RC, 3
+    |  lg RC, 0(RC, BASE)
+    |  checktab TAB:RB, ->vmeta_tsetv
+    |
+    |  // Integer key?
+    |  checkint RC, >5
+    |  cl RC, TAB:RB->asize		// Takes care of unordered, too.
+    |  jhe ->vmeta_tsetv
+    |  llgfr RC, RC
+    |  sllg RC, RC, 3
+    |  ag RC, TAB:RB->array
+    |  lghi TMPR0, LJ_TNIL
+    |  cg TMPR0, 0(RC)
+    |  je >3				// Previous value is nil?
+    |1:
+    |  tm TAB:RB->marked, LJ_GC_BLACK	// isblack(table)
+    |  jne >7
+    |2:  // Set array slot.
+    |  sllg RA, RA, 3
+    |  lg RB, 0(RA, BASE)
+    |  stg RB, 0(RC)
+    |  ins_next
+    |
+    |3:  // Check for __newindex if previous value is nil.
+    |  lg TAB:TMPR1, TAB:RB->metatable
+    |  cghi TAB:TMPR1, 0
+    |  je <1
+    |  tm TAB:TMPR1->nomm, 1<<MM_newindex
+    |  je ->vmeta_tsetv			// 'no __newindex' flag NOT set: check.
+    |  j <1
+    |
+    |5:  // String key?
+    |  cghi ITYPE, LJ_TSTR; jne ->vmeta_tsetv
+    |  cleartp STR:RC
+    |  j ->BC_TSETS_Z
+    |
+    |7:  // Possible table write barrier for the value. Skip valiswhite check.
+    |  barrierback TAB:RB, TMPR1
+    |  j <2
+    break;
+  case BC_TSETS:
+    |  ins_ABC	// RA = src, RB = table, RC = str const (~)
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  lghi TMPR0, -1
+    |  xgr RC, TMPR0 // ~RC
+    |  sllg RC, RC, 3
+    |  lg STR:RC, 0(RC, KBASE)
+    |  checktab TAB:RB, ->vmeta_tsets
+    |->BC_TSETS_Z:	// RB = GCtab *, RC = GCstr *
+    |  l TMPR1, TAB:RB->hmask
+    |  n TMPR1, STR:RC->sid
+    |  lgfr TMPR1, TMPR1
+    |  mghi TMPR1, #NODE
+    |  mvi TAB:RB->nomm, 0		// Clear metamethod cache.
+    |  ag NODE:TMPR1, TAB:RB->node
+    |  settp ITYPE, STR:RC, LJ_TSTR
+    |1:
+    |  cg ITYPE, NODE:TMPR1->key
+    |  jne >5
+    |  // Ok, key found. Assumes: offsetof(Node, val) == 0
+    |  lghi TMPR0, LJ_TNIL
+    |  cg TMPR0, 0(TMPR1)
+    |  je >4				// Previous value is nil?
+    |2:
+    |  tm TAB:RB->marked, LJ_GC_BLACK	// isblack(table)
+    |  jne >7
+    |3:  // Set node value.
+    |  sllg RA, RA, 3
+    |  lg ITYPE, 0(RA, BASE)
+    |  stg ITYPE, 0(TMPR1)
+    |  ins_next
+    |
+    |4:  // Check for __newindex if previous value is nil.
+    |  lg TAB:ITYPE, TAB:RB->metatable
+    |  cghi TAB:ITYPE, 0
+    |  je <2
+    |  tm TAB:ITYPE->nomm, 1<<MM_newindex
+    |  je ->vmeta_tsets			// 'no __newindex' flag NOT set: check.
+    |  j <2
+    |
+    |5:  // Follow hash chain.
+    |  lg NODE:TMPR1, NODE:TMPR1->next
+    |  cghi NODE:TMPR1, 0
+    |  jne <1
+    |  // End of hash chain: key not found, add a new one.
+    |
+    |  // But check for __newindex first.
+    |  lg TAB:TMPR1, TAB:RB->metatable
+    |  cghi TAB:TMPR1, 0
+    |  je >6				// No metatable: continue.
+    |  tm TAB:TMPR1->nomm, 1<<MM_newindex
+    |  je ->vmeta_tsets			// 'no __newindex' flag NOT set: check.
+    |6:
+    |  stg ITYPE, SAVE_TMP
+    |  lg L:CARG1, SAVE_L
+    |  stg BASE, L:CARG1->base
+    |  la CARG3, SAVE_TMP
+    |  lgr CARG2, TAB:RB
+    |  stg PC, SAVE_PC
+    |  brasl r14, extern lj_tab_newkey	// (lua_State *L, GCtab *t, TValue *k)
+    |  // Handles write barrier for the new key. TValue * returned in r2 (CRET1).
+    |  lgr TMPR1, CRET1
+    |  lg L:CRET1, SAVE_L
+    |  lg BASE, L:CRET1->base
+    |  llgc RA, PC_RA
+    |  j <2				// Must check write barrier for value.
+    |
+    |7:  // Possible table write barrier for the value. Skip valiswhite check.
+    |  barrierback TAB:RB, ITYPE
+    |  j <3
+    break;
+  case BC_TSETB:
+    |  ins_ABC	// RA = src, RB = table, RC = byte literal
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  checktab TAB:RB, ->vmeta_tsetb
+    |  cl RC, TAB:RB->asize
+    |  jhe ->vmeta_tsetb
+    |  sllg RC, RC, 3
+    |  ag RC, TAB:RB->array
+    |  lghi TMPR0, LJ_TNIL
+    |  cg TMPR0, 0(RC)
+    |  je >3				// Previous value is nil?
+    |1:
+    |  tm TAB:RB->marked, LJ_GC_BLACK		// isblack(table)
+    |  jne >7
+    |2:	 // Set array slot.
+    |  sllg RA, RA, 3
+    |  lg ITYPE, 0(RA, BASE)
+    |  stg ITYPE, 0(RC)
+    |  ins_next
+    |
+    |3:  // Check for __newindex if previous value is nil.
+    |  lg TAB:TMPR1, TAB:RB->metatable
+    |  cghi TAB:TMPR1, 0
+    |  je <1
+    |  tm TAB:TMPR1->nomm, 1<<MM_newindex
+    |  je ->vmeta_tsetb			// 'no __newindex' flag NOT set: check.
+    |  j <1
+    |
+    |7:  // Possible table write barrier for the value. Skip valiswhite check.
+    |  barrierback TAB:RB, TMPR1
+    |  j <2
+    break;
+  case BC_TSETR:
+    |  ins_ABC	// RA = src, RB = table, RC = key
+    |  sllg RB, RB, 3
+    |  lg TAB:RB, 0(RB, BASE)
+    |  cleartp TAB:RB
+    |  sllg RC, RC, 3
+    |  lg RC, 0(RC, BASE)
+    |  tm TAB:RB->marked, LJ_GC_BLACK			// isblack(table)
+    |  jne >7
+    |2:
+    |  cl RC, TAB:RB->asize
+    |  jhe ->vmeta_tsetr
+    |  llgfr RC, RC
+    |  sllg RC, RC, 3
+    |  ag RC, TAB:RB->array
+    |  // Set array slot.
+    |->BC_TSETR_Z:
+    |  sllg RA, RA, 3
+    |  lg ITYPE, 0(RA, BASE)
+    |  stg ITYPE, 0(RC)
+    |  ins_next
+    |
+    |7:  // Possible table write barrier for the value. Skip valiswhite check.
+    |  barrierback TAB:RB, TMPR1
+    |  j <2
+    break;
+
+  case BC_TSETM:
+    |  ins_AD	// RA = base (table at base-1), RD = num const (start index)
+    |1:
+    |  sllg RA, RA, 3
+    |  sllg TMPR1, RD, 3
+    |  llgf TMPR1, 4(TMPR1, KBASE)	// Integer constant is in lo-word.
+    |  la RA, 0(RA, BASE)
+    |  lg TAB:RB, -8(RA)		// Guaranteed to be a table.
+    |  cleartp TAB:RB
+    |  tm TAB:RB->marked, LJ_GC_BLACK		// isblack(table)
+    |  jne >7
+    |2:
+    |  llgf RD, SAVE_MULTRES
+    |  aghi RD, -1
+    |  je >4				// Nothing to copy?
+    |  agr RD, TMPR1			// Compute needed size.
+    |  clgf RD, TAB:RB->asize
+    |  jh >5				// Doesn't fit into array part?
+    |  sgr RD, TMPR1
+    |  sllg TMPR1, TMPR1, 3
+    |  ag TMPR1, TAB:RB->array
+    |3:  // Copy result slots to table.
+    |  lg RB, 0(RA)
+    |  la RA, 8(RA)
+    |  stg RB, 0(TMPR1)
+    |  la TMPR1, 8(TMPR1)
+    |  brctg RD, <3
+    |4:
+    |  ins_next
+    |
+    |5:  // Need to resize array part.
+    |  lg L:CARG1, SAVE_L
+    |  stg BASE, L:CARG1->base
+    |  lgr CARG2, TAB:RB
+    |  lgfr CARG3, RD
+    |  lgr L:RB, L:CARG1
+    |  stg PC, SAVE_PC
+    |  brasl r14, extern lj_tab_reasize	// (lua_State *L, GCtab *t, int nasize)
+    |  lg BASE, L:RB->base
+    |  llgc RA, PC_RA			// Restore RA.
+    |  llgh RD, PC_RD			// Restore RD.
+    |  j <1				// Retry.
+    |
+    |7:  // Possible table write barrier for any value. Skip valiswhite check.
+    |  barrierback TAB:RB, RD
+    |  j <2
+    break;
+
+  /* -- Calls and vararg handling ----------------------------------------- */
+
+  case BC_CALL: case BC_CALLM:
+    |  ins_A_C	// RA = base, (RB = nresults+1,) RC = nargs+1 | extra_nargs
+    |  sllg RA, RA, 3
+    |  lgr RD, RC
+    if (op == BC_CALLM) {
+      |  agf NARGS:RD, SAVE_MULTRES
+    }
+    |  lg LFUNC:RB, 0(RA, BASE)
+    |  checkfunc LFUNC:RB, ->vmeta_call_ra
+    |  la BASE, 16(RA, BASE)
+    |  ins_call
+    break;
+
+  case BC_CALLMT:
+    |  ins_AD	// RA = base, RD = extra_nargs
+    |  a NARGS:RD, SAVE_MULTRES
+    |  // Fall through. Assumes BC_CALLT follows and ins_AD is a no-op.
+    break;
+  case BC_CALLT:
+    |  ins_AD	// RA = base, RD = nargs+1
+    |  sllg RA, RA, 3
+    |  la RA, 16(RA, BASE)
+    |  lgr KBASE, BASE			// Use KBASE for move + vmeta_call hint.
+    |  lg LFUNC:RB, -16(RA)
+    |  checktp_nc LFUNC:RB, LJ_TFUNC, ->vmeta_call
+    |->BC_CALLT_Z:
+    |  lg PC, -8(BASE)
+    |  tmll PC, FRAME_TYPE
+    |  jne >7
+    |1:
+    |  stg LFUNC:RB, -16(BASE)		// Copy func+tag down, reloaded below.
+    |  st NARGS:RD, SAVE_MULTRES
+    |  aghi NARGS:RD, -1
+    |  je >3
+    |2:  // Move args down.
+    |  lg RB, 0(RA)
+    |  la RA, 8(RA)
+    |  stg RB, 0(KBASE)
+    |  la KBASE, 8(KBASE)
+    |  brctg NARGS:RD, <2
+    |
+    |  lg LFUNC:RB, -16(BASE)
+    |3:
+    |  cleartp LFUNC:RB
+    |  llgf NARGS:RD, SAVE_MULTRES
+    |  llgc TMPR1, LFUNC:RB->ffid
+    |  cghi TMPR1, 1			// (> FF_C) Calling a fast function?
+    |  jh >5
+    |4:
+    |  ins_callt
+    |
+    |5:  // Tailcall to a fast function.
+    |  tmll PC, FRAME_TYPE		// Lua frame below?
+    |  jne <4
+    |  llgc RA, PC_RA
+    |  lcgr RA, RA
+    |  sllg RA, RA, 3
+    |  lg LFUNC:KBASE, -32(RA, BASE)	// Need to prepare KBASE.
+    |  cleartp LFUNC:KBASE
+    |  lg KBASE, LFUNC:KBASE->pc
+    |  lg KBASE, (PC2PROTO(k))(KBASE)
+    |  j <4
+    |
+    |7:  // Tailcall from a vararg function.
+    |  aghi PC, -FRAME_VARG
+    |  tmll PC, FRAME_TYPEP
+    |  jne >8				// Vararg frame below?
+    |  sgr BASE, PC			// Need to relocate BASE/KBASE down.
+    |  lgr KBASE, BASE
+    |  lg PC, -8(BASE)
+    |  j <1
+    |8:
+    |  aghi PC, FRAME_VARG
+    |  j <1
+    break;
+
+  case BC_ITERC:
+    |  ins_A	// RA = base, (RB = nresults+1,) RC = nargs+1 (2+1)
+    |  sllg RA, RA, 3
+    |  la RA, 16(RA, BASE)		// fb = base+2
+    |  lg RB, -32(RA)			// Copy state. fb[0] = fb[-4].
+    |  lg RC, -24(RA)			// Copy control var. fb[1] = fb[-3].
+    |  stg RB, 0(RA)
+    |  stg RC, 8(RA)
+    |  lg LFUNC:RB, -40(RA)		// Copy callable. fb[-2] = fb[-5]
+    |  stg LFUNC:RB, -16(RA)
+    |  lghi NARGS:RD, 2+1		// Handle like a regular 2-arg call.
+    |  checkfunc LFUNC:RB, ->vmeta_call
+    |  lgr BASE, RA
+    |  ins_call
+    break;
+
+  case BC_ITERN:
+    |.if JIT
+    |  hotloop RB // NYI: add hotloop, record BC_ITERN.
+    |.endif
+    |->vm_IITERN:
+    |  ins_A	// RA = base, (RB = nresults+1, RC = nargs+1 (2+1))
+    |  sllg RA, RA, 3
+    |  lg TAB:RB, -16(RA, BASE)
+    |  cleartp TAB:RB
+    |  llgf RC, -4(RA, BASE)		// Get index from control var.
+    |  llgf TMPR1, TAB:RB->asize
+    |  la PC, 4(PC)
+    |  lg ITYPE, TAB:RB->array
+    |1:  // Traverse array part.
+    |  clr RC, TMPR1; jhe >5		// Index points after array part?
+    |  sllg RD, RC, 3		// Warning: won't work if RD==RC!
+    |  lg TMPR0, 0(RD, ITYPE)
+    |  cghi TMPR0, LJ_TNIL;  je >4
+    |  // Copy array slot to returned value.
+    |  lgr RB, TMPR0
+    |  stg RB, 8(RA, BASE)
+    |  // Return array index as a numeric key.
+    |  setint ITYPE, RC
+    |  stg ITYPE, 0(RA, BASE)
+    |  ahi RC, 1
+    |  sty RC, -4(RA, BASE)		// Update control var.
+    |2:
+    |  llgh RD, PC_RD			// Get target from ITERL.
+    |  branchPC RD
+    |3:
+    |  ins_next
+    |
+    |4:  // Skip holes in array part.
+    |  ahi RC, 1
+    |  j <1
+    |
+    |5:  // Traverse hash part.
+    |  sr RC, TMPR1
+    |6:
+    |  cl RC, TAB:RB->hmask; jh <3	// End of iteration? Branch to ITERL+1.
+    |  llgfr ITYPE, RC
+    |  mghi ITYPE, #NODE
+    |  ag NODE:ITYPE, TAB:RB->node
+    |  lghi TMPR0, LJ_TNIL
+    |  cg TMPR0, NODE:ITYPE->val; je >7
+    |  ar TMPR1, RC
+    |  ahi TMPR1, 1
+    |  // Copy key and value from hash slot.
+    |  lg RB, NODE:ITYPE->key
+    |  lg RC, NODE:ITYPE->val
+    |  stg RB, 0(RA, BASE)
+    |  stg RC, 8(RA, BASE)
+    |  sty TMPR1, -4(RA, BASE)
+    |  j <2
+    |
+    |7:  // Skip holes in hash part.
+    |  ahi RC, 1
+    |  j <6
+    break;
+
+  case BC_ISNEXT:
+    |  ins_AD	// RA = base, RD = target (points to ITERN)
+    |  sllg RA, RA, 3
+    |  lg CFUNC:RB, -24(RA, BASE)
+    |  checkfunc CFUNC:RB, >5
+    |  lg TMPR1, -16(RA, BASE)
+    |  checktptp TMPR1, LJ_TTAB, >5
+    |  lghi TMPR0, LJ_TNIL
+    |  cg TMPR0, -8(RA, BASE); jne >5
+    |  llgc TMPR1, CFUNC:RB->ffid
+    |  clfi TMPR1, (uint8_t)FF_next_N; jne >5
+    |  branchPC RD
+    |  llihl TMPR1, 0x7fff
+    |  iihh TMPR1, 0xfffe
+    |  stg TMPR1, -8(RA, BASE)		// Initialize control var.
+    |1:
+    |  ins_next
+    |5:  // Despecialize bytecode if any of the checks fail.
+    |  lghi TMPR0, BC_JMP
+    |  stcy  TMPR0, PC_OP
+    |  branchPC RD
+    |  mvi 3(PC), BC_ITERC
+    |  j <1
+    break;
+
+  case BC_VARG:
+    |  ins_ABC	// RA = base, RB = nresults+1, RC = numparams
+    |  sllg RA, RA, 3
+    |  sllg RB, RB, 3
+    |  sllg RC, RC, 3
+    |  la TMPR1, (16+FRAME_VARG)(RC, BASE)
+    |  la RA, 0(RA, BASE)
+    |  sg TMPR1, -8(BASE)
+    |  // Note: TMPR1 may now be even _above_ BASE if nargs was < numparams.
+    |  cghi RB, 0
+    |  je >5				// Copy all varargs?
+    |  lay RB, -8(RA, RB)
+    |  clgr TMPR1, BASE			// No vararg slots?
+    |  lghi TMPR0, LJ_TNIL
+    |  jnl >2
+    |1:  // Copy vararg slots to destination slots.
+    |  lg RC, -16(TMPR1)
+    |  la TMPR1, 8(TMPR1)
+    |  stg RC, 0(RA)
+    |  la RA, 8(RA)
+    |  clgr RA, RB			// All destination slots filled?
+    |  jnl >3
+    |  clgr TMPR1, BASE			// No more vararg slots?
+    |  jl <1
+    |2:  // Fill up remainder with nil.
+    |  stg TMPR0, 0(RA)
+    |  la RA, 8(RA)
+    |  clgr RA, RB
+    |  jl <2
+    |3:
+    |  ins_next
+    |
+    |5:  // Copy all varargs.
+    |  lghi TMPR0, 1
+    |  st TMPR0, SAVE_MULTRES		// MULTRES = 0+1
+    |  lgr RC, BASE
+    |  slgr RC, TMPR1
+    |  jno <3				// No vararg slots? (borrow or zero)
+    |  llgfr RB, RC
+    |  srlg RB, RB, 3
+    |  ahi RB, 1
+    |  st RB, SAVE_MULTRES		// MULTRES = #varargs+1
+    |  lg L:RB, SAVE_L
+    |  agr RC, RA
+    |  clg RC, L:RB->maxstack
+    |  jh >7				// Need to grow stack?
+    |6:  // Copy all vararg slots.
+    |  lg RC, -16(TMPR1)
+    |  la TMPR1, 8(TMPR1)
+    |  stg RC, 0(RA)
+    |  la RA, 8(RA)
+    |  clgr TMPR1, BASE			// No more vararg slots?
+    |  jl <6
+    |  j <3
+    |
+    |7:  // Grow stack for varargs.
+    |  stg BASE, L:RB->base
+    |  stg RA, L:RB->top
+    |  stg PC, SAVE_PC
+    |  sgr TMPR1, BASE			// Need delta, because BASE may change.
+    |  st TMPR1, SAVE_TMP_HI
+    |  llgf CARG2, SAVE_MULTRES
+    |  aghi CARG2, -1
+    |  lgr CARG1, L:RB
+    |  brasl r14, extern lj_state_growstack	// (lua_State *L, int n)
+    |  lg BASE, L:RB->base
+    |  lgf TMPR1, SAVE_TMP_HI
+    |  lg RA, L:RB->top
+    |  agr TMPR1, BASE
+    |  j <6
+    break;
+
+  /* -- Returns ----------------------------------------------------------- */
+
+  case BC_RETM:
+    |  ins_AD	// RA = results, RD = extra_nresults
+    |  agf RD, SAVE_MULTRES			// MULTRES >=1, so RD >=1.
+    |  // Fall through. Assumes BC_RET follows and ins_AD is a no-op.
+    break;
+
+  case BC_RET: case BC_RET0: case BC_RET1:
+    |  ins_AD	// RA = results, RD = nresults+1
+    if (op != BC_RET0) {
+      |  sllg RA, RA, 3
+    }
+    |1:
+    |  lg PC, -8(BASE)
+    |  st RD, SAVE_MULTRES		// Save nresults+1.
+    |  tmll PC, FRAME_TYPE		// Check frame type marker.
+    |  jne >7				// Not returning to a fixarg Lua func?
+    switch (op) {
+    case BC_RET:
+      |->BC_RET_Z:
+      |  lgr KBASE, BASE		// Use KBASE for result move.
+      |  aghi RD, -1
+      |  je >3
+      |2:  // Move results down.
+      |  lg RB, 0(KBASE, RA)
+      |  stg RB, -16(KBASE)
+      |  la KBASE, 8(KBASE)
+      |  brctg RD, <2
+      |3:
+      |  llgf RD, SAVE_MULTRES		// Note: MULTRES may be >256.
+      |  llgc RB, PC_RB
+      |5:
+      |  cgr RB, RD			// More results expected?
+      |  jh >6
+      break;
+    case BC_RET1:
+      |  lg RB, 0(BASE, RA)
+      |  stg RB, -16(BASE)
+      /* fallthrough */
+    case BC_RET0:
+      |5:
+      |  llgc TMPR1, PC_RB
+      |  cgr TMPR1, RD
+      |  jh >6
+    default:
+      break;
+    }
+    |  llgc RA, PC_RA
+    |  lcgr RA, RA
+    |  sllg RA, RA, 3
+    |  lay BASE, -16(RA, BASE)		// base = base - (RA+2)*8
+    |  lg LFUNC:KBASE, -16(BASE)
+    |  cleartp LFUNC:KBASE
+    |  lg KBASE, LFUNC:KBASE->pc
+    |  lg KBASE, PC2PROTO(k)(KBASE)
+    |  ins_next
+    |
+    |6:  // Fill up results with nil.
+    |  lghi TMPR1, LJ_TNIL
+    if (op == BC_RET) {
+      |  stg TMPR1, -16(KBASE)		// Note: relies on shifted base.
+      |  la KBASE, 8(KBASE)
+    } else {
+      |  sllg RC, RD, 3 		// RC used as temp.
+      |  stg TMPR1, -24(RC, BASE)
+    }
+    |  la RD, 1(RD)
+    |  j <5
+    |
+    |7:  // Non-standard return case.
+    |  lay RB, -FRAME_VARG(PC)
+    |  tmll RB, FRAME_TYPEP
+    |  jne ->vm_return
+    |  // Return from vararg function: relocate BASE down and RA up.
+    |  sgr BASE, RB
+    if (op != BC_RET0) {
+      |  agr RA, RB
+    }
+    |  j <1
+    break;
+
+  /* -- Loops and branches ------------------------------------------------ */
+
+  |.define FOR_IDX,  0(RA)
+  |.define FOR_STOP, 8(RA)
+  |.define FOR_STEP, 16(RA)
+  |.define FOR_EXT,  24(RA)
+
+  case BC_FORL:
+  {
+    |.if JIT
+    |  hotloop RB
+    |.endif
+    | // Fall through. Assumes BC_IFORL follows and ins_AJ is a no-op.
+    break;
+  }
+
+  case BC_JFORI:
+  case BC_JFORL:
+#if !LJ_HASJIT
+    break;
+#endif
+  case BC_FORI:
+  case BC_IFORL:
+    vk = (op == BC_IFORL || op == BC_JFORL);
+    |  ins_AJ	// RA = base, RD = target (after end of loop or start of loop)
+    |  sllg RA, RA, 3
+    |  la RA, 0(RA, BASE)
+    |  lg RB, FOR_IDX
+    |  checkint RB, >9
+    |  lg TMPR1, FOR_STOP
+    if (!vk) {
+      |  checkint TMPR1, ->vmeta_for
+      |  lg ITYPE, FOR_STEP
+      |  chi ITYPE, 0; jl >5
+      |  srag ITYPE, ITYPE, 47
+      |  cghi ITYPE, LJ_TISNUM; jne ->vmeta_for
+    } else {
+#ifdef LUA_USE_ASSERT
+      |  // lg TMPR1, FOR_STOP
+      |  checkinttp TMPR1, ->assert_bad_for_arg_type
+      |  lg TMPR0, FOR_STEP
+      |  checkinttp TMPR0, ->assert_bad_for_arg_type
+#endif
+      |  lg ITYPE, FOR_STEP
+      |  chi ITYPE, 0; jl >5
+      |  ar RB, ITYPE; jo >1
+      |  setint RB
+      |  stg RB, FOR_IDX
+    }
+    |  cr RB, TMPR1
+    |  stg RB, FOR_EXT
+    if (op == BC_FORI) {
+      |  jle >7
+      |1:
+      |6:
+      |  branchPC RD
+    } else if (op == BC_JFORI) {
+      |  branchPC RD
+      |  llgh RD, PC_RD
+      |  jle =>BC_JLOOP
+      |1:
+      |6:
+    } else if (op == BC_IFORL) {
+      |  jh >7
+      |6:
+      |  branchPC RD
+      |1:
+    } else {
+      |  jle =>BC_JLOOP
+      |1:
+      |6:
+    }
+    |7:
+    |  ins_next
+    |
+    |5:  // Invert check for negative step.
+    if (!vk) {
+      |  srag ITYPE, ITYPE, 47
+      |  cghi ITYPE, LJ_TISNUM; jne ->vmeta_for
+    } else {
+      |  ar RB, ITYPE; jo <1
+      |  setint RB
+      |  stg RB, FOR_IDX
+    }
+    |  cr RB, TMPR1
+    |  stg RB, FOR_EXT
+    if (op == BC_FORI) {
+      |  jhe <7
+    } else if (op == BC_JFORI) {
+      |  branchPC RD
+      |  llgh RD, PC_RD
+      |  jhe =>BC_JLOOP
+    } else if (op == BC_IFORL) {
+      |  jl <7
+    } else {
+      |  jhe =>BC_JLOOP
+    }
+    |  j <6
+    |9:  // Fallback to FP variant.
+    if (!vk) {
+      |  jhe ->vmeta_for
+    }
+    if (!vk) {
+      |  lg TMPR0, FOR_STOP
+      |  checknumtp TMPR0, ->vmeta_for
+    } else {
+#ifdef LUA_USE_ASSERT
+      |  lg TMPR0, FOR_STOP
+      |  checknumtp TMPR0, ->assert_bad_for_arg_type
+      |  lg TMPR0, FOR_STEP
+      |  checknumtp TMPR0, ->assert_bad_for_arg_type
+#endif
+    }
+    |  lg RB, FOR_STEP
+    if (!vk) {
+      |  checknum RB, ->vmeta_for
+    }
+    |  ld f0, FOR_IDX
+    |  ld f1, FOR_STOP
+    if (vk) {
+      |  adb f0, FOR_STEP
+      |  std f0, FOR_IDX
+    }
+    |  cghi RB, 0; jl >3
+    |  cdbr f1, f0
+    |1:
+    |  std f0, FOR_EXT
+    if (op == BC_FORI) {
+      |  jnl <7
+    } else if (op == BC_JFORI) {
+      |  branchPC RD
+      |  llgh RD, PC_RD
+      |  jnl =>BC_JLOOP
+    } else if (op == BC_IFORL) {
+      |  jl <7
+    } else {
+      |  jnl =>BC_JLOOP
+    }
+    |  j <6
+    |
+    |3:  // Invert comparison if step is negative.
+    |  cdbr f0, f1
+    |  j <1
+    break;
+
+  case BC_ITERL:
+    |.if JIT
+    |  hotloop RB
+    |.endif
+    | // Fall through. Assumes BC_IITERL follows and ins_AJ is a no-op.
+    break;
+
+  case BC_JITERL:
+#if !LJ_HASJIT
+    break;
+#endif
+  case BC_IITERL:
+    |  ins_AJ	// RA = base, RD = target
+    |  sllg RA, RA, 3
+    |  la RA, 0(RA, BASE)
+    |  lg RB, 0(RA)
+    |  cghi RB, LJ_TNIL; je >1		// Stop if iterator returned nil.
+    if (op == BC_JITERL) {
+      |  stg RB, -8(RA)
+      |  j =>BC_JLOOP
+    } else {
+      |  branchPC RD			// Otherwise save control var + branch.
+      |  stg RB, -8(RA)
+    }
+    |1:
+    |  ins_next
+    break;
+
+  case BC_LOOP:
+    |  ins_A	// RA = base, RD = target (loop extent)
+    |  // Note: RA/RD is only used by trace recorder to determine scope/extent
+    |  // This opcode does NOT jump, it's only purpose is to detect a hot loop.
+    |.if JIT
+    |  hotloop RB
+    |.endif
+    | // Fall through. Assumes BC_ILOOP follows and ins_A is a no-op.
+    break;
+
+  case BC_ILOOP:
+    |  ins_A	// RA = base, RD = target (loop extent)
+    |  ins_next
+    break;
+
+  case BC_JLOOP:
+    |  stg r0, 0
+    |  stg r0, 0
+    break;
+
+  case BC_JMP:
+    |  ins_AJ	// RA = unused, RD = target
+    |  branchPC RD
+    |  ins_next
+    break;
+
+  /* -- Function headers -------------------------------------------------- */
+
+   /*
+   ** Reminder: A function may be called with func/args above L->maxstack,
+   ** i.e. occupying EXTRA_STACK slots. And vmeta_call may add one extra slot,
+   ** too. This means all FUNC* ops (including fast functions) must check
+   ** for stack overflow _before_ adding more slots!
+   */
+
+  case BC_FUNCF:
+    |.if JIT
+    |  stg r0, 0
+    |.endif
+  case BC_FUNCV:  /* NYI: compiled vararg functions. */
+    | // Fall through. Assumes BC_IFUNCF/BC_IFUNCV follow and ins_AD is a no-op.
+    break;
+
+  case BC_JFUNCF:
+#if !LJ_HASJIT
+    break;
+#endif
+  case BC_IFUNCF:
+    |  ins_AD  // BASE = new base, RA = framesize, RD = nargs+1
+    |  lg KBASE, (PC2PROTO(k)-4)(PC)
+    |  lg L:RB, SAVE_L
+    |  sllg RA, RA, 3
+    |  la RA, 0(RA, BASE)		// Top of frame.
+    |  clg RA, L:RB->maxstack
+    |  jh ->vm_growstack_f
+    |  llgc RA, (PC2PROTO(numparams)-4)(PC)
+    |  clgr NARGS:RD, RA		// Check for missing parameters.
+    |  jle >3
+    |2:
+    if (op == BC_JFUNCF) {
+      |  llgh RD, PC_RD
+      |  j =>BC_JLOOP
+    } else {
+      |  ins_next
+    }
+    |
+    |3:  // Clear missing parameters.
+    |  sllg TMPR1, NARGS:RD, 3
+    |  lghi TMPR0, LJ_TNIL
+    |4:
+    |  stg TMPR0, -8(TMPR1, BASE)
+    |  la TMPR1, 8(TMPR1)
+    |  la RD, 1(RD)
+    |  clgr RD, RA
+    |  jle <4
+    |  j <2
+    break;
+
+  case BC_JFUNCV:
+#if !LJ_HASJIT
+    break;
+#endif
+    | stg r0, 0  // NYI: compiled vararg functions
+    break;           /* NYI: compiled vararg functions. */
+
+  case BC_IFUNCV:
+    |  ins_AD  // BASE = new base, RA = framesize, RD = nargs+1
+    |  sllg TMPR1, NARGS:RD, 3
+    |  la RB, (FRAME_VARG+8)(TMPR1)
+    |  la RD, 8(TMPR1, BASE)
+    |  lg LFUNC:KBASE, -16(BASE)
+    |  stg RB, -8(RD)			// Store delta + FRAME_VARG.
+    |  stg LFUNC:KBASE, -16(RD)		// Store copy of LFUNC.
+    |  lg L:RB, SAVE_L
+    |  sllg RA, RA, 3
+    |  la RA, 0(RA, RD)
+    |  cg RA, L:RB->maxstack
+    |  jh ->vm_growstack_v		// Need to grow stack.
+    |  lgr RA, BASE
+    |  lgr BASE, RD
+    |  llgc RB, (PC2PROTO(numparams)-4)(PC)
+    |  cghi RB, 0
+    |  je >2
+    |  aghi RA, 8
+    |  lghi TMPR1, LJ_TNIL
+    |1:  // Copy fixarg slots up to new frame.
+    |  la RA, 8(RA)
+    |  cgr RA, BASE
+    |  jnl >3				// Less args than parameters?
+    |  lg KBASE, -16(RA)
+    |  stg KBASE, 0(RD)
+    |  la RD, 8(RD)
+    |  stg TMPR1, -16(RA)	// Clear old fixarg slot (help the GC).
+    |  brctg RB, <1
+    |2:
+    if (op == BC_JFUNCV) {
+      |  llgh RD, PC_RD
+      |  j =>BC_JLOOP
+    } else {
+      |  lg KBASE, (PC2PROTO(k)-4)(PC)
+      |  ins_next
+    }
+    |
+    |3:  // Clear missing parameters.
+    |  stg TMPR1, 0(RD)			// TMPR1=LJ_TNIL (-1) here.
+    |  la RD, 8(RD)
+    |  brctg RB, <3
+    |  j <2
+    break;
+
+  case BC_FUNCC:
+  case BC_FUNCCW:
+    |  ins_AD  // BASE = new base, RD = nargs+1
+    |  lg CFUNC:RB, -16(BASE)
+    |  cleartp CFUNC:RB
+    |  lg KBASE, CFUNC:RB->f
+    |  lg L:RB, SAVE_L
+    |  sllg RD, NARGS:RD, 3
+    |  lay RD, -8(RD,BASE)
+    |  stg BASE, L:RB->base
+    |  la RA, (8*LUA_MINSTACK)(RD)
+    |  clg RA, L:RB->maxstack
+    |  stg RD, L:RB->top
+    |  lgr CARG1, L:RB
+    if (op != BC_FUNCC) {
+      |  lgr CARG2, KBASE
+    }
+    |  jh ->vm_growstack_c		// Need to grow stack.
+    |  set_vmstate C
+    if (op == BC_FUNCC) {
+      |  basr r14, KBASE		// (lua_State *L)
+    } else {
+      |  // (lua_State *L, lua_CFunction f)
+      |  lg TMPR1, (DISPATCH_GL(wrapf))(DISPATCH)
+      |  basr r14, TMPR1
+    }
+    |  // nresults returned in r2 (CRET1).
+    |  lgr RD, CRET1
+    |  lg BASE, L:RB->base
+    |  stg L:RB, (DISPATCH_GL(cur_L))(DISPATCH)
+    |  set_vmstate INTERP
+    |  sllg TMPR1, RD, 3
+    |  la RA, 0(TMPR1, BASE)
+    |  lcgr RA, RA
+    |  ag RA, L:RB->top			// RA = (L->top-(L->base+nresults))*8
+    |  lg PC, -8(BASE)			// Fetch PC of caller.
+    |  j ->vm_returnc
+    break;
+
+  /* ---------------------------------------------------------------------- */
+
+  default:
+    fprintf(stderr, "Error: undefined opcode BC_%s\n", bc_names[op]);
+    exit(2);
+    break;
+  }
+}
+
+static int build_backend(BuildCtx *ctx)
+{
+  int op;
+  dasm_growpc(Dst, BC__MAX);
+  build_subroutines(ctx);
+  |.code_op
+  for (op = 0; op < BC__MAX; op++)
+    build_ins(ctx, (BCOp)op, op);
+  return BC__MAX;
+}
+
+/* Emit pseudo frame-info for all assembler functions. */
+static void emit_asm_debug(BuildCtx *ctx)
+{
+  int fcofs = (int)((uint8_t *)ctx->glob[GLOB_vm_ffi_call] - ctx->code);
+  switch (ctx->mode) {
+  case BUILD_elfasm:
+    fprintf(ctx->fp, "\t.section .debug_frame,\"\",@progbits\n");
+    fprintf(ctx->fp,
+	".Lframe0:\n"
+	"\t.long .LECIE0-.LSCIE0\n"
+	".LSCIE0:\n"
+	"\t.long 0xffffffff\n"
+	"\t.byte 0x1\n"
+	"\t.string \"\"\n"
+	"\t.uleb128 1\n"
+	"\t.sleb128 -8\n"
+	"\t.byte 0xe\n"
+	"\t.byte 0xc\n\t.uleb128 0xf\n\t.uleb128 160\n"
+	"\t.align 8\n"
+	".LECIE0:\n\n");
+    fprintf(ctx->fp,
+	".LSFDE0:\n"
+	"\t.long .LEFDE0-.LASFDE0\n"
+	".LASFDE0:\n"
+	"\t.long .Lframe0\n"
+	"\t.quad .Lbegin\n"
+	"\t.quad %d\n"
+	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
+	"\t.byte 0x86\n\t.uleb128 0xe\n"	/* offset r6 */
+	"\t.byte 0x87\n\t.uleb128 0xd\n"	/* offset r7 */
+	"\t.byte 0x88\n\t.uleb128 0xc\n"	/* offset r8 */
+	"\t.byte 0x89\n\t.uleb128 0xb\n"	/* offset r9 */
+	"\t.byte 0x8a\n\t.uleb128 0xa\n"	/* offset r10 */
+	"\t.byte 0x8b\n\t.uleb128 0x9\n"	/* offset r11 */
+	"\t.byte 0x8c\n\t.uleb128 0x8\n"	/* offset r12 */
+	"\t.byte 0x8d\n\t.uleb128 0x7\n"	/* offset r13 */
+	"\t.byte 0x8e\n\t.uleb128 0x6\n"	/* offset r14 */
+	"\t.byte 0x8f\n\t.uleb128 0x5\n"	/* offset r15 */
+	"\t.align 8\n"
+	".LEFDE0:\n\n", fcofs, CFRAME_SIZE+160);
+#if LJ_HASFFI
+    fprintf(ctx->fp,
+	".LSFDE1:\n"
+	"\t.long .LEFDE1-.LASFDE1\n"
+	".LASFDE1:\n"
+	"\t.long .Lframe0\n"
+	"\t.quad lj_vm_ffi_call\n"
+	"\t.quad %d\n"
+	"\t.byte 0xe\n\t.uleb128 160\n"		/* def_cfa_offset */
+	"\t.byte 0xd\n\t.uleb128 0xd\n"		/* def_cfa_register r13 (FP) */
+	"\t.byte 0x86\n\t.uleb128 0xe\n"	/* offset r6 */
+	"\t.byte 0x87\n\t.uleb128 0xd\n"	/* offset r7 */
+	"\t.byte 0x88\n\t.uleb128 0xc\n"	/* offset r8 */
+	"\t.byte 0x89\n\t.uleb128 0xb\n"	/* offset r9 */
+	"\t.byte 0x8a\n\t.uleb128 0xa\n"	/* offset r10 */
+	"\t.byte 0x8b\n\t.uleb128 0x9\n"	/* offset r11 */
+	"\t.byte 0x8c\n\t.uleb128 0x8\n"	/* offset r12 */
+	"\t.byte 0x8d\n\t.uleb128 0x7\n"	/* offset r13 */
+	"\t.byte 0x8e\n\t.uleb128 0x6\n"	/* offset r14 */
+	"\t.byte 0x8f\n\t.uleb128 0x5\n"	/* offset r15 */
+	"\t.align 8\n"
+	".LEFDE1:\n\n", (int)ctx->codesz - fcofs);
+#endif
+#if !LJ_NO_UNWIND
+    fprintf(ctx->fp, "\t.section .eh_frame,\"a\",@progbits\n");
+    fprintf(ctx->fp,
+	".Lframe1:\n"
+	"\t.long .LECIE1-.LSCIE1\n"
+	".LSCIE1:\n"
+	"\t.long 0\n"
+	"\t.byte 0x1\n"
+	"\t.string \"zPR\"\n"
+	"\t.uleb128 0x1\n"
+	"\t.sleb128 -8\n"
+	"\t.byte 0xe\n"
+	"\t.uleb128 6\n"			/* augmentation length */
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.long lj_err_unwind_dwarf-.\n"
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.byte 0xc\n\t.uleb128 0xf\n\t.uleb128 160\n"
+	"\t.align 8\n"
+	".LECIE1:\n\n");
+    fprintf(ctx->fp,
+	".LSFDE2:\n"
+	"\t.long .LEFDE2-.LASFDE2\n"
+	".LASFDE2:\n"
+	"\t.long .LASFDE2-.Lframe1\n"
+	"\t.long .Lbegin-.\n"
+	"\t.long %d\n"
+	"\t.uleb128 0\n"			/* augmentation length */
+	"\t.byte 0xe\n\t.uleb128 %d\n"		/* def_cfa_offset */
+	"\t.byte 0x86\n\t.uleb128 0xe\n"	/* offset r6 */
+	"\t.byte 0x87\n\t.uleb128 0xd\n"	/* offset r7 */
+	"\t.byte 0x88\n\t.uleb128 0xc\n"	/* offset r8 */
+	"\t.byte 0x89\n\t.uleb128 0xb\n"	/* offset r9 */
+	"\t.byte 0x8a\n\t.uleb128 0xa\n"	/* offset r10 */
+	"\t.byte 0x8b\n\t.uleb128 0x9\n"	/* offset r11 */
+	"\t.byte 0x8c\n\t.uleb128 0x8\n"	/* offset r12 */
+	"\t.byte 0x8d\n\t.uleb128 0x7\n"	/* offset r13 */
+	"\t.byte 0x8e\n\t.uleb128 0x6\n"	/* offset r14 */
+	"\t.byte 0x8f\n\t.uleb128 0x5\n"	/* offset r15 */
+	"\t.align 8\n"
+	".LEFDE2:\n\n", fcofs, CFRAME_SIZE+160);
+#if LJ_HASFFI
+    fprintf(ctx->fp,
+	".Lframe2:\n"
+	"\t.long .LECIE2-.LSCIE2\n"
+	".LSCIE2:\n"
+	"\t.long 0\n"
+	"\t.byte 0x1\n"
+	"\t.string \"zR\"\n"
+	"\t.uleb128 0x1\n"
+	"\t.sleb128 -8\n"
+	"\t.byte 0xe\n"
+	"\t.uleb128 1\n"			/* augmentation length */
+	"\t.byte 0x1b\n"			/* pcrel|sdata4 */
+	"\t.byte 0xc\n\t.uleb128 0xf\n\t.uleb128 160\n"
+	"\t.align 8\n"
+	".LECIE2:\n\n");
+    fprintf(ctx->fp,
+	".LSFDE3:\n"
+	"\t.long .LEFDE3-.LASFDE3\n"
+	".LASFDE3:\n"
+	"\t.long .LASFDE3-.Lframe2\n"
+	"\t.long lj_vm_ffi_call-.\n"
+	"\t.long %d\n"
+	"\t.uleb128 0\n"			/* augmentation length */
+	"\t.byte 0xe\n\t.uleb128 160\n"		/* def_cfa_offset */
+	"\t.byte 0xd\n\t.uleb128 0xd\n"		/* def_cfa_register r13 (FP) */
+	"\t.byte 0x86\n\t.uleb128 0xe\n"	/* offset r6 */
+	"\t.byte 0x87\n\t.uleb128 0xd\n"	/* offset r7 */
+	"\t.byte 0x88\n\t.uleb128 0xc\n"	/* offset r8 */
+	"\t.byte 0x89\n\t.uleb128 0xb\n"	/* offset r9 */
+	"\t.byte 0x8a\n\t.uleb128 0xa\n"	/* offset r10 */
+	"\t.byte 0x8b\n\t.uleb128 0x9\n"	/* offset r11 */
+	"\t.byte 0x8c\n\t.uleb128 0x8\n"	/* offset r12 */
+	"\t.byte 0x8d\n\t.uleb128 0x7\n"	/* offset r13 */
+	"\t.byte 0x8e\n\t.uleb128 0x6\n"	/* offset r14 */
+	"\t.byte 0x8f\n\t.uleb128 0x5\n"	/* offset r15 */
+	"\t.align 8\n"
+	".LEFDE3:\n\n", (int)ctx->codesz - fcofs);
+#endif
+#endif
+    break;
+  default:  /* No other modes. */
+    break;
+  }
+}
+
diff --git a/lib/luajit-3065c9/src/vm_x64.dasc b/lib/luajit2/src/vm_x64.dasc
similarity index 98%
rename from lib/luajit-3065c9/src/vm_x64.dasc
rename to lib/luajit2/src/vm_x64.dasc
index 03d96557a..48d6b6118 100644
--- a/lib/luajit-3065c9/src/vm_x64.dasc
+++ b/lib/luajit2/src/vm_x64.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for x64 CPUs in LJ_GC64 mode.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |
 |.arch x64
 |.section code_op, code_sub
@@ -1463,6 +1463,9 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc_1 pcall
+  |  mov L:RB, SAVE_L
+  |  lea RA, [BASE+NARGS:RD*8]
+  |  cmp RA, L:RB->maxstack; ja ->fff_fallback
   |  lea RA, [BASE+16]
   |  sub NARGS:RDd, 1
   |  mov PCd, 16+FRAME_PCALL
@@ -1481,6 +1484,9 @@ static void build_subroutines(BuildCtx *ctx)
   |  jmp ->vm_call_dispatch
   |
   |.ffunc_2 xpcall
+  |  mov L:RB, SAVE_L
+  |  lea RA, [BASE+NARGS:RD*8]
+  |  cmp RA, L:RB->maxstack; ja ->fff_fallback
   |  mov LFUNC:RA, [BASE+8]
   |  checktp_nc LFUNC:RA, LJ_TFUNC, ->fff_fallback
   |  mov LFUNC:RB, [BASE]		// Swap function and traceback.
@@ -2452,8 +2458,21 @@ static void build_subroutines(BuildCtx *ctx)
   |  mov r13, [RA-8]
   |  mov r12, [RA]
   |  mov rsp, RA			// Reposition stack to C frame.
+#ifdef LUA_USE_TRACE_LOGS
+  |  mov CARG1, SAVE_L
+  |  mov L:CARG1->base, BASE
+  |  mov RB, RD     // Save RD
+  |  mov TMP1, PC  // Save PC
+  |  mov CARG3, PC   // CARG3 == BASE
+  |  mov CARG2d, dword [DISPATCH+DISPATCH_GL(vmstate)]
+  |  call extern lj_log_trace_direct_exit@8
+  |  mov PC, TMP1
+  |  mov RD, RB
+  |  mov RB, SAVE_L
+  |  mov BASE, L:RB->base
+#endif
   |.endif
-  |  test RDd, RDd; js >9		// Check for error from exit.
+  |  cmp RDd, -LUA_ERRERR; jae >9	// Check for error from exit.
   |  mov L:RB, SAVE_L
   |  mov MULTRES, RDd
   |  mov LFUNC:KBASE, [BASE-16]
@@ -2469,6 +2488,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  movzx OP, RCL
   |  add PC, 4
   |  shr RCd, 16
+  |  cmp MULTRES, -17			// Static dispatch?
+  |  je >5
   |  cmp OP, BC_FUNCF			// Function header?
   |  jb >3
   |  cmp OP, BC_FUNCC+2			// Fast function?
@@ -2491,6 +2512,15 @@ static void build_subroutines(BuildCtx *ctx)
   |  mov KBASE, [KBASE+PC2PROTO(k)]
   |  jmp <2
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  mov RA, [DISPATCH+DISPATCH_J(trace)]
+  |  mov TRACE:RA, [RA+RD*8]
+  |  mov RCd, TRACE:RA->startins
+  |  movzx RAd, RCH
+  |  movzx OP, RCL
+  |  shr RCd, 16
+  |  jmp aword [DISPATCH+OP*8+GG_DISP2STATIC]
+  |
   |9:  // Rethrow error from the right C frame.
   |  mov CARG2d, RDd
   |  mov CARG1, L:RB
@@ -2744,12 +2774,12 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |  // Copy stack slots.
   |  movzx ecx, byte CCSTATE->nsp
-  |  sub ecx, 1
+  |  sub ecx, 8
   |  js >2
   |1:
-  |  mov rax, [CCSTATE+rcx*8+offsetof(CCallState, stack)]
-  |  mov [rsp+rcx*8+CCALL_SPS_EXTRA*8], rax
-  |  sub ecx, 1
+  |  mov rax, [CCSTATE+rcx+offsetof(CCallState, stack)]
+  |  mov [rsp+rcx+CCALL_SPS_EXTRA*8], rax
+  |  sub ecx, 8
   |  jns <1
   |2:
   |
@@ -4511,6 +4541,19 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_JLOOP:
     |.if JIT
     |  ins_AD	// RA = base (ignored), RD = traceno
+#ifdef LUA_USE_TRACE_LOGS
+    |.if not X64WIN
+    |  mov L:RB, SAVE_L
+    |  mov L:RB->base, BASE  // Save BASE
+    |  mov TMP1, RD     // Save RD
+    |  mov CARG3, PC  // CARG3 == BASE
+    |  mov CARG2, RD
+    |  mov CARG1, RB
+    |  call extern lj_log_trace_entry@8
+    |  mov RD, TMP1
+    |  mov BASE, L:RB->base
+    |.endif
+#endif
     |  mov RA, [DISPATCH+DISPATCH_J(trace)]
     |  mov TRACE:RD, [RA+RD*8]
     |  mov RD, TRACE:RD->mcode
diff --git a/lib/luajit-3065c9/src/vm_x86.dasc b/lib/luajit2/src/vm_x86.dasc
similarity index 98%
rename from lib/luajit-3065c9/src/vm_x86.dasc
rename to lib/luajit2/src/vm_x86.dasc
index 18ca87b54..d3d3d16f3 100644
--- a/lib/luajit-3065c9/src/vm_x86.dasc
+++ b/lib/luajit2/src/vm_x86.dasc
@@ -1,6 +1,6 @@
 |// Low-level VM code for x86 CPUs.
 |// Bytecode interpreter, fast functions and helper functions.
-|// Copyright (C) 2005-2022 Mike Pall. See Copyright Notice in luajit.h
+|// Copyright (C) 2005-2023 Mike Pall. See Copyright Notice in luajit.h
 |
 |.if P64
 |.arch x64
@@ -1369,7 +1369,7 @@ static void build_subroutines(BuildCtx *ctx)
   |  mov LFUNC:RB, [RA-8]
   |  add NARGS:RD, 1
   |  // This is fragile. L->base must not move, KBASE must always be defined.
-  |.if x64
+  |.if X64
   |  cmp KBASEa, rdx			// Continue with CALLT if flag set.
   |.else
   |  cmp KBASE, BASE			// Continue with CALLT if flag set.
@@ -1793,6 +1793,9 @@ static void build_subroutines(BuildCtx *ctx)
   |//-- Base library: catch errors ----------------------------------------
   |
   |.ffunc_1 pcall
+  |  mov L:RB, SAVE_L
+  |  lea RA, [BASE+NARGS:RD*8]
+  |  cmp RA, L:RB->maxstack; ja ->fff_fallback
   |  lea RA, [BASE+8]
   |  sub NARGS:RD, 1
   |  mov PC, 8+FRAME_PCALL
@@ -1804,6 +1807,9 @@ static void build_subroutines(BuildCtx *ctx)
   |  jmp ->vm_call_dispatch
   |
   |.ffunc_2 xpcall
+  |  mov L:RB, SAVE_L
+  |  lea RA, [BASE+NARGS:RD*8]
+  |  cmp RA, L:RB->maxstack; ja ->fff_fallback
   |  cmp dword [BASE+12], LJ_TFUNC;  jne ->fff_fallback
   |  mov RB, [BASE+4]			// Swap function and traceback.
   |  mov [BASE+12], RB
@@ -2902,7 +2908,22 @@ static void build_subroutines(BuildCtx *ctx)
   |  mov r13, TMPa
   |  mov r12, TMPQ
   |.endif
-  |  test RD, RD; js >9			// Check for error from exit.
+#ifdef LUA_USE_TRACE_LOGS
+  |.if X64
+  |  mov FCARG1, SAVE_L
+  |  mov L:FCARG1->base, BASE
+  |  mov RB, RD     // Save RD
+  |  mov TMP1, PC  // Save PC
+  |  mov CARG3d, PC   // CARG3d == BASE
+  |  mov FCARG2, dword [DISPATCH+DISPATCH_GL(vmstate)]
+  |  call extern lj_log_trace_direct_exit@8
+  |  mov PC, TMP1
+  |  mov RD, RB
+  |  mov RB, SAVE_L
+  |  mov BASE, L:RB->base
+  |.endif
+#endif
+  |  cmp RD, -LUA_ERRERR; jae >9	// Check for error from exit.
   |  mov L:RB, SAVE_L
   |  mov MULTRES, RD
   |  mov LFUNC:KBASE, [BASE-8]
@@ -2917,6 +2938,8 @@ static void build_subroutines(BuildCtx *ctx)
   |  movzx OP, RCL
   |  add PC, 4
   |  shr RC, 16
+  |  cmp MULTRES, -17			// Static dispatch?
+  |  je >5
   |  cmp OP, BC_FUNCF			// Function header?
   |  jb >3
   |  cmp OP, BC_FUNCC+2			// Fast function?
@@ -2942,6 +2965,19 @@ static void build_subroutines(BuildCtx *ctx)
   |  mov KBASE, [KBASE+PC2PROTO(k)]
   |  jmp <2
   |
+  |5:  // Dispatch to static entry of original ins replaced by BC_JLOOP.
+  |  mov RA, [DISPATCH+DISPATCH_J(trace)]
+  |  mov TRACE:RA, [RA+RD*4]
+  |  mov RC, TRACE:RA->startins
+  |  movzx RA, RCH
+  |  movzx OP, RCL
+  |  shr RC, 16
+  |.if X64
+  |  jmp aword [DISPATCH+OP*8+GG_DISP2STATIC]
+  |.else
+  |  jmp aword [DISPATCH+OP*4+GG_DISP2STATIC]
+  |.endif
+  |
   |9:  // Rethrow error from the right C frame.
   |  mov FCARG2, RD
   |  mov FCARG1, L:RB
@@ -3299,19 +3335,25 @@ static void build_subroutines(BuildCtx *ctx)
   |
   |  // Copy stack slots.
   |  movzx ecx, byte CCSTATE->nsp
-  |  sub ecx, 1
+  |.if X64
+  |  sub ecx, 8
   |  js >2
   |1:
-  |.if X64
-  |  mov rax, [CCSTATE+rcx*8+offsetof(CCallState, stack)]
-  |  mov [rsp+rcx*8+CCALL_SPS_EXTRA*8], rax
+  |  mov rax, [CCSTATE+rcx+offsetof(CCallState, stack)]
+  |  mov [rsp+rcx+CCALL_SPS_EXTRA*8], rax
+  |  sub ecx, 8
+  |  jns <1
+  |2:
   |.else
-  |  mov eax, [CCSTATE+ecx*4+offsetof(CCallState, stack)]
-  |  mov [esp+ecx*4], eax
-  |.endif
-  |  sub ecx, 1
+  |  sub ecx, 4
+  |  js >2
+  |1:
+  |  mov eax, [CCSTATE+ecx+offsetof(CCallState, stack)]
+  |  mov [esp+ecx], eax
+  |  sub ecx, 4
   |  jns <1
   |2:
+  |.endif
   |
   |.if X64
   |  movzx eax, byte CCSTATE->nfpr
@@ -5305,6 +5347,19 @@ static void build_ins(BuildCtx *ctx, BCOp op, int defop)
   case BC_JLOOP:
     |.if JIT
     |  ins_AD	// RA = base (ignored), RD = traceno
+#ifdef LUA_USE_TRACE_LOGS
+    |.if X64
+    |  mov L:RB, SAVE_L
+    |  mov L:RB->base, BASE  // Save BASE
+    |  mov TMP1, RD     // Save RD
+    |  mov CARG3d, PC  // CARG3d == BASE
+    |  mov FCARG2, RD
+    |  mov FCARG1, RB
+    |  call extern lj_log_trace_entry@8
+    |  mov RD, TMP1
+    |  mov BASE, L:RB->base
+    |.endif
+#endif
     |  mov RA, [DISPATCH+DISPATCH_J(trace)]
     |  mov TRACE:RD, [RA+RD*4]
     |  mov RDa, TRACE:RD->mcode
diff --git a/lib/luajit2/src/x64/Makefile b/lib/luajit2/src/x64/Makefile
new file mode 100644
index 000000000..27277140d
--- /dev/null
+++ b/lib/luajit2/src/x64/Makefile
@@ -0,0 +1,13 @@
+.PHONY: default test benchmark clean
+
+default:
+	@echo "make target include: test bechmark clean"
+
+test:
+	$(MAKE) -C test test
+
+benchmark:
+	$(MAKE) -C test benchmark
+
+clean:
+	$(MAKE) -C test clean
diff --git a/lib/luajit2/src/x64/test/Makefile b/lib/luajit2/src/x64/test/Makefile
new file mode 100644
index 000000000..4326ab3db
--- /dev/null
+++ b/lib/luajit2/src/x64/test/Makefile
@@ -0,0 +1,47 @@
+.PHONY: default test benchmark
+
+default: test benchmark
+
+COMMON_OBJ := test_util.o
+
+TEST_PROGRAM := ht_test
+BENCHMARK_PROGRAM := ht_benchmark
+
+TEST_PROGRAM_OBJ := $(COMMON_OBJ) test.o
+BENCHMARK_PROGRAM_OBJ := $(COMMON_OBJ) benchmark.o
+
+ifeq ($(WITH_VALGRIND), 1)
+    VALGRIND := valgrind --leak-check=full
+else
+    VALGRIND :=
+endif
+
+CXXFLAGS := -O3 -MD -g -msse4.2 -Wall -I../src -I../../../src
+
+%.o: %.cxx
+	$(CXX) $(CXXFLAGS) -MD -c $<
+
+test: $(TEST_PROGRAM)
+	@echo "some unit test"
+	$(VALGRIND) ./$(TEST_PROGRAM)
+
+	@echo "smoke test"
+	../../luajit test_str_comp.lua
+
+benchmark: $(BENCHMARK_PROGRAM)
+	# micro benchmark
+	./$(BENCHMARK_PROGRAM)
+
+$(TEST_PROGRAM) : $(TEST_PROGRAM_OBJ)
+	cat $(TEST_PROGRAM_OBJ:.o=.d) > dep1.txt
+	$(CXX) $+ $(CXXFLAGS) -lm -o $@
+
+$(BENCHMARK_PROGRAM): $(BENCHMARK_PROGRAM_OBJ)
+	cat $(BENCHMARK_PROGRAM_OBJ:.o=.d) > dep2.txt
+	$(CXX) $+ $(CXXFLAGS) -o $@
+
+-include dep1.txt
+-include dep2.txt
+
+clean:
+	-rm -f *.o *.d dep*.txt $(BENCHMARK_PROGRAM) $(TEST_PROGRAM)
diff --git a/lib/luajit2/src/x64/test/benchmark.cxx b/lib/luajit2/src/x64/test/benchmark.cxx
new file mode 100644
index 000000000..1ea8fb6bb
--- /dev/null
+++ b/lib/luajit2/src/x64/test/benchmark.cxx
@@ -0,0 +1,360 @@
+#include <sys/time.h> // for gettimeofday()
+extern "C" {
+#define LUAJIT_SECURITY_STRHASH 1
+#include "../../lj_str.h"
+str_sparse_hashfn hash_sparse;
+str_dense_hashfn hash_dense;
+#include "../../lj_str_hash.c"
+}
+#include <string>
+#include <vector>
+#include <utility>
+#include <algorithm>
+#include "test_util.hpp"
+#include <stdio.h>
+#include <math.h>
+
+using namespace std;
+
+#define lj_rol(x, n) (((x)<<(n)) | ((x)>>(-(int)(n)&(8*sizeof(x)-1))))
+#define lj_ror(x, n) (((x)<<(-(int)(n)&(8*sizeof(x)-1))) | ((x)>>(n)))
+
+const char* separator = "-------------------------------------------";
+
+static uint32_t LJ_AINLINE
+original_hash_sparse(uint64_t seed, const char *str, size_t len)
+{
+  uint32_t a, b, h = len ^ seed;
+  if (len >= 4) {
+    a = lj_getu32(str); h ^= lj_getu32(str+len-4);
+    b = lj_getu32(str+(len>>1)-2);
+    h ^= b; h -= lj_rol(b, 14);
+    b += lj_getu32(str+(len>>2)-1);
+    a ^= h; a -= lj_rol(h, 11);
+    b ^= a; b -= lj_rol(a, 25);
+    h ^= b; h -= lj_rol(b, 16);
+  } else {
+    a = *(const uint8_t *)str;
+    h ^= *(const uint8_t *)(str+len-1);
+    b = *(const uint8_t *)(str+(len>>1));
+    h ^= b; h -= lj_rol(b, 14);
+  }
+
+  a ^= h; a -= lj_rol(h, 11);
+  b ^= a; b -= lj_rol(a, 25);
+  h ^= b; h -= lj_rol(b, 16);
+
+  return h;
+}
+
+static uint32_t original_hash_dense(uint64_t seed, uint32_t h,
+				    const char *str, size_t len)
+{
+  uint32_t b = lj_bswap(lj_rol(h ^ (uint32_t)(seed >> 32), 4));
+  if (len > 12) {
+    uint32_t a = (uint32_t)seed;
+    const char *pe = str+len-12, *p = pe, *q = str;
+    do {
+      a += lj_getu32(p);
+      b += lj_getu32(p+4);
+      h += lj_getu32(p+8);
+      p = q; q += 12;
+      h ^= b; h -= lj_rol(b, 14);
+      a ^= h; a -= lj_rol(h, 11);
+      b ^= a; b -= lj_rol(a, 25);
+    } while (p < pe);
+    h ^= b; h -= lj_rol(b, 16);
+    a ^= h; a -= lj_rol(h, 4);
+    b ^= a; b -= lj_rol(a, 14);
+  }
+  return b;
+}
+
+
+template<class T> double
+BenchmarkHashTmpl(T func, uint64_t seed, char* buf, size_t len)
+{
+  TestClock timer;
+  uint32_t h = 0;
+
+  timer.start();
+  for(int i = 1; i < 1000000 * 100; i++) {
+    // So the buf is not loop invariant, hence the F(...)
+    buf[i % 4096] = i;
+    h += func(seed, buf, len) ^ i;
+  }
+  timer.stop();
+
+  // make h alive
+  test_printf("%x", h);
+  return timer.getElapseInSecond();
+}
+
+struct TestFuncWasSparse
+{
+  uint32_t operator()(uint64_t seed, const char* buf, uint32_t len) {
+    return original_hash_sparse(seed, buf, len);
+  }
+};
+
+struct TestFuncIsSparse
+{
+  uint32_t operator()(uint64_t seed, const char* buf, uint32_t len) {
+    return hash_sparse_sse42(seed, buf, len);
+  }
+};
+
+struct TestFuncWasDense
+{
+  uint32_t operator()(uint64_t seed, const char* buf, uint32_t len) {
+    return original_hash_dense(seed, 42, buf, len);
+  }
+};
+
+struct TestFuncIsDense
+{
+  uint32_t operator()(uint64_t seed, const char* buf, uint32_t len) {
+    return hash_dense_sse42(seed, 42, buf, len);
+  }
+};
+
+static void
+benchmarkIndividual(uint64_t seed, char* buf)
+{
+  fprintf(stdout,"\n\nCompare performance of particular len (in second)\n");
+  fprintf(stdout, "%-12s%-8s%-8s%s%-8s%-8s%s\n", "len",
+	  "was (s)", "is (s)", "diff (s)",
+	  "was (d)", "is (d)", "diff (d)");
+  fprintf(stdout, "-------------------------------------------\n");
+
+  uint32_t lens[] = {3, 4, 7, 10, 15, 16, 20, 32, 36, 63, 80, 100,
+                     120, 127, 280, 290, 400};
+  for (unsigned i = 0; i < sizeof(lens)/sizeof(lens[0]); i++) {
+    uint32_t len = lens[i];
+    double e1 = BenchmarkHashTmpl(TestFuncWasSparse(), seed, buf, len);
+    double e2 = BenchmarkHashTmpl(TestFuncIsSparse(), seed, buf, len);
+    double e3 = BenchmarkHashTmpl(TestFuncWasDense(), seed, buf, len);
+    double e4 = BenchmarkHashTmpl(TestFuncIsDense(), seed, buf, len);
+    fprintf(stdout, "len = %4d: %-7.3lf %-7.3lf %-7.2f%% %-7.3lf %-7.3lf %.2f%%\n",
+	    len, e1, e2, 100*(e1-e2)/e1, e3, e4, 100*(e3-e4)/e3);
+  }
+}
+
+template<class T> double
+BenchmarkChangeLenTmpl(T func, uint64_t seed, char* buf, uint32_t* len_vect,
+		       uint32_t len_num)
+{
+  TestClock timer;
+  uint32_t h = 0;
+
+  timer.start();
+  for(int i = 1; i < 1000000 * 100; i++) {
+    for (int j = 0; j < (int)len_num; j++) {
+      // So the buf is not loop invariant, hence the F(...)
+      buf[(i + j) % 4096] = i;
+      h += func(seed, buf, len_vect[j]) ^ j;
+    }
+  }
+  timer.stop();
+
+  // make h alive
+  test_printf("%x", h);
+  return timer.getElapseInSecond();
+}
+
+// It is to measure the performance when length is changing.
+// The purpose is to see how balanced branches impact the performance.
+//
+static void
+benchmarkToggleLens(uint64_t seed, char* buf)
+{
+  double e1, e2, e3, e4;
+  fprintf(stdout,"\nChanging length (in second):");
+  fprintf(stdout, "\n%-24s%-8s%-8s%s%-8s%-8s%s\n%s\n", "len",
+	  "was (s)", "is (s)", "diff (s)",
+	  "was (d)", "is (d)", "diff (d)",
+          separator);
+
+  uint32_t lens1[] = {4, 9};
+  e1 = BenchmarkChangeLenTmpl(TestFuncWasSparse(), seed, buf, lens1, 2);
+  e2 = BenchmarkChangeLenTmpl(TestFuncIsSparse(), seed, buf, lens1, 2);
+  e3 = BenchmarkChangeLenTmpl(TestFuncWasDense(), seed, buf, lens1, 2);
+  e4 = BenchmarkChangeLenTmpl(TestFuncIsDense(), seed, buf, lens1, 2);
+  fprintf(stdout, "%-20s%-7.3lf %-7.3lf %-7.2f%% %-7.3lf %-7.3lf %.2f%%\n", "4,9",
+	  e1, e2, 100*(e1-e2)/e1, e3, e4, 100*(e3-e4)/e3);
+
+  uint32_t lens2[] = {1, 4, 9};
+  e1 = BenchmarkChangeLenTmpl(TestFuncWasSparse(), seed, buf, lens2, 3);
+  e2 = BenchmarkChangeLenTmpl(TestFuncIsSparse(), seed, buf, lens2, 3);
+  e3 = BenchmarkChangeLenTmpl(TestFuncWasDense(), seed, buf, lens2, 3);
+  e4 = BenchmarkChangeLenTmpl(TestFuncIsDense(), seed, buf, lens2, 3);
+  fprintf(stdout, "%-20s%-7.3lf %-7.3lf %-7.2f%% %-7.3lf %-7.3lf %.2f%%\n", "1,4,9",
+	  e1, e2, 100*(e1-e2)/e1, e3, e4, 100*(e3-e4)/e3);
+
+  uint32_t lens3[] = {1, 33, 4, 9};
+  e1 = BenchmarkChangeLenTmpl(TestFuncWasSparse(), seed, buf, lens3, 4);
+  e2 = BenchmarkChangeLenTmpl(TestFuncIsSparse(), seed, buf, lens3, 4);
+  e3 = BenchmarkChangeLenTmpl(TestFuncWasDense(), seed, buf, lens3, 4);
+  e4 = BenchmarkChangeLenTmpl(TestFuncIsDense(), seed, buf, lens3, 4);
+  fprintf(stdout, "%-20s%-7.3lf %-7.3lf %-7.2f%% %-7.3lf %-7.3lf %.2f%%\n",
+	  "1,33,4,9", e1, e2, 100*(e1-e2)/e1, e3, e4, 100*(e3-e4)/e3);
+
+  uint32_t lens4[] = {16, 33, 64, 89};
+  e1 = BenchmarkChangeLenTmpl(TestFuncWasSparse(), seed, buf, lens4, 4);
+  e2 = BenchmarkChangeLenTmpl(TestFuncIsSparse(), seed, buf, lens4, 4);
+  e3 = BenchmarkChangeLenTmpl(TestFuncWasDense(), seed, buf, lens4, 4);
+  e4 = BenchmarkChangeLenTmpl(TestFuncIsDense(), seed, buf, lens4, 4);
+  fprintf(stdout, "%-20s%-7.3lf %-7.3lf %-7.2f%% %-7.3lf %-7.3lf %.2f%%\n",
+	  "16,33,64,89", e1, e2, 100*(e1-e2)/e1, e3, e4, 100*(e3-e4)/e3);
+}
+
+static void
+genRandomString(uint32_t min, uint32_t max,
+                uint32_t num, vector<string>& result)
+{
+  double scale = (max - min) / (RAND_MAX + 1.0);
+  result.clear();
+  result.reserve(num);
+  for (uint32_t i = 0; i < num; i++) {
+    uint32_t len = (rand() * scale) + min;
+
+    char* buf = new char[len];
+    for (uint32_t l = 0; l < len; l++) {
+      buf[l] = rand() % 255;
+    }
+    result.push_back(string(buf, len));
+    delete[] buf;
+  }
+}
+
+// Return the standard deviation of given array of number
+static double
+standarDeviation(const vector<uint32_t>& v)
+{
+  uint64_t total = 0;
+  for (vector<uint32_t>::const_iterator i = v.begin(), e = v.end();
+      i != e; ++i) {
+    total += *i;
+  }
+
+  double avg = total / (double)v.size();
+  double sd = 0;
+
+  for (vector<uint32_t>::const_iterator i = v.begin(), e = v.end();
+       i != e; ++i) {
+    double t = avg - *i;
+    sd = sd + t*t;
+  }
+
+  return sqrt(sd/v.size());
+}
+
+static vector<double>
+benchmarkConflictHelper(uint64_t seed, uint32_t bucketNum,
+			const vector<string>& strs)
+{
+  if (bucketNum & (bucketNum - 1)) {
+    bucketNum = (1L << (log2_floor(bucketNum) + 1));
+  }
+  uint32_t mask = bucketNum - 1;
+
+  vector<uint32_t> conflictWasSparse(bucketNum);
+  vector<uint32_t> conflictIsSparse(bucketNum);
+  vector<uint32_t> conflictWasDense(bucketNum);
+  vector<uint32_t> conflictIsDense(bucketNum);
+
+  conflictWasSparse.resize(bucketNum);
+  conflictIsSparse.resize(bucketNum);
+  conflictWasDense.resize(bucketNum);
+  conflictIsDense.resize(bucketNum);
+
+  for (vector<string>::const_iterator i = strs.begin(), e = strs.end();
+       i != e; ++i) {
+    uint32_t h1 = original_hash_sparse(seed, i->c_str(), i->size());
+    uint32_t h2 = hash_sparse_sse42(seed, i->c_str(), i->size());
+    uint32_t h3 = original_hash_dense(seed, h1, i->c_str(), i->size());
+    uint32_t h4 = hash_dense_sse42(seed, h2, i->c_str(), i->size());
+
+    conflictWasSparse[h1 & mask]++;
+    conflictIsSparse[h2 & mask]++;
+    conflictWasDense[h3 & mask]++;
+    conflictIsDense[h4 & mask]++;
+  }
+
+#if 0
+  std::sort(conflictWas.begin(), conflictWas.end(), std::greater<int>());
+  std::sort(conflictIs.begin(), conflictIs.end(), std::greater<int>());
+
+  fprintf(stderr, "%d %d %d %d vs %d %d %d %d\n",
+          conflictWas[0], conflictWas[1], conflictWas[2], conflictWas[3],
+          conflictIs[0], conflictIs[1], conflictIs[2], conflictIs[3]);
+#endif
+  vector<double> ret(4);
+  ret[0] = standarDeviation(conflictWasSparse);
+  ret[1] = standarDeviation(conflictIsSparse);
+  ret[2] = standarDeviation(conflictWasDense);
+  ret[3] = standarDeviation(conflictIsDense);
+
+  return ret;
+}
+
+static void
+benchmarkConflict(uint64_t seed)
+{
+  float loadFactor[] = { 0.5f, 1.0f, 2.0f, 4.0f, 8.0f };
+  int bucketNum[] = { 512, 1024, 2048, 4096, 8192, 16384};
+  int lenRange[][2] = { {1,3}, {4, 15}, {16, 127}, {128, 1024}, {1, 1024}};
+
+  fprintf(stdout,
+          "\nBechmarking conflict (stand deviation of conflict)\n%s\n",
+          separator);
+
+  for (uint32_t k = 0; k < sizeof(lenRange)/sizeof(lenRange[0]); k++) {
+    fprintf(stdout, "\nlen range from %d - %d\n", lenRange[k][0],
+            lenRange[k][1]);
+    fprintf(stdout, "%-10s %-12s %-10s %-10s diff (s) %-10s %-10s diff (d)\n%s\n",
+	    "bucket", "load-factor", "was (s)", "is (s)", "was (d)", "is (d)",
+	    separator);
+    for (uint32_t i = 0; i < sizeof(bucketNum)/sizeof(bucketNum[0]); ++i) {
+      for (uint32_t j = 0;
+           j < sizeof(loadFactor)/sizeof(loadFactor[0]);
+           ++j) {
+        int strNum = bucketNum[i] * loadFactor[j];
+        vector<string> strs(strNum);
+        genRandomString(lenRange[k][0], lenRange[k][1], strNum, strs);
+
+        vector<double> p;
+        p = benchmarkConflictHelper(seed, bucketNum[i], strs);
+        fprintf(stdout, "%-10d %-12.2f %-10.2f %-10.2f %-10.2f %-10.2f %-10.2f %.2f\n",
+                bucketNum[i], loadFactor[j],
+		p[0], p[1], p[0] - p[1],
+		p[2], p[3], p[2] - p[3]);
+      }
+    }
+  }
+}
+
+static void
+benchmarkHashFunc()
+{
+  srand(time(0));
+
+  uint64_t seed = (uint32_t) rand();
+  char buf[4096];
+  char c = getpid() % 'a';
+  for (int i = 0; i < (int)sizeof(buf); i++) {
+    buf[i] = (c + i) % 255;
+  }
+
+  benchmarkConflict(seed);
+  benchmarkIndividual(seed, buf);
+  benchmarkToggleLens(seed, buf);
+}
+
+int
+main(int argc, char** argv)
+{
+  fprintf(stdout, "========================\nMicro benchmark...\n");
+  benchmarkHashFunc();
+  return 0;
+}
diff --git a/lib/luajit2/src/x64/test/test.cpp b/lib/luajit2/src/x64/test/test.cpp
new file mode 100644
index 000000000..432c7bbbd
--- /dev/null
+++ b/lib/luajit2/src/x64/test/test.cpp
@@ -0,0 +1,81 @@
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <map>
+#define LUAJIT_SECURITY_STRHASH 1
+#include "test_util.hpp"
+#include "../../lj_str.h"
+str_sparse_hashfn hash_sparse;
+str_dense_hashfn hash_dense;
+#include "../../lj_str_hash.c"
+
+using namespace std;
+
+
+static bool
+smoke_test()
+{
+  fprintf(stdout, "running smoke tests...\n");
+	char buf[1024];
+  char c = getpid() % 'a';
+  srand(time(0));
+
+  for (int i = 0; i < (int)sizeof(buf); i++) {
+    buf[i] = (c + i) % 255;
+  }
+
+  uint32_t lens[] = {3, 4, 5, 7, 8, 16, 17, 24, 25, 32, 33, 127, 128,
+                     255, 256, 257};
+  for (unsigned i = 0; i < sizeof(lens)/sizeof(lens[0]); i++) {
+    string s(buf, lens[i]);
+    uint32_t h = hash_sparse_sse42(rand(), s.c_str(), lens[i]);
+    test_printf("%d", h);
+    test_printf("%d", hash_dense_sse42(rand(), h, s.c_str(), lens[i]));
+  }
+
+  return true;
+}
+
+static bool
+verify_log2()
+{
+  fprintf(stdout, "verify log2...\n");
+  bool err = false;
+  std::map<uint32_t, uint32_t> lm;
+  lm[0] =(uint32_t)-1;
+  lm[1] = 0;
+  lm[2] = 1;
+  for (int i = 2; i < 31; i++) {
+    lm[(1<<i) - 2] = i - 1;
+    lm[(1<<i) - 1] = i - 1;
+    lm[1<<i] = i;
+    lm[(1<<i) + 1] = i;
+  }
+  lm[(uint32_t)-1] = 31;
+
+  for (map<uint32_t, uint32_t>::iterator iter = lm.begin(), iter_e = lm.end();
+       iter != iter_e; ++iter) {
+    uint32_t v = (*iter).first;
+    uint32_t log2_expect = (*iter).second;
+    uint32_t log2_get = log2_floor(v);
+    if (log2_expect != log2_get) {
+      err = true;
+      fprintf(stderr, "log2(%u) expect %u, get %u\n", v, log2_expect, log2_get);
+      exit(1);
+    }
+  }
+  return !err;
+}
+
+int
+main(int argc, char** argv)
+{
+  fprintf(stdout, "=======================\nRun unit testing...\n");
+
+  ASSERT(smoke_test(), "smoke_test test failed");
+  ASSERT(verify_log2(), "log2 failed");
+
+  fprintf(stdout, TestErrMsgMgr::noError() ? "succ\n\n" : "fail\n\n");
+
+  return TestErrMsgMgr::noError() ? 0 : -1;
+}
diff --git a/lib/luajit2/src/x64/test/test_str_comp.lua b/lib/luajit2/src/x64/test/test_str_comp.lua
new file mode 100644
index 000000000..3a5c3e676
--- /dev/null
+++ b/lib/luajit2/src/x64/test/test_str_comp.lua
@@ -0,0 +1,67 @@
+--[[
+ Given two content-idental string s1, s2, test if they end up to be the
+ same string object. The purpose of this test is to make sure hash function
+ do not accidently include extraneous bytes before and after the string in
+ question.
+]]
+
+local ffi = require("ffi")
+local C = ffi.C
+
+ffi.cdef[[
+    void free(void*);
+    char* malloc(size_t);
+    void *memset(void*, int, size_t);
+    void *memcpy(void*, void*, size_t);
+    long time(void*);
+    void srandom(unsigned);
+    long random(void);
+]]
+
+
+local function test_equal(len_min, len_max)
+    -- source string is wrapped by 16-byte-junk both before and after the
+    -- string
+    local x = C.random()
+    local l = len_min + x % (len_max - len_min);
+    local buf_len = tonumber(l + 16 * 2)
+
+    local src_buf = C.malloc(buf_len)
+    for i = 0, buf_len - 1 do
+        src_buf[i] = C.random() % 255
+    end
+
+    -- dest string is the clone of the source string, but it is sandwiched
+    -- by different junk bytes
+    local dest_buf = C.malloc(buf_len)
+    C.memset(dest_buf, 0x5a, buf_len)
+
+    local ofst = 8 + (C.random() % 8)
+    C.memcpy(dest_buf + ofst, src_buf + 16, l);
+
+    local str1 = ffi.string(src_buf + 16, l)
+    local str2 = ffi.string(dest_buf + ofst, l)
+
+    C.free(src_buf)
+    C.free(dest_buf)
+
+    if str1 ~= str2 then
+        -- Oops, look like hash function mistakenly include extraneous bytes
+        -- close to the string
+        return 1 -- wtf
+    end
+end
+
+--local lens = {1, 4, 16, 128, 1024}
+local lens = {128, 1024}
+local iter = 1000
+
+for i = 1, #lens - 1 do
+    for j = 1, iter do
+        if test_equal(lens[i], lens[i+1]) ~= nil then
+            os.exit(1)
+        end
+    end
+end
+
+os.exit(0)
diff --git a/lib/luajit2/src/x64/test/test_util.cxx b/lib/luajit2/src/x64/test/test_util.cxx
new file mode 100644
index 000000000..34b7d6751
--- /dev/null
+++ b/lib/luajit2/src/x64/test/test_util.cxx
@@ -0,0 +1,21 @@
+#include <stdarg.h>
+#include <stdio.h>
+#include "test_util.hpp"
+
+using namespace std;
+
+std::vector<TestErrMsg> TestErrMsgMgr::_errMsg;
+
+void
+test_printf(const char* format, ...)
+{
+  va_list args;
+  va_start (args, format);
+
+  FILE* devNull = fopen("/dev/null", "w");
+  if (devNull != 0) {
+    (void)vfprintf (devNull, format, args);
+  }
+  fclose(devNull);
+  va_end (args);
+}
diff --git a/lib/luajit2/src/x64/test/test_util.d b/lib/luajit2/src/x64/test/test_util.d
new file mode 100644
index 000000000..e539432e5
--- /dev/null
+++ b/lib/luajit2/src/x64/test/test_util.d
@@ -0,0 +1,107 @@
+test_util.o: test_util.cxx /usr/include/stdc-predef.h \
+ /usr/lib/gcc/x86_64-redhat-linux/10/include/stdarg.h \
+ /usr/include/stdio.h /usr/include/bits/libc-header-start.h \
+ /usr/include/features.h /usr/include/sys/cdefs.h \
+ /usr/include/bits/wordsize.h /usr/include/bits/long-double.h \
+ /usr/include/gnu/stubs.h /usr/include/gnu/stubs-64.h \
+ /usr/lib/gcc/x86_64-redhat-linux/10/include/stddef.h \
+ /usr/include/bits/types.h /usr/include/bits/timesize.h \
+ /usr/include/bits/typesizes.h /usr/include/bits/time64.h \
+ /usr/include/bits/types/__fpos_t.h /usr/include/bits/types/__mbstate_t.h \
+ /usr/include/bits/types/__fpos64_t.h /usr/include/bits/types/__FILE.h \
+ /usr/include/bits/types/FILE.h /usr/include/bits/types/struct_FILE.h \
+ /usr/include/bits/types/cookie_io_functions_t.h \
+ /usr/include/bits/stdio_lim.h /usr/include/bits/sys_errlist.h \
+ /usr/include/bits/stdio.h test_util.hpp /usr/include/sys/time.h \
+ /usr/include/bits/types/time_t.h \
+ /usr/include/bits/types/struct_timeval.h /usr/include/sys/select.h \
+ /usr/include/bits/select.h /usr/include/bits/types/sigset_t.h \
+ /usr/include/bits/types/__sigset_t.h \
+ /usr/include/bits/types/struct_timespec.h /usr/include/bits/endian.h \
+ /usr/include/bits/endianness.h /usr/include/c++/10/string \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/c++config.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/os_defines.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/cpu_defines.h \
+ /usr/include/c++/10/bits/stringfwd.h \
+ /usr/include/c++/10/bits/memoryfwd.h \
+ /usr/include/c++/10/bits/char_traits.h \
+ /usr/include/c++/10/bits/stl_algobase.h \
+ /usr/include/c++/10/bits/functexcept.h \
+ /usr/include/c++/10/bits/exception_defines.h \
+ /usr/include/c++/10/bits/cpp_type_traits.h \
+ /usr/include/c++/10/ext/type_traits.h \
+ /usr/include/c++/10/ext/numeric_traits.h \
+ /usr/include/c++/10/bits/stl_pair.h /usr/include/c++/10/bits/move.h \
+ /usr/include/c++/10/type_traits \
+ /usr/include/c++/10/bits/stl_iterator_base_types.h \
+ /usr/include/c++/10/bits/stl_iterator_base_funcs.h \
+ /usr/include/c++/10/bits/concept_check.h \
+ /usr/include/c++/10/debug/assertions.h \
+ /usr/include/c++/10/bits/stl_iterator.h \
+ /usr/include/c++/10/bits/ptr_traits.h /usr/include/c++/10/debug/debug.h \
+ /usr/include/c++/10/bits/predefined_ops.h \
+ /usr/include/c++/10/bits/postypes.h /usr/include/c++/10/cwchar \
+ /usr/include/wchar.h /usr/include/bits/floatn.h \
+ /usr/include/bits/floatn-common.h /usr/include/bits/wchar.h \
+ /usr/include/bits/types/wint_t.h /usr/include/bits/types/mbstate_t.h \
+ /usr/include/bits/types/locale_t.h /usr/include/bits/types/__locale_t.h \
+ /usr/include/c++/10/cstdint \
+ /usr/lib/gcc/x86_64-redhat-linux/10/include/stdint.h \
+ /usr/include/stdint.h /usr/include/bits/stdint-intn.h \
+ /usr/include/bits/stdint-uintn.h /usr/include/c++/10/bits/allocator.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/c++allocator.h \
+ /usr/include/c++/10/ext/new_allocator.h /usr/include/c++/10/new \
+ /usr/include/c++/10/exception /usr/include/c++/10/bits/exception.h \
+ /usr/include/c++/10/bits/exception_ptr.h \
+ /usr/include/c++/10/bits/cxxabi_init_exception.h \
+ /usr/include/c++/10/typeinfo /usr/include/c++/10/bits/hash_bytes.h \
+ /usr/include/c++/10/bits/nested_exception.h \
+ /usr/include/c++/10/bits/localefwd.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/c++locale.h \
+ /usr/include/c++/10/clocale /usr/include/locale.h \
+ /usr/include/bits/locale.h /usr/include/c++/10/iosfwd \
+ /usr/include/c++/10/cctype /usr/include/ctype.h \
+ /usr/include/c++/10/bits/ostream_insert.h \
+ /usr/include/c++/10/bits/cxxabi_forced.h \
+ /usr/include/c++/10/bits/stl_function.h \
+ /usr/include/c++/10/backward/binders.h \
+ /usr/include/c++/10/bits/range_access.h \
+ /usr/include/c++/10/initializer_list \
+ /usr/include/c++/10/bits/iterator_concepts.h \
+ /usr/include/c++/10/concepts /usr/include/c++/10/bits/range_cmp.h \
+ /usr/include/c++/10/bits/int_limits.h \
+ /usr/include/c++/10/bits/basic_string.h \
+ /usr/include/c++/10/ext/atomicity.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/gthr.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/gthr-default.h \
+ /usr/include/pthread.h /usr/include/sched.h /usr/include/bits/sched.h \
+ /usr/include/bits/types/struct_sched_param.h /usr/include/bits/cpu-set.h \
+ /usr/include/time.h /usr/include/bits/time.h /usr/include/bits/timex.h \
+ /usr/include/bits/types/clock_t.h /usr/include/bits/types/struct_tm.h \
+ /usr/include/bits/types/clockid_t.h /usr/include/bits/types/timer_t.h \
+ /usr/include/bits/types/struct_itimerspec.h \
+ /usr/include/bits/pthreadtypes.h /usr/include/bits/thread-shared-types.h \
+ /usr/include/bits/pthreadtypes-arch.h /usr/include/bits/struct_mutex.h \
+ /usr/include/bits/struct_rwlock.h /usr/include/bits/setjmp.h \
+ /usr/include/c++/10/x86_64-redhat-linux/bits/atomic_word.h \
+ /usr/include/c++/10/ext/alloc_traits.h \
+ /usr/include/c++/10/bits/alloc_traits.h \
+ /usr/include/c++/10/bits/stl_construct.h \
+ /usr/include/c++/10/ext/string_conversions.h /usr/include/c++/10/cstdlib \
+ /usr/include/stdlib.h /usr/include/bits/waitflags.h \
+ /usr/include/bits/waitstatus.h /usr/include/sys/types.h \
+ /usr/include/endian.h /usr/include/bits/byteswap.h \
+ /usr/include/bits/uintn-identity.h /usr/include/alloca.h \
+ /usr/include/bits/stdlib-bsearch.h /usr/include/bits/stdlib-float.h \
+ /usr/include/c++/10/bits/std_abs.h /usr/include/c++/10/cstdio \
+ /usr/include/c++/10/cerrno /usr/include/errno.h \
+ /usr/include/bits/errno.h /usr/include/linux/errno.h \
+ /usr/include/asm/errno.h /usr/include/asm-generic/errno.h \
+ /usr/include/asm-generic/errno-base.h /usr/include/bits/types/error_t.h \
+ /usr/include/c++/10/bits/charconv.h \
+ /usr/include/c++/10/bits/functional_hash.h \
+ /usr/include/c++/10/bits/basic_string.tcc /usr/include/c++/10/vector \
+ /usr/include/c++/10/bits/stl_uninitialized.h \
+ /usr/include/c++/10/bits/stl_vector.h \
+ /usr/include/c++/10/bits/stl_bvector.h \
+ /usr/include/c++/10/bits/vector.tcc
diff --git a/lib/luajit2/src/x64/test/test_util.hpp b/lib/luajit2/src/x64/test/test_util.hpp
new file mode 100644
index 000000000..6cc2ea2cf
--- /dev/null
+++ b/lib/luajit2/src/x64/test/test_util.hpp
@@ -0,0 +1,57 @@
+#ifndef _TEST_UTIL_HPP_
+#define _TEST_UTIL_HPP_
+
+#include <sys/time.h> // gettimeofday()
+#include <string>
+#include <vector>
+
+struct TestErrMsg
+{
+  const char* fileName;
+  unsigned lineNo;
+  std::string errMsg;
+
+  TestErrMsg(const char* FN, unsigned LN, const char* Err):
+             fileName(FN), lineNo(LN), errMsg(Err) {}
+};
+
+class TestErrMsgMgr
+{
+public:
+  static std::vector<TestErrMsg> getError();
+  static void
+  addError(const char* fileName, unsigned lineNo, const char* Err) {
+    _errMsg.push_back(TestErrMsg(fileName, lineNo, Err));
+  }
+
+  static bool noError() {
+    return _errMsg.empty();
+  }
+
+private:
+  static std::vector<TestErrMsg> _errMsg;
+};
+
+#define ASSERT(c, e) \
+  if (!(c)) { TestErrMsgMgr::addError(__FILE__, __LINE__, (e)); }
+
+class TestClock
+{
+public:
+  void start() { gettimeofday(&_start, 0); }
+  void stop() { gettimeofday(&_end, 0); }
+  double getElapseInSecond() {
+    return (_end.tv_sec - _start.tv_sec)
+            + ((long)_end.tv_usec - (long)_start.tv_usec) / 1000000.0;
+  }
+
+private:
+  struct timeval _start, _end;
+};
+
+// write to /dev/null, the only purpose is to make the data fed to the
+// function alive.
+extern void test_printf(const char* format, ...)
+  __attribute__ ((format (printf, 1, 2)));
+
+#endif //_TEST_UTIL_HPP_
diff --git a/lib/luajit-3065c9/src/xb1build.bat b/lib/luajit2/src/xb1build.bat
similarity index 92%
rename from lib/luajit-3065c9/src/xb1build.bat
rename to lib/luajit2/src/xb1build.bat
index 2eb681714..019d6ebe7 100644
--- a/lib/luajit-3065c9/src/xb1build.bat
+++ b/lib/luajit2/src/xb1build.bat
@@ -31,6 +31,9 @@ if exist minilua.exe.manifest^
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h vm_x64.dasc
 @if errorlevel 1 goto :BAD
 
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
 %LJCOMPILE% /I "." /I %DASMDIR% /D_DURANGO host\buildvm*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
diff --git a/lib/luajit-3065c9/src/xedkbuild.bat b/lib/luajit2/src/xedkbuild.bat
similarity index 92%
rename from lib/luajit-3065c9/src/xedkbuild.bat
rename to lib/luajit2/src/xedkbuild.bat
index 37322d03d..5444024ee 100644
--- a/lib/luajit-3065c9/src/xedkbuild.bat
+++ b/lib/luajit2/src/xedkbuild.bat
@@ -31,6 +31,9 @@ if exist minilua.exe.manifest^
 minilua %DASM% -LN %DASMFLAGS% -o host\buildvm_arch.h vm_ppc.dasc
 @if errorlevel 1 goto :BAD
 
+if exist ..\.git ( git show -s --format=%%ct >luajit_relver.txt ) else ( type ..\.relver >luajit_relver.txt )
+minilua host\genversion.lua
+
 %LJCOMPILE% /I "." /I %DASMDIR% /D_XBOX_VER=200 /DLUAJIT_TARGET=LUAJIT_ARCH_PPC  host\buildvm*.c
 @if errorlevel 1 goto :BAD
 %LJLINK% /out:buildvm.exe buildvm*.obj
diff --git a/lib/luajit2/t/TestLJ.pm b/lib/luajit2/t/TestLJ.pm
new file mode 100644
index 000000000..de5d65023
--- /dev/null
+++ b/lib/luajit2/t/TestLJ.pm
@@ -0,0 +1,98 @@
+package t::TestLJ;
+
+use v5.10.1;
+use Test::Base -Base;
+use IPC::Run3;
+use Cwd qw( cwd );
+use Test::LongString;
+use File::Temp qw( tempdir );
+
+our @EXPORT = qw( run_tests );
+
+$ENV{LUA_CPATH} = "../?.so;;";
+$ENV{LUA_PATH} = "../lua/?.lua;;";
+#$ENV{LUA_PATH} = ($ENV{LUA_PATH} || "" ) . ';' . getcwd . "/runtime/?.lua" . ';;';
+
+my $cwd = cwd;
+
+sub run_test ($) {
+    my $block = shift;
+    #print $json_xs->pretty->encode(\@new_rows);
+    #my $res = #print $json_xs->pretty->encode($res);
+    my $name = $block->name;
+
+    my $lua = $block->lua or
+        die "No --- lua specified for test $name\n";
+
+    my $luafile = "test.lua";
+
+    {
+        my $dir = tempdir "testlj_XXXXXXX", CLEANUP => 1;
+        chdir $dir or die "$name - Cannot chdir to $dir: $!";
+        open my $fh, ">$luafile"
+            or die "$name - Cannot open $luafile in $dir for writing: $!\n";
+        print $fh $lua;
+        close $fh;
+    }
+
+    my ($res, $err);
+
+    my @cmd;
+
+    if ($ENV{TEST_LJ_USE_VALGRIND}) {
+        warn "$name\n";
+        @cmd =  ('valgrind', '-q', '--leak-check=full', 'luajit',
+                 defined($block->jv) ? '-jv' : (),
+                 defined($block->jdump) ? '-jdump' : (),
+                 $luafile);
+    } else {
+        @cmd =  ('luajit',
+                 defined($block->jv) ? '-jv' : (),
+                 defined($block->jdump) ? '-jdump' : (),
+                 $luafile);
+    }
+
+    run3 \@cmd, undef, \$res, \$err;
+    my $rc = $?;
+
+    #warn "res:$res\nerr:$err\n";
+
+    my $exp_rc = $block->exit // 0;
+
+    is $exp_rc, $rc >> 8, "$name - exit code okay";
+
+    my $exp_err = $block->err;
+    if (defined $exp_err) {
+        if ($err =~ /.*:.*:.*: (.*\s)?/) {
+            $err = $1;
+        }
+
+	if (ref $exp_err) {
+	  like $err, $exp_err, "$name - err like expected";
+
+	} else {
+	  is $err, $exp_err, "$name - err expected";
+	}
+
+    } elsif (defined $err && $err ne '') {
+        warn "$name - STDERR:\n$err";
+    }
+
+    if (defined $block->out) {
+        #is $res, $block->out, "$name - output ok";
+        is $res, $block->out, "$name - output ok";
+
+    } elsif (defined $res && $res ne '') {
+        warn "$name - STDOUT:\n$res";
+    }
+
+    chdir $cwd or die $!;
+}
+
+sub run_tests () {
+    for my $block (blocks()) {
+        run_test($block);
+    }
+}
+
+1;
diff --git a/lib/luajit2/t/exdata.t b/lib/luajit2/t/exdata.t
new file mode 100644
index 000000000..4cd270c3e
--- /dev/null
+++ b/lib/luajit2/t/exdata.t
@@ -0,0 +1,271 @@
+# vim: set ss=4 ft= sw=4 et sts=4 ts=4:
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: interpreted (sanity)
+--- lua
+jit.off()
+local assert = assert
+local exdata = require "thread.exdata"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+for i = 1, 5 do
+    exdata(u64)
+    local q = exdata()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(ptr))
+print(tostring(saved_q))
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+
+
+
+=== TEST 2: newly created coroutines should inherit the exdata
+--- lua
+jit.off()
+local exdata = require "thread.exdata"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local ptr2 = ffi.cast("void *", u64 + 1)
+local ptr3 = ffi.cast("void *", u64 - 2)
+local saved_q
+local function f()
+    coroutine.yield(exdata())
+    exdata(ptr2)
+    coroutine.yield(exdata())
+    coroutine.yield(exdata())
+end
+
+exdata(u64)
+
+local co = coroutine.create(f)
+
+local ok, data = coroutine.resume(co)
+assert(ok)
+print(tostring(data))
+
+ok, data = coroutine.resume(co)
+assert(ok)
+print(tostring(data))
+
+exdata(ptr3)
+
+ok, data = coroutine.resume(co)
+assert(ok)
+print(tostring(data))
+
+print(tostring(exdata()))
+--- jv
+--- out
+cdata<void *>: 0xefdeadbeef
+cdata<void *>: 0xefdeadbef0
+cdata<void *>: 0xefdeadbef0
+cdata<void *>: 0xefdeadbeed
+--- err
+
+
+
+=== TEST 3: JIT mode (reading)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+local assert = assert
+local exdata = require "thread.exdata"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+exdata(u64)
+for i = 1, 10 do
+    local q = exdata()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(ptr))
+print(tostring(saved_q))
+
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+[TRACE   1 test.lua:9 loop]
+
+
+
+=== TEST 4: JIT mode (writing)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+local assert = assert
+local exdata = require "thread.exdata"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+for i = 1, 10 do
+    exdata(u64)
+    local q = exdata()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(ptr))
+print(tostring(saved_q))
+
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+[TRACE --- test.lua:8 -- trace too short at test.lua:9]
+
+
+
+=== TEST 5: interpreted  - check the number of arguments
+--- lua
+jit.off()
+local assert = assert
+local select = select
+local exdata = require "thread.exdata"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+
+local function nargs(...)
+    return select('#', ...)
+end
+print(nargs(exdata(ptr)))
+print(nargs(exdata()))
+--- jv
+--- out
+0
+1
+--- err
+
+
+
+=== TEST 6: JIT mode  - check the number of arguments
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+local assert = assert
+local select = select
+local exdata = require "thread.exdata"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+
+local function nargs(...)
+    return select('#', ...)
+end
+
+local total = 0
+for i = 1, 10 do
+    total = total + nargs(exdata(ptr))
+end
+
+print("set: " .. total)
+
+total = 0
+for i = 1, 10 do
+    total = total + nargs(exdata())
+end
+
+print("get: " .. total)
+--- jv
+--- out
+set: 0
+get: 10
+--- err
+[TRACE --- test.lua:14 -- trace too short at test.lua:15]
+[TRACE   1 test.lua:21 loop]
+
+
+
+=== TEST 7: interpreted (no ffi initialized)
+--- lua
+jit.off()
+local assert = assert
+local exdata = require "thread.exdata"
+local saved_q
+for i = 1, 5 do
+    local q = exdata()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(saved_q))
+--- jv
+--- out
+--- err
+ffi module not loaded (yet)
+--- exit: 1
+
+
+
+=== TEST 8: default value (interpreted)
+--- lua
+jit.off()
+local assert = assert
+require "ffi"
+local exdata = require "thread.exdata"
+local saved_q
+for i = 1, 5 do
+    local q = exdata()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(saved_q == nil)
+print(tostring(saved_q))
+--- jv
+--- out
+true
+cdata<void *>: NULL
+--- err
+
+
+
+=== TEST 9: default value (JIT)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+jit.on()
+local assert = assert
+require "ffi"
+local exdata = require "thread.exdata"
+local saved_q
+for i = 1, 5 do
+    local q = exdata()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(saved_q == nil)
+print(tostring(saved_q))
+--- jv
+--- out
+true
+cdata<void *>: NULL
+--- err
+[TRACE   1 test.lua:7 loop]
diff --git a/lib/luajit2/t/exdata2.t b/lib/luajit2/t/exdata2.t
new file mode 100644
index 000000000..3eed13005
--- /dev/null
+++ b/lib/luajit2/t/exdata2.t
@@ -0,0 +1,300 @@
+# vim: set ss=4 ft= sw=4 et sts=4 ts=4:
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: interpreted (sanity)
+--- lua
+jit.off()
+local assert = assert
+local exdata2 = require "thread.exdata2"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+for i = 1, 5 do
+    exdata2(u64)
+    local q = exdata2()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(ptr))
+print(tostring(saved_q))
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+
+
+
+=== TEST 2: interpreted (using both exdata and exdata2)
+--- lua
+jit.off()
+local assert = assert
+local exdata = require "thread.exdata"
+local exdata2 = require "thread.exdata2"
+assert(exdata ~= exdata2)
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local u64_2 = ffi.new("uintptr_t", 0xefdeaddeddbeffLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+exdata(u64)
+exdata2(u64_2)
+print(tostring(exdata()))
+print(tostring(exdata2()))
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeddbeff
+--- err
+
+
+
+=== TEST 3: newly created coroutines should inherit the exdata2
+--- lua
+jit.off()
+local exdata2 = require "thread.exdata2"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local ptr2 = ffi.cast("void *", u64 + 1)
+local ptr3 = ffi.cast("void *", u64 - 2)
+local saved_q
+local function f()
+    coroutine.yield(exdata2())
+    exdata2(ptr2)
+    coroutine.yield(exdata2())
+    coroutine.yield(exdata2())
+end
+
+exdata2(u64)
+
+local co = coroutine.create(f)
+
+local ok, data = coroutine.resume(co)
+assert(ok)
+print(tostring(data))
+
+ok, data = coroutine.resume(co)
+assert(ok)
+print(tostring(data))
+
+exdata2(ptr3)
+
+ok, data = coroutine.resume(co)
+assert(ok)
+print(tostring(data))
+
+print(tostring(exdata2()))
+--- jv
+--- out
+cdata<void *>: 0xefdeadbeef
+cdata<void *>: 0xefdeadbef0
+cdata<void *>: 0xefdeadbef0
+cdata<void *>: 0xefdeadbeed
+--- err
+
+
+
+=== TEST 4: JIT mode (reading)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+local assert = assert
+local exdata2 = require "thread.exdata2"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+exdata2(u64)
+for i = 1, 10 do
+    local q = exdata2()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(ptr))
+print(tostring(saved_q))
+
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+[TRACE   1 test.lua:9 loop]
+
+
+
+=== TEST 5: JIT mode (writing)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+local assert = assert
+local exdata2 = require "thread.exdata2"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+local saved_q
+for i = 1, 10 do
+    exdata2(u64)
+    local q = exdata2()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(ptr))
+print(tostring(saved_q))
+
+--- jv
+--- out
+cdata<void *>: 0xefdeaddeadbeef
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+[TRACE --- test.lua:8 -- trace too short at test.lua:9]
+
+
+
+=== TEST 6: interpreted  - check the number of arguments
+--- lua
+jit.off()
+local assert = assert
+local select = select
+local exdata2 = require "thread.exdata2"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+
+local function nargs(...)
+    return select('#', ...)
+end
+print(nargs(exdata2(ptr)))
+print(nargs(exdata2()))
+--- jv
+--- out
+0
+1
+--- err
+
+
+
+=== TEST 7: JIT mode  - check the number of arguments
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+local assert = assert
+local select = select
+local exdata = require "thread.exdata"
+local exdata2 = require "thread.exdata2"
+local ffi = require "ffi"
+local u64 = ffi.new("uintptr_t", 0xefdeaddeadbeefLL)
+local ptr = ffi.cast("void *", u64)
+
+local function nargs(...)
+    return select('#', ...)
+end
+
+local total = 0
+for i = 1, 10 do
+    total = total + nargs(exdata2(ptr))
+end
+
+print("set: " .. total)
+
+total = 0
+for i = 1, 10 do
+    total = total + nargs(exdata2())
+end
+
+print("get: " .. total)
+print(tostring(exdata()))
+print(tostring(exdata2()))
+--- jv
+--- out
+set: 0
+get: 10
+cdata<void *>: NULL
+cdata<void *>: 0xefdeaddeadbeef
+--- err
+[TRACE --- test.lua:15 -- trace too short at test.lua:16]
+[TRACE   1 test.lua:22 loop]
+
+
+
+=== TEST 8: interpreted (no ffi initialized)
+--- lua
+jit.off()
+local assert = assert
+local exdata2 = require "thread.exdata2"
+local saved_q
+for i = 1, 5 do
+    local q = exdata2()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(tostring(saved_q))
+--- jv
+--- out
+--- err
+ffi module not loaded (yet)
+--- exit: 1
+
+
+
+=== TEST 9: default value (interpreted)
+--- lua
+jit.off()
+local assert = assert
+require "ffi"
+local exdata2 = require "thread.exdata2"
+local saved_q
+for i = 1, 5 do
+    local q = exdata2()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(saved_q == nil)
+print(tostring(saved_q))
+--- jv
+--- out
+true
+cdata<void *>: NULL
+--- err
+
+
+
+=== TEST 10: default value (JIT)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+jit.on()
+local assert = assert
+require "ffi"
+local exdata2 = require "thread.exdata2"
+local saved_q
+for i = 1, 5 do
+    local q = exdata2()
+    if saved_q then
+        assert(q == saved_q)
+    end
+    saved_q = q
+end
+print(saved_q == nil)
+print(tostring(saved_q))
+--- jv
+--- out
+true
+cdata<void *>: NULL
+--- err
+[TRACE   1 test.lua:7 loop]
diff --git a/lib/luajit2/t/isarr-interp.t b/lib/luajit2/t/isarr-interp.t
new file mode 100644
index 000000000..a4e786ed7
--- /dev/null
+++ b/lib/luajit2/t/isarr-interp.t
@@ -0,0 +1,152 @@
+# vim:ft=
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: decimal boolean keys
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = { [3] = 3, [5.3] = 4 }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+
+
+
+=== TEST 2: discrete boolean keys
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = { [3] = "a", [5] = true }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+
+
+
+=== TEST 3: normal arrays
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = { "a", nil, true, 3.14 }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+
+
+
+=== TEST 4: empty table
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = {}
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+
+
+
+=== TEST 5: boolean-like string keys only
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = { ["1"] = 3, ["2"] = 4 }
+for i = 1, 150 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+
+
+
+=== TEST 6: non-boolean-like string keys only
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = { ["dog"] = 3, ["cat"] = 4 }
+for i = 1, 150 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+
+
+
+=== TEST 7: empty hash part
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = require "table.new"(0, 20)
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+
+
+
+=== TEST 8: mixing int keys and string keys
+--- lua
+jit.off()
+local isarray = require "table.isarray"
+local a
+local t = { "dog", "cat", true, ["bird"] = 3 }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
diff --git a/lib/luajit2/t/isarr-jit.t b/lib/luajit2/t/isarr-jit.t
new file mode 100644
index 000000000..93bb60fa2
--- /dev/null
+++ b/lib/luajit2/t/isarr-jit.t
@@ -0,0 +1,180 @@
+# vim:ft=
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: decimal boolean keys
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { [3] = 3, [5.3] = 4 }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 2: discrete boolean keys
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { [3] = "a", [5] = true }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 3: normal arrays
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { "a", nil, true, 3.14 }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 4: empty table
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = {}
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 5: boolean-like string keys only
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { ["1"] = 3, ["2"] = 4 }
+for i = 1, 150 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 6: non-boolean-like string keys only
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { ["dog"] = 3, ["cat"] = 4 }
+for i = 1, 150 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 7: empty hash part
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = require "table.new"(0, 20)
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 8: mixing int keys and string keys
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { "dog", "cat", true, ["bird"] = 3 }
+for i = 1, 5 do
+    a = isarray(t)
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	false
+--- err
+[TRACE   1 test.lua:5 loop]
+
+
+
+=== TEST 9: last table is an array
+--- lua
+require "jit.opt".start("hotloop=3")
+local isarray = require "table.isarray"
+local a
+local t = { "dog", "cat", true, ["bird"] = 3 }
+local ts = { t, t, t, t, t, {1, 2} }
+for i = 1, 6 do
+    a = isarray(ts[i])
+end
+print(type(a), a)
+
+--- jv
+--- out
+boolean	true
+--- err
+[TRACE   1 test.lua:6 loop]
diff --git a/lib/luajit2/t/isempty.t b/lib/luajit2/t/isempty.t
new file mode 100644
index 000000000..04703fb67
--- /dev/null
+++ b/lib/luajit2/t/isempty.t
@@ -0,0 +1,114 @@
+# vim:ft=
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: empty tables - interpreted
+--- lua
+jit.off()
+local new_tab = require "table.new"
+local isempty = require "table.isempty"
+local list = {
+  {},
+  new_tab(5, 6),
+  { nil },
+  { dogs = nil },
+}
+for i, t in ipairs(list) do
+    assert(isempty(t))
+end
+print("ok")
+
+--- jv
+--- out
+ok
+--- err
+
+
+
+=== TEST 2: empty tables - JIT
+--- lua
+jit.on()
+require "jit.opt".start("hotloop=3")
+local new_tab = require "table.new"
+local isempty = require "table.isempty"
+local list = {
+  {},
+  new_tab(5, 6),
+  { nil },
+  { dogs = nil },
+}
+for i, t in ipairs(list) do
+    for i = 1, 10 do
+        assert(isempty(t))
+    end
+end
+print("ok")
+
+--- jv
+--- out
+ok
+--- err
+[TRACE   1 test.lua:12 loop]
+[TRACE   2 test.lua:11 -> 1]
+
+
+
+=== TEST 3: non-empty tables - interpreted
+--- lua
+jit.off()
+local new_tab = require "table.new"
+local isempty = require "table.isempty"
+local list = {
+  { 3.1 },
+  { "a", "b" },
+  { nil, false },
+  { dogs = 3 },
+  { dogs = 3, cats = 4 },
+  { dogs = 3, 5 },
+}
+for i, t in ipairs(list) do
+    assert(not isempty(t))
+end
+print("ok")
+
+--- jv
+--- out
+ok
+--- err
+
+
+
+=== TEST 4: non-empty tables - JIT
+--- lua
+jit.on()
+require "jit.opt".start("hotloop=3")
+local new_tab = require "table.new"
+local isempty = require "table.isempty"
+local list = {
+  { 3.1 },
+  { "a", "b" },
+  { nil, false },
+  { dogs = 3 },
+  { dogs = 3, cats = 4 },
+  { dogs = 3, 5 },
+}
+for i, t in ipairs(list) do
+    for i = 1, 10 do
+        assert(not isempty(t))
+    end
+end
+print("ok")
+
+--- jv
+--- out
+ok
+--- err
+[TRACE   1 test.lua:14 loop]
+[TRACE   2 test.lua:13 -> 1]
diff --git a/lib/luajit2/t/iter.t b/lib/luajit2/t/iter.t
new file mode 100644
index 000000000..bc03d6983
--- /dev/null
+++ b/lib/luajit2/t/iter.t
@@ -0,0 +1,105 @@
+# vim: set ss=4 ft= sw=4 et sts=4 ts=4:
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: pairs() loop jit
+--- jv
+--- lua
+jit.opt.start("minstitch=1", "hotloop=2")
+local tb = {}
+for i = 1, 100 do
+  local s = "a" .. i
+  tb[s] = i
+end
+local total = 0
+for k, v in pairs(tb) do
+  total = total + tb[k]
+end
+print("total = " .. total)
+--- out
+total = 5050
+--- err eval
+qr#\Q[TRACE   1 test.lua:3 loop]
+[TRACE   2 test.lua:8 loop]
+\E(\Q[TRACE   3 (2/1) test.lua:8 stitch print]
+\E)?#ms
+
+
+=== TEST 2: explicit next() in loops
+--- jv
+--- lua
+jit.opt.start("minstitch=1", "hotloop=2")
+local tb = {}
+for i = 1, 100 do
+  local s = "a" .. i
+  tb[s] = i
+end
+local function f(tb, k)
+  if not next(tb) then
+    return nil
+  end
+  -- print("k = " .. k)
+  return k, tb["a" .. k]
+end
+local total = 0
+for i = 1, 100 do
+  local k, v = f(tb, i)
+  if not v then
+    break
+  end
+  total = total + v
+end
+print("total = " .. total)
+--- out
+total = 5050
+--- err
+[TRACE   1 test.lua:3 loop]
+[TRACE   2 test.lua:15 loop]
+
+
+
+=== TEST 3: custom lua iterator
+--- jv
+--- lua
+jit.opt.start("minstitch=1", "hotloop=2")
+local tb = {}
+for i = 1, 100 do
+  local s = "a" .. i
+  tb[s] = i
+end
+local iter
+function iter2(tb, k)
+    if k >= 100 then
+        return nil
+    end
+    return k + 1, tb["a" .. (k + 1)]
+end
+
+function iter(tb, k)
+    -- print("tb = " .. tostring(tb))
+    -- print("key = " .. tostring(k))
+    if k == nil then
+        return iter2, tb, 0
+    end
+    error("bad")
+end
+local total = 0
+for k, v in iter(tb) do
+    if not v then
+        print("value is nil for key " .. tostring(k))
+    end
+    total = total + v
+end
+print("total = " .. total)
+--- out
+total = 5050
+--- err
+[TRACE   1 test.lua:3 loop]
+[TRACE   2 test.lua:24 loop]
diff --git a/lib/luajit2/t/nkeys.t b/lib/luajit2/t/nkeys.t
new file mode 100644
index 000000000..8bd99cfd3
--- /dev/null
+++ b/lib/luajit2/t/nkeys.t
@@ -0,0 +1,175 @@
+# vim: set ss=4 ft= sw=4 et sts=4 ts=4:
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: hash table, interpreted
+--- lua
+jit.off()
+local new_tab = require "table.new"
+local assert = assert
+local nkeys = require "table.nkeys"
+print(nkeys(new_tab(0, 4)))
+print(nkeys({}))
+print(nkeys({ cats = 4 }))
+print(nkeys({ dogs = 3, cats = 4 }))
+print(nkeys({ dogs = nil, cats = 4 }))
+--- jv
+--- out
+0
+0
+1
+2
+1
+--- err
+
+
+
+=== TEST 2: hash table, JIT
+--- lua
+jit.on()
+jit.opt.start("minstitch=100000", "hotloop=2")
+
+local new_tab = require "table.new"
+local assert = assert
+local nkeys = require "table.nkeys"
+
+local list = {
+  new_tab(0, 4),
+  {},
+  { cats = 4 },
+  { dogs = 3, cats = 4 },
+  { dogs = nil, cats = 4 },
+}
+
+for i, t in ipairs(list) do
+  local total = 0
+  for i = 1, 10 do
+    total = total + nkeys(t)
+  end
+  print(total)
+end
+--- jv
+--- out
+0
+0
+10
+20
+10
+--- err
+[TRACE   1 test.lua:18 loop]
+[TRACE   2 test.lua:16 -> 1]
+
+
+
+=== TEST 3: pure arrays, interpreted
+--- lua
+jit.off()
+local new_tab = require "table.new"
+local assert = assert
+local nkeys = require "table.nkeys"
+print(nkeys(new_tab(5, 0)))
+print(nkeys({}))
+print(nkeys({ "cats" }))
+print(nkeys({ "dogs", 3, "cats", 4 }))
+print(nkeys({ "dogs", nil, "cats", 4 }))
+--- jv
+--- out
+0
+0
+1
+4
+3
+--- err
+
+
+
+=== TEST 4: pure array, JIT
+--- lua
+jit.on()
+jit.opt.start("minstitch=100000", "hotloop=2")
+
+local new_tab = require "table.new"
+local assert = assert
+local nkeys = require "table.nkeys"
+
+local list = {
+  new_tab(0, 4),
+  {},
+  { 3 },
+  { "cats", 4 },
+  { "dogs", 3, "cats", 4 },
+  { "dogs", nil, "cats", 4 },
+}
+
+for i, t in ipairs(list) do
+  local total = 0
+  for i = 1, 10 do
+    total = total + nkeys(t)
+  end
+  print(total)
+end
+--- jv
+--- out
+0
+0
+10
+20
+40
+30
+--- err
+[TRACE   1 test.lua:19 loop]
+[TRACE   2 test.lua:17 -> 1]
+
+
+
+=== TEST 5: mixing array and hash table, interpreted
+--- lua
+jit.off()
+local new_tab = require "table.new"
+local assert = assert
+local nkeys = require "table.nkeys"
+print(nkeys({ cats = 4, 5, 6 }))
+print(nkeys({ nil, "foo", dogs = 3, cats = 4 }))
+--- jv
+--- out
+3
+3
+--- err
+
+
+
+=== TEST 6: mixing array & hash, JIT
+--- lua
+jit.on()
+jit.opt.start("minstitch=100000", "hotloop=2")
+
+local new_tab = require "table.new"
+local assert = assert
+local nkeys = require "table.nkeys"
+
+local list = {
+  { cats = 4, 5, 6 },
+  { nil, "foo", dogs = 3, cats = 4 },
+}
+
+for i, t in ipairs(list) do
+  local total = 0
+  for i = 1, 10 do
+    total = total + nkeys(t)
+  end
+  print(total)
+end
+--- jv
+--- out
+30
+30
+--- err
+[TRACE   1 test.lua:15 loop]
+[TRACE   2 test.lua:13 -> 1]
diff --git a/lib/luajit2/t/prngstate.t b/lib/luajit2/t/prngstate.t
new file mode 100644
index 000000000..511a2a601
--- /dev/null
+++ b/lib/luajit2/t/prngstate.t
@@ -0,0 +1,76 @@
+# vim: set ss=4 ft= sw=4 et sts=4 ts=4:
+
+use lib '.';
+use t::TestLJ;
+
+plan tests => 3 * blocks();
+
+run_tests();
+
+__DATA__
+
+=== TEST 1: interpreted (sanity)
+--- lua
+jit.off()
+
+function print_array(a)
+  local out = a[1]
+  for i=2,#a do
+    out = out.." "..tostring(a[i])
+  end
+  print(out)
+end
+
+jit.prngstate({32})
+print_array(jit.prngstate({56,1,7}))
+print_array(jit.prngstate({423,432,432,423,56,867,35,5347}))
+print_array(jit.prngstate())
+print_array(jit.prngstate({423,432,432,423,56,867,35,5347,452}))
+--- out
+32 0 0 0 0 0 0 0
+56 1 7 0 0 0 0 0
+423 432 432 423 56 867 35 5347
+--- jv
+--- err
+bad argument #1 to 'prngstate' (PRNG state must be an array with up to 8 integers or an integer)
+--- exit: 1
+
+
+
+=== TEST 2: JIT (set)
+--- lua
+jit.opt.start("minstitch=100000", "hotloop=2")
+
+for i = 1, 50 do
+  jit.prngstate({i})
+end
+print('ok')
+--- out
+ok
+--- jv
+--- err eval
+qr/trace too short at test.lua:4/
+
+
+
+=== TEST 3: PRNG state can be an integer
+--- lua
+function print_array(a)
+  local out = a[1]
+  for i=2,#a do
+    out = out.." "..tostring(a[i])
+  end
+  print(out)
+end
+
+jit.prngstate(0)
+print_array(jit.prngstate(30))
+print_array(jit.prngstate(32))
+print_array(jit.prngstate(4294967296)) -- 2 ** 32
+--- out
+0 0 0 0 0 0 0 0
+30 0 0 0 0 0 0 0
+--- jv
+--- err
+bad argument #1 to 'prngstate' (PRNG state must be an array with up to 8 integers or an integer)
+--- exit: 1
diff --git a/lib/monkey/deps/flb_libco/libco.c b/lib/monkey/deps/flb_libco/libco.c
index e0101d238..a66b5b311 100644
--- a/lib/monkey/deps/flb_libco/libco.c
+++ b/lib/monkey/deps/flb_libco/libco.c
@@ -16,7 +16,9 @@
     #include "arm.c"
   #elif defined(__aarch64__)
     #include "aarch64.c"
-  #elif defined(_ARCH_PPC)
+  #elif defined(__powerpc64__) && defined(_CALL_ELF) && _CALL_ELF == 2
+    #include "ppc64le.c"
+  #elif defined(_ARCH_PPC) && !defined(__LITTLE_ENDIAN__)
     #include "ppc.c"
   #elif defined(_WIN32)
     #include "fiber.c"
diff --git a/lib/monkey/deps/flb_libco/ppc64le.c b/lib/monkey/deps/flb_libco/ppc64le.c
new file mode 100644
index 000000000..ae1f17245
--- /dev/null
+++ b/lib/monkey/deps/flb_libco/ppc64le.c
@@ -0,0 +1,239 @@
+/*
+  libco.ppc (2016-09-14)
+  author: blargg
+  license: public domain
+*/
+
+#define LIBCO_C
+#include "libco.h"
+#include "settings.h"
+
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+/* state format (offsets in 32-bit words)
+ +0 pointer to swap code
+    rest of function descriptor for entry function
+ +8 PC
++10 SP
+    special registers
+    GPRs
+    FPRs
+    VRs
+    stack
+*/
+
+enum { state_size  = 1024 };
+enum { above_stack = 2048 };
+enum { stack_align = 256  };
+
+static thread_local cothread_t co_active_handle = 0;
+
+/* determine environment */
+
+#define LIBCO_PPC64 (_ARCH_PPC64 || __PPC64__ || __ppc64__ || __powerpc64__)
+
+text_section
+static const uint32_t libco_ppc_code[1024] = {
+  0xf8240008, /* std r1, 8(4)     */
+  0xf8440010, /* std r2, 16(4)    */
+  0xf9840060, /* std r12, 96(4)   */
+  0xf9a40068, /* std r13, 104(4)  */
+  0xf9c40070, /* std r14, 112(4)  */
+  0xf9e40078, /* std r15, 120(4)  */
+  0xfa040080, /* std r16, 128(4)  */
+  0xfa240088, /* std r17, 136(4)  */
+  0xfa440090, /* std r18, 144(4)  */
+  0xfa640098, /* std r19, 152(4)  */
+  0xfa8400a0, /* std r20, 160(4)  */
+  0xfaa400a8, /* std r21, 168(4)  */
+  0xfac400b0, /* std r22, 176(4)  */
+  0xfae400b8, /* std r23, 184(4)  */
+  0xfb0400c0, /* std r24, 192(4)  */
+  0xfb2400c8, /* std r25, 200(4)  */
+  0xfb4400d0, /* std r26, 208(4)  */
+  0xfb6400d8, /* std r27, 216(4)  */
+  0xfb8400e0, /* std r28, 224(4)  */
+  0xfba400e8, /* std r29, 232(4)  */
+  0xfbc400f0, /* std r30, 240(4)  */
+  0xfbe400f8, /* std r31, 248(4)  */
+  0x7ca802a6, /* mflr r5          */
+  0xf8a40100, /* std r5, 256(4)   */
+  0x7ca00026, /* mfcr r5          */
+  0xf8a40108, /* std r5, 264(4)   */
+  0xe8230008, /* ld r1, 8(3)     */
+  0xe8430010, /* ld r2, 16(3)    */
+  0xe9830060, /* ld r12, 96(3)   */
+  0xe9a30068, /* ld r13, 104(3)  */
+  0xe9c30070, /* ld r14, 112(3)  */
+  0xe9e30078, /* ld r15, 120(3)  */
+  0xea030080, /* ld r16, 128(3)  */
+  0xea230088, /* ld r17, 136(3)  */
+  0xea430090, /* ld r18, 144(3)  */
+  0xea630098, /* ld r19, 152(3)  */
+  0xea8300a0, /* ld r20, 160(3)  */
+  0xeaa300a8, /* ld r21, 168(3)  */
+  0xeac300b0, /* ld r22, 176(3)  */
+  0xeae300b8, /* ld r23, 184(3)  */
+  0xeb0300c0, /* ld r24, 192(3)  */
+  0xeb2300c8, /* ld r25, 200(3)  */
+  0xeb4300d0, /* ld r26, 208(3)  */
+  0xeb6300d8, /* ld r27, 216(3)  */
+  0xeb8300e0, /* ld r28, 224(3)  */
+  0xeba300e8, /* ld r29, 232(3)  */
+  0xebc300f0, /* ld r30, 240(3)  */
+  0xebe300f8, /* ld r31, 248(3)  */
+  0xe8a30100, /* ld r5, 256(3)   */
+  0x7ca803a6, /* mtlr r5         */
+  0xe8a30108, /* ld r5, 264(3)   */
+  0x7caff120, /* mtcr r5         */
+
+  #ifndef LIBCO_PPC_NOFP
+  0xd9c40180, /* stfd r14, 384(4) */
+  0xd9e40188, /* stfd r15, 392(4) */
+  0xda040190, /* stfd r16, 400(4) */
+  0xda240198, /* stfd r17, 408(4) */
+  0xda4401a0, /* stfd r18, 416(4) */
+  0xda6401a8, /* stfd r19, 424(4) */
+  0xda8401b0, /* stfd r20, 432(4) */
+  0xdaa401b8, /* stfd r21, 440(4) */
+  0xdac401c0, /* stfd r22, 448(4) */
+  0xdae401c8, /* stfd r23, 456(4) */
+  0xdb0401d0, /* stfd r24, 464(4) */
+  0xdb2401d8, /* stfd r25, 472(4) */
+  0xdb4401e0, /* stfd r26, 480(4) */
+  0xdb6401e8, /* stfd r27, 488(4) */
+  0xdb8401f0, /* stfd r28, 496(4) */
+  0xdba401f8, /* stfd r29, 504(4) */
+  0xdbc40200, /* stfd r30, 512(4) */
+  0xdbe40208, /* stfd r31, 520(4) */
+  0xc9c30180, /* lfd r14, 384(3) */
+  0xc9e30188, /* lfd r15, 392(3) */
+  0xca030190, /* lfd r16, 400(3) */
+  0xca230198, /* lfd r17, 408(3) */
+  0xca4301a0, /* lfd r18, 416(3) */
+  0xca6301a8, /* lfd r19, 424(3) */
+  0xca8301b0, /* lfd r20, 432(3) */
+  0xcaa301b8, /* lfd r21, 440(3) */
+  0xcac301c0, /* lfd r22, 448(3) */
+  0xcae301c8, /* lfd r23, 456(3) */
+  0xcb0301d0, /* lfd r24, 464(3) */
+  0xcb2301d8, /* lfd r25, 472(3) */
+  0xcb4301e0, /* lfd r26, 480(3) */
+  0xcb6301e8, /* lfd r27, 488(3) */
+  0xcb8301f0, /* lfd r28, 496(3) */
+  0xcba301f8, /* lfd r29, 504(3) */
+  0xcbc30200, /* lfd r30, 512(3) */
+  0xcbe30208, /* lfd r31, 520(3) */
+  #endif
+
+  #ifdef __ALTIVEC__
+  0x38a00210, /* li r5, 528        */
+  0x7e842bce, /* stvxl v20, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7ea42bce, /* stvxl v21, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7ec42bce, /* stvxl v22, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7ee42bce, /* stvxl v23, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7f042bce, /* stvxl v24, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7f242bce, /* stvxl v25, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7f442bce, /* stvxl v26, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7f642bce, /* stvxl v27, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7f842bce, /* stvxl v28, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7fa42bce, /* stvxl v29, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7fc42bce, /* stvxl v30, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7fe42bce, /* stvxl v31, r4, r5 */
+  0x38a50010, /* addi r5, r5, 16   */
+  0x7ca042a6, /* mfvrsave r5       */
+  0x90a402e0, /* stw r5, 736(4)    */
+  0x38a00210, /* li r5, 528      */
+  0x7e832ace, /* lvxl v20, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7ea32ace, /* lvxl v21, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7ec32ace, /* lvxl v22, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7ee32ace, /* lvxl v23, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7f032ace, /* lvxl v24, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7f232ace, /* lvxl v25, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7f432ace, /* lvxl v26, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7f632ace, /* lvxl v27, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7f832ace, /* lvxl v28, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7fa32ace, /* lvxl v29, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7fc32ace, /* lvxl v30, r3, r5 */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x7fe32ace, /* lvxl v31, r3, 5  */
+  0x38a50010, /* addi r5, r5, 16 */
+  0x80a302d0, /* lwz r5, 720(3)  */
+  0x7ca043a6, /* mtvrsave r5     */
+  #endif
+
+  0x4e800020  /* blr             */
+};
+
+/* function call goes directly to code */
+#define CO_SWAP_ASM(x, y) ((void (*)(cothread_t, cothread_t))(uintptr_t)libco_ppc_code)(x, y)
+
+cothread_t co_active() {
+  if(!co_active_handle) co_active_handle = (uint64_t*)malloc(state_size);
+  return co_active_handle;
+}
+
+cothread_t co_create(unsigned int size, void (*entry_)(void),
+                     size_t *out_size) {
+
+  uintptr_t entry = (uintptr_t)entry_;
+  uint64_t* t = 0;
+  uintptr_t sp;
+  int shift;
+
+  /* be sure main thread was successfully allocated */
+  if(co_active()) {
+    size += state_size + above_stack + stack_align;
+    t = (uint64_t*)malloc(size);
+  }
+
+  if(t) {
+    /* save current registers into new thread, so that any special ones will have proper values when thread is begun */
+    CO_SWAP_ASM(t, t);
+
+    /* put stack near end of block, and align */
+    sp = (uintptr_t)t + size - above_stack;
+    sp -= sp % stack_align;
+
+    /* set up sp and entry will be called on next swap */
+    t[1] = (uint64_t)sp;
+    t[12] = (uint64_t)entry;
+    t[32] = (uint64_t)entry;
+  }
+  *out_size = size;
+  return t;
+}
+
+void co_delete(cothread_t t) {
+  free(t);
+}
+
+void co_switch(cothread_t t) {
+  cothread_t old = co_active_handle;
+  co_active_handle = t;
+
+  CO_SWAP_ASM(t, old);
+}
